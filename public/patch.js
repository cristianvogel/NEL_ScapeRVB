var CABLES;
(() => {
  "use strict";
  var __webpack_require__ = {};
  (() => {
    __webpack_require__.d = (exports, definition) => {
      for (var key in definition) {
        if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        }
      }
    };
  })();
  (() => {
    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  })();
  (() => {
    __webpack_require__.r = (exports) => {
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      }
      Object.defineProperty(exports, "__esModule", { value: true });
    };
  })();
  var __webpack_exports__ = {};
  __webpack_require__.d(__webpack_exports__, {
    "default": () => (
      /* binding */
      core
    )
  });
  var base64_namespaceObject = {};
  __webpack_require__.r(base64_namespaceObject);
  __webpack_require__.d(base64_namespaceObject, {
    b64decTypedArray: () => b64decTypedArray,
    b64encTypesArray: () => b64encTypesArray,
    base64Chars: () => base64Chars,
    base64lookup: () => base64lookup
  });
  var utils_namespaceObject = {};
  __webpack_require__.r(utils_namespaceObject);
  __webpack_require__.d(utils_namespaceObject, {
    UTILS: () => UTILS,
    ajax: () => ajax,
    ajaxSync: () => ajaxSync,
    basename: () => basename,
    cacheBust: () => cacheBust,
    clamp: () => clamp,
    cleanJson: () => cleanJson,
    copyArray: () => copyArray,
    filename: () => filename,
    generateUUID: () => generateUUID,
    getShortOpName: () => getShortOpName,
    keyCodeToName: () => keyCodeToName,
    logStack: () => logStack,
    map: () => map,
    prefixedHash: () => prefixedHash,
    request: () => request,
    shortId: () => shortId,
    shuffleArray: () => shuffleArray,
    simpleId: () => simpleId,
    smoothStep: () => smoothStep,
    smootherStep: () => smootherStep,
    uuid: () => uuid
  });
  var anim_namespaceObject = {};
  __webpack_require__.r(anim_namespaceObject);
  __webpack_require__.d(anim_namespaceObject, {
    ANIM: () => ANIM,
    Anim: () => Anim
  });
  ;
  const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const _base64lookup = new Uint8Array(256);
  for (let i = 0; i < base64Chars.length; i++)
    _base64lookup[base64Chars.charCodeAt(i)] = i;
  const base64lookup = _base64lookup;
  const b64encTypesArray = function(arraybuffer) {
    if (arraybuffer.buffer)
      arraybuffer = arraybuffer.buffer;
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
    for (i = 0; i < len; i += 3) {
      base64 += base64Chars[bytes[i] >> 2];
      base64 += base64Chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += base64Chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += base64Chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2)
      base64 = base64.substring(0, base64.length - 1) + "=";
    else if (len % 3 === 1)
      base64 = base64.substring(0, base64.length - 2) + "==";
    return base64;
  };
  const b64decTypedArray = function(base64) {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=")
        bufferLength--;
    }
    let arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
      encoded1 = base64lookup[base64.charCodeAt(i)];
      encoded2 = base64lookup[base64.charCodeAt(i + 1)];
      encoded3 = base64lookup[base64.charCodeAt(i + 2)];
      encoded4 = base64lookup[base64.charCodeAt(i + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
  };
  ;
  const CONSTANTS2 = {
    "ANIM": {
      "EASINGS": [
        "linear",
        "absolute",
        "smoothstep",
        "smootherstep",
        "Cubic In",
        "Cubic Out",
        "Cubic In Out",
        "Expo In",
        "Expo Out",
        "Expo In Out",
        "Sin In",
        "Sin Out",
        "Sin In Out",
        "Quart In",
        "Quart Out",
        "Quart In Out",
        "Quint In",
        "Quint Out",
        "Quint In Out",
        "Back In",
        "Back Out",
        "Back In Out",
        "Elastic In",
        "Elastic Out",
        "Bounce In",
        "Bounce Out"
      ],
      "EASING_LINEAR": 0,
      "EASING_ABSOLUTE": 1,
      "EASING_SMOOTHSTEP": 2,
      "EASING_SMOOTHERSTEP": 3,
      "EASING_CUBICSPLINE": 4,
      "EASING_CUBIC_IN": 5,
      "EASING_CUBIC_OUT": 6,
      "EASING_CUBIC_INOUT": 7,
      "EASING_EXPO_IN": 8,
      "EASING_EXPO_OUT": 9,
      "EASING_EXPO_INOUT": 10,
      "EASING_SIN_IN": 11,
      "EASING_SIN_OUT": 12,
      "EASING_SIN_INOUT": 13,
      "EASING_BACK_IN": 14,
      "EASING_BACK_OUT": 15,
      "EASING_BACK_INOUT": 16,
      "EASING_ELASTIC_IN": 17,
      "EASING_ELASTIC_OUT": 18,
      "EASING_BOUNCE_IN": 19,
      "EASING_BOUNCE_OUT": 21,
      "EASING_QUART_IN": 22,
      "EASING_QUART_OUT": 23,
      "EASING_QUART_INOUT": 24,
      "EASING_QUINT_IN": 25,
      "EASING_QUINT_OUT": 26,
      "EASING_QUINT_INOUT": 27
    },
    "OP": {
      "OP_PORT_TYPE_VALUE": 0,
      "OP_PORT_TYPE_NUMBER": 0,
      "OP_PORT_TYPE_FUNCTION": 1,
      "OP_PORT_TYPE_TRIGGER": 1,
      "OP_PORT_TYPE_OBJECT": 2,
      "OP_PORT_TYPE_TEXTURE": 2,
      "OP_PORT_TYPE_ARRAY": 3,
      "OP_PORT_TYPE_DYNAMIC": 4,
      "OP_PORT_TYPE_STRING": 5,
      "OP_VERSION_PREFIX": "_v"
    },
    "PORT": {
      "PORT_DIR_IN": 0,
      "PORT_DIR_OUT": 1
    },
    "PACO": {
      "PACO_CLEAR": 0,
      "PACO_VALUECHANGE": 1,
      "PACO_OP_DELETE": 2,
      "PACO_UNLINK": 3,
      "PACO_LINK": 4,
      "PACO_LOAD": 5,
      "PACO_OP_CREATE": 6,
      "PACO_OP_ENABLE": 7,
      "PACO_OP_DISABLE": 8,
      "PACO_UIATTRIBS": 9,
      "PACO_VARIABLES": 10,
      "PACO_TRIGGERS": 11,
      "PACO_PORT_SETVARIABLE": 12,
      "PACO_PORT_SETANIMATED": 13,
      "PACO_PORT_ANIM_UPDATED": 14,
      "PACO_DESERIALIZE": 15
    }
  };
  ;
  const UTILS = {};
  UTILS.float32Concat = function(first, second) {
    if (!(first instanceof Float32Array))
      first = new Float32Array(first);
    if (!(second instanceof Float32Array))
      second = new Float32Array(second);
    const result = new Float32Array(first.length + second.length);
    result.set(first);
    result.set(second, first.length);
    return result;
  };
  const getShortOpName = function(fullname) {
    let name2 = fullname.split(".")[fullname.split(".").length - 1];
    if (name2.contains(CONSTANTS2.OP.OP_VERSION_PREFIX)) {
      const n = name2.split(CONSTANTS2.OP.OP_VERSION_PREFIX)[1];
      name2 = name2.substring(0, name2.length - (CONSTANTS2.OP.OP_VERSION_PREFIX + n).length);
    }
    return name2;
  };
  const shuffleArray = function(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.seededRandom() * (i + 1));
      const temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
    return array;
  };
  const _shortIds = {};
  const _shortId = function() {
    let str = Math.random().toString(36).substr(2, 9);
    if (_shortIds.hasOwnProperty(str))
      str = _shortId();
    _shortIds[str] = true;
    return str;
  };
  const shortId = _shortId;
  const _uuid = function() {
    let d = (/* @__PURE__ */ new Date()).getTime();
    const uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c == "x" ? r : r & 3 | 8).toString(16);
    });
    return uuid2;
  };
  const uuid = _uuid;
  const generateUUID = _uuid;
  function cleanJson(obj) {
    for (const i in obj) {
      if (obj[i] && typeof objValue === "object" && obj[i].constructor === Object)
        obj[i] = cleanJson(obj[i]);
      if (obj[i] === null || obj[i] === void 0)
        delete obj[i];
      else if (Array.isArray(obj[i]) && obj[i].length == 0)
        delete obj[i];
    }
    return obj;
  }
  const _prefixedHash = function(str, prefix = "id") {
    let hash = 0;
    if (Array.prototype.reduce) {
      hash = str.split("").reduce((a, b) => {
        a = (a << 5) - a + b.charCodeAt(0);
        return a & a;
      }, 0);
    } else {
      if (str.length > 0) {
        for (let i = 0; i < str.length; i++) {
          let character = str.charCodeAt(i);
          hash = (hash << 5) - hash + character;
          hash &= hash;
        }
      }
    }
    return prefix + "" + hash;
  };
  const prefixedHash = _prefixedHash;
  let simpleIdCounter = 0;
  const simpleId = function() {
    simpleIdCounter++;
    return simpleIdCounter;
  };
  const smoothStep = function(perc) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * (3 - 2 * x);
    return perc;
  };
  const smootherStep = function(perc) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10);
    return perc;
  };
  const clamp = function(value, min, max) {
    return Math.min(Math.max(value, min), max);
  };
  const map = function(x, _oldMin, _oldMax, _newMin, _newMax, _easing) {
    if (x >= _oldMax)
      return _newMax;
    if (x <= _oldMin)
      return _newMin;
    let reverseInput = false;
    const oldMin = Math.min(_oldMin, _oldMax);
    const oldMax = Math.max(_oldMin, _oldMax);
    if (oldMin != _oldMin)
      reverseInput = true;
    let reverseOutput = false;
    const newMin = Math.min(_newMin, _newMax);
    const newMax = Math.max(_newMin, _newMax);
    if (newMin != _newMin)
      reverseOutput = true;
    let portion = 0;
    let r = 0;
    if (reverseInput)
      portion = (oldMax - x) * (newMax - newMin) / (oldMax - oldMin);
    else
      portion = (x - oldMin) * (newMax - newMin) / (oldMax - oldMin);
    if (reverseOutput)
      r = newMax - portion;
    else
      r = portion + newMin;
    if (!_easing)
      return r;
    if (_easing == 1) {
      x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
      return _newMin + x * x * (3 - 2 * x) * (_newMax - _newMin);
    }
    if (_easing == 2) {
      x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
      return _newMin + x * x * x * (x * (x * 6 - 15) + 10) * (_newMax - _newMin);
    }
    return r;
  };
  Math.randomSeed = 1;
  Math.setRandomSeed = function(seed) {
    Math.randomSeed = seed * 50728129;
    if (seed != 0) {
      Math.randomSeed = Math.seededRandom() * 17624813;
      Math.randomSeed = Math.seededRandom() * 9737333;
    }
  };
  Math.seededRandom = function(max, min) {
    if (Math.randomSeed === 0)
      Math.randomSeed = Math.random() * 999;
    max = max || 1;
    min = min || 0;
    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;
    const rnd = Math.randomSeed / 233280;
    return min + rnd * (max - min);
  };
  UTILS.isNumeric = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };
  UTILS.isArray = function(v) {
    return Object.prototype.toString.call(v) === "[object Array]";
  };
  String.prototype.endl = function() {
    return this + "\n";
  };
  String.prototype.startsWith = function(prefix) {
    return this.indexOf(prefix) === 0;
  };
  String.prototype.endsWith = String.prototype.endsWith || function(suffix) {
    return this.match(suffix + "$") == suffix;
  };
  String.prototype.contains = String.prototype.contains || function(searchStr) {
    return this.indexOf(searchStr) > -1;
  };
  const cacheBust = function(url = "") {
    if (!url)
      return "";
    if (url.startsWith("data:"))
      return;
    if (url.contains("?"))
      url += "&";
    else
      url += "?";
    return url + "cache=" + CABLES.uuid();
  };
  const copyArray = function(src, dst) {
    if (!src)
      return null;
    dst = dst || [];
    dst.length = src.length;
    for (let i = 0; i < src.length; i++) {
      dst[i] = src[i];
    }
    return dst;
  };
  const basename = function(url) {
    let name2 = CABLES.filename(url);
    const parts2 = name2.split(".");
    name2 = parts2[0];
    return name2;
  };
  const logStack = function() {
    console.log("logstack", new Error().stack);
  };
  const filename = function(url) {
    let name2 = "";
    if (!url)
      return "";
    if (url.startsWith("data:") && url.contains(":")) {
      const parts2 = url.split(",");
      return parts2[0];
    }
    let parts = (url + "").split("/");
    if (parts.length > 0) {
      const str = parts[parts.length - 1];
      let parts2 = str.split("?");
      name2 = parts2[0];
    }
    return name2 || "";
  };
  const ajaxSync = function(url, cb, method, post, contenttype) {
    request({
      "url": url,
      "cb": cb,
      "method": method,
      "data": post,
      "contenttype": contenttype,
      "sync": true
    });
  };
  const ajax = function(url, cb, method, post, contenttype, jsonP, headers = {}, options = {}) {
    const requestOptions = {
      "url": url,
      "cb": cb,
      "method": method,
      "data": post,
      "contenttype": contenttype,
      "sync": false,
      "jsonP": jsonP,
      "headers": headers
    };
    if (options && options.credentials)
      requestOptions.credentials = options.credentials;
    request(requestOptions);
  };
  const request = function(options) {
    if (!options.hasOwnProperty("asynch"))
      options.asynch = true;
    let xhr;
    try {
      xhr = new XMLHttpRequest();
    } catch (e) {
    }
    xhr.onreadystatechange = function() {
      if (xhr.readyState != 4)
        return;
      if (options.cb) {
        if (xhr.status == 200 || xhr.status == 0)
          options.cb(false, xhr.responseText, xhr);
        else
          options.cb(true, xhr.responseText, xhr);
      }
    };
    try {
      xhr.open(options.method ? options.method.toUpperCase() : "GET", options.url, !options.sync);
    } catch (e) {
      if (options.cb && e)
        options.cb(true, e.msg, xhr);
    }
    if (typeof options.headers === "object") {
      if (options.headers) {
        const keys = Object.keys(options.headers);
        for (let i = 0; i < keys.length; i++) {
          const name2 = keys[i];
          const value = options.headers[name2];
          xhr.setRequestHeader(name2, value);
        }
      }
    }
    if (options.credentials && options.credentials !== "omit") {
      xhr.withCredentials = true;
    }
    try {
      if (!options.post && !options.data) {
        xhr.send();
      } else {
        xhr.setRequestHeader(
          "Content-type",
          options.contenttype ? options.contenttype : "application/x-www-form-urlencoded"
        );
        xhr.send(options.data || options.post);
      }
    } catch (e) {
      if (options.cb)
        options.cb(true, e.msg, xhr);
    }
  };
  const keyCodeToName = function(keyCode) {
    if (!keyCode && keyCode !== 0)
      return "Unidentified";
    const keys = {
      "8": "Backspace",
      "9": "Tab",
      "12": "Clear",
      "13": "Enter",
      "16": "Shift",
      "17": "Control",
      "18": "Alt",
      "19": "Pause",
      "20": "CapsLock",
      "27": "Escape",
      "32": "Space",
      "33": "PageUp",
      "34": "PageDown",
      "35": "End",
      "36": "Home",
      "37": "ArrowLeft",
      "38": "ArrowUp",
      "39": "ArrowRight",
      "40": "ArrowDown",
      "45": "Insert",
      "46": "Delete",
      "112": "F1",
      "113": "F2",
      "114": "F3",
      "115": "F4",
      "116": "F5",
      "117": "F6",
      "118": "F7",
      "119": "F8",
      "120": "F9",
      "121": "F10",
      "122": "F11",
      "123": "F12",
      "144": "NumLock",
      "145": "ScrollLock",
      "224": "Meta"
    };
    if (keys[keyCode]) {
      return keys[keyCode];
    } else {
      return String.fromCharCode(keyCode);
    }
  };
  window.performance = window.performance || {
    "offset": Date.now(),
    "now": function now2() {
      return Date.now() - this.offset;
    }
  };
  ;
  class Logger {
    constructor(initiator) {
      this.initiator = initiator;
    }
    stack(t) {
      console.info("[" + this.initiator + "] ", t);
      console.log(new Error().stack);
    }
    groupCollapsed(t) {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments) || !CABLES.logSilent)
        console.log("[" + this.initiator + "]", ...arguments);
      console.groupCollapsed("[" + this.initiator + "] " + t);
    }
    table(t) {
      console.table(t);
    }
    groupEnd() {
      console.groupEnd();
    }
    error() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 2 }, ...arguments) || !CABLES.logSilent)
        console.error("[" + this.initiator + "]", ...arguments);
    }
    errorGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 2 }, ...arguments);
    }
    warn() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 1 }, ...arguments) || !CABLES.logSilent)
        console.warn("[" + this.initiator + "]", ...arguments);
    }
    verbose() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments) || !CABLES.logSilent)
        console.log("[" + this.initiator + "]", ...arguments);
    }
    info() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments) || !CABLES.logSilent)
        console.info("[" + this.initiator + "]", ...arguments);
    }
    log() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments) || !CABLES.logSilent)
        console.log("[" + this.initiator + "]", ...arguments);
    }
    logGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments);
    }
    userInteraction(text) {
    }
  }
  ;
  const Key = function(obj) {
    this.time = 0;
    this.value = 0;
    this.onChange = null;
    this._easing = 0;
    this.cb = null;
    this.cbTriggered = false;
    this.setEasing(CONSTANTS2.ANIM.EASING_LINEAR);
    this.set(obj);
  };
  Key.cubicSpline = function(perc, key1, key2) {
    let previousPoint = key1.value, previousTangent = key1.bezTangOut, nextPoint = key2.value, nextTangent = key2.bezTangIn;
    let t = perc;
    let t2 = t * t;
    let t3 = t2 * t;
    return (2 * t3 - 3 * t2 + 1) * previousPoint + (t3 - 2 * t2 + t) * previousTangent + (-2 * t3 + 3 * t2) * nextPoint + (t3 - t2) * nextTangent;
  };
  Key.easeCubicSpline = function(perc, key2) {
    return Key.cubicSpline(perc, this, key2);
  };
  Key.linear = function(perc, key1, key2) {
    return parseFloat(key1.value) + parseFloat(key2.value - key1.value) * perc;
  };
  Key.easeLinear = function(perc, key2) {
    return Key.linear(perc, this, key2);
  };
  Key.easeAbsolute = function(perc, key2) {
    return this.value;
  };
  const easeExpoIn = function(t) {
    return t = 2 ** (10 * (t - 1));
  };
  Key.easeExpoIn = function(t, key2) {
    t = easeExpoIn(t);
    return Key.linear(t, this, key2);
  };
  const easeExpoOut = function(t) {
    t = -(2 ** (-10 * t)) + 1;
    return t;
  };
  Key.easeExpoOut = function(t, key2) {
    t = easeExpoOut(t);
    return Key.linear(t, this, key2);
  };
  const easeExpoInOut = function(t) {
    t *= 2;
    if (t < 1) {
      t = 0.5 * 2 ** (10 * (t - 1));
    } else {
      t--;
      t = 0.5 * (-(2 ** (-10 * t)) + 2);
    }
    return t;
  };
  Key.easeExpoInOut = function(t, key2) {
    t = easeExpoInOut(t);
    return Key.linear(t, this, key2);
  };
  Key.easeSinIn = function(t, key2) {
    t = -1 * Math.cos(t * Math.PI / 2) + 1;
    return Key.linear(t, this, key2);
  };
  Key.easeSinOut = function(t, key2) {
    t = Math.sin(t * Math.PI / 2);
    return Key.linear(t, this, key2);
  };
  Key.easeSinInOut = function(t, key2) {
    t = -0.5 * (Math.cos(Math.PI * t) - 1);
    return Key.linear(t, this, key2);
  };
  const easeCubicIn = function(t) {
    t = t * t * t;
    return t;
  };
  Key.easeCubicIn = function(t, key2) {
    t = easeCubicIn(t);
    return Key.linear(t, this, key2);
  };
  Key.easeInQuint = function(t, key2) {
    t = t * t * t * t * t;
    return Key.linear(t, this, key2);
  };
  Key.easeOutQuint = function(t, key2) {
    t = (t -= 1) * t * t * t * t + 1;
    return Key.linear(t, this, key2);
  };
  Key.easeInOutQuint = function(t, key2) {
    if ((t /= 0.5) < 1)
      t = 0.5 * t * t * t * t * t;
    else
      t = 0.5 * ((t -= 2) * t * t * t * t + 2);
    return Key.linear(t, this, key2);
  };
  Key.easeInQuart = function(t, key2) {
    t = t * t * t * t;
    return Key.linear(t, this, key2);
  };
  Key.easeOutQuart = function(t, key2) {
    t = -1 * ((t -= 1) * t * t * t - 1);
    return Key.linear(t, this, key2);
  };
  Key.easeInOutQuart = function(t, key2) {
    if ((t /= 0.5) < 1)
      t = 0.5 * t * t * t * t;
    else
      t = -0.5 * ((t -= 2) * t * t * t - 2);
    return Key.linear(t, this, key2);
  };
  Key.bounce = function(t) {
    if ((t /= 1) < 1 / 2.75)
      t = 7.5625 * t * t;
    else if (t < 2 / 2.75)
      t = 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    else if (t < 2.5 / 2.75)
      t = 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    else
      t = 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    return t;
  };
  Key.easeInBounce = function(t, key2) {
    return Key.linear(Key.bounce(t), this, key2);
  };
  Key.easeOutBounce = function(t, key2) {
    return Key.linear(Key.bounce(t), this, key2);
  };
  Key.easeInElastic = function(t, key2) {
    let s = 1.70158;
    let p = 0;
    let a = 1;
    const b = 0;
    const d = 1;
    const c = 1;
    if (t === 0)
      t = b;
    else if ((t /= d) == 1)
      t = b + c;
    else {
      if (!p)
        p = d * 0.3;
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else
        s = p / (2 * Math.PI) * Math.asin(c / a);
      t = -(a * 2 ** (10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    }
    return Key.linear(t, this, key2);
  };
  Key.easeOutElastic = function(t, key2) {
    let s = 1.70158;
    let p = 0;
    let a = 1;
    const b = 0;
    const d = 1;
    const c = 1;
    if (t === 0)
      t = b;
    else if ((t /= d) == 1)
      t = b + c;
    else {
      if (!p)
        p = d * 0.3;
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else
        s = p / (2 * Math.PI) * Math.asin(c / a);
      t = a * 2 ** (-10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
    }
    return Key.linear(t, this, key2);
  };
  Key.easeInBack = function(t, key2) {
    const s = 1.70158;
    t = t * t * ((s + 1) * t - s);
    return Key.linear(t, this, key2);
  };
  Key.easeOutBack = function(t, key2) {
    const s = 1.70158;
    t = (t = t / 1 - 1) * t * ((s + 1) * t + s) + 1;
    return Key.linear(t, this, key2);
  };
  Key.easeInOutBack = function(t, key2) {
    let s = 1.70158;
    const c = 1 / 2;
    if ((t /= 1 / 2) < 1)
      t = c * (t * t * (((s *= 1.525) + 1) * t - s));
    else
      t = c * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    return Key.linear(t, this, key2);
  };
  const easeCubicOut = function(t) {
    t--;
    t = t * t * t + 1;
    return t;
  };
  Key.easeCubicOut = function(t, key2) {
    t = easeCubicOut(t);
    return Key.linear(t, this, key2);
  };
  const easeCubicInOut = function(t) {
    t *= 2;
    if (t < 1)
      t = 0.5 * t * t * t;
    else {
      t -= 2;
      t = 0.5 * (t * t * t + 2);
    }
    return t;
  };
  Key.easeCubicInOut = function(t, key2) {
    t = easeCubicInOut(t);
    return Key.linear(t, this, key2);
  };
  Key.easeSmoothStep = function(perc, key2) {
    const x = Math.max(0, Math.min(1, perc));
    perc = x * x * (3 - 2 * x);
    return Key.linear(perc, this, key2);
  };
  Key.easeSmootherStep = function(perc, key2) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10);
    return Key.linear(perc, this, key2);
  };
  Key.prototype.setEasing = function(e) {
    this._easing = e;
    if (this._easing == CONSTANTS2.ANIM.EASING_LINEAR)
      this.ease = Key.easeLinear;
    else if (this._easing == CONSTANTS2.ANIM.EASING_ABSOLUTE)
      this.ease = Key.easeAbsolute;
    else if (this._easing == CONSTANTS2.ANIM.EASING_SMOOTHSTEP)
      this.ease = Key.easeSmoothStep;
    else if (this._easing == CONSTANTS2.ANIM.EASING_SMOOTHERSTEP)
      this.ease = Key.easeSmootherStep;
    else if (this._easing == CONSTANTS2.ANIM.EASING_CUBIC_IN)
      this.ease = Key.easeCubicIn;
    else if (this._easing == CONSTANTS2.ANIM.EASING_CUBIC_OUT)
      this.ease = Key.easeCubicOut;
    else if (this._easing == CONSTANTS2.ANIM.EASING_CUBIC_INOUT)
      this.ease = Key.easeCubicInOut;
    else if (this._easing == CONSTANTS2.ANIM.EASING_EXPO_IN)
      this.ease = Key.easeExpoIn;
    else if (this._easing == CONSTANTS2.ANIM.EASING_EXPO_OUT)
      this.ease = Key.easeExpoOut;
    else if (this._easing == CONSTANTS2.ANIM.EASING_EXPO_INOUT)
      this.ease = Key.easeExpoInOut;
    else if (this._easing == CONSTANTS2.ANIM.EASING_SIN_IN)
      this.ease = Key.easeSinIn;
    else if (this._easing == CONSTANTS2.ANIM.EASING_SIN_OUT)
      this.ease = Key.easeSinOut;
    else if (this._easing == CONSTANTS2.ANIM.EASING_SIN_INOUT)
      this.ease = Key.easeSinInOut;
    else if (this._easing == CONSTANTS2.ANIM.EASING_BACK_OUT)
      this.ease = Key.easeOutBack;
    else if (this._easing == CONSTANTS2.ANIM.EASING_BACK_IN)
      this.ease = Key.easeInBack;
    else if (this._easing == CONSTANTS2.ANIM.EASING_BACK_INOUT)
      this.ease = Key.easeInOutBack;
    else if (this._easing == CONSTANTS2.ANIM.EASING_ELASTIC_IN)
      this.ease = Key.easeInElastic;
    else if (this._easing == CONSTANTS2.ANIM.EASING_ELASTIC_OUT)
      this.ease = Key.easeOutElastic;
    else if (this._easing == CONSTANTS2.ANIM.EASING_ELASTIC_INOUT)
      this.ease = Key.easeElasticInOut;
    else if (this._easing == CONSTANTS2.ANIM.EASING_BOUNCE_IN)
      this.ease = Key.easeInBounce;
    else if (this._easing == CONSTANTS2.ANIM.EASING_BOUNCE_OUT)
      this.ease = Key.easeOutBounce;
    else if (this._easing == CONSTANTS2.ANIM.EASING_QUART_OUT)
      this.ease = Key.easeOutQuart;
    else if (this._easing == CONSTANTS2.ANIM.EASING_QUART_IN)
      this.ease = Key.easeInQuart;
    else if (this._easing == CONSTANTS2.ANIM.EASING_QUART_INOUT)
      this.ease = Key.easeInOutQuart;
    else if (this._easing == CONSTANTS2.ANIM.EASING_QUINT_OUT)
      this.ease = Key.easeOutQuint;
    else if (this._easing == CONSTANTS2.ANIM.EASING_QUINT_IN)
      this.ease = Key.easeInQuint;
    else if (this._easing == CONSTANTS2.ANIM.EASING_QUINT_INOUT)
      this.ease = Key.easeInOutQuint;
    else if (this._easing == CONSTANTS2.ANIM.EASING_CUBICSPLINE) {
      this.ease = Key.easeCubicSpline;
    } else {
      this._easing = CONSTANTS2.ANIM.EASING_LINEAR;
      this.ease = Key.easeLinear;
    }
  };
  Key.prototype.trigger = function() {
    this.cb();
    this.cbTriggered = true;
  };
  Key.prototype.setValue = function(v) {
    this.value = v;
    if (this.onChange !== null)
      this.onChange();
  };
  Key.prototype.set = function(obj) {
    if (obj) {
      if (obj.e)
        this.setEasing(obj.e);
      if (obj.cb) {
        this.cb = obj.cb;
        this.cbTriggered = false;
      }
      if (obj.b) {
      }
      if (obj.hasOwnProperty("t"))
        this.time = obj.t;
      if (obj.hasOwnProperty("time"))
        this.time = obj.time;
      if (obj.hasOwnProperty("v"))
        this.value = obj.v;
      else if (obj.hasOwnProperty("value"))
        this.value = obj.value;
    }
    if (this.onChange !== null)
      this.onChange();
  };
  Key.prototype.getSerialized = function() {
    const obj = {};
    obj.t = this.time;
    obj.v = this.value;
    obj.e = this._easing;
    return obj;
  };
  Key.prototype.getEasing = function() {
    return this._easing;
  };
  ;
  const EventTarget = function() {
    this._log = new Logger("eventtarget");
    this._eventCallbacks = {};
    this._logName = "";
    this._logEvents = false;
    this._listeners = {};
    this.addEventListener = this.on = function(which, cb, idPrefix) {
      const event2 = {
        "id": (idPrefix || "") + CABLES.simpleId(),
        "name": which,
        "cb": cb
      };
      if (!this._eventCallbacks[which])
        this._eventCallbacks[which] = [event2];
      else
        this._eventCallbacks[which].push(event2);
      this._listeners[event2.id] = event2;
      return event2.id;
    };
    this.hasEventListener = function(which, cb) {
      if (which && !cb) {
        if (this._listeners[which])
          return true;
        else
          return false;
      } else {
        this._log.warn("old eventtarget function haseventlistener!");
        if (which && cb) {
          if (this._eventCallbacks[which]) {
            const idx = this._eventCallbacks[which].indexOf(cb);
            if (idx == -1)
              return false;
            return true;
          }
        }
      }
    };
    this.hasListenerForEventName = function(eventName) {
      return this._eventCallbacks[eventName] && this._eventCallbacks[eventName].length > 0;
    };
    this.removeEventListener = this.off = function(which, cb) {
      if (which === null || which === void 0)
        return;
      if (!cb) {
        const event2 = this._listeners[which];
        if (!event2) {
          this._log.log("could not find event...");
          return;
        }
        let found = true;
        while (found) {
          found = false;
          let index2 = -1;
          for (let i = 0; i < this._eventCallbacks[event2.name].length; i++) {
            if (this._eventCallbacks[event2.name][i].id.startsWith(which)) {
              found = true;
              index2 = i;
            }
          }
          if (index2 !== -1) {
            this._eventCallbacks[event2.name].splice(index2, 1);
            delete this._listeners[which];
          }
        }
        return;
      }
      this._log.info("[eventtaget] ", "old function signature: removeEventListener! use listener id");
      this._log.log(new Error().stack);
      let index = null;
      for (let i = 0; i < this._eventCallbacks[which].length; i++)
        if (this._eventCallbacks[which][i].cb == cb)
          index = i;
      if (index !== null) {
        delete this._eventCallbacks[index];
      } else
        this._log.warn("removeEventListener not found " + which);
    };
    this.logEvents = function(enabled, name2) {
      this._logEvents = enabled;
      this._logName = name2;
    };
    this.emitEvent = function(which, param1, param2, param3, param4, param5, param6) {
      if (this._logEvents)
        this._log.log("[event] ", this._logName, which, this._eventCallbacks);
      if (this._eventCallbacks[which]) {
        for (let i = 0; i < this._eventCallbacks[which].length; i++) {
          if (this._eventCallbacks[which][i]) {
            this._eventCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6);
          }
        }
      } else {
        if (this._logEvents)
          this._log.log("[event] has no event callback", which, this._eventCallbacks);
      }
    };
  };
  ;
  const Anim = function(cfg) {
    EventTarget.apply(this);
    cfg = cfg || {};
    this.keys = [];
    this.onChange = null;
    this.stayInTimeline = false;
    this.loop = false;
    this._log = new Logger("Anim");
    this._lastKeyIndex = 0;
    this._cachedIndex = 0;
    this.name = cfg.name || null;
    this.defaultEasing = cfg.defaultEasing || CONSTANTS2.ANIM.EASING_LINEAR;
    this.onLooped = null;
    this._timesLooped = 0;
    this._needsSort = false;
  };
  Anim.prototype.forceChangeCallback = function() {
    if (this.onChange !== null)
      this.onChange();
    this.emitEvent("onChange", this);
  };
  Anim.prototype.getLoop = function() {
    return this.loop;
  };
  Anim.prototype.setLoop = function(target) {
    this.loop = target;
    this.emitEvent("onChange", this);
  };
  Anim.prototype.hasEnded = function(time) {
    if (this.keys.length === 0)
      return true;
    if (this.keys[this._lastKeyIndex].time <= time)
      return true;
    return false;
  };
  Anim.prototype.isRising = function(time) {
    if (this.hasEnded(time))
      return false;
    const ki = this.getKeyIndex(time);
    if (this.keys[ki].value < this.keys[ki + 1].value)
      return true;
    return false;
  };
  Anim.prototype.clearBefore = function(time) {
    const v = this.getValue(time);
    const ki = this.getKeyIndex(time);
    this.setValue(time, v);
    if (ki > 1)
      this.keys.splice(0, ki);
    this._updateLastIndex();
  };
  Anim.prototype.clear = function(time) {
    let v = 0;
    if (time)
      v = this.getValue(time);
    this.keys.length = 0;
    this._updateLastIndex();
    if (time)
      this.setValue(time, v);
    if (this.onChange !== null)
      this.onChange();
    this.emitEvent("onChange", this);
  };
  Anim.prototype.sortKeys = function() {
    this.keys.sort((a, b) => {
      return parseFloat(a.time) - parseFloat(b.time);
    });
    this._updateLastIndex();
    this._needsSort = false;
    if (this.keys.length % 1e3 == 0)
      console.log(this.name, this.keys.length);
  };
  Anim.prototype.getLength = function() {
    if (this.keys.length === 0)
      return 0;
    return this.keys[this.keys.length - 1].time;
  };
  Anim.prototype.getKeyIndex = function(time) {
    let index = 0;
    let start = 0;
    if (this._cachedIndex && this.keys.length > this._cachedIndex && time >= this.keys[this._cachedIndex].time)
      start = this._cachedIndex;
    for (let i = start; i < this.keys.length; i++) {
      if (time >= this.keys[i].time)
        index = i;
      if (this.keys[i].time > time) {
        if (time != 0)
          this._cachedIndex = index;
        return index;
      }
    }
    return index;
  };
  Anim.prototype.setValue = function(time, value, cb) {
    let found = null;
    if (this.keys.length == 0 || time <= this.keys[this.keys.length - 1].time) {
      for (let i = 0; i < this.keys.length; i++)
        if (this.keys[i].time == time) {
          found = this.keys[i];
          this.keys[i].setValue(value);
          this.keys[i].cb = cb;
          break;
        }
    }
    if (!found) {
      found = new Key(
        {
          "time": time,
          "value": value,
          "e": this.defaultEasing,
          "cb": cb
        }
      );
      this.keys.push(found);
      this._updateLastIndex();
    }
    if (this.onChange)
      this.onChange();
    this.emitEvent("onChange", this);
    this._needsSort = true;
    return found;
  };
  Anim.prototype.setKeyEasing = function(index, e) {
    if (this.keys[index]) {
      this.keys[index].setEasing(e);
      this.emitEvent("onChange", this);
    }
  };
  Anim.prototype.getSerialized = function() {
    const obj = {};
    obj.keys = [];
    obj.loop = this.loop;
    for (let i = 0; i < this.keys.length; i++)
      obj.keys.push(this.keys[i].getSerialized());
    return obj;
  };
  Anim.prototype.getKey = function(time) {
    const index = this.getKeyIndex(time);
    return this.keys[index];
  };
  Anim.prototype.getNextKey = function(time) {
    let index = this.getKeyIndex(time) + 1;
    if (index >= this.keys.length)
      index = this.keys.length - 1;
    return this.keys[index];
  };
  Anim.prototype.isFinished = function(time) {
    if (this.keys.length <= 0)
      return true;
    return time > this.keys[this.keys.length - 1].time;
  };
  Anim.prototype.isStarted = function(time) {
    if (this.keys.length <= 0)
      return false;
    return time >= this.keys[0].time;
  };
  Anim.prototype.getValue = function(time) {
    if (this.keys.length === 0) {
      return 0;
    }
    if (this._needsSort)
      this.sortKeys();
    if (!this.loop && time > this.keys[this._lastKeyIndex].time) {
      if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered)
        this.keys[this._lastKeyIndex].trigger();
      return this.keys[this._lastKeyIndex].value;
    }
    if (time < this.keys[0].time) {
      return this.keys[0].value;
    }
    if (this.loop && time > this.keys[this._lastKeyIndex].time) {
      const currentLoop = time / this.keys[this._lastKeyIndex].time;
      if (currentLoop > this._timesLooped) {
        this._timesLooped++;
        if (this.onLooped)
          this.onLooped();
      }
      time = (time - this.keys[0].time) % (this.keys[this._lastKeyIndex].time - this.keys[0].time);
      time += this.keys[0].time;
    }
    const index = this.getKeyIndex(time);
    if (index >= this._lastKeyIndex) {
      if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered)
        this.keys[this._lastKeyIndex].trigger();
      return this.keys[this._lastKeyIndex].value;
    }
    const index2 = index + 1;
    const key1 = this.keys[index];
    const key2 = this.keys[index2];
    if (key1.cb && !key1.cbTriggered)
      key1.trigger();
    if (!key2)
      return -1;
    const perc = (time - key1.time) / (key2.time - key1.time);
    if (!key1.ease)
      this.log._warn("has no ease", key1, key2);
    return key1.ease(perc, key2);
  };
  Anim.prototype._updateLastIndex = function() {
    this._lastKeyIndex = this.keys.length - 1;
  };
  Anim.prototype.addKey = function(k) {
    if (k.time === void 0) {
      this.log.warn("key time undefined, ignoring!");
    } else {
      this.keys.push(k);
      if (this.onChange !== null)
        this.onChange();
      this.emitEvent("onChange", this);
    }
    this._updateLastIndex();
  };
  Anim.prototype.easingFromString = function(str) {
    if (str == "linear")
      return CONSTANTS2.ANIM.EASING_LINEAR;
    if (str == "absolute")
      return CONSTANTS2.ANIM.EASING_ABSOLUTE;
    if (str == "smoothstep")
      return CONSTANTS2.ANIM.EASING_SMOOTHSTEP;
    if (str == "smootherstep")
      return CONSTANTS2.ANIM.EASING_SMOOTHERSTEP;
    if (str == "Cubic In")
      return CONSTANTS2.ANIM.EASING_CUBIC_IN;
    if (str == "Cubic Out")
      return CONSTANTS2.ANIM.EASING_CUBIC_OUT;
    if (str == "Cubic In Out")
      return CONSTANTS2.ANIM.EASING_CUBIC_INOUT;
    if (str == "Expo In")
      return CONSTANTS2.ANIM.EASING_EXPO_IN;
    if (str == "Expo Out")
      return CONSTANTS2.ANIM.EASING_EXPO_OUT;
    if (str == "Expo In Out")
      return CONSTANTS2.ANIM.EASING_EXPO_INOUT;
    if (str == "Sin In")
      return CONSTANTS2.ANIM.EASING_SIN_IN;
    if (str == "Sin Out")
      return CONSTANTS2.ANIM.EASING_SIN_OUT;
    if (str == "Sin In Out")
      return CONSTANTS2.ANIM.EASING_SIN_INOUT;
    if (str == "Back In")
      return CONSTANTS2.ANIM.EASING_BACK_IN;
    if (str == "Back Out")
      return CONSTANTS2.ANIM.EASING_BACK_OUT;
    if (str == "Back In Out")
      return CONSTANTS2.ANIM.EASING_BACK_INOUT;
    if (str == "Elastic In")
      return CONSTANTS2.ANIM.EASING_ELASTIC_IN;
    if (str == "Elastic Out")
      return CONSTANTS2.ANIM.EASING_ELASTIC_OUT;
    if (str == "Bounce In")
      return CONSTANTS2.ANIM.EASING_BOUNCE_IN;
    if (str == "Bounce Out")
      return CONSTANTS2.ANIM.EASING_BOUNCE_OUT;
    if (str == "Quart Out")
      return CONSTANTS2.ANIM.EASING_QUART_OUT;
    if (str == "Quart In")
      return CONSTANTS2.ANIM.EASING_QUART_IN;
    if (str == "Quart In Out")
      return CONSTANTS2.ANIM.EASING_QUART_INOUT;
    if (str == "Quint Out")
      return CONSTANTS2.ANIM.EASING_QUINT_OUT;
    if (str == "Quint In")
      return CONSTANTS2.ANIM.EASING_QUINT_IN;
    if (str == "Quint In Out")
      return CONSTANTS2.ANIM.EASING_QUINT_INOUT;
  };
  Anim.prototype.createPort = function(op, title, cb) {
    const port = op.inDropDown(title, CONSTANTS2.ANIM.EASINGS, "Cubic Out");
    port.set("linear");
    port.defaultValue = "linear";
    port.onChange = function() {
      this.defaultEasing = this.easingFromString(port.get());
      this.emitEvent("onChangeDefaultEasing", this);
      if (cb)
        cb();
    }.bind(this);
    return port;
  };
  Anim.slerpQuaternion = function(time, q, animx, animy, animz, animw) {
    if (!Anim.slerpQuaternion.q1) {
      Anim.slerpQuaternion.q1 = quat.create();
      Anim.slerpQuaternion.q2 = quat.create();
    }
    const i1 = animx.getKeyIndex(time);
    let i2 = i1 + 1;
    if (i2 >= animx.keys.length)
      i2 = animx.keys.length - 1;
    if (i1 == i2) {
      quat.set(q, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);
    } else {
      const key1Time = animx.keys[i1].time;
      const key2Time = animx.keys[i2].time;
      const perc = (time - key1Time) / (key2Time - key1Time);
      quat.set(Anim.slerpQuaternion.q1, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);
      quat.set(Anim.slerpQuaternion.q2, animx.keys[i2].value, animy.keys[i2].value, animz.keys[i2].value, animw.keys[i2].value);
      quat.slerp(q, Anim.slerpQuaternion.q1, Anim.slerpQuaternion.q2, perc);
    }
    return q;
  };
  const ANIM = { "Key": Key };
  ;
  const Link = function(scene) {
    EventTarget.apply(this);
    this.id = CABLES.simpleId();
    this.portIn = null;
    this.portOut = null;
    this.scene = scene;
    this.activityCounter = 0;
    this.ignoreInSerialize = false;
  };
  Link.prototype.setValue = function(v) {
    if (v === void 0)
      this._setValue();
    else
      this.portIn.set(v);
  };
  Link.prototype.activity = function() {
    this.activityCounter++;
  };
  Link.prototype._setValue = function() {
    if (!this.portOut) {
      this.remove();
      return;
    }
    const v = this.portOut.get();
    if (v == v) {
      if (this.portIn.type != CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION)
        this.activity();
      if (this.portIn.get() !== v) {
        this.portIn.set(v);
      } else {
        if (this.portIn.changeAlways)
          this.portIn.set(v);
        if (this.portOut.forceRefChange)
          this.portIn.forceChange();
      }
    }
  };
  Link.prototype.getOtherPort = function(p) {
    if (p == this.portIn)
      return this.portOut;
    return this.portIn;
  };
  Link.prototype.remove = function() {
    if (this.portIn)
      this.portIn.removeLink(this);
    if (this.portOut)
      this.portOut.removeLink(this);
    if (this.scene) {
      this.scene.emitEvent("onUnLink", this.portIn, this.portOut, this);
    }
    if (this.portIn && (this.portIn.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT || this.portIn.type == CONSTANTS2.OP.OP_PORT_TYPE_ARRAY)) {
      this.portIn.set(null);
      if (this.portIn.links.length > 0)
        this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get());
    }
    if (this.portIn)
      this.portIn.op._checkLinksNeededToWork();
    if (this.portOut)
      this.portOut.op._checkLinksNeededToWork();
    this.portIn = null;
    this.portOut = null;
    this.scene = null;
  };
  Link.prototype.link = function(p1, p2) {
    if (!Link.canLink(p1, p2)) {
      console.warn("[core_link] cannot link ports!", p1, p2);
      return false;
    }
    if (p1.direction == CONSTANTS2.PORT.PORT_DIR_IN) {
      this.portIn = p1;
      this.portOut = p2;
    } else {
      this.portIn = p2;
      this.portOut = p1;
    }
    p1.addLink(this);
    p2.addLink(this);
    this.setValue();
    if (p1.onLink)
      p1.onLink(this);
    if (p2.onLink)
      p2.onLink(this);
    p1.op._checkLinksNeededToWork();
    p2.op._checkLinksNeededToWork();
  };
  Link.prototype.getSerialized = function() {
    const obj = {};
    obj.portIn = this.portIn.getName();
    obj.portOut = this.portOut.getName();
    obj.objIn = this.portIn.op.id;
    obj.objOut = this.portOut.op.id;
    return obj;
  };
  Link.canLinkText = function(p1, p2) {
    if (p1.direction == p2.direction) {
      let txt = "(out)";
      if (p2.direction == CONSTANTS2.PORT.PORT_DIR_IN)
        txt = "(in)";
      return "can not link: same direction " + txt;
    }
    if (p1.op == p2.op)
      return "can not link: same op";
    if (p1.type != CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC && p2.type != CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC) {
      if (p1.type != p2.type)
        return "can not link: different type";
    }
    if (CABLES.UI && p1.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT && p2.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT) {
      if (p1.uiAttribs.objType && p2.uiAttribs.objType) {
        if (p1.uiAttribs.objType != p2.uiAttribs.objType)
          return "incompatible objects";
      }
    }
    if (!p1)
      return "can not link: port 1 invalid";
    if (!p2)
      return "can not link: port 2 invalid";
    if (p1.direction == CONSTANTS2.PORT.PORT_DIR_IN && p1.isAnimated())
      return "can not link: is animated";
    if (p2.direction == CONSTANTS2.PORT.PORT_DIR_IN && p2.isAnimated())
      return "can not link: is animated";
    if (p1.isLinkedTo(p2))
      return "ports already linked";
    if (p1.canLink && !p1.canLink(p2) || p2.canLink && !p2.canLink(p1))
      return "Incompatible";
    return "can link";
  };
  Link.canLink = function(p1, p2) {
    if (!p1)
      return false;
    if (!p2)
      return false;
    if (p1.direction == CONSTANTS2.PORT.PORT_DIR_IN && p1.isAnimated())
      return false;
    if (p2.direction == CONSTANTS2.PORT.PORT_DIR_IN && p2.isAnimated())
      return false;
    if (p1.isHidden() || p2.isHidden())
      return false;
    if (p1.isLinkedTo(p2))
      return false;
    if (p1.direction == p2.direction)
      return false;
    if (CABLES.UI && p1.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT && p2.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT) {
      if (p1.uiAttribs.objType && p2.uiAttribs.objType) {
        if (p1.uiAttribs.objType.indexOf("sg_") == 0 && p2.uiAttribs.objType.indexOf("sg_") == 0)
          return true;
        if (p1.uiAttribs.objType != p2.uiAttribs.objType)
          return false;
      }
    }
    if (p1.type != p2.type && (p1.type != CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC && p2.type != CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC))
      return false;
    if (p1.type == CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC || p2.type == CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC)
      return true;
    if (p1.op == p2.op)
      return false;
    if (p1.canLink && !p1.canLink(p2))
      return false;
    if (p2.canLink && !p2.canLink(p1))
      return false;
    return true;
  };
  ;
  const Port = function(___op, name2, type, uiAttribs) {
    EventTarget.apply(this);
    this.data = {};
    this._log = new Logger("core_port");
    this.direction = CONSTANTS2.PORT.PORT_DIR_IN;
    this.id = String(CABLES.simpleId());
    this._op = ___op;
    this.links = [];
    this.value = 0;
    this.name = name2;
    this.type = type || CONSTANTS2.OP.OP_PORT_TYPE_VALUE;
    this.uiAttribs = uiAttribs || {};
    this.anim = null;
    this._oldAnimVal = -5711;
    this.defaultValue = null;
    this._uiActiveState = true;
    this.ignoreValueSerialize = false;
    this.onLinkChanged = null;
    this.crashed = false;
    this._valueBeforeLink = null;
    this._lastAnimFrame = -1;
    this._animated = false;
    this.onValueChanged = null;
    this.onTriggered = null;
    this.onUiActiveStateChange = null;
    this.changeAlways = false;
    this.forceRefChange = false;
    this._useVariableName = null;
    this.activityCounter = 0;
    this.apf = 0;
    this.activityCounterStartFrame = 0;
    this._tempLastUiValue = null;
    Object.defineProperty(this, "title", {
      get() {
        return this.uiAttribs.title || this.name;
      }
    });
    Object.defineProperty(this, "parent", {
      get() {
        this._log.stack("use port.op, not .parent");
        return this._op;
      }
    });
    Object.defineProperty(this, "op", {
      get() {
        return this._op;
      }
    });
    Object.defineProperty(this, "val", {
      get() {
        this._log.warn("val getter deprecated!", this);
        this._log.stack("val getter deprecated");
        return this.get();
      },
      set(v) {
        this._log.warn("val setter deprecated!", this);
        this._log.stack("val setter deprecated");
        this.setValue(v);
      }
    });
  };
  Port.prototype.copyLinkedUiAttrib = function(which, port) {
    if (!CABLES.UI)
      return;
    if (!this.isLinked())
      return;
    const attr = {};
    attr[which] = this.links[0].getOtherPort(this).getUiAttrib(which);
    port.setUiAttribs(attr);
  };
  Port.prototype.getValueForDisplay = function() {
    let str = this.value;
    if (typeof this.value === "string" || this.value instanceof String) {
      if (str.length > 1e3) {
        str = str.substring(0, 999);
        str += "...";
      }
      if (this.uiAttribs && this.uiAttribs.display == "boolnum") {
        str += " - ";
        if (!this.value)
          str += "false";
        else
          str += "true";
      }
      str = str.replace(/[\u00A0-\u9999<>\&]/g, function(i) {
        return "&#" + i.charCodeAt(0) + ";";
      });
      if (str.length > 100)
        str = str.substring(0, 100);
    } else {
      str = this.value;
    }
    return str;
  };
  Port.prototype.onAnimToggle = function() {
  };
  Port.prototype._onAnimToggle = function() {
    this.onAnimToggle();
  };
  Port.prototype.remove = function() {
    this.removeLinks();
    this._op.removePort(this);
  };
  Port.prototype.setUiAttribs = function(newAttribs) {
    let changed = false;
    if (!this.uiAttribs)
      this.uiAttribs = {};
    for (const p in newAttribs) {
      if (newAttribs[p] === void 0) {
        delete this.uiAttribs[p];
        continue;
      }
      if (this.uiAttribs[p] != newAttribs[p])
        changed = true;
      this.uiAttribs[p] = newAttribs[p];
      if (p == "group" && this.indexPort)
        this.indexPort.setUiAttribs({ "group": newAttribs[p] });
    }
    if (newAttribs.hasOwnProperty("expose"))
      this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch);
    if (changed)
      this.emitEvent("onUiAttrChange", newAttribs, this);
  };
  Port.prototype.getUiAttribs = function() {
    return this.uiAttribs;
  };
  Port.prototype.getUiAttrib = function(attribName) {
    if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(attribName)) {
      return null;
    }
    return this.uiAttribs[attribName];
  };
  Port.prototype.get = function() {
    if (this._animated && this._lastAnimFrame != this._op.patch.getFrameNum()) {
      this._lastAnimFrame = this._op.patch.getFrameNum();
      this.value = this.anim.getValue(this._op.patch.timer.getTime());
      this._oldAnimVal = this.value;
      this.forceChange();
    }
    return this.value;
  };
  Port.prototype.setRef = function(v) {
    this.forceRefChange = true;
    this.set(v);
  };
  Port.prototype.set = Port.prototype.setValue = function(v) {
    if (v === void 0)
      v = null;
    if (this._op.enabled && !this.crashed) {
      if (v !== this.value || this.changeAlways || this.type == CONSTANTS2.OP.OP_PORT_TYPE_TEXTURE || this.type == CONSTANTS2.OP.OP_PORT_TYPE_ARRAY) {
        if (this._animated) {
          this.anim.setValue(this._op.patch.timer.getTime(), v);
        } else {
          try {
            this.value = v;
            this.forceChange();
          } catch (ex) {
            this.crashed = true;
            this.setValue = function(_v) {
            };
            this.onTriggered = function() {
            };
            this._log.error("exception in ", this._op);
            this._log.error(ex);
            this._op.patch.emitEvent("exception", ex, this._op);
          }
          if (this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == CONSTANTS2.OP.OP_PORT_TYPE_TEXTURE)
            gui.texturePreview().updateTexturePort(this);
        }
        if (this.direction == CONSTANTS2.PORT.PORT_DIR_OUT)
          for (let i = 0; i < this.links.length; ++i)
            this.links[i].setValue();
      }
    }
  };
  Port.prototype.updateAnim = function() {
    if (this._animated) {
      this.value = this.get();
      if (this._oldAnimVal != this.value || this.changeAlways) {
        this._oldAnimVal = this.value;
        this.forceChange();
      }
      this._oldAnimVal = this.value;
    }
  };
  Port.prototype.forceChange = function() {
    if (this.onValueChanged || this.onChange) {
    }
    this._activity();
    this.emitEvent("change", this.value, this);
    if (this.onChange)
      this.onChange(this, this.value);
    else if (this.onValueChanged)
      this.onValueChanged(this, this.value);
  };
  Port.prototype.getTypeString = function() {
    if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_VALUE)
      return "Number";
    if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION)
      return "Trigger";
    if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT)
      return "Object";
    if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC)
      return "Dynamic";
    if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_ARRAY)
      return "Array";
    if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_STRING)
      return "String";
    return "Unknown";
  };
  Port.prototype.deSerializeSettings = function(objPort) {
    if (!objPort)
      return;
    if (objPort.animated)
      this.setAnimated(objPort.animated);
    if (objPort.useVariable)
      this.setVariableName(objPort.useVariable);
    if (objPort.title)
      this.setUiAttribs({ "title": objPort.title });
    if (objPort.expose)
      this.setUiAttribs({ "expose": true });
    if (objPort.order)
      this.setUiAttribs({ "order": objPort.order });
    if (objPort.multiPortManual)
      this.setUiAttribs({ "multiPortManual": objPort.multiPortManual });
    if (objPort.multiPortNum)
      this.setUiAttribs({ "multiPortNum": objPort.multiPortNum });
    if (objPort.anim) {
      if (!this.anim)
        this.anim = new Anim({ "name": "port " + this.name });
      this._op._hasAnimPort = true;
      this.anim.addEventListener("onChange", () => {
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
      });
      if (objPort.anim.loop)
        this.anim.loop = objPort.anim.loop;
      for (const ani in objPort.anim.keys) {
        this.anim.keys.push(new ANIM.Key(objPort.anim.keys[ani]));
      }
      this.anim.sortKeys();
    }
  };
  Port.prototype.setInitialValue = function(v) {
    if (this.op.preservedPortLinks[this.name]) {
      for (let i = 0; i < this.op.preservedPortLinks[this.name].length; i++) {
        const lobj = this.op.preservedPortLinks[this.name][i];
        this.op.patch._addLink(
          lobj.objIn,
          lobj.objOut,
          lobj.portIn,
          lobj.portOut
        );
      }
    }
    if (this.op.preservedPortValues && this.op.preservedPortValues.hasOwnProperty(this.name) && this.op.preservedPortValues[this.name] !== void 0) {
      this.set(this.op.preservedPortValues[this.name]);
    } else if (v !== void 0)
      this.set(v);
    if (v !== void 0)
      this.defaultValue = v;
  };
  Port.prototype.getSerialized = function() {
    let obj = { "name": this.getName() };
    if (!this.ignoreValueSerialize && this.links.length === 0) {
      if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT && this.value && this.value.tex) {
      } else
        obj.value = this.value;
    }
    if (this._useVariableName)
      obj.useVariable = this._useVariableName;
    if (this._animated)
      obj.animated = true;
    if (this.anim)
      obj.anim = this.anim.getSerialized();
    if (this.uiAttribs.multiPortNum)
      obj.multiPortNum = this.uiAttribs.multiPortNum;
    if (this.uiAttribs.multiPortManual)
      obj.multiPortManual = this.uiAttribs.multiPortManual;
    if (this.uiAttribs.display == "file")
      obj.display = this.uiAttribs.display;
    if (this.uiAttribs.expose) {
      obj.expose = true;
      if (this.uiAttribs.hasOwnProperty("order"))
        obj.order = this.uiAttribs.order;
    }
    if (this.uiAttribs.title)
      obj.title = this.uiAttribs.title;
    if ((this.preserveLinks || this.direction == CONSTANTS2.PORT.PORT_DIR_OUT) && this.links.length > 0) {
      obj.links = [];
      for (const i in this.links) {
        if (!this.links[i].ignoreInSerialize && (this.links[i].portIn && this.links[i].portOut))
          obj.links.push(this.links[i].getSerialized());
      }
    }
    if (this.direction == CONSTANTS2.PORT.PORT_DIR_IN && this.links.length > 0) {
      for (const i in this.links) {
        if (!this.links[i].portIn || !this.links[i].portOut)
          continue;
        const otherp = this.links[i].getOtherPort(this);
        if (otherp.op.isInBlueprint2 && this.op.isInBlueprint2) {
          if (otherp.op.isInBlueprint2() && !this.op.isInBlueprint2()) {
            obj.links = obj.links || [];
            obj.links.push(this.links[i].getSerialized());
          }
        }
      }
    }
    if (obj.links && obj.links.length == 0)
      delete obj.links;
    if (this.type === CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION)
      delete obj.value;
    if (this.type === CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION && this.links.length == 0)
      obj = null;
    if (obj && Object.keys(obj).length == 1 && obj.name)
      obj = null;
    cleanJson(obj);
    return obj;
  };
  Port.prototype.shouldLink = function() {
    return true;
  };
  Port.prototype.removeLinks = function() {
    let count = 0;
    while (this.links.length > 0) {
      count++;
      if (count > 5e3) {
        this._log.warn("could not delete links... / infinite loop");
        this.links.length = 0;
        break;
      }
      this.links[0].remove();
    }
  };
  Port.prototype.removeLink = function(link) {
    for (const i in this.links)
      if (this.links[i] == link)
        this.links.splice(i, 1);
    if (this.direction == CONSTANTS2.PORT.PORT_DIR_IN) {
      if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_VALUE)
        this.setValue(this._valueBeforeLink || 0);
      else
        this.setValue(this._valueBeforeLink || null);
    }
    if (CABLES.UI && this._op.checkLinkTimeWarnings)
      this._op.checkLinkTimeWarnings();
    if (this.onLinkChanged)
      this.onLinkChanged();
    this.emitEvent("onLinkChanged");
    this.emitEvent("onLinkRemoved");
    this._op.emitEvent("onLinkChanged");
  };
  Port.prototype.getName = function() {
    return this.name;
  };
  Port.prototype.getTitle = function() {
    if (this.uiAttribs.title)
      return this.uiAttribs.title;
    return this.name;
  };
  Port.prototype.addLink = function(l) {
    this._valueBeforeLink = this.value;
    this.links.push(l);
    if (CABLES.UI && this._op.checkLinkTimeWarnings)
      this._op.checkLinkTimeWarnings();
    if (this.onLinkChanged)
      this.onLinkChanged();
    this.emitEvent("onLinkChanged");
    this._op.emitEvent("onLinkChanged");
  };
  Port.prototype.getLinkTo = function(p2) {
    for (const i in this.links)
      if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
        return this.links[i];
  };
  Port.prototype.removeLinkTo = function(p2) {
    for (const i in this.links) {
      if (this.links[i].portIn == p2 || this.links[i].portOut == p2) {
        this.links[i].remove();
        if (CABLES.UI && this._op.checkLinkTimeWarnings)
          this._op.checkLinkTimeWarnings();
        if (this.onLinkChanged)
          this.onLinkChanged();
        this.emitEvent("onLinkChanged");
        this.emitEvent("onLinkRemoved");
        return;
      }
    }
  };
  Port.prototype.isLinkedTo = function(p2) {
    for (const i in this.links)
      if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
        return true;
    return false;
  };
  Port.prototype._activity = function() {
    this.activityCounter++;
  };
  Port.prototype.trigger = function() {
    const linksLength = this.links.length;
    this._activity();
    if (linksLength === 0)
      return;
    if (!this._op.enabled)
      return;
    let portTriggered = null;
    try {
      for (let i = 0; i < linksLength; ++i) {
        if (this.links[i].portIn) {
          portTriggered = this.links[i].portIn;
          portTriggered.op.patch.pushTriggerStack(portTriggered);
          portTriggered._onTriggered();
          portTriggered.op.patch.popTriggerStack();
        }
        if (this.links[i])
          this.links[i].activity();
      }
    } catch (ex) {
      portTriggered.op.enabled = false;
      if (this._op.patch.isEditorMode()) {
        if (portTriggered.op.onError)
          portTriggered.op.onError(ex);
      }
      this._log.error("exception in port: " + portTriggered.op.name, portTriggered.op);
      this._log.error(ex);
    }
  };
  Port.prototype.call = function() {
    this._log.warn("call deprecated - use trigger() ");
    this.trigger();
  };
  Port.prototype.execute = function() {
    this._log.warn("### execute port: " + this.getName(), this.goals.length);
  };
  Port.prototype.setVariableName = function(n) {
    this._useVariableName = n;
    this._op.patch.on("variableRename", (oldname, newname) => {
      if (oldname != this._useVariableName)
        return;
      this._useVariableName = newname;
    });
  };
  Port.prototype.getVariableName = function() {
    return this._useVariableName;
  };
  Port.prototype.setVariable = function(v) {
    this.setAnimated(false);
    const attr = { "useVariable": false };
    if (this._variableIn && this._varChangeListenerId) {
      this._variableIn.off(this._varChangeListenerId);
      this._variableIn = null;
    }
    if (v) {
      this._variableIn = this._op.patch.getVar(v);
      if (!this._variableIn) {
        this._log.warn("PORT VAR NOT FOUND!!!", v);
      } else {
        if (this.type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT) {
          this._varChangeListenerId = this._variableIn.on("change", () => {
            this.set(null);
            this.set(this._variableIn.getValue());
          });
        } else {
          this._varChangeListenerId = this._variableIn.on("change", this.set.bind(this));
        }
        this.set(this._variableIn.getValue());
      }
      this._useVariableName = v;
      attr.useVariable = true;
      attr.variableName = this._useVariableName;
    } else {
      attr.variableName = this._useVariableName = null;
      attr.useVariable = false;
    }
    this.setUiAttribs(attr);
    this._op.patch.emitEvent("portSetVariable", this._op, this, v);
  };
  Port.prototype._handleNoTriggerOpAnimUpdates = function(a) {
    let hasTriggerPort = false;
    for (let i = 0; i < this._op.portsIn.length; i++) {
      if (this._op.portsIn.type == CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION) {
        hasTriggerPort = true;
        break;
      }
    }
    if (!hasTriggerPort) {
      if (a)
        this._notriggerAnimUpdate = this._op.patch.on(
          "onRenderFrame",
          () => {
            this.updateAnim();
          }
        );
      else
        this._op.patch.removeEventListener(this._notriggerAnimUpdate);
    }
  };
  Port.prototype.setAnimated = function(a) {
    if (this._animated != a) {
      this._animated = a;
      this._op._hasAnimPort = true;
      if (this._animated && !this.anim) {
        this.anim = new Anim({ "name": "port " + this.name });
        this.anim.addEventListener("onChange", () => {
          this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
        });
      }
      this._onAnimToggle();
    }
    this._handleNoTriggerOpAnimUpdates(a);
    if (!a) {
      this.anim = null;
    }
    this.setUiAttribs({ "isAnimated": this._animated });
  };
  Port.prototype.toggleAnim = function() {
    this._animated = !this._animated;
    if (this._animated && !this.anim) {
      this.anim = new Anim({ "name": "port " + this.name });
      this.anim.addEventListener("onChange", () => {
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
      });
    }
    this.setAnimated(this._animated);
    this._onAnimToggle();
    this.setUiAttribs({ "isAnimated": this._animated });
  };
  Port.prototype.getType = function() {
    return this.type;
  };
  Port.prototype.isLinked = function() {
    return this.links.length > 0 || this._animated || this._useVariableName != null;
  };
  Port.prototype.isBoundToVar = function() {
    const b = this._useVariableName != null;
    this.uiAttribs.boundToVar = b;
    return b;
  };
  Port.prototype.isAnimated = function() {
    return this._animated;
  };
  Port.prototype.isHidden = function() {
    return this.uiAttribs.hidePort;
  };
  Port.prototype._onTriggered = function(a) {
    this._activity();
    this._op.updateAnims();
    if (this._op.enabled && this.onTriggered)
      this.onTriggered(a);
    if (this._op.enabled)
      this.emitEvent("trigger");
  };
  Port.prototype._onSetProfiling = function(v) {
    this._op.patch.profiler.add("port", this);
    this.setValue(v);
    this._op.patch.profiler.add("port", null);
  };
  Port.prototype._onTriggeredProfiling = function() {
    if (this._op.enabled && this.onTriggered) {
      this._op.patch.profiler.add("port", this);
      this.onTriggered();
      this._op.patch.profiler.add("port", null);
    }
  };
  Port.prototype.getUiActiveState = function() {
    return this._uiActiveState;
  };
  Port.prototype.setUiActiveState = function(onoff) {
    this._uiActiveState = onoff;
    if (this.onUiActiveStateChange)
      this.onUiActiveStateChange();
  };
  Port.prototype.onValueChange = function(cb) {
    this.onChange = cb;
  };
  Port.prototype.hidePort = function() {
  };
  Port.portTypeNumberToString = function(type) {
    if (type == CONSTANTS2.OP.OP_PORT_TYPE_VALUE)
      return "value";
    if (type == CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION)
      return "function";
    if (type == CONSTANTS2.OP.OP_PORT_TYPE_OBJECT)
      return "object";
    if (type == CONSTANTS2.OP.OP_PORT_TYPE_ARRAY)
      return "array";
    if (type == CONSTANTS2.OP.OP_PORT_TYPE_STRING)
      return "string";
    if (type == CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC)
      return "dynamic";
    return "unknown";
  };
  ;
  class SwitchPort extends Port {
    constructor(__parent, name2, type, uiAttribs, indexPort) {
      super(__parent, name2, type, uiAttribs);
      this.get = () => {
        let s = super.get();
        if (CABLES.UI) {
          if (s === "" || s === null || s === void 0 || uiAttribs.values && uiAttribs.values.indexOf(String(s)) === -1) {
            this.op.setUiError("invalidswitch", "Invalid Value [" + this.name + ']: "' + s + '"', 1);
          } else
            this.op.setUiError("invalidswitch", null);
        }
        if (s === null || s === void 0)
          s = "";
        return s;
      };
      this.indexPort = indexPort;
      this.indexPort.set = (value) => {
        const values = uiAttribs.values;
        if (!values) {
          return;
        }
        let intValue = Math.floor(value);
        intValue = Math.min(intValue, values.length - 1);
        intValue = Math.max(intValue, 0);
        this.indexPort.setValue(intValue);
        this.set(values[intValue]);
        if (this.op.patch.isEditorMode() && performance.now() - (this.lastTime || 0) > 100 && window.gui && gui.patchView.isCurrentOp(this.op)) {
          gui.opParams.show(this.op);
          this.lastTime = performance.now();
        }
      };
    }
    setUiAttribs(attribs) {
      const hidePort = attribs.hidePort;
      attribs.hidePort = true;
      super.setUiAttribs(attribs);
      if (typeof hidePort !== "undefined") {
        this.indexPort.setUiAttribs({ hidePort });
      }
    }
  }
  ;
  class ValueSelectPort extends SwitchPort {
    setUiAttribs(newAttribs) {
      if (this.indexPort.isLinked()) {
        for (const p in newAttribs) {
          if (p == "greyout" && !newAttribs[p])
            newAttribs[p] = "true";
        }
      }
      super.setUiAttribs(newAttribs);
    }
  }
  ;
  const MIN_NUM_PORTS = 2;
  class MultiPort extends Port {
    constructor(__parent, name2, type, dir, uiAttribs, uiAttribsPorts) {
      super(__parent, name2, CONSTANTS2.OP.OP_PORT_TYPE_ARRAY, uiAttribs);
      this.setUiAttribs({ "multiPort": true, "group": this.name, "order": -1 });
      this.ports = [];
      this.direction = dir;
      this._uiAttribsPorts = uiAttribsPorts;
      const updateArray = () => {
        const arr = [];
        let ll = 1;
        if (this.uiAttribs.multiPortManual)
          ll = 0;
        for (let i = 0; i < this.ports.length - ll; i++)
          arr[i] = this.ports[i];
        this.setRef(arr);
      };
      const updateUi = () => {
        let grey = !this.uiAttribs.multiPortManual || void 0;
        if (this.direction == CONSTANTS2.PORT.PORT_DIR_OUT)
          grey = false;
        for (let i = 0; i < this.ports.length; i++) {
          let lp;
          let addPort = false;
          let title;
          let o = {};
          if (this.op.preservedPortTitles && this.op.preservedPortTitles[this.ports[i].name])
            title = this.op.preservedPortTitles[this.ports[i].name];
          if (i == 0)
            lp = this.ports.length;
          if (!this.uiAttribs.multiPortManual) {
            if (i == this.ports.length - 1) {
              title = "add port";
              addPort = true;
              grey = true;
            }
          }
          for (const attin in this._uiAttribsPorts) {
            o[attin] = this._uiAttribsPorts[attin];
          }
          o.addPort = addPort;
          o.longPort = lp;
          o.title = title;
          o.greyout = grey;
          o.group = this.name;
          this.ports[i].setUiAttribs(o);
        }
      };
      this.removeInvalidPorts = () => {
        for (let i = 0; i < this.ports.length; i++) {
          if (!this.ports[i])
            this.ports.splice(i, 1);
        }
        if (!this.uiAttribs.multiPortManual) {
          if (this.ports.length > MIN_NUM_PORTS)
            for (let i = this.ports.length - 1; i > 1; i--) {
              if (!this.ports[i].isLinked())
                this.uiAttribs.multiPortNum = i;
              else
                break;
            }
        }
        updateArray();
      };
      this.countPorts = () => {
        if (CABLES.UI && !gui.isRemoteClient && gui.patchView && gui.patchView.patchRenderer && gui.patchView.patchRenderer.isDraggingPort()) {
          clearTimeout(this.retryTo);
          this.retryTo = setTimeout(this.countPorts.bind(this));
          return;
        }
        this.retryTo = null;
        let redo = false;
        this.removeListeners();
        this.removeInvalidPorts();
        for (let i = 0; i < this.ports.length; i++) {
          if (this.ports[i] && this.ports[i].links.length > 1) {
            const po = this.ports[i + 1];
            const otherPort = this.ports[i].links[0].getOtherPort(this.ports[i]);
            if (!po || !otherPort) {
              this._log.warn("no port found?", po.name);
            } else {
              this.ports[i].links[0].remove();
              this.op.patch.link(this.op, po.name, otherPort.op, otherPort.name);
              redo = true;
            }
            break;
          }
        }
        if (!this.uiAttribs.multiPortManual) {
          let foundHole = true;
          while (foundHole) {
            foundHole = false;
            for (let i = this.ports.length - 1; i > 1; i--) {
              if (this.ports[i] && this.ports[i].links.length > 0 && this.ports[i - 1].links.length == 0) {
                const otherPort = this.ports[i].links[0].getOtherPort(this.ports[i]);
                this.ports[i].links[0].remove();
                const po = this.ports[i - 1];
                if (po && this.ports[i]) {
                  this.op.patch.link(this.op, po.name, otherPort.op, otherPort.name);
                  foundHole = true;
                  redo = true;
                  break;
                }
              }
            }
          }
        }
        if (!this.uiAttribs.multiPortManual) {
          while (this.ports.length > MIN_NUM_PORTS && !this.ports[this.ports.length - 1].isLinked() && !this.ports[this.ports.length - 2].isLinked()) {
            let i = this.ports.length - 1;
            if (!this.ports[i].isLinked() && this.ports[i - 1] && !this.ports[i - 1].isLinked()) {
              this.ports[i].setUiAttribs({ "removed": true });
              this.ports[i].remove();
              this.ports.splice(i, 1);
            }
          }
        }
        this.removeInvalidPorts();
        if (!this.uiAttribs.multiPortManual && this.ports.length > 0 && this.ports[this.ports.length - 1].isLinked())
          this.newPort();
        updateArray();
        updateUi();
        if (redo)
          this.countPorts();
        else
          this.addListeners();
      };
      this.removeListeners = () => {
        for (let i = 0; i < this.ports.length; i++) {
          const po = this.ports[i];
          po.multiPortChangeListener = po.off(po.multiPortChangeListener);
          po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
        }
      };
      this.addListeners = () => {
        for (let i = 0; i < this.ports.length; i++) {
          const po = this.ports[i];
          const idx = i;
          if (po.multiPortChangeListener)
            po.multiPortChangeListener = po.off(po.multiPortChangeListener);
          po.multiPortChangeListener = po.on("change", updateArray.bind(this));
          if (po.multiPortTriggerListener)
            po.multiPortTriggerListener = po.off(po.multiPortTriggerListener);
          po.multiPortTriggerListener = po.on("trigger", () => {
            this._onTriggered(idx);
          });
          if (po.multiLinkChangeListener)
            po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
          po.multiLinkChangeListener = po.on("onLinkChanged", () => {
            this.countPorts();
            this.emitEvent("onLinkChanged");
          });
          if (po.multiLinkRemoveListener)
            po.multiLinkRemoveListener = po.off(po.multiLinkRemoveListener);
          po.multiLinkRemoveListener = po.on("onLinkRemoved", () => {
            updateUi();
            this.emitEvent("onLinkChanged");
          });
        }
      };
      this.newPort = () => {
        const attrs = {};
        attrs.type = type;
        const po = new Port(this.op, name2 + "_" + this.ports.length, type, attrs);
        po.direction = dir;
        this.ports.push(po);
        if (this.direction == CONSTANTS2.PORT.PORT_DIR_OUT)
          this.op.addOutPort(po);
        else
          this.op.addInPort(po);
        if (type == CONSTANTS2.OP.OP_PORT_TYPE_NUMBER)
          po.setInitialValue(0);
        else if (type == CONSTANTS2.OP.OP_PORT_TYPE_STRING)
          po.setInitialValue("");
        this.addListeners();
        updateUi();
        updateArray();
        this.emitEvent("onLinkChanged");
        if (this.op.preservedPortTitles && this.op.preservedPortTitles[po.name])
          po.setUiAttribs({ "title": this.op.preservedPortTitles[po.name] });
        return po;
      };
      this.initPorts = () => {
        for (let i = 0; i < MIN_NUM_PORTS; i++)
          this.newPort();
        updateArray();
        updateUi();
      };
      this.checkNum = () => {
        this.uiAttribs.multiPortNum = Math.max(MIN_NUM_PORTS, this.uiAttribs.multiPortNum);
        while (this.ports.length < this.uiAttribs.multiPortNum)
          this.newPort();
        while (this.ports.length > this.uiAttribs.multiPortNum)
          if (this.ports[this.ports.length - 1])
            this.ports.pop().remove();
        this.removeInvalidPorts();
      };
      this.incDec = (incDir) => {
        this.uiAttribs.multiPortNum = this.uiAttribs.multiPortNum || MIN_NUM_PORTS;
        this.setUiAttribs({ "multiPortNum": this.uiAttribs.multiPortNum + incDir });
        this.checkNum();
        updateUi();
      };
      this.toggleManual = () => {
        this.setUiAttribs({ "multiPortManual": !this.uiAttribs.multiPortManual });
        this.op.refreshParams();
      };
      this.on("onUiAttrChange", (attribs) => {
        if (attribs.hasOwnProperty("multiPortManual")) {
          updateUi();
          this.removeInvalidPorts();
          this.checkNum();
          this.countPorts();
          updateUi();
        }
      });
      this.on("onUiAttrChange", this.checkNum.bind(this));
      this.checkNum();
      this.countPorts();
      this.removeInvalidPorts();
      updateUi();
    }
  }
  ;
  const Ops2 = {};
  const Op = function() {
    EventTarget.apply(this);
    this._log = new Logger("core_op");
    this.data = {};
    this.storage = {};
    this.__objName = "";
    this.portsOut = [];
    this.portsIn = [];
    this.portsInData = [];
    this.opId = "";
    this.uiAttribs = {};
    this.enabled = true;
    this.patch = arguments[0];
    this._name = arguments[1];
    this.preservedPortTitles = {};
    this.preservedPortValues = {};
    this.preservedPortLinks = {};
    this._linkTimeRules = {
      "needsLinkedToWork": [],
      "needsParentOp": null
    };
    this.shouldWork = {};
    this.hasUiErrors = false;
    this._uiErrors = {};
    this._hasAnimPort = false;
    if (arguments[1]) {
      this._shortOpName = CABLES.getShortOpName(arguments[1]);
      this.getTitle();
    }
    this.id = arguments[2] || shortId();
    this.onAddPort = null;
    this.onCreate = null;
    this.onResize = null;
    this.onLoaded = null;
    this.onDelete = null;
    this.onError = null;
    this._instances = null;
    this.preRender = null;
    this.init = null;
    Object.defineProperty(this, "name", {
      get() {
        return this.getTitle();
      },
      set(v) {
        this.setTitle(v);
      }
    });
    Object.defineProperty(this, "_objName", { set(on) {
      this.__objName = on;
      this._log = new Logger("op " + on);
    } });
    Object.defineProperty(this, "objName", { get() {
      return this.__objName;
    } });
    Object.defineProperty(this, "shortName", { get() {
      return this._shortOpName;
    } });
    if (this.initUi)
      this.initUi();
  };
  {
    Op.prototype.clearUiAttrib = function(name2) {
      const obj = {};
      this.uiAttrib(obj);
    };
    Op.prototype.checkMainloopExists = function() {
      if (!CABLES.UI)
        return;
      if (!this.patch.cgl.mainloopOp)
        this.setUiError("nomainloop", "patch should have a mainloop to use this op");
      else
        this.setUiError("nomainloop", null);
    };
    Op.prototype.getTitle = function() {
      if (!this.uiAttribs)
        return "nouiattribs" + this._name;
      return this.uiAttribs.title || this._shortOpName;
    };
    Op.prototype.setTitle = function(title) {
      if (title != this.getTitle())
        this.uiAttr({ "title": title });
    };
    Op.prototype.setStorage = function(newAttribs) {
      if (!newAttribs)
        return;
      this.storage = this.storage || {};
      let changed = false;
      for (const p in newAttribs) {
        if (this.storage[p] != newAttribs[p])
          changed = true;
        this.storage[p] = newAttribs[p];
      }
      if (changed)
        this.emitEvent("onStorageChange", newAttribs);
    };
    Op.prototype.isSubPatchOp = function() {
      if (this.storage)
        return this.storage.subPatchVer || 0;
    };
    const _setUiAttrib = function(newAttribs) {
      if (!newAttribs)
        return;
      if (newAttribs.error || newAttribs.warning || newAttribs.hint) {
        this._log.warn("old ui error/warning attribute in " + this._name + ", use op.setUiError !", newAttribs);
      }
      if (typeof newAttribs != "object")
        this._log.error("op.uiAttrib attribs are not of type object");
      if (!this.uiAttribs)
        this.uiAttribs = {};
      let changed = false;
      let emitMove = false;
      if (CABLES.UI && newAttribs.hasOwnProperty("translate") && (!this.uiAttribs.translate || this.uiAttribs.translate.x != newAttribs.translate.x || this.uiAttribs.translate.y != newAttribs.translate.y))
        emitMove = true;
      if (newAttribs.hasOwnProperty("title") && newAttribs.title != this.uiAttribs.title) {
        this.uiAttribs.title = newAttribs.title;
        changed = true;
      }
      if (newAttribs.hasOwnProperty("disabled"))
        this.setEnabled(!newAttribs.disabled);
      for (const p in newAttribs) {
        if (this.uiAttribs[p] != newAttribs[p])
          changed = true;
        this.uiAttribs[p] = newAttribs[p];
      }
      if (this.uiAttribs.hasOwnProperty("selected") && this.uiAttribs.selected == false)
        delete this.uiAttribs.selected;
      if (changed) {
        this.emitEvent("onUiAttribsChange", newAttribs);
        this.patch.emitEvent("onUiAttribsChange", this, newAttribs);
      }
      if (emitMove)
        this.emitEvent("move");
    };
    Op.prototype.setUiAttribs = Op.prototype.setUiAttrib = Op.prototype.uiAttr = _setUiAttrib;
    Op.prototype.getName = function() {
      if (this.uiAttribs.name)
        return this.uiAttribs.name;
      return this._name;
    };
    Op.prototype.addOutPort = function(p) {
      p.direction = CONSTANTS2.PORT.PORT_DIR_OUT;
      p._op = this;
      this.portsOut.push(p);
      this.emitEvent("onPortAdd", p);
      return p;
    };
    Op.prototype.hasDynamicPort = function() {
      let i = 0;
      for (i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].type == CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC)
          return true;
        if (this.portsIn[i].getName() == "dyn")
          return true;
      }
      for (i = 0; i < this.portsOut.length; i++) {
        if (this.portsOut[i].type == CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC)
          return true;
        if (this.portsOut[i].getName() == "dyn")
          return true;
      }
      return false;
    };
    Op.prototype.addInPort = function(p) {
      if (!(p instanceof Port))
        throw new Error("parameter is not a port!");
      p.direction = CONSTANTS2.PORT.PORT_DIR_IN;
      p._op = this;
      this.portsIn.push(p);
      this.emitEvent("onPortAdd", p);
      return p;
    };
    Op.prototype.inFunction = Op.prototype.inTrigger = function(name2, v) {
      const p = this.addInPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION));
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.inFunctionButton = Op.prototype.inTriggerButton = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION, {
          "display": "button"
        })
      );
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.inFunctionButton = Op.prototype.inUiTriggerButtons = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION, {
          "display": "buttons"
        })
      );
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.inValueFloat = Op.prototype.inValue = Op.prototype.inFloat = function(name2, v) {
      const p = this.addInPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE));
      p.setInitialValue(v);
      return p;
    };
    Op.prototype.inValueBool = Op.prototype.inBool = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_NUMBER, {
          "display": "bool"
        })
      );
      if (v === true)
        v = 1;
      if (v === false)
        v = 0;
      p.setInitialValue(v);
      return p;
    };
    Op.prototype.inMultiPort = function(name2, type) {
      const p = new MultiPort(
        this,
        name2,
        type,
        CONSTANTS2.PORT.PORT_DIR_IN,
        {
          "addPort": true,
          "hidePort": true
        }
      );
      p.ignoreValueSerialize = true;
      this.addInPort(p);
      p.initPorts();
      return p;
    };
    Op.prototype.outMultiPort = function(name2, type, uiAttribsPort = {}) {
      const p = new MultiPort(
        this,
        name2,
        type,
        CONSTANTS2.PORT.PORT_DIR_OUT,
        {
          "display": "multiport",
          "hidePort": true
        },
        uiAttribsPort
      );
      p.ignoreValueSerialize = true;
      this.addOutPort(p);
      p.initPorts();
      return p;
    };
    Op.prototype.inValueString = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "type": "string"
        })
      );
      p.value = "";
      p.setInitialValue(v);
      return p;
    };
    Op.prototype.inString = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_STRING, {
          "type": "string"
        })
      );
      v = v || "";
      p.setInitialValue(v);
      return p;
    };
    Op.prototype.inValueText = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "type": "string",
          "display": "text"
        })
      );
      p.value = "";
      p.setInitialValue(v);
      return p;
    };
    Op.prototype.inTextarea = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_STRING, {
          "type": "string",
          "display": "text"
        })
      );
      p.value = "";
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.inStringEditor = function(name2, v, syntax, hideFormatButton = true) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_STRING, {
          "type": "string",
          "display": "editor",
          "editShortcut": true,
          "editorSyntax": syntax,
          "hideFormatButton": hideFormatButton
        })
      );
      p.value = "";
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.inValueEditor = function(name2, v, syntax, hideFormatButton = true) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_NUMBER, {
          "type": "string",
          "display": "editor",
          "editorSyntax": syntax,
          "hideFormatButton": hideFormatButton
        })
      );
      p.value = "";
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.inValueSelect = Op.prototype.inDropDown = function(name2, values, v, noindex) {
      let p = null;
      if (!noindex) {
        const indexPort = new Port(this, name2 + " index", CONSTANTS2.OP.OP_PORT_TYPE_NUMBER, {
          "increment": "integer",
          "hideParam": true
        });
        const n = this.addInPort(indexPort);
        if (values)
          for (let i = 0; i < values.length; i++)
            values[i] = String(values[i]);
        const valuePort = new ValueSelectPort(
          this,
          name2,
          CONSTANTS2.OP.OP_PORT_TYPE_NUMBER,
          {
            "display": "dropdown",
            "hidePort": true,
            "type": "string",
            "values": values
          },
          n
        );
        valuePort.indexPort = indexPort;
        valuePort.on("change", (val, thePort) => {
          if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values) {
            const idx = thePort.uiAttribs.values.indexOf(val);
            if (idx > -1)
              thePort.indexPort.set(idx);
          }
        });
        indexPort.onLinkChanged = function() {
          valuePort.setUiAttribs({ "greyout": indexPort.isLinked() });
        };
        p = this.addInPort(valuePort);
        if (v !== void 0) {
          p.set(v);
          const index = values.findIndex((item) => {
            return item == v;
          });
          n.setValue(index);
          p.defaultValue = v;
          n.defaultValue = index;
        }
      } else {
        const valuePort = new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "display": "dropdown",
          "hidePort": true,
          "type": "string",
          values
        });
        p = this.addInPort(valuePort);
      }
      return p;
    };
    Op.prototype.inSwitch = function(name2, values, v, noindex) {
      let p = null;
      if (!noindex) {
        if (!v)
          v = values[0];
        const indexPort = new Port(this, name2 + " index", CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "increment": "integer",
          "values": values,
          "hideParam": true
        });
        const n = this.addInPort(indexPort);
        if (values)
          for (let i = 0; i < values.length; i++)
            values[i] = String(values[i]);
        const switchPort = new SwitchPort(
          this,
          name2,
          CONSTANTS2.OP.OP_PORT_TYPE_STRING,
          {
            "display": "switch",
            "hidePort": true,
            "type": "string",
            "values": values
          },
          n
        );
        switchPort.indexPort = indexPort;
        switchPort.on("change", (val, thePort) => {
          if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values) {
            const idx = thePort.uiAttribs.values.indexOf(val);
            if (idx > -1)
              thePort.indexPort.set(idx);
          }
        });
        indexPort.onLinkChanged = function() {
          switchPort.setUiAttribs({ "greyout": indexPort.isLinked() });
        };
        p = this.addInPort(switchPort);
        if (v !== void 0) {
          p.set(v);
          const index = values.findIndex((item) => {
            return item == v;
          });
          n.setValue(index);
          p.defaultValue = v;
          n.defaultValue = index;
        }
      } else {
        const switchPort = new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_STRING, {
          "display": "switch",
          "hidePort": true,
          "type": "string",
          "values": values
        });
        p = this.addInPort(switchPort);
      }
      return p;
    };
    Op.prototype.inValueInt = Op.prototype.inInt = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "increment": "integer"
        })
      );
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.inFile = function(name2, filter, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "display": "file",
          "type": "string",
          "filter": filter
        })
      );
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.inUrl = function(name2, filter, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_STRING, {
          "display": "file",
          "type": "string",
          "filter": filter
        })
      );
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.inTexture = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_OBJECT, {
          "display": "texture",
          "objType": "texture",
          "preview": true
        })
      );
      p.ignoreValueSerialize = true;
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.inObject = function(name2, v, objType) {
      const p = this.addInPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_OBJECT, { "objType": objType }));
      p.ignoreValueSerialize = true;
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.inGradient = function(name2, v) {
      const p = this.addInPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "display": "gradient"
          // "hidePort": true
        })
      );
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.getPortVisibleIndex = function(p) {
      let ports = this.portsIn;
      if (p.direction == CONSTANTS2.PORT_DIR_OUT)
        ports = this.portsOut;
      let index = 0;
      for (let i = 0; i < ports.length; i++) {
        if (ports[i].uiAttribs.hidePort)
          continue;
        index++;
        if (ports[i] == p)
          return index;
      }
    };
    Op.prototype.inArray = function(name2, v, stride) {
      if (!stride && CABLES.UTILS.isNumeric(v))
        stride = v;
      const p = this.addInPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_ARRAY, { "stride": stride }));
      if (v !== void 0 && (Array.isArray(v) || v == null))
        p.set(v);
      return p;
    };
    Op.prototype.inValueSlider = Op.prototype.inFloatSlider = function(name2, v, min, max) {
      const uiattribs = { "display": "range" };
      if (min != void 0 && max != void 0) {
        uiattribs.min = min;
        uiattribs.max = max;
      }
      const p = this.addInPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, uiattribs));
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.outFunction = Op.prototype.outTrigger = function(name2, v) {
      const p = this.addOutPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION));
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.outValue = Op.prototype.outNumber = function(name2, v) {
      const p = this.addOutPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE));
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.outValueBool = Op.prototype.outBool = function(name2, v) {
      const p = this.addOutPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "display": "bool"
        })
      );
      if (v !== void 0)
        p.set(v);
      else
        p.set(0);
      return p;
    };
    Op.prototype.outBoolNum = function(name2, v) {
      const p = this.addOutPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "display": "boolnum"
        })
      );
      p.set = function(b) {
        this.setValue(b ? 1 : 0);
      }.bind(p);
      if (v !== void 0)
        p.set(v);
      else
        p.set(0);
      return p;
    };
    Op.prototype.outValueString = function(name2, v) {
      const p = this.addOutPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_VALUE, {
          "type": "string"
        })
      );
      if (v !== void 0)
        p.set(v);
      return p;
    };
    Op.prototype.outString = function(name2, v) {
      const p = this.addOutPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_STRING, {
          "type": "string"
        })
      );
      if (v !== void 0)
        p.set(v);
      else
        p.set("");
      return p;
    };
    Op.prototype.outObject = function(name2, v, objType) {
      const p = this.addOutPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_OBJECT, { "objType": objType || null }));
      p.set(v || null);
      p.ignoreValueSerialize = true;
      return p;
    };
    Op.prototype.outArray = function(name2, v, stride) {
      if (!stride && CABLES.UTILS.isNumeric(v))
        stride = v;
      const p = this.addOutPort(new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_ARRAY, { "stride": stride }));
      if (v !== void 0 && (Array.isArray(v) || v == null))
        p.set(v);
      p.ignoreValueSerialize = true;
      return p;
    };
    Op.prototype.outTexture = function(name2, v) {
      const p = this.addOutPort(
        new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_OBJECT, {
          "preview": true,
          "objType": "texture",
          "display": "texture"
        })
      );
      if (v !== void 0)
        p.set(v || CGL.Texture.getEmptyTexture(this.patch.cgl));
      p.ignoreValueSerialize = true;
      return p;
    };
    Op.prototype.inDynamic = function(name2, filter, options, v) {
      const p = new Port(this, name2, CONSTANTS2.OP.OP_PORT_TYPE_DYNAMIC, options);
      p.shouldLink = function(p1, p2) {
        if (filter && UTILS.isArray(filter)) {
          for (let i = 0; i < filter.length; i++) {
            if (p1 == this && p2.type === filter[i])
              return true;
            if (p2 == this && p1.type === filter[i])
              return true;
          }
          return false;
        }
        return true;
      };
      this.addInPort(p);
      if (v !== void 0) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };
    Op.prototype.removeLinks = function() {
      for (let i = 0; i < this.portsIn.length; i++)
        this.portsIn[i].removeLinks();
      for (let i = 0; i < this.portsOut.length; i++)
        this.portsOut[i].removeLinks();
    };
    Op.prototype.getSerialized = function() {
      const opObj = {};
      if (this.opId)
        opObj.opId = this.opId;
      if (this.patch.storeObjNames)
        opObj.objName = this.objName;
      opObj.id = this.id;
      opObj.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {};
      if (this.storage && Object.keys(this.storage).length > 0)
        opObj.storage = JSON.parse(JSON.stringify(this.storage));
      if (this.uiAttribs.hasOwnProperty("working") && this.uiAttribs.working == true)
        delete this.uiAttribs.working;
      if (opObj.uiAttribs.hasOwnProperty("uierrors"))
        delete opObj.uiAttribs.uierrors;
      if (opObj.uiAttribs.title === "")
        delete opObj.uiAttribs.title;
      if (opObj.uiAttribs.color === null)
        delete opObj.uiAttribs.color;
      if (opObj.uiAttribs.comment === null)
        delete opObj.uiAttribs.comment;
      if (opObj.uiAttribs.title == this._shortOpName || (this.uiAttribs.title || "").toLowerCase() == this._shortOpName.toLowerCase())
        delete opObj.uiAttribs.title;
      opObj.portsIn = [];
      opObj.portsOut = [];
      for (let i = 0; i < this.portsIn.length; i++) {
        const s = this.portsIn[i].getSerialized();
        if (s)
          opObj.portsIn.push(s);
      }
      for (let i = 0; i < this.portsOut.length; i++) {
        const s = this.portsOut[i].getSerialized();
        if (s)
          opObj.portsOut.push(s);
      }
      if (opObj.portsIn.length == 0)
        delete opObj.portsIn;
      if (opObj.portsOut.length == 0)
        delete opObj.portsOut;
      cleanJson(opObj);
      return opObj;
    };
    Op.prototype.getFirstOutPortByType = function(type) {
      for (const ipo in this.portsOut)
        if (this.portsOut[ipo].type == type)
          return this.portsOut[ipo];
    };
    Op.prototype.getFirstInPortByType = function(type) {
      for (const ipo in this.portsIn)
        if (this.portsIn[ipo].type == type)
          return this.portsIn[ipo];
    };
    Op.prototype.getPort = Op.prototype.getPortByName = function(name2, lowerCase) {
      if (lowerCase) {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
          if (this.portsIn[ipi].getName().toLowerCase() == name2 || this.portsIn[ipi].id.toLowerCase() == name2)
            return this.portsIn[ipi];
        for (let ipo = 0; ipo < this.portsOut.length; ipo++)
          if (this.portsOut[ipo].getName().toLowerCase() == name2 || this.portsOut[ipo].id.toLowerCase() == name2)
            return this.portsOut[ipo];
      } else {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
          if (this.portsIn[ipi].getName() == name2 || this.portsIn[ipi].id == name2)
            return this.portsIn[ipi];
        for (let ipo = 0; ipo < this.portsOut.length; ipo++)
          if (this.portsOut[ipo].getName() == name2 || this.portsOut[ipo].id == name2)
            return this.portsOut[ipo];
      }
    };
    Op.prototype.getPortById = function(id) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        if (this.portsIn[ipi].id == id)
          return this.portsIn[ipi];
      for (let ipo = 0; ipo < this.portsOut.length; ipo++)
        if (this.portsOut[ipo].id == id)
          return this.portsOut[ipo];
    };
    Op.prototype.updateAnims = function() {
      if (this._hasAnimPort)
        for (let i = 0; i < this.portsIn.length; i++)
          this.portsIn[i].updateAnim();
    };
    Op.prototype.log = function() {
      this._log.log(...arguments);
    };
    Op.prototype.error = Op.prototype.logError = function() {
      this._log.error(...arguments);
    };
    Op.prototype.warn = Op.prototype.logWarn = function() {
      this._log.warn(...arguments);
    };
    Op.prototype.verbose = Op.prototype.logVerbose = function() {
      this._log.verbose(...arguments);
    };
    Op.prototype.profile = function(enable) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        this.portsIn[ipi]._onTriggered = this.portsIn[ipi]._onTriggeredProfiling;
        this.portsIn[ipi].set = this.portsIn[ipi]._onSetProfiling;
      }
    };
    Op.prototype.findParent = function(objName) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        if (this.portsIn[ipi].isLinked()) {
          if (this.portsIn[ipi].links[0].portOut.parent.objName == objName)
            return this.portsIn[ipi].links[0].portOut.parent;
          let found = null;
          found = this.portsIn[ipi].links[0].portOut.parent.findParent(objName);
          if (found)
            return found;
        }
      }
      return null;
    };
    Op.prototype.cleanUp = function() {
      if (this._instances) {
        for (let i = 0; i < this._instances.length; i++) {
          if (this._instances[i].onDelete)
            this._instances[i].onDelete();
        }
        this._instances.length = 0;
      }
      for (let i = 0; i < this.portsIn.length; i++) {
        this.portsIn[i].setAnimated(false);
      }
      if (this.onAnimFrame)
        this.patch.removeOnAnimFrame(this);
    };
    Op.prototype.instanced = function(triggerPort) {
      this._log.log("instanced", this.patch.instancing.numCycles());
      if (this.patch.instancing.numCycles() === 0)
        return false;
      let i = 0;
      let ipi = 0;
      if (!this._instances || this._instances.length != this.patch.instancing.numCycles()) {
        if (!this._instances)
          this._instances = [];
        this._.log("creating instances of ", this.objName, this.patch.instancing.numCycles(), this._instances.length);
        this._instances.length = this.patch.instancing.numCycles();
        for (i = 0; i < this._instances.length; i++) {
          this._instances[i] = this.patch.createOp(this.objName, true);
          this._instances[i].instanced = function() {
            return false;
          };
          this._instances[i].uiAttr(this.uiAttribs);
          for (let ipo = 0; ipo < this.portsOut.length; ipo++) {
            if (this.portsOut[ipo].type == CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION) {
              this._instances[i].getPortByName(this.portsOut[ipo].name).trigger = this.portsOut[ipo].trigger.bind(this.portsOut[ipo]);
            }
          }
        }
        for (ipi = 0; ipi < this.portsIn.length; ipi++) {
          this.portsIn[ipi].onChange = null;
          this.portsIn[ipi].onValueChanged = null;
        }
      }
      const theTriggerPort = null;
      for (ipi = 0; ipi < this.portsIn.length; ipi++) {
        if (this.portsIn[ipi].type == CONSTANTS2.OP.OP_PORT_TYPE_VALUE || this.portsIn[ipi].type == CONSTANTS2.OP.OP_PORT_TYPE_ARRAY) {
          this._instances[this.patch.instancing.index()].portsIn[ipi].set(this.portsIn[ipi].get());
        }
        if (this.portsIn[ipi].type == CONSTANTS2.OP.OP_PORT_TYPE_FUNCTION) {
        }
      }
      if (theTriggerPort)
        theTriggerPort.onTriggered();
      for (ipi = 0; ipi < this.portsOut.length; ipi++) {
        if (this.portsOut[ipi].type == CONSTANTS2.OP.OP_PORT_TYPE_VALUE) {
          this.portsOut[ipi].set(this._instances[this.patch.instancing.index()].portsOut[ipi].get());
        }
      }
      return true;
    };
    Op.prototype.initInstancable = function() {
    };
    Op.prototype.setValues = function(obj) {
      for (const i in obj) {
        const port = this.getPortByName(i);
        if (port)
          port.set(obj[i]);
        else
          this._log.warn("op.setValues: port not found:", i);
      }
    };
    Op.prototype.hasUiError = function(id) {
      return this._uiErrors.hasOwnProperty(id) && this._uiErrors[id];
    };
    Op.prototype.setUiError = function(id, txt, level) {
    };
    Op.prototype.setError = function(id, txt) {
      this._log.warn("old error message op.error() - use op.setUiError()");
    };
    Op.prototype.setEnabled = function(b) {
      this.enabled = b;
      this.emitEvent("onEnabledChange", b);
    };
    Op.prototype.setPortGroup = function(name2, ports) {
      for (let i = 0; i < ports.length; i++) {
        if (ports[i])
          if (ports[i].setUiAttribs)
            ports[i].setUiAttribs({ "group": name2 });
          else {
            this._log.error("setPortGroup: invalid port!");
          }
      }
    };
    Op.prototype.setUiAxisPorts = function(px, py, pz) {
      if (px)
        px.setUiAttribs({ "axis": "X" });
      if (py)
        py.setUiAttribs({ "axis": "Y" });
      if (pz)
        pz.setUiAttribs({ "axis": "Z" });
    };
    Op.prototype.removePort = function(port) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        if (this.portsIn[ipi] == port) {
          this.portsIn.splice(ipi, 1);
          this.emitEvent("onUiAttribsChange", {});
          this.emitEvent("onPortRemoved", {});
          return;
        }
      }
      for (let ipi = 0; ipi < this.portsOut.length; ipi++) {
        if (this.portsOut[ipi] == port) {
          this.portsOut.splice(ipi, 1);
          this.emitEvent("onUiAttribsChange", {});
          this.emitEvent("onPortRemoved", {});
          return;
        }
      }
    };
    Op.prototype._checkLinksNeededToWork = function() {
    };
    Op.prototype.toWorkNeedsParent = function(parentOpName) {
      if (!this.patch.isEditorMode())
        return;
      this._linkTimeRules.needsParentOp = parentOpName;
    };
    Op.prototype.toWorkShouldNotBeChild = function(parentOpName, type) {
      if (!this.patch.isEditorMode())
        return;
      this._linkTimeRules.forbiddenParent = parentOpName;
      if (type != void 0)
        this._linkTimeRules.forbiddenParentType = type;
    };
    Op.prototype.toWorkPortsNeedToBeLinked = function() {
      if (!this.patch.isEditorMode())
        return;
      for (let i = 0; i < arguments.length; i++)
        if (this._linkTimeRules.needsLinkedToWork.indexOf(arguments[i]) == -1)
          this._linkTimeRules.needsLinkedToWork.push(arguments[i]);
    };
    Op.prototype.toWorkPortsNeedToBeLinkedReset = function() {
      if (!this.patch.isEditorMode())
        return;
      this._linkTimeRules.needsLinkedToWork.length = 0;
      if (this.checkLinkTimeWarnings)
        this.checkLinkTimeWarnings();
    };
    Op.prototype.initVarPorts = function() {
      for (let i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].getVariableName())
          this.portsIn[i].setVariable(this.portsIn[i].getVariableName());
      }
    };
    Op.prototype.refreshParams = function() {
      if (this.patch && this.patch.isEditorMode() && this.isCurrentUiOp()) {
        gui.opParams.show(this);
      }
    };
    Op.prototype.isCurrentUiOp = function() {
      if (this.patch.isEditorMode())
        return gui.patchView.isCurrentOp(this);
    };
    Op.prototype.renderVizLayer = null;
  }
  ;
  const LoadingStatus = function(patch) {
    EventTarget.apply(this);
    this._log = new Logger("LoadingStatus");
    this._loadingAssets = {};
    this._cbFinished = [];
    this._assetTasks = [];
    this._percent = 0;
    this._count = 0;
    this._countFinished = 0;
    this._order = 0;
    this._startTime = 0;
    this._patch = patch;
    this._wasFinishedPrinted = false;
    this._loadingAssetTaskCb = false;
  };
  LoadingStatus.prototype.setOnFinishedLoading = function(cb) {
    this._cbFinished.push(cb);
  };
  LoadingStatus.prototype.getNumAssets = function() {
    return this._countFinished;
  };
  LoadingStatus.prototype.getProgress = function() {
    return this._percent;
  };
  LoadingStatus.prototype.checkStatus = function() {
    this._countFinished = 0;
    this._count = 0;
    for (const i in this._loadingAssets) {
      this._count++;
      if (!this._loadingAssets[i].finished) {
        this._countFinished++;
      }
    }
    this._percent = (this._count - this._countFinished) / this._count;
    if (this._countFinished === 0) {
      for (let j = 0; j < this._cbFinished.length; j++) {
        if (this._cbFinished[j]) {
          const cb = this._cbFinished[j];
          setTimeout(() => {
            cb(this._patch);
            this.emitEvent("finishedAll");
          }, 100);
        }
      }
      if (!this._wasFinishedPrinted) {
        this._wasFinishedPrinted = true;
        this.print();
      }
      this.emitEvent("finishedAll");
    }
  };
  LoadingStatus.prototype.getList = function() {
    let arr = [];
    for (const i in this._loadingAssets) {
      arr.push(this._loadingAssets[i]);
    }
    return arr;
  };
  LoadingStatus.prototype.getListJobs = function() {
    let arr = [];
    for (const i in this._loadingAssets) {
      if (!this._loadingAssets[i].finished)
        arr.push(this._loadingAssets[i].name);
    }
    return arr;
  };
  LoadingStatus.prototype.print = function() {
    if (this._patch.config.silent)
      return;
    const rows = [];
    for (const i in this._loadingAssets) {
      rows.push([
        this._loadingAssets[i].order,
        this._loadingAssets[i].type,
        this._loadingAssets[i].name,
        (this._loadingAssets[i].timeEnd - this._loadingAssets[i].timeStart) / 1e3 + "s"
      ]);
    }
    this._log.groupCollapsed("finished loading " + this._order + " assets in " + (Date.now() - this._startTime) / 1e3 + "s");
    this._log.table(rows);
    this._log.groupEnd();
  };
  LoadingStatus.prototype.finished = function(id) {
    const l = this._loadingAssets[id];
    if (l) {
      if (l.finished)
        this._log.warn("loading job was already finished", l);
      if (l.op)
        l.op.setUiAttribs({ "loading": false });
      l.finished = true;
      l.timeEnd = Date.now();
    }
    this.checkStatus();
    this.emitEvent("finishedTask");
    return null;
  };
  LoadingStatus.prototype._startAssetTasks = function() {
    for (let i = 0; i < this._assetTasks.length; i++)
      this._assetTasks[i]();
    this._assetTasks.length = 0;
  };
  LoadingStatus.prototype.addAssetLoadingTask = function(cb) {
    if (this._patch.isEditorMode() && !CABLES.UI.loaded) {
      this._assetTasks.push(cb);
      if (!this._loadingAssetTaskCb)
        window.gui.addEventListener("uiloaded", this._startAssetTasks.bind(this));
      this._loadingAssetTaskCb = true;
    } else {
      cb();
    }
    this.emitEvent("addAssetTask");
  };
  LoadingStatus.prototype.existByName = function(name2) {
    for (let i in this._loadingAssets) {
      if (this._loadingAssets[i].name == name2 && !this._loadingAssets[i].finished)
        return true;
    }
  };
  LoadingStatus.prototype.start = function(type, name2, op) {
    if (this._startTime == 0)
      this._startTime = Date.now();
    const id = generateUUID();
    name2 = name2 || "unknown";
    if (name2.length > 100)
      name2 = name2.substring(0, 100);
    if (op)
      op.setUiAttribs({ "loading": true });
    this._loadingAssets[id] = {
      "id": id,
      "op": op,
      "type": type,
      "name": name2,
      "finished": false,
      "timeStart": Date.now(),
      "order": this._order
    };
    this._order++;
    this.emitEvent("startTask");
    return id;
  };
  ;
  const Instancing = function() {
    this._loops = [];
    this._indizes = [];
    this._index = 0;
  };
  Instancing.prototype.pushLoop = function(maxNum) {
    this._loops.push(Math.abs(Math.floor(maxNum)));
    this._indizes.push(this._index);
  };
  Instancing.prototype.popLoop = function() {
    this._loops.pop();
    this._index = this._indizes.pop();
    if (this._loops.length === 0)
      this._index = 0;
  };
  Instancing.prototype.numLoops = function() {
    return this._loops.length;
  };
  Instancing.prototype.numCycles = function() {
    if (this._loops.length === 0)
      return 0;
    let num = this._loops[0];
    for (let i = 1; i < this._loops.length; i++)
      num *= this._loops[i];
    return num;
  };
  Instancing.prototype.inLoop = function() {
    return this._loops.length > 0;
  };
  Instancing.prototype.increment = function() {
    this._index++;
  };
  Instancing.prototype.index = function() {
    return this._index;
  };
  ;
  const internalNow = function() {
    return window.performance.now();
  };
  const now = function() {
    return internalNow();
  };
  const Timer = function() {
    EventTarget.apply(this);
    this._timeStart = internalNow();
    this._timeOffset = 0;
    this._currentTime = 0;
    this._lastTime = 0;
    this._paused = true;
    this._delay = 0;
    this.overwriteTime = -1;
  };
  Timer.prototype._internalNow = function() {
    if (this._ts)
      return this._ts;
    return internalNow();
  };
  Timer.prototype._getTime = function() {
    this._lastTime = (this._internalNow() - this._timeStart) / 1e3;
    return this._lastTime + this._timeOffset;
  };
  Timer.prototype.setDelay = function(d) {
    this._delay = d;
    this.emitEvent("timeChange");
  };
  Timer.prototype.isPlaying = function() {
    return !this._paused;
  };
  Timer.prototype.update = function(ts) {
    if (ts)
      this._ts = ts;
    if (this._paused)
      return;
    this._currentTime = this._getTime();
    return this._currentTime;
  };
  Timer.prototype.getMillis = function() {
    return this.get() * 1e3;
  };
  Timer.prototype.get = Timer.prototype.getTime = function() {
    if (this.overwriteTime >= 0)
      return this.overwriteTime - this._delay;
    return this._currentTime - this._delay;
  };
  Timer.prototype.togglePlay = function() {
    if (this._paused)
      this.play();
    else
      this.pause();
  };
  Timer.prototype.setTime = function(t) {
    if (isNaN(t) || t < 0)
      t = 0;
    this._timeStart = this._internalNow();
    this._timeOffset = t;
    this._currentTime = t;
    this.emitEvent("timeChange");
  };
  Timer.prototype.setOffset = function(val) {
    if (this._currentTime + val < 0) {
      this._timeStart = this._internalNow();
      this._timeOffset = 0;
      this._currentTime = 0;
    } else {
      this._timeOffset += val;
      this._currentTime = this._lastTime + this._timeOffset;
    }
    this.emitEvent("timeChange");
  };
  Timer.prototype.play = function() {
    this._timeStart = this._internalNow();
    this._paused = false;
    this.emitEvent("playPause");
  };
  Timer.prototype.pause = function() {
    this._timeOffset = this._currentTime;
    this._paused = true;
    this.emitEvent("playPause");
  };
  ;
  class Profiler {
    constructor(patch) {
      this.startFrame = patch.getFrameNum();
      this.items = {};
      this.currentId = null;
      this.currentStart = 0;
      this._patch = patch;
    }
    getItems() {
      return this.items;
    }
    clear() {
      if (this.paused)
        return;
      this.items = {};
    }
    togglePause() {
      this.paused = !this.paused;
      if (!this.paused) {
        this.items = {};
        this.currentStart = performance.now();
      }
    }
    add(type, object) {
      if (this.paused)
        return;
      if (this.currentId !== null) {
        if (!object || object.id != this.currentId) {
          if (this.items[this.currentId]) {
            this.items[this.currentId].timeUsed += performance.now() - this.currentStart;
            if (!this.items[this.currentId].peakTime || now() - this.items[this.currentId].peakTime > 5e3) {
              this.items[this.currentId].peak = 0;
              this.items[this.currentId].peakTime = now();
            }
            this.items[this.currentId].peak = Math.max(this.items[this.currentId].peak, performance.now() - this.currentStart);
          }
        }
      }
      if (object !== null) {
        if (!this.items[object.id]) {
          this.items[object.id] = {
            "numTriggers": 0,
            "timeUsed": 0
          };
        }
        if (this.items[object.id].lastFrame != this._patch.getFrameNum())
          this.items[object.id].numTriggers = 0;
        this.items[object.id].lastFrame = this._patch.getFrameNum();
        this.items[object.id].numTriggers++;
        this.items[object.id].opid = object.op.id;
        this.items[object.id].title = object.op.name + "." + object.name;
        this.items[object.id].subPatch = object.op.uiAttribs.subPatch;
        this.currentId = object.id;
        this.currentStart = performance.now();
      } else {
        this.currentId = null;
      }
    }
    print() {
      console.log("--------");
      for (const i in this.items) {
        console.log(this.items[i].title + ": " + this.items[i].numTriggers + " / " + this.items[i].timeUsed);
      }
    }
  }
  ;
  const SHADER = {
    // default attributes
    "SHADERVAR_VERTEX_POSITION": "vPosition",
    "SHADERVAR_VERTEX_NUMBER": "attrVertIndex",
    "SHADERVAR_VERTEX_NORMAL": "attrVertNormal",
    "SHADERVAR_VERTEX_TEXCOORD": "attrTexCoord",
    "SHADERVAR_INSTANCE_MMATRIX": "instMat",
    "SHADERVAR_VERTEX_COLOR": "attrVertColor",
    "SHADERVAR_INSTANCE_INDEX": "instanceIndex",
    // default uniforms
    "SHADERVAR_UNI_PROJMAT": "projMatrix",
    "SHADERVAR_UNI_VIEWMAT": "viewMatrix",
    "SHADERVAR_UNI_MODELMAT": "modelMatrix",
    "SHADERVAR_UNI_NORMALMAT": "normalMatrix",
    "SHADERVAR_UNI_INVVIEWMAT": "inverseViewMatrix",
    "SHADERVAR_UNI_INVPROJMAT": "invProjMatrix",
    "SHADERVAR_UNI_MATERIALID": "materialId",
    "SHADERVAR_UNI_OBJECTID": "objectId",
    "SHADERVAR_UNI_VIEWPOS": "camPos"
  };
  const BLEND_MODES = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4
  };
  const RAD2DEG = 180 / Math.PI;
  const DEG2RAD = Math.PI / 180;
  const constants_CONSTANTS = {
    "MATH": {
      "DEG2RAD": DEG2RAD,
      "RAD2DEG": RAD2DEG
    },
    "SHADER": SHADER,
    "BLEND_MODES": BLEND_MODES
  };
  ;
  class CgUniform {
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName) {
      this._log = new Logger("cg_uniform");
      this._type = __type;
      this._name = __name;
      this._shader = __shader;
      this._value = 1e-5;
      this._oldValue = null;
      this._port = null;
      this._structName = _structName;
      this._structUniformName = _structUniformName;
      this._propertyName = _propertyName;
      this._shader._addUniform(this);
      this.needsUpdate = true;
      this.shaderType = null;
      this.comment = null;
      if (__type == "f") {
        this.set = this.setValue = this.setValueF.bind(this);
        this.updateValue = this.updateValueF.bind(this);
      } else if (__type == "f[]") {
        this.set = this.setValue = this.setValueArrayF.bind(this);
        this.updateValue = this.updateValueArrayF.bind(this);
      } else if (__type == "2f[]") {
        this.set = this.setValue = this.setValueArray2F.bind(this);
        this.updateValue = this.updateValueArray2F.bind(this);
      } else if (__type == "3f[]") {
        this.set = this.setValue = this.setValueArray3F.bind(this);
        this.updateValue = this.updateValueArray3F.bind(this);
      } else if (__type == "4f[]") {
        this.set = this.setValue = this.setValueArray4F.bind(this);
        this.updateValue = this.updateValueArray4F.bind(this);
      } else if (__type == "i") {
        this.set = this.setValue = this.setValueI.bind(this);
        this.updateValue = this.updateValueI.bind(this);
      } else if (__type == "2i") {
        this.set = this.setValue = this.setValue2I.bind(this);
        this.updateValue = this.updateValue2I.bind(this);
      } else if (__type == "3i") {
        this.set = this.setValue = this.setValue3I.bind(this);
        this.updateValue = this.updateValue3I.bind(this);
      } else if (__type == "4i") {
        this.set = this.setValue = this.setValue4I.bind(this);
        this.updateValue = this.updateValue4I.bind(this);
      } else if (__type == "b") {
        this.set = this.setValue = this.setValueBool.bind(this);
        this.updateValue = this.updateValueBool.bind(this);
      } else if (__type == "4f") {
        this.set = this.setValue = this.setValue4F.bind(this);
        this.updateValue = this.updateValue4F.bind(this);
      } else if (__type == "3f") {
        this.set = this.setValue = this.setValue3F.bind(this);
        this.updateValue = this.updateValue3F.bind(this);
      } else if (__type == "2f") {
        this.set = this.setValue = this.setValue2F.bind(this);
        this.updateValue = this.updateValue2F.bind(this);
      } else if (__type == "t") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (__type == "tc") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (__type == "t[]") {
        this.set = this.setValue = this.setValueArrayT.bind(this);
        this.updateValue = this.updateValueArrayT.bind(this);
      } else if (__type == "m4" || __type == "m4[]") {
        this.set = this.setValue = this.setValueM4.bind(this);
        this.updateValue = this.updateValueM4.bind(this);
      } else
        throw new Error("Unknown uniform type");
      if (typeof _value == "object" && _value instanceof Port) {
        this._port = _value;
        this._value = this._port.get();
        if (_port2 && _port3 && _port4) {
          if (!(_port2 instanceof Port) || !(_port3 instanceof Port) || !(_port4 instanceof Port)) {
            this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
          }
          this._value = [0, 0, 0, 0];
          this._port2 = _port2;
          this._port3 = _port3;
          this._port4 = _port4;
          this._port.on("change", this.updateFromPort4f.bind(this));
          this._port2.on("change", this.updateFromPort4f.bind(this));
          this._port3.on("change", this.updateFromPort4f.bind(this));
          this._port4.on("change", this.updateFromPort4f.bind(this));
          this.updateFromPort4f();
        } else if (_port2 && _port3) {
          if (!(_port2 instanceof Port) || !(_port3 instanceof Port)) {
            this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
          }
          this._value = [0, 0, 0];
          this._port2 = _port2;
          this._port3 = _port3;
          this._port.on("change", this.updateFromPort3f.bind(this));
          this._port2.on("change", this.updateFromPort3f.bind(this));
          this._port3.on("change", this.updateFromPort3f.bind(this));
          this.updateFromPort3f();
        } else if (_port2) {
          if (!(_port2 instanceof Port)) {
            this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
          }
          this._value = [0, 0];
          this._port2 = _port2;
          this._port.on("change", this.updateFromPort2f.bind(this));
          this._port2.on("change", this.updateFromPort2f.bind(this));
          this.updateFromPort2f();
        } else {
          this._port.on("change", this.updateFromPort.bind(this));
        }
      } else
        this._value = _value;
      this.setValue(this._value);
      this.needsUpdate = true;
    }
    getType() {
      return this._type;
    }
    getName() {
      return this._name;
    }
    getValue() {
      return this._value;
    }
    getShaderType() {
      return this.shaderType;
    }
    isStructMember() {
      return !!this._structName;
    }
    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }
    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }
    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }
    updateFromPort() {
      this.setValue(this._port.get());
    }
  }
  const cg_uniform = CgUniform;
  ;
  class Uniform extends cg_uniform {
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName) {
      super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);
      this._loc = -1;
      this._cgl = __shader._cgl;
    }
    get name() {
      return this._name;
    }
    copy(newShader) {
      const uni = new Uniform(newShader, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
      uni.shaderType = this.shaderType;
      return uni;
    }
    /**
     * returns type as glsl type string. e.g. 'f' returns 'float'
     * @function getGlslTypeString
     * @memberof Uniform
     * @instance
     * @return {string} type as string
     */
    getGlslTypeString() {
      return Uniform.glslTypeString(this._type);
    }
    _isValidLoc() {
      return this._loc != -1;
    }
    resetLoc() {
      this._loc = -1;
      this.needsUpdate = true;
    }
    bindTextures() {
    }
    getLoc() {
      return this._loc;
    }
    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }
    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }
    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }
    updateFromPort() {
      this.setValue(this._port.get());
    }
    updateValueF() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1f(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueF(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }
    updateValueI() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    updateValue2I() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    updateValue3I() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    updateValue4I() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueI(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }
    setValue2I(v) {
      if (!v)
        return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this.needsUpdate = true;
      }
      this._value = v;
    }
    setValue3I(v) {
      if (!v)
        return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }
      this._value = v;
    }
    setValue4I(v) {
      this.needsUpdate = true;
      this._value = v || vec4.create();
    }
    updateValueBool() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueBool(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }
    setValueArray4F(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValueArray4F() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform4fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArray3F(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValueArray3F() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform3fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArray2F(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValueArray2F() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform2fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArrayF(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValueArrayF() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform1fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArrayT(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValue3F() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    setValue3F(v) {
      if (!v)
        return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }
      this._value = v;
    }
    updateValue2F() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    setValue2F(v) {
      if (!v)
        return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this.needsUpdate = true;
      }
      this._value = v;
    }
    updateValue4F() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      if (!this._value) {
        this._log.warn("no value for uniform", this._name, this);
        this._value = [0, 0, 0, 0];
      }
      this.needsUpdate = false;
      this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
      this._cgl.profileData.profileUniformCount++;
    }
    setValue4F(v) {
      if (typeof this.value == "number")
        this.value = vec4.create();
      if (!v)
        return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2, 3];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2] || v[3] != this._oldValue[3]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }
      this._value = v;
    }
    updateValueM4() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      if (!this._value || this._value.length % 16 != 0)
        return console.log("this.name", this._name, this._value);
      this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueM4(v) {
      this.needsUpdate = true;
      this._value = v || mat4.create();
    }
    updateValueArrayT() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform1iv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    updateValueT() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._cgl.profileData.profileUniformCount++;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this.needsUpdate = false;
    }
    setValueT(v) {
      this.needsUpdate = true;
      this._value = v;
    }
  }
  Uniform.glslTypeString = (t) => {
    if (t == "f")
      return "float";
    if (t == "b")
      return "bool";
    if (t == "i")
      return "int";
    if (t == "2i")
      return "ivec2";
    if (t == "2f")
      return "vec2";
    if (t == "3f")
      return "vec3";
    if (t == "4f")
      return "vec4";
    if (t == "m4")
      return "mat4";
    if (t == "t")
      return "sampler2D";
    if (t == "tc")
      return "samplerCube";
    if (t == "3f[]")
      return null;
    if (t == "m4[]")
      return null;
    if (t == "f[]")
      return null;
    console.warn("[CGL UNIFORM] unknown glsl type string ", t);
  };
  ;
  const DEFAULT_TEXTURE_SIZE = 8;
  const Texture = function(__cgl, options = {}) {
    if (!__cgl)
      throw new Error("no cgl");
    this._log = new Logger("cgl_texture");
    this._cgl = __cgl;
    this.pixelFormat = options.pixelFormat || Texture.PFORMATSTR_RGBA8UB;
    this.tex = this._cgl.gl.createTexture();
    this.id = CABLES.uuid();
    this.width = 0;
    this.height = 0;
    this.loading = false;
    this.flip = true;
    this.flipped = false;
    this.shadowMap = false;
    this.deleted = false;
    this.image = null;
    this.anisotropic = 0;
    this.filter = Texture.FILTER_NEAREST;
    this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
    this.texTarget = this._cgl.gl.TEXTURE_2D;
    if (options && options.type)
      this.texTarget = options.type;
    this.textureType = Texture.TYPE_DEFAULT;
    this.unpackAlpha = true;
    this._fromData = true;
    this.name = "unknown";
    this._glDataType = -1;
    this._glInternalFormat = -1;
    this._glDataFormat = -1;
    if (options) {
      this.name = options.name || this.name;
      if (options.isDepthTexture) {
        this.textureType = Texture.TYPE_DEPTH;
      }
      if (options.isFloatingPointTexture === true)
        this.textureType = Texture.TYPE_FLOAT;
      if ("textureType" in options)
        this.textureType = options.textureType;
      if ("filter" in options)
        this.filter = options.filter;
      if ("wrap" in options)
        this.wrap = options.wrap;
      if ("unpackAlpha" in options)
        this.unpackAlpha = options.unpackAlpha;
      if ("flip" in options)
        this.flip = options.flip;
      if ("shadowMap" in options)
        this.shadowMap = options.shadowMap;
      if ("anisotropic" in options)
        this.anisotropic = options.anisotropic;
    } else {
      options = {};
    }
    if (!options.pixelFormat && options.isFloatingPointTexture)
      this.pixelFormat = Texture.PFORMATSTR_RGBA32F;
    if (this.textureType == Texture.TYPE_DEPTH)
      this.pixelFormat = Texture.PFORMATSTR_DEPTH;
    if (!options.width)
      options.width = DEFAULT_TEXTURE_SIZE;
    if (!options.height)
      options.height = DEFAULT_TEXTURE_SIZE;
    this._cgl.profileData.profileTextureNew++;
    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
    this._cgl.profileData.addHeavyEvent("texture created", this.name, options.width + "x" + options.height);
    this.setSize(options.width, options.height);
    this.getInfoOneLine();
  };
  Texture.prototype.isFloatingPoint = function() {
    return Texture.isPixelFormatFloat(this.pixelFormat);
  };
  Texture.prototype.compareSettings = function(tex) {
    if (!tex)
      return false;
    return tex.width == this.width && tex.height == this.height && tex.filter == this.filter && tex.wrap == this.wrap && tex.textureType == this.textureType && tex.unpackAlpha == this.unpackAlpha && tex.anisotropic == this.anisotropic && tex.shadowMap == this.shadowMap && tex.texTarget == this.texTarget && tex.flip == this.flip;
  };
  Texture.prototype.clone = function() {
    const newTex = new Texture(this._cgl, {
      "name": this.name,
      "filter": this.filter,
      "anisotropic": this.anisotropic,
      "wrap": this.wrap,
      "textureType": this.textureType,
      "pixelFormat": this.pixelFormat,
      "unpackAlpha": this.unpackAlpha,
      "flip": this.flip,
      "width": this.width,
      "height": this.height
    });
    this._cgl.profileData.addHeavyEvent("texture created", this.name, this.width + "x" + this.height);
    if (!this.compareSettings(newTex)) {
      this._log.error("Cloned texture settings do not compare!");
      this._log.error(this);
      this._log.error(newTex);
    }
    return newTex;
  };
  Texture.prototype.setFormat = function(o) {
    this.pixelFormat = o.pixelFormat;
    this._glDataFormat = o.glDataFormat;
    this._glInternalFormat = o.glInternalFormat;
    this._glDataType = o.glDataType;
  };
  Texture.setUpGlPixelFormat = function(cgl, pixelFormatStr) {
    const o = {};
    if (!pixelFormatStr) {
      cgl._log.error("no pixelformatstr!");
      cgl._log.log(new Error());
      pixelFormatStr = Texture.PFORMATSTR_RGBA8UB;
    }
    o.pixelFormatBase = pixelFormatStr;
    o.pixelFormat = pixelFormatStr;
    o.glDataType = cgl.gl.UNSIGNED_BYTE;
    o.glInternalFormat = cgl.gl.RGBA8;
    o.glDataFormat = cgl.gl.RGBA;
    let floatDatatype = cgl.gl.FLOAT;
    if (cgl.glUseHalfFloatTex) {
      if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F)
        pixelFormatStr = Texture.PFORMATSTR_RGBA16F;
      if (pixelFormatStr == Texture.PFORMATSTR_RG32F)
        pixelFormatStr = Texture.PFORMATSTR_RG16F;
      if (pixelFormatStr == Texture.PFORMATSTR_R32F)
        pixelFormatStr = Texture.PFORMATSTR_R16F;
    }
    if (pixelFormatStr.contains("16bit")) {
      if (cgl.glVersion == 2) {
        const hasExt = cgl.enableExtension("EXT_color_buffer_half_float");
        if (!hasExt) {
          console.warn("no 16bit extension, fallback to 32bit", pixelFormatStr);
          if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F)
            pixelFormatStr = Texture.PFORMATSTR_RGBA32F;
          if (pixelFormatStr == Texture.PFORMATSTR_RGB16F)
            pixelFormatStr = Texture.PFORMATSTR_RGB32F;
          if (pixelFormatStr == Texture.PFORMATSTR_RG16F)
            pixelFormatStr = Texture.PFORMATSTR_RG32F;
          if (pixelFormatStr == Texture.PFORMATSTR_R16F)
            pixelFormatStr = Texture.PFORMATSTR_R32F;
        } else {
          floatDatatype = cgl.gl.HALF_FLOAT;
        }
      }
    }
    if (cgl.glVersion == 1) {
      o.glInternalFormat = cgl.gl.RGBA;
      if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F || pixelFormatStr == Texture.PFORMATSTR_RG16F || pixelFormatStr == Texture.PFORMATSTR_R16F) {
        const ext = cgl.enableExtension("OES_texture_half_float");
        if (!ext)
          throw new Error("no half float texture extension");
        floatDatatype = ext.HALF_FLOAT_OES;
      }
    }
    if (pixelFormatStr == Texture.PFORMATSTR_RGBA8UB) {
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGB565) {
      o.glInternalFormat = cgl.gl.RGB565;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R8UB) {
      o.glInternalFormat = cgl.gl.R8;
      o.glDataFormat = cgl.gl.RED;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RG8UB) {
      o.glInternalFormat = cgl.gl.RG8;
      o.glDataFormat = cgl.gl.RG;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGB8UB) {
      o.glInternalFormat = cgl.gl.RGB8;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture.PFORMATSTR_SRGBA8) {
      o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R32F) {
      o.glInternalFormat = cgl.gl.R32F;
      o.glDataFormat = cgl.gl.RED;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R16F) {
      o.glInternalFormat = cgl.gl.R16F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RED;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RG16F) {
      o.glInternalFormat = cgl.gl.RG16F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RG;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F) {
      if (cgl.glVersion == 1)
        o.glInternalFormat = cgl.gl.RGBA;
      else
        o.glInternalFormat = cgl.gl.RGBA16F;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F) {
      o.glInternalFormat = cgl.gl.R11F_G11F_B10F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F) {
      if (cgl.glVersion == 1)
        o.glInternalFormat = cgl.gl.RGBA;
      else
        o.glInternalFormat = cgl.gl.RGBA32F;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture.PFORMATSTR_DEPTH) {
      if (cgl.glVersion == 1) {
        o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;
        o.glDataType = cgl.gl.UNSIGNED_SHORT;
        o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
      } else {
        o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;
        o.glDataType = cgl.gl.FLOAT;
        o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
      }
    } else {
      console.log("unknown pixelformat ", pixelFormatStr);
    }
    if (pixelFormatStr.contains("32bit") || pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F) {
      if (cgl.glVersion == 2)
        cgl.enableExtension("EXT_color_buffer_float");
      if (cgl.glVersion == 2)
        cgl.enableExtension("EXT_float_blend");
      cgl.enableExtension("OES_texture_float_linear");
    }
    o.numColorChannels = 1;
    if (pixelFormatStr.startsWith("R"))
      o.numColorChannels = 1;
    if (pixelFormatStr.startsWith("RG"))
      o.numColorChannels = 2;
    if (pixelFormatStr.startsWith("RGB"))
      o.numColorChannels = 3;
    if (pixelFormatStr.startsWith("RGBA"))
      o.numColorChannels = 4;
    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat)
      console.log("pixelformat wrong ?!", pixelFormatStr, o.glDataType, o.glInternalFormat, o.glDataFormat, this);
    return o;
  };
  Texture.prototype.setSize = function(w, h) {
    if (this._cgl.aborted)
      return;
    if (w != w || w <= 0 || !w)
      w = DEFAULT_TEXTURE_SIZE;
    if (h != h || h <= 0 || !h)
      h = DEFAULT_TEXTURE_SIZE;
    if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize)
      this._log.error("texture size too big! " + w + "x" + h + " / max: " + this._cgl.maxTexSize);
    w = Math.min(w, this._cgl.maxTexSize);
    h = Math.min(h, this._cgl.maxTexSize);
    w = Math.floor(w);
    h = Math.floor(h);
    if (this.width == w && this.height == h)
      return;
    w = this._cgl.checkTextureSize(w);
    h = this._cgl.checkTextureSize(h);
    this.width = w;
    this.height = h;
    this.deleted = false;
    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
    this.shortInfoString = this.getInfoOneLine();
    this._cgl.gl.bindTexture(this.texTarget, this.tex);
    this._cgl.profileData.profileTextureResize++;
    const uarr = null;
    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, uarr);
    this._setFilter();
    this.updateMipMap();
    this._cgl.gl.bindTexture(this.texTarget, null);
  };
  Texture.prototype.initFromData = function(data, w, h, filter, wrap) {
    this.filter = filter;
    this.wrap = wrap;
    if (filter == void 0)
      this.filter = Texture.FILTER_LINEAR;
    if (wrap == void 0)
      this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
    this.width = w;
    this.height = h;
    this._fromData = true;
    this.deleted = false;
    if (this.height > this._cgl.maxTexSize || this.width > this._cgl.maxTexSize) {
      const t = CGL.Texture.getTempTexture(this._cgl);
      this.width = t.width;
      this.height = t.height;
      this.tex = t.tex;
      this._log.error("[cgl_texture] texture size to big!!!", this.width, this.height, this._cgl.maxTexSize);
      return;
    }
    if (this.flip)
      this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);
    this._cgl.gl.bindTexture(this.texTarget, this.tex);
    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, data);
    this._setFilter();
    this.updateMipMap();
    if (this.flip)
      this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);
    this._cgl.gl.bindTexture(this.texTarget, null);
  };
  Texture.prototype.updateMipMap = function() {
    if ((this._cgl.glVersion == 2 || this.isPowerOfTwo()) && this.filter == Texture.FILTER_MIPMAP) {
      this._cgl.gl.generateMipmap(this.texTarget);
      this._cgl.profileData.profileGenMipMap++;
    }
  };
  Texture.prototype.initTexture = function(img, filter) {
    this._cgl.printError("before initTexture");
    this._cgl.checkFrameStarted("texture inittexture");
    this._fromData = false;
    this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
    if (img.width || img.videoWidth)
      this.width = img.videoWidth || img.width;
    if (img.height || img.videoHeight)
      this.height = img.videoHeight || img.height;
    if (filter !== void 0)
      this.filter = filter;
    if (img.height > this._cgl.maxTexSize || img.width > this._cgl.maxTexSize) {
      const t = CGL.Texture.getTempTexture(this._cgl);
      this.width = t.width;
      this.height = t.height;
      this.tex = t.tex;
      this._log.error("[cgl_texture] texture size to big!!!", img.width, img.height, this._cgl.maxTexSize);
      return;
    }
    this._cgl.gl.bindTexture(this.texTarget, this.tex);
    this.deleted = false;
    this.flipped = !this.flip;
    if (this.flipped)
      this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped);
    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, this._glDataFormat, this._glDataType, img);
    this._setFilter();
    this.updateMipMap();
    this._cgl.gl.bindTexture(this.texTarget, null);
    this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    if (this.flipped)
      this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.getInfoOneLine();
    this._cgl.printError("initTexture");
  };
  Texture.prototype.dispose = Texture.prototype.delete = function() {
    if (this.loading) {
      return;
    }
    this.deleted = true;
    this.width = 0;
    this.height = 0;
    this._cgl.profileData.profileTextureDelete++;
    this._cgl.gl.deleteTexture(this.tex);
    this.image = null;
    this.tex = null;
  };
  Texture.prototype.isPowerOfTwo = function() {
    return Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height);
  };
  Texture.prototype.printInfo = function() {
    console.log(this.getInfo());
  };
  Texture.prototype.getInfoReadable = function() {
    const info = this.getInfo();
    let html = "";
    info.name = info.name.substr(0, info.name.indexOf("?rnd="));
    for (const i in info) {
      html += "* " + i + ":  **" + info[i] + "**\n";
    }
    return html;
  };
  Texture.prototype.getInfoOneLine = function() {
    let txt = "" + this.width + "x" + this.height;
    txt += " ";
    txt += this.pixelFormat;
    if (this.filter === CGL.Texture.FILTER_NEAREST)
      txt += " nearest";
    if (this.filter === CGL.Texture.FILTER_LINEAR)
      txt += " linear";
    if (this.filter === CGL.Texture.FILTER_MIPMAP)
      txt += " mipmap";
    if (this.wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE)
      txt += " clamp";
    if (this.wrap === CGL.Texture.WRAP_REPEAT)
      txt += " repeat";
    if (this.wrap === CGL.Texture.WRAP_MIRRORED_REPEAT)
      txt += " repeatmir";
    this.shortInfoString = txt;
    return txt;
  };
  Texture.prototype.getInfoOneLineShort = function() {
    let txt = "" + this.width + "x" + this.height;
    txt += " ";
    txt += this.pixelFormat;
    this.shortInfoString = txt;
    return txt;
  };
  Texture.prototype.getInfo = function() {
    return Texture.getTexInfo(this);
  };
  Texture.prototype._setFilter = function() {
    this._cgl.printError("before _setFilter");
    if (!this._fromData) {
      this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
    }
    if (this.shadowMap) {
      this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_MODE, this._cgl.gl.COMPARE_REF_TO_TEXTURE);
      this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_FUNC, this._cgl.gl.LEQUAL);
    }
    if (this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_MIPMAP) {
      this.filter = Texture.FILTER_LINEAR;
      this._log.stack("texture: HDR and mipmap filtering at the same time is not possible");
    }
    if (this._cgl.glVersion == 1 && !this.isPowerOfTwo()) {
      this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
      this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);
      this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
      this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);
      this.filter = Texture.FILTER_NEAREST;
      this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
    } else {
      if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE) {
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);
      } else if (this.wrap == Texture.WRAP_REPEAT) {
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.REPEAT);
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.REPEAT);
      } else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT) {
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.MIRRORED_REPEAT);
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.MIRRORED_REPEAT);
      }
      if (this.filter == Texture.FILTER_NEAREST) {
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);
      } else if (this.filter == Texture.FILTER_LINEAR) {
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR);
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
      } else if (this.filter == Texture.FILTER_MIPMAP) {
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR_MIPMAP_LINEAR);
      } else {
        this._log.log("unknown texture filter!", this.filter);
        throw new Error("unknown texture filter!" + this.filter);
      }
      if (this.anisotropic) {
        const ext = this._cgl.enableExtension("EXT_texture_filter_anisotropic");
        if (this._cgl.maxAnisotropic) {
          const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);
          this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, aniso);
        }
      }
    }
    this.getInfoOneLine();
    this._cgl.printError("_setFilter");
  };
  Texture.load = function(cgl, url, finishedCallback, settings) {
    if (!url)
      return finishedCallback({ "error": true });
    let loadingId = null;
    if (!cgl.patch.loading.existByName(url))
      loadingId = cgl.patch.loading.start("cgl.texture", url);
    const texture = new Texture(cgl);
    texture.name = url;
    texture.image = new Image();
    texture.image.crossOrigin = "anonymous";
    texture.loading = true;
    if (settings && settings.hasOwnProperty("filter"))
      texture.filter = settings.filter;
    if (settings && settings.hasOwnProperty("flip"))
      texture.flip = settings.flip;
    if (settings && settings.hasOwnProperty("wrap"))
      texture.wrap = settings.wrap;
    if (settings && settings.hasOwnProperty("anisotropic"))
      texture.anisotropic = settings.anisotropic;
    if (settings && settings.hasOwnProperty("unpackAlpha"))
      texture.unpackAlpha = settings.unpackAlpha;
    if (settings && settings.hasOwnProperty("pixelFormat"))
      texture.pixelFormat = settings.pixelFormat;
    texture.image.onabort = texture.image.onerror = (e) => {
      console.warn("[cgl.texture.load] error loading texture", url, e);
      texture.loading = false;
      if (loadingId)
        cgl.patch.loading.finished(loadingId);
      const error = { "error": true };
      if (finishedCallback)
        finishedCallback(error, texture);
    };
    texture.image.onload = function(e) {
      cgl.addNextFrameOnceCallback(() => {
        texture.initTexture(texture.image);
        if (loadingId)
          cgl.patch.loading.finished(loadingId);
        texture.loading = false;
        if (finishedCallback)
          finishedCallback(null, texture);
      });
    };
    texture.image.src = url;
    return texture;
  };
  Texture.getTempTexture = function(cgl) {
    if (!cgl)
      console.error("[getTempTexture] no cgl!");
    if (!cgl.tempTexture)
      cgl.tempTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT);
    return cgl.tempTexture;
  };
  Texture.getErrorTexture = function(cgl) {
    if (!cgl)
      console.error("[getTempTexture] no cgl!");
    if (!cgl.errorTexture)
      cgl.errorTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT, 1, 0.2, 0.2);
    return cgl.errorTexture;
  };
  Texture.getEmptyTexture = function(cgl, fp) {
    if (fp)
      return Texture.getEmptyTextureFloat(cgl);
    if (!cgl)
      console.error("[getEmptyTexture] no cgl!");
    if (cgl.tempTextureEmpty)
      return cgl.tempTextureEmpty;
    cgl.tempTextureEmpty = new Texture(cgl, { "name": "emptyTexture" });
    const data = new Uint8Array(8 * 8 * 4).fill(0);
    for (let i = 0; i < 8 * 8 * 4; i += 4)
      data[i + 3] = 0;
    cgl.tempTextureEmpty.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);
    return cgl.tempTextureEmpty;
  };
  Texture.getEmptyTextureFloat = function(cgl) {
    if (!cgl)
      console.error("[getEmptyTextureFloat] no cgl!");
    if (cgl.tempTextureEmptyFloat)
      return cgl.tempTextureEmptyFloat;
    cgl.tempTextureEmptyFloat = new Texture(cgl, { "name": "emptyTexture", "isFloatingPointTexture": true });
    const data = new Float32Array(8 * 8 * 4).fill(1);
    for (let i = 0; i < 8 * 8 * 4; i += 4)
      data[i + 3] = 0;
    cgl.tempTextureEmptyFloat.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);
    return cgl.tempTextureEmptyFloat;
  };
  Texture.getRandomTexture = function(cgl) {
    if (!cgl)
      console.error("[getRandomTexture] no cgl!");
    if (cgl.randomTexture)
      return cgl.randomTexture;
    const size = 256;
    const data = new Uint8Array(size * size * 4);
    for (let x = 0; x < size * size; x++) {
      data[x * 4 + 0] = Math.random() * 255;
      data[x * 4 + 1] = Math.random() * 255;
      data[x * 4 + 2] = Math.random() * 255;
      data[x * 4 + 3] = 255;
    }
    cgl.randomTexture = new Texture(cgl);
    cgl.randomTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);
    return cgl.randomTexture;
  };
  Texture.getRandomFloatTexture = function(cgl) {
    if (!cgl)
      console.error("[getRandomTexture] no cgl!");
    if (cgl.getRandomFloatTexture)
      return cgl.getRandomFloatTexture;
    const size = 256;
    const data = new Float32Array(size * size * 4);
    for (let x = 0; x < size * size; x++) {
      data[x * 4 + 0] = (Math.random() - 0.5) * 2;
      data[x * 4 + 1] = (Math.random() - 0.5) * 2;
      data[x * 4 + 2] = (Math.random() - 0.5) * 2;
      data[x * 4 + 3] = 1;
    }
    cgl.getRandomFloatTexture = new Texture(cgl, { "isFloatingPointTexture": true });
    cgl.getRandomFloatTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);
    return cgl.getRandomFloatTexture;
  };
  Texture.getBlackTexture = function(cgl) {
    if (!cgl)
      this._log.error("[getBlackTexture] no cgl!");
    if (cgl.blackTexture)
      return cgl.blackTexture;
    const size = 8;
    const data = new Uint8Array(size * size * 4);
    for (let x = 0; x < size * size; x++) {
      data[x * 4 + 0] = data[x * 4 + 1] = data[x * 4 + 2] = 0;
      data[x * 4 + 3] = 255;
    }
    cgl.blackTexture = new Texture(cgl);
    cgl.blackTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);
    return cgl.blackTexture;
  };
  Texture.getEmptyCubemapTexture = function(cgl) {
    const faces = [
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
    ];
    const tex = cgl.gl.createTexture();
    const target = cgl.gl.TEXTURE_CUBE_MAP;
    const filter = Texture.FILTER_NEAREST;
    const wrap = Texture.WRAP_CLAMP_TO_EDGE;
    const width = 8;
    const height = 8;
    cgl.profileData.profileTextureNew++;
    cgl.gl.bindTexture(target, tex);
    cgl.profileData.profileTextureResize++;
    for (let i = 0; i < 6; i += 1) {
      const data = new Uint8Array(8 * 8 * 4);
      cgl.gl.texImage2D(faces[i], 0, cgl.gl.RGBA, 8, 8, 0, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, data);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);
    }
    cgl.gl.bindTexture(target, null);
    return {
      "id": CABLES.uuid(),
      "tex": tex,
      "cubemap": tex,
      "width": width,
      "height": height,
      "filter": filter,
      "wrap": wrap,
      "unpackAlpha": true,
      "flip": true,
      "_fromData": true,
      "name": "emptyCubemapTexture",
      "anisotropic": 0
    };
  };
  Texture.getTempGradientTexture = function(cgl) {
    if (!cgl)
      console.error("[getTempGradientTexture] no cgl!");
    if (cgl.tempTextureGradient)
      return cgl.tempTextureGradient;
    const temptex = new Texture(cgl);
    const size = 256;
    const data = new Uint8Array(size * size * 4);
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        data[(x + y * size) * 4 + 0] = data[(x + y * size) * 4 + 1] = data[(x + y * size) * 4 + 2] = 255 - y;
        data[(x + y * size) * 4 + 3] = 255;
      }
    }
    temptex.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);
    cgl.tempTextureGradient = temptex;
    return temptex;
  };
  Texture.getTemporaryTexture = function(cgl, size, filter, wrap, r, g, b) {
    if (r === void 0)
      r = 1;
    if (g === void 0)
      g = 1;
    if (b === void 0)
      b = 1;
    const temptex = new Texture(cgl);
    const arr = [];
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if ((x + y) % 64 < 32) {
          arr.push((200 + y / size * 25 + x / size * 25) * r);
          arr.push((200 + y / size * 25 + x / size * 25) * g);
          arr.push((200 + y / size * 25 + x / size * 25) * b);
        } else {
          arr.push((40 + y / size * 25 + x / size * 25) * r);
          arr.push((40 + y / size * 25 + x / size * 25) * g);
          arr.push((40 + y / size * 25 + x / size * 25) * b);
        }
        arr.push(255);
      }
    }
    const data = new Uint8Array(arr);
    temptex.initFromData(data, size, size, filter, wrap);
    return temptex;
  };
  Texture.createFromImage = function(cgl, img, options) {
    options = options || {};
    const texture = new Texture(cgl, options);
    texture.flip = false;
    texture.image = img;
    texture.width = img.videoWidth || img.width || 8;
    texture.height = img.videoHeight || img.height || 8;
    if (options.hasOwnProperty("wrap"))
      texture.wrap = options.wrap;
    texture.initTexture(img, options.filter);
    return texture;
  };
  Texture.fromImage = function(cgl, img, filter, wrap) {
    console.error("deprecated texture from image...");
    const texture = new Texture(cgl);
    texture.flip = false;
    if (filter)
      texture.filter = filter;
    if (wrap)
      texture.wrap = wrap;
    texture.image = img;
    texture.initTexture(img);
    return texture;
  };
  Texture.isPowerOfTwo = function(x) {
    return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384;
  };
  Texture.getTexInfo = function(tex) {
    const obj = {};
    obj.name = tex.name;
    obj["power of two"] = tex.isPowerOfTwo();
    obj.size = tex.width + " x " + tex.height;
    let targetString = tex.texTarget;
    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D)
      targetString = "TEXTURE_2D";
    obj.target = targetString;
    obj.unpackAlpha = tex.unpackAlpha;
    if (tex.cubemap)
      obj.cubemap = true;
    if (tex.textureType == Texture.TYPE_FLOAT)
      obj.textureType = "TYPE_FLOAT";
    if (tex.textureType == Texture.TYPE_HALF_FLOAT)
      obj.textureType = "TYPE_HALF_FLOAT";
    else if (tex.textureType == Texture.TYPE_DEPTH)
      obj.textureType = "TYPE_DEPTH";
    else if (tex.textureType == Texture.TYPE_DEFAULT)
      obj.textureType = "TYPE_DEFAULT";
    else
      obj.textureType = "UNKNOWN " + this.textureType;
    if (tex.wrap == Texture.WRAP_CLAMP_TO_EDGE)
      obj.wrap = "CLAMP_TO_EDGE";
    else if (tex.wrap == Texture.WRAP_REPEAT)
      obj.wrap = "WRAP_REPEAT";
    else if (tex.wrap == Texture.WRAP_MIRRORED_REPEAT)
      obj.wrap = "WRAP_MIRRORED_REPEAT";
    else
      obj.wrap = "UNKNOWN";
    if (tex.filter == Texture.FILTER_NEAREST)
      obj.filter = "FILTER_NEAREST";
    else if (tex.filter == Texture.FILTER_LINEAR)
      obj.filter = "FILTER_LINEAR";
    else if (tex.filter == Texture.FILTER_MIPMAP)
      obj.filter = "FILTER_MIPMAP";
    else
      obj.filter = "UNKNOWN";
    obj.pixelFormat = tex.pixelFormat || "unknown";
    return obj;
  };
  Texture.FILTER_NEAREST = 0;
  Texture.FILTER_LINEAR = 1;
  Texture.FILTER_MIPMAP = 2;
  Texture.WRAP_REPEAT = 0;
  Texture.WRAP_MIRRORED_REPEAT = 1;
  Texture.WRAP_CLAMP_TO_EDGE = 2;
  Texture.TYPE_DEFAULT = 0;
  Texture.TYPE_DEPTH = 1;
  Texture.TYPE_FLOAT = 2;
  Texture.PFORMATSTR_RGB565 = "RGB 5/6/5bit ubyte";
  Texture.PFORMATSTR_R8UB = "R 8bit ubyte";
  Texture.PFORMATSTR_RG8UB = "RG 8bit ubyte";
  Texture.PFORMATSTR_RGB8UB = "RGB 8bit ubyte";
  Texture.PFORMATSTR_RGBA8UB = "RGBA 8bit ubyte";
  Texture.PFORMATSTR_SRGBA8 = "SRGBA 8bit ubyte";
  Texture.PFORMATSTR_R11FG11FB10F = "RGB 11/11/10bit float";
  Texture.PFORMATSTR_R16F = "R 16bit float";
  Texture.PFORMATSTR_RG16F = "RG 16bit float";
  Texture.PFORMATSTR_RGB16F = "RGB 16bit float";
  Texture.PFORMATSTR_RGBA16F = "RGBA 16bit float";
  Texture.PFORMATSTR_R32F = "R 32bit float";
  Texture.PFORMATSTR_RG32F = "RG 32bit float";
  Texture.PFORMATSTR_RGB32F = "RGB 32bit float";
  Texture.PFORMATSTR_RGBA32F = "RGBA 32bit float";
  Texture.PFORMATSTR_DEPTH = "DEPTH";
  Texture.PIXELFORMATS = [
    Texture.PFORMATSTR_RGB565,
    Texture.PFORMATSTR_R8UB,
    Texture.PFORMATSTR_RG8UB,
    Texture.PFORMATSTR_RGB8UB,
    Texture.PFORMATSTR_RGBA8UB,
    Texture.PFORMATSTR_SRGBA8,
    Texture.PFORMATSTR_R11FG11FB10F,
    Texture.PFORMATSTR_R16F,
    Texture.PFORMATSTR_RG16F,
    Texture.PFORMATSTR_RGBA16F,
    Texture.PFORMATSTR_R32F,
    Texture.PFORMATSTR_RGBA32F
  ];
  Texture.isPixelFormatFloat = (pxlfrmt) => {
    return (pxlfrmt || "").contains("float");
  };
  Texture.isPixelFormatHalfFloat = (pxlfrmt) => {
    return (pxlfrmt || "").contains("float") && (pxlfrmt || "").contains("16bit");
  };
  ;
  class BoundingBox {
    constructor(geom) {
      this._init();
      this._first = true;
      this._wireMesh = null;
      if (geom)
        this.apply(geom);
    }
    _init() {
      this._max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
      this._min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
      this._center = [0, 0, 0];
      this._size = [0, 0, 0];
      this._maxAxis = 0;
      this._first = true;
    }
    /**
     * get biggest number of maxX,maxY,maxZ
     * @type {Number}
     */
    get maxAxis() {
      return this._maxAxis || 1;
    }
    /**
     * size of bounding box
     * @type {vec3}
     */
    get size() {
      return this._size;
    }
    /**
     * center of bounding box
     * @type {vec3}
     */
    get center() {
      return this._center;
    }
    /**
     * center x
     * @type {Number}
     */
    get x() {
      return this._center[0];
    }
    /**
     * center y
     * @type {Number}
     */
    get y() {
      return this._center[1];
    }
    /**
     * center z
     * @type {Number}
     */
    get z() {
      return this._center[2];
    }
    /**
     * minimum x
     * @type {Number}
     */
    get minX() {
      return this._min[0];
    }
    /**
     * minimum y
     * @type {Number}
     */
    get minY() {
      return this._min[1];
    }
    /**
     * minimum z
     * @type {Number}
     */
    get minZ() {
      return this._min[2];
    }
    /**
     * maximum x
     * @type {Number}
     */
    get maxX() {
      return this._max[0];
    }
    /**
     * maximum y
     * @type {Number}
     */
    get maxY() {
      return this._max[1];
    }
    /**
     * maximum z
     * @type {Number}
     */
    get maxZ() {
      return this._max[2];
    }
    apply(geom, mat) {
      if (!geom) {
        return;
      }
      if (geom instanceof BoundingBox) {
        const bb = geom;
        this.applyPos(bb.maxX, bb.maxY, bb.maxZ);
        this.applyPos(bb.minX, bb.minY, bb.minZ);
      } else {
        for (let i = 0; i < geom.vertices.length; i += 3)
          this.applyPos(geom.vertices[i], geom.vertices[i + 1], geom.vertices[i + 2]);
      }
      this.calcCenterSize();
    }
    /**
     * returns a copy of the bounding box
     * @function copy
     * @memberof BoundingBox
     * @instance
     */
    copy() {
      return new BoundingBox(this);
    }
    get changed() {
      return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE);
    }
    applyPos(x, y, z) {
      if (x == Number.MAX_VALUE || x == -Number.MAX_VALUE || y == Number.MAX_VALUE || y == -Number.MAX_VALUE || z == Number.MAX_VALUE || z == -Number.MAX_VALUE)
        return;
      if (!CABLES.UTILS.isNumeric(x) || !CABLES.UTILS.isNumeric(y) || !CABLES.UTILS.isNumeric(z))
        return;
      if (this._first) {
        this._max[0] = x;
        this._max[1] = y;
        this._max[2] = z;
        this._min[0] = x;
        this._min[1] = y;
        this._min[2] = z;
        this._first = false;
        return;
      }
      this._max[0] = Math.max(this._max[0], x);
      this._max[1] = Math.max(this._max[1], y);
      this._max[2] = Math.max(this._max[2], z);
      this._min[0] = Math.min(this._min[0], x);
      this._min[1] = Math.min(this._min[1], y);
      this._min[2] = Math.min(this._min[2], z);
    }
    calcCenterSize() {
      if (this._first)
        return;
      this._size[0] = this._max[0] - this._min[0];
      this._size[1] = this._max[1] - this._min[1];
      this._size[2] = this._max[2] - this._min[2];
      this._center[0] = (this._min[0] + this._max[0]) / 2;
      this._center[1] = (this._min[1] + this._max[1]) / 2;
      this._center[2] = (this._min[2] + this._max[2]) / 2;
      this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1]));
    }
    mulMat4(m) {
      if (this._first) {
        this._max[0] = 0;
        this._max[1] = 0;
        this._max[2] = 0;
        this._min[0] = 0;
        this._min[1] = 0;
        this._min[2] = 0;
        this._first = false;
      }
      vec3.transformMat4(this._max, this._max, m);
      vec3.transformMat4(this._min, this._min, m);
      this.calcCenterSize();
    }
    render(cgl, shader, op) {
      if (!this._wireMesh)
        this._wireMesh = new CGL.WireCube(cgl);
      cgl.pushModelMatrix();
      mat4.translate(cgl.mMatrix, cgl.mMatrix, this._center);
      if (CABLES.UI && op) {
        CABLES.UI.OverlayMeshes.drawCube(op, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2);
      }
      cgl.popModelMatrix();
    }
  }
  ;
  const Geometry = function(name2) {
    this.name = name2 || "unknown";
    this._log = new Logger("cgl_geometry");
    this.faceVertCount = 3;
    this.glPrimitive = null;
    this._attributes = {};
    this._vertices = [];
    this.verticesIndices = [];
    this.isGeometry = true;
    this.morphTargets = [];
    Object.defineProperty(this, "vertices", {
      get() {
        return this._vertices;
      },
      set(v) {
        this.setVertices(v);
      }
    });
    Object.defineProperty(this, "texCoords", {
      get() {
        const att = this.getAttribute("texCoords");
        if (!att)
          return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("texCoords", v, 2);
      }
    });
    Object.defineProperty(this, "vertexNormals", {
      get() {
        const att = this.getAttribute("vertexNormals");
        if (!att)
          return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("vertexNormals", v, 3);
      }
    });
    Object.defineProperty(this, "tangents", {
      get() {
        const att = this.getAttribute("tangents");
        if (!att)
          return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("tangents", v, 3);
      }
    });
    Object.defineProperty(this, "biTangents", {
      get() {
        const att = this.getAttribute("biTangents");
        if (!att)
          return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("biTangents", v, 3);
      }
    });
    Object.defineProperty(this, "vertexColors", {
      get() {
        const att = this.getAttribute("vertexColors");
        if (!att)
          return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("vertexColors", v, 4);
      }
    });
  };
  Geometry.prototype.clear = function() {
    this._vertices = new Float32Array([]);
    this.verticesIndices = [];
    this.texCoords = new Float32Array([]);
    this.vertexNormals = new Float32Array([]);
    this.tangents = [];
    this.biTangents = [];
    this._attributes = {};
  };
  Geometry.prototype.getAttributes = function() {
    return this._attributes;
  };
  Geometry.prototype.getAttribute = function(name2) {
    for (const i in this._attributes) {
      if (this._attributes[i].name == name2)
        return this._attributes[i];
    }
    return null;
  };
  Geometry.prototype.setAttribute = function(name2, arr, itemSize) {
    let attrType = "";
    if (!itemSize || itemSize > 4) {
      console.log("itemsize wrong?", itemSize, name2);
      this._log.stack("itemsize");
      itemSize = 3;
    }
    if (itemSize == 1)
      attrType = "float";
    else if (itemSize == 2)
      attrType = "vec2";
    else if (itemSize == 3)
      attrType = "vec3";
    else if (itemSize == 4)
      attrType = "vec4";
    const attr = {
      "name": name2,
      "data": arr,
      "itemSize": itemSize,
      "type": attrType
    };
    this._attributes[name2] = attr;
  };
  Geometry.prototype.copyAttribute = function(name2, newgeom) {
    const attr = this.getAttribute(name2);
    newgeom.setAttribute(name2, new Float32Array(attr.data), attr.itemSize);
  };
  Geometry.prototype.setVertices = function(arr) {
    if (arr instanceof Float32Array)
      this._vertices = arr;
    else
      this._vertices = new Float32Array(arr);
  };
  Geometry.prototype.setTexCoords = function(arr) {
    if (arr instanceof Float32Array)
      this.texCoords = arr;
    else
      this.texCoords = new Float32Array(arr);
  };
  Geometry.prototype.calcNormals = function(smooth) {
    const options = { "smooth": smooth };
    this.calculateNormals(options);
  };
  Geometry.prototype.flipNormals = function(x, y, z) {
    let vec = vec3.create();
    if (x == void 0)
      x = 1;
    if (y == void 0)
      y = 1;
    if (z == void 0)
      z = 1;
    for (let i = 0; i < this.vertexNormals.length; i += 3) {
      vec3.set(
        vec,
        this.vertexNormals[i + 0],
        this.vertexNormals[i + 1],
        this.vertexNormals[i + 2]
      );
      vec[0] *= -x;
      vec[1] *= -y;
      vec[2] *= -z;
      vec3.normalize(vec, vec);
      this.vertexNormals[i + 0] = vec[0];
      this.vertexNormals[i + 1] = vec[1];
      this.vertexNormals[i + 2] = vec[2];
    }
  };
  Geometry.prototype.getNumTriangles = function() {
    if (this.verticesIndices && this.verticesIndices.length)
      return this.verticesIndices.length / 3;
    return this.vertices.length / 3;
  };
  Geometry.prototype.flipVertDir = function() {
    const newInd = [];
    newInd.length = this.verticesIndices.length;
    for (let i = 0; i < this.verticesIndices.length; i += 3) {
      newInd[i] = this.verticesIndices[i + 2];
      newInd[i + 1] = this.verticesIndices[i + 1];
      newInd[i + 2] = this.verticesIndices[i];
    }
    this.verticesIndices = newInd;
  };
  Geometry.prototype.setPointVertices = function(verts) {
    if (verts.length % 3 !== 0) {
      this._log.error("SetPointVertices: Array must be multiple of three.");
      return;
    }
    if (!(verts instanceof Float32Array))
      this.vertices = new Float32Array(verts);
    else
      this.vertices = verts;
    if (!(this.texCoords instanceof Float32Array))
      this.texCoords = new Float32Array(verts.length / 3 * 2);
    this.verticesIndices.length = verts.length / 3;
    for (let i = 0; i < verts.length / 3; i++) {
      this.verticesIndices[i] = i;
      this.texCoords[i * 2] = 0;
      this.texCoords[i * 2 + 1] = 0;
    }
  };
  Geometry.prototype.merge = function(geom) {
    if (!geom)
      return;
    if (this.isIndexed() != geom.isIndexed()) {
      if (this.isIndexed()) {
        this.unIndex(false, true);
      }
      if (geom.isIndexed()) {
        const g = geom.copy();
        g.unIndex(false, true);
        geom = g;
      }
    }
    const oldIndizesLength = this.verticesIndices.length;
    const vertLength = this._vertices.length / 3;
    this.verticesIndices.length += geom.verticesIndices.length;
    for (let i = 0; i < geom.verticesIndices.length; i++)
      this.verticesIndices[oldIndizesLength + i] = geom.verticesIndices[i] + vertLength;
    this.vertices = UTILS.float32Concat(this._vertices, geom.vertices);
    this.texCoords = UTILS.float32Concat(this.texCoords, geom.texCoords);
    this.vertexNormals = UTILS.float32Concat(this.vertexNormals, geom.vertexNormals);
    this.tangents = UTILS.float32Concat(this.tangents, geom.tangents);
    this.biTangents = UTILS.float32Concat(this.biTangents, geom.biTangents);
  };
  Geometry.prototype.copy = function() {
    const geom = new Geometry(this.name + " copy");
    geom.faceVertCount = this.faceVertCount;
    geom.glPrimitive = this.glPrimitive;
    geom.setVertices(this._vertices.slice(0));
    if (this.verticesIndices) {
      geom.verticesIndices.length = this.verticesIndices.length;
      for (let i = 0; i < this.verticesIndices.length; i++)
        geom.verticesIndices[i] = this.verticesIndices[i];
    }
    for (let i in this._attributes)
      this.copyAttribute(i, geom);
    geom.morphTargets.length = this.morphTargets.length;
    for (let i = 0; i < this.morphTargets.length; i++)
      geom.morphTargets[i] = this.morphTargets[i];
    return geom;
  };
  Geometry.prototype.calculateNormals = function(options) {
    options = options || {};
    if (options.smooth === false)
      this.unIndex();
    const u = vec3.create();
    const v = vec3.create();
    const n = vec3.create();
    function calcNormal(triangle) {
      vec3.subtract(u, triangle[0], triangle[1]);
      vec3.subtract(v, triangle[0], triangle[2]);
      vec3.cross(n, u, v);
      vec3.normalize(n, n);
      if (options && options.forceZUp) {
        if (n[2] < 0) {
          n[0] *= -1;
          n[1] *= -1;
          n[2] *= -1;
        }
      }
      return n;
    }
    this.getVertexVec = function(which) {
      const vec = [0, 0, 0];
      vec[0] = this.vertices[which * 3 + 0];
      vec[1] = this.vertices[which * 3 + 1];
      vec[2] = this.vertices[which * 3 + 2];
      return vec;
    };
    if (!(this.vertexNormals instanceof Float32Array) || this.vertexNormals.length != this.vertices.length)
      this.vertexNormals = new Float32Array(this.vertices.length);
    for (let i = 0; i < this.vertices.length; i++) {
      this.vertexNormals[i] = 0;
    }
    if (!this.isIndexed()) {
      const norms = [];
      for (let i = 0; i < this.vertices.length; i += 9) {
        const triangle = [[this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]], [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]], [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]]];
        const nn = calcNormal(triangle);
        norms.push(nn[0], nn[1], nn[2], nn[0], nn[1], nn[2], nn[0], nn[1], nn[2]);
      }
      this.vertexNormals = norms;
    } else {
      const faceNormals = [];
      faceNormals.length = Math.floor(this.verticesIndices.length / 3);
      for (let i = 0; i < this.verticesIndices.length; i += 3) {
        const triangle = [this.getVertexVec(this.verticesIndices[i + 0]), this.getVertexVec(this.verticesIndices[i + 1]), this.getVertexVec(this.verticesIndices[i + 2])];
        faceNormals[i / 3] = calcNormal(triangle);
        this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] += faceNormals[i / 3][0];
        this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] += faceNormals[i / 3][1];
        this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] += faceNormals[i / 3][2];
        this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] += faceNormals[i / 3][0];
        this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] += faceNormals[i / 3][1];
        this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] += faceNormals[i / 3][2];
        this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] += faceNormals[i / 3][0];
        this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] += faceNormals[i / 3][1];
        this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] += faceNormals[i / 3][2];
      }
      for (let i = 0; i < this.verticesIndices.length; i += 3) {
        for (let k = 0; k < 3; k++) {
          const vv = [this.vertexNormals[this.verticesIndices[i + k] * 3 + 0], this.vertexNormals[this.verticesIndices[i + k] * 3 + 1], this.vertexNormals[this.verticesIndices[i + k] * 3 + 2]];
          vec3.normalize(vv, vv);
          this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];
          this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];
          this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];
        }
      }
    }
  };
  Geometry.prototype.calcTangentsBitangents = function() {
    if (!this.vertices.length) {
      return;
    }
    if (!this.vertexNormals.length) {
      return;
    }
    if (!this.texCoords.length) {
      const texCoordLength = this.vertices.length / 3 * 2;
      this.texCoords = new Float32Array(texCoordLength);
      for (let i = 0; i < texCoordLength; i += 1)
        this.texCoords[i] = 0;
    }
    if (!this.verticesIndices || !this.verticesIndices.length) {
      return;
    }
    if (this.verticesIndices.length % 3 !== 0) {
      this._log.error("Vertex indices mismatch!");
      return;
    }
    const triangleCount = this.verticesIndices.length / 3;
    const vertexCount = this.vertices.length / 3;
    this.tangents = new Float32Array(this.vertexNormals.length);
    this.biTangents = new Float32Array(this.vertexNormals.length);
    const tempVertices = [];
    tempVertices.length = vertexCount * 2;
    const v1 = vec3.create();
    const v2 = vec3.create();
    const v3 = vec3.create();
    const w1 = vec2.create();
    const w2 = vec2.create();
    const w3 = vec2.create();
    const sdir = vec3.create();
    const tdir = vec3.create();
    for (let tri = 0; tri < triangleCount; tri += 1) {
      const i1 = this.verticesIndices[tri * 3];
      const i2 = this.verticesIndices[tri * 3 + 1];
      const i3 = this.verticesIndices[tri * 3 + 2];
      vec3.set(v1, this.vertices[i1 * 3], this.vertices[i1 * 3 + 1], this.vertices[i1 * 3 + 2]);
      vec3.set(v2, this.vertices[i2 * 3], this.vertices[i2 * 3 + 1], this.vertices[i2 * 3 + 2]);
      vec3.set(v3, this.vertices[i3 * 3], this.vertices[i3 * 3 + 1], this.vertices[i3 * 3 + 2]);
      vec2.set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);
      vec2.set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);
      vec2.set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);
      const x1 = v2[0] - v1[0];
      const x2 = v3[0] - v1[0];
      const y1 = v2[1] - v1[1];
      const y2 = v3[1] - v1[1];
      const z1 = v2[2] - v1[2];
      const z2 = v3[2] - v1[2];
      const s1 = w2[0] - w1[0];
      const s2 = w3[0] - w1[0];
      const t1 = w2[1] - w1[1];
      const t2 = w3[1] - w1[1];
      const r = 1 / (s1 * t2 - s2 * t1);
      vec3.set(sdir, (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      vec3.set(tdir, (s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
      tempVertices[i1] = sdir;
      tempVertices[i2] = sdir;
      tempVertices[i3] = sdir;
      tempVertices[i1 + vertexCount] = tdir;
      tempVertices[i2 + vertexCount] = tdir;
      tempVertices[i3 + vertexCount] = tdir;
    }
    const normal = vec3.create();
    const tempVert = vec3.create();
    const tan = vec3.create();
    const bitan = vec3.create();
    const temp1 = vec3.create();
    const temp2 = vec3.create();
    const crossPd = vec3.create();
    const normalized = vec3.create();
    for (let vert = 0; vert < vertexCount; vert += 1) {
      if (!tempVertices[vert])
        continue;
      vec3.set(normal, this.vertexNormals[vert * 3], this.vertexNormals[vert * 3 + 1], this.vertexNormals[vert * 3 + 2]);
      vec3.set(tempVert, tempVertices[vert][0], tempVertices[vert][1], tempVertices[vert][2]);
      const _dp = vec3.dot(normal, tempVert);
      vec3.scale(temp1, normal, _dp);
      vec3.subtract(temp2, tempVert, temp1);
      vec3.normalize(normalized, temp2);
      vec3.cross(crossPd, normal, tempVert);
      const w = 1;
      vec3.scale(tan, normalized, 1 / w);
      vec3.cross(bitan, normal, tan);
      this.tangents[vert * 3 + 0] = tan[0];
      this.tangents[vert * 3 + 1] = tan[1];
      this.tangents[vert * 3 + 2] = tan[2];
      this.biTangents[vert * 3 + 0] = bitan[0];
      this.biTangents[vert * 3 + 1] = bitan[1];
      this.biTangents[vert * 3 + 2] = bitan[2];
    }
  };
  Geometry.prototype.isIndexed = function() {
    if (this._vertices.length == 0)
      return true;
    return this.verticesIndices.length != 0;
  };
  Geometry.prototype.unIndex = function(reIndex, dontCalcNormals) {
    const newVerts = [];
    const newIndizes = [];
    let count = 0;
    for (let j in this._attributes) {
      const attr = this._attributes[j];
      let na = [];
      for (let i = 0; i < this.verticesIndices.length; i += 3) {
        for (let s = 0; s < 3; s++) {
          if (attr.itemSize == 3)
            na.push(
              attr.data[this.verticesIndices[i + s] * 3 + 0],
              attr.data[this.verticesIndices[i + s] * 3 + 1],
              attr.data[this.verticesIndices[i + s] * 3 + 2]
            );
          else if (attr.itemSize == 4)
            na.push(
              attr.data[this.verticesIndices[i + s] * 4 + 0],
              attr.data[this.verticesIndices[i + s] * 4 + 1],
              attr.data[this.verticesIndices[i + s] * 4 + 2],
              attr.data[this.verticesIndices[i + s] * 4 + 3]
            );
          else if (attr.itemSize == 2)
            na.push(
              attr.data[this.verticesIndices[i + s] * 2 + 0],
              attr.data[this.verticesIndices[i + s] * 2 + 1]
            );
          else if (attr.itemSize == 1)
            na.push(
              attr.data[this.verticesIndices[i + s]]
            );
          else
            console.log("unknown attr", attr);
        }
      }
      this.setAttribute(attr.name, na, attr.itemSize);
    }
    for (let i = 0; i < this.verticesIndices.length; i += 3) {
      newVerts.push(
        this.vertices[this.verticesIndices[i + 0] * 3 + 0],
        this.vertices[this.verticesIndices[i + 0] * 3 + 1],
        this.vertices[this.verticesIndices[i + 0] * 3 + 2]
      );
      newIndizes.push(count);
      count++;
      newVerts.push(
        this.vertices[this.verticesIndices[i + 1] * 3 + 0],
        this.vertices[this.verticesIndices[i + 1] * 3 + 1],
        this.vertices[this.verticesIndices[i + 1] * 3 + 2]
      );
      newIndizes.push(count);
      count++;
      newVerts.push(
        this.vertices[this.verticesIndices[i + 2] * 3 + 0],
        this.vertices[this.verticesIndices[i + 2] * 3 + 1],
        this.vertices[this.verticesIndices[i + 2] * 3 + 2]
      );
      newIndizes.push(count);
      count++;
    }
    this.vertices = newVerts;
    this.verticesIndices = [];
    if (reIndex)
      this.verticesIndices = newIndizes;
    if (!dontCalcNormals)
      this.calculateNormals();
  };
  Geometry.prototype.calcBarycentric = function() {
    let barycentrics = [];
    barycentrics.length = this.vertices.length;
    for (let i = 0; i < this.vertices.length; i++)
      barycentrics[i] = 0;
    let count = 0;
    for (let i = 0; i < this.vertices.length; i += 3) {
      barycentrics[i + count] = 1;
      count++;
      if (count == 3)
        count = 0;
    }
    this.setAttribute("attrBarycentric", barycentrics, 3);
  };
  Geometry.prototype.getBounds = function() {
    return new BoundingBox(this);
  };
  Geometry.prototype.center = function(x, y, z) {
    if (x === void 0) {
      x = true;
      y = true;
      z = true;
    }
    let i = 0;
    const bounds = this.getBounds();
    const offset = [bounds.minX + (bounds.maxX - bounds.minX) / 2, bounds.minY + (bounds.maxY - bounds.minY) / 2, bounds.minZ + (bounds.maxZ - bounds.minZ) / 2];
    for (i = 0; i < this.vertices.length; i += 3) {
      if (this.vertices[i + 0] == this.vertices[i + 0]) {
        if (x)
          this.vertices[i + 0] -= offset[0];
        if (y)
          this.vertices[i + 1] -= offset[1];
        if (z)
          this.vertices[i + 2] -= offset[2];
      }
    }
    return offset;
  };
  Geometry.prototype.mapTexCoords2d = function() {
    const bounds = this.getBounds();
    const num = this.vertices.length / 3;
    this.texCoords = new Float32Array(num * 2);
    for (let i = 0; i < num; i++) {
      const vertX = this.vertices[i * 3 + 0];
      const vertY = this.vertices[i * 3 + 1];
      this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;
      this.texCoords[i * 2 + 1] = 1 - vertY / (bounds.maxY - bounds.minY) + 0.5;
    }
  };
  Geometry.prototype.getInfoOneLine = function() {
    let txt = "";
    if (this.faceVertCount == 3 && this.verticesIndices)
      txt += this.verticesIndices.length / 3;
    else
      txt += 0;
    txt += " tris ";
    if (this.vertices)
      txt += this.vertices.length / 3;
    else
      txt += 0;
    txt += " verts";
    return txt;
  };
  Geometry.prototype.getInfo = function() {
    const info = {};
    if (this.faceVertCount == 3 && this.verticesIndices)
      info.numFaces = this.verticesIndices.length / 3;
    else
      info.numFaces = 0;
    if (this.verticesIndices && this.verticesIndices.length)
      info.indices = this.verticesIndices.length;
    if (this.vertices)
      info.numVerts = this.vertices.length / 3;
    else
      info.numVerts = 0;
    if (this.vertexNormals)
      info.numNormals = this.vertexNormals.length / 3;
    else
      info.numNormals = 0;
    if (this.texCoords)
      info.numTexCoords = this.texCoords.length / 2;
    else
      info.numTexCoords = 0;
    if (this.tangents)
      info.numTangents = this.tangents.length / 3;
    else
      info.numTangents = 0;
    if (this.biTangents)
      info.numBiTangents = this.biTangents.length / 3;
    else
      info.numBiTangents = 0;
    if (this.biTangents)
      info.numBiTangents = this.biTangents.length / 3;
    else
      info.numBiTangents = 0;
    if (this.vertexColors)
      info.numVertexColors = this.vertexColors.length / 4;
    else
      info.numVertexColors = 0;
    if (this.getAttributes())
      info.numAttribs = Object.keys(this.getAttributes()).length;
    else
      info.numAttribs = 0;
    info.isIndexed = this.isIndexed();
    return info;
  };
  Geometry.buildFromFaces = function(arr, name2, optimize) {
    const vertices = [];
    const verticesIndices = [];
    for (let i = 0; i < arr.length; i += 3) {
      const a = arr[i + 0];
      const b = arr[i + 1];
      const c = arr[i + 2];
      const face = [-1, -1, -1];
      if (optimize)
        for (let iv = 0; iv < vertices.length; iv += 3) {
          if (vertices[iv + 0] == a[0] && vertices[iv + 1] == a[1] && vertices[iv + 2] == a[2])
            face[0] = iv / 3;
          if (vertices[iv + 0] == b[0] && vertices[iv + 1] == b[1] && vertices[iv + 2] == b[2])
            face[1] = iv / 3;
          if (vertices[iv + 0] == c[0] && vertices[iv + 1] == c[1] && vertices[iv + 2] == c[2])
            face[2] = iv / 3;
        }
      if (face[0] == -1) {
        vertices.push(a[0], a[1], a[2]);
        face[0] = (vertices.length - 1) / 3;
      }
      if (face[1] == -1) {
        vertices.push(b[0], b[1], b[2]);
        face[1] = (vertices.length - 1) / 3;
      }
      if (face[2] == -1) {
        vertices.push(c[0], c[1], c[2]);
        face[2] = (vertices.length - 1) / 3;
      }
      verticesIndices.push(parseInt(face[0], 10));
      verticesIndices.push(parseInt(face[1], 10));
      verticesIndices.push(parseInt(face[2], 10));
    }
    const geom = new Geometry(name2);
    geom.name = name2;
    geom.vertices = vertices;
    geom.verticesIndices = verticesIndices;
    return geom;
  };
  Geometry.json2geom = function(jsonMesh) {
    const geom = new Geometry("jsonMeshGeom");
    geom.verticesIndices = [];
    geom.vertices = jsonMesh.vertices || [];
    geom.vertexNormals = jsonMesh.normals || [];
    geom.vertexColors = jsonMesh.colors || [];
    geom.tangents = jsonMesh.tangents || [];
    geom.biTangents = jsonMesh.bitangents || [];
    if (jsonMesh.texturecoords)
      geom.setTexCoords(jsonMesh.texturecoords[0]);
    if (jsonMesh.vertices_b64)
      geom.vertices = new Float32Array(b64decTypedArray(jsonMesh.vertices_b64));
    if (jsonMesh.normals_b64)
      geom.vertexNormals = new Float32Array(b64decTypedArray(jsonMesh.normals_b64));
    if (jsonMesh.tangents_b64)
      geom.tangents = new Float32Array(b64decTypedArray(jsonMesh.tangents_b64));
    if (jsonMesh.bitangents_b64)
      geom.biTangents = new Float32Array(b64decTypedArray(jsonMesh.bitangents_b64));
    if (jsonMesh.texturecoords_b64)
      geom.setTexCoords(new Float32Array(b64decTypedArray(jsonMesh.texturecoords_b64[0])));
    if (jsonMesh.faces_b64) {
      geom.verticesIndices = new Uint32Array(b64decTypedArray(jsonMesh.faces_b64));
    } else {
      geom.verticesIndices.length = jsonMesh.faces.length * 3;
      for (let i = 0; i < jsonMesh.faces.length; i++) {
        geom.verticesIndices[i * 3] = jsonMesh.faces[i][0];
        geom.verticesIndices[i * 3 + 1] = jsonMesh.faces[i][1];
        geom.verticesIndices[i * 3 + 2] = jsonMesh.faces[i][2];
      }
    }
    return geom;
  };
  ;
  function extendMeshWithFeedback(Mesh2) {
    Mesh2.prototype.hasFeedbacks = function() {
      return this._feedBacks.length > 0;
    };
    Mesh2.prototype.removeFeedbacks = function(shader) {
      if (!this._feedbacks)
        return;
      this._feedbacks.length = 0;
      this._feedBacksChanged = true;
    };
    Mesh2.prototype.setAttributeFeedback = function() {
    };
    Mesh2.prototype.setFeedback = function(attrib, nameOut, initialArr) {
      let fb = { nameOut };
      let found = false;
      this.unBindFeedbacks();
      for (let i = 0; i < this._feedBacks.length; i++) {
        if (this._feedBacks[i].nameOut == nameOut) {
          fb = this._feedBacks[i];
          found = true;
        }
      }
      if (!found)
        this._feedBacksChanged = true;
      fb.initialArr = initialArr;
      fb.attrib = attrib;
      if (fb.outBuffer)
        this._cgl.gl.deleteBuffer(fb.outBuffer);
      fb.outBuffer = this._cgl.gl.createBuffer();
      this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.outBuffer);
      this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, fb.initialArr, this._cgl.gl.STATIC_DRAW);
      this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.attrib.buffer);
      this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, fb.initialArr, this._cgl.gl.STATIC_DRAW);
      if (!found)
        this._feedBacks.push(fb);
      return fb;
    };
    Mesh2.prototype.bindFeedback = function(attrib) {
      if (!this._feedBacks || this._feedBacks.length === 0)
        return;
      if (this._transformFeedBackLoc == -1)
        this._transformFeedBackLoc = this._cgl.gl.createTransformFeedback();
      this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);
      let found = false;
      for (let i = 0; i < this._feedBacks.length; i++) {
        const fb = this._feedBacks[i];
        if (fb.attrib == attrib) {
          found = true;
          this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, fb.outBuffer);
        }
      }
      if (!found) {
      }
    };
    Mesh2.prototype.drawFeedbacks = function(shader, prim) {
      let i = 0;
      if (this._feedBacksChanged) {
        const names = [];
        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);
        for (i = 0; i < this._feedBacks.length; i++)
          names.push(this._feedBacks[i].nameOut);
        shader.setFeedbackNames(names);
        console.log("feedbacknames", names);
        shader.compile();
        this._feedBacksChanged = false;
        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);
        console.log("changed finished");
        return;
      }
      this._cgl.gl.beginTransformFeedback(this.glPrimitive);
      this._cgl.gl.drawArrays(prim, 0, this._feedBacks[0].attrib.numItems);
      this._cgl.gl.endTransformFeedback();
      this.unBindFeedbacks();
      this.feedBacksSwapBuffers();
    };
    Mesh2.prototype.unBindFeedbacks = function() {
      for (let i = 0; i < this._feedBacks.length; i++) {
        this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, null);
      }
      this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);
    };
    Mesh2.prototype.feedBacksSwapBuffers = function() {
      for (let i = 0; i < this._feedBacks.length; i++) {
        const t = this._feedBacks[i].attrib.buffer;
        this._feedBacks[i].attrib.buffer = this._feedBacks[i].outBuffer;
        this._feedBacks[i].outBuffer = t;
      }
    };
  }
  ;
  const MESH = {};
  MESH.lastMesh = null;
  const Mesh = function(_cgl, __geom, _options) {
    this._cgl = _cgl;
    let options = _options || {};
    if (CABLES.UTILS.isNumeric(options))
      options = { "glPrimitive": _options };
    this._log = new Logger("cgl_mesh");
    this._bufVertexAttrib = null;
    this._bufVerticesIndizes = this._cgl.gl.createBuffer();
    this._indexType = this._cgl.gl.UNSIGNED_SHORT;
    this._attributes = [];
    this._attribLocs = {};
    this._geom = null;
    this._lastShader = null;
    this._numInstances = 0;
    this._glPrimitive = options.glPrimitive;
    this.opId = options.opId || "";
    this._preWireframeGeom = null;
    this.addVertexNumbers = false;
    this._name = "unknown";
    this.feedBackAttributes = [];
    this.setGeom(__geom);
    this._feedBacks = [];
    this._feedBacksChanged = false;
    this._transformFeedBackLoc = -1;
    this._lastAttrUpdate = 0;
    this.memFreed = false;
    this._cgl.profileData.addHeavyEvent("mesh constructed", this._name);
    this._queryExt = null;
    Object.defineProperty(this, "numInstances", {
      get() {
        return this._numInstances;
      },
      set(v) {
        this.setNumInstances(v);
      }
    });
  };
  Mesh.prototype.freeMem = function() {
    this.memFreed = true;
    for (let i = 0; i < this._attributes.length; i++) {
      this._attributes[i].floatArray = null;
    }
  };
  Mesh.prototype.updateVertices = function(geom) {
    this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION, geom.vertices, 3);
    this._numVerts = geom.vertices.length / 3;
  };
  Mesh.prototype.setAttributePointer = function(attrName, name2, stride, offset) {
    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].name == attrName) {
        if (!this._attributes[i].pointer)
          this._attributes[i].pointer = [];
        this._attributes[i].pointer.push(
          {
            "loc": -1,
            "name": name2,
            "stride": stride,
            "offset": offset,
            "instanced": attrName == constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX
          }
        );
      }
    }
  };
  Mesh.prototype.getAttribute = function(name2) {
    for (let i = 0; i < this._attributes.length; i++)
      if (this._attributes[i].name == name2)
        return this._attributes[i];
  };
  Mesh.prototype.setAttributeRange = function(attr, array, start, end) {
    if (!attr)
      return;
    if (!start && !end)
      return;
    if (!attr.name) {
      this._log.stack("no attrname?!");
    }
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
    this._cgl.profileData.profileMeshAttributes += end - start || 0;
    this._cgl.profileData.profileSingleMeshAttribute[this._name] = this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0;
    this._cgl.profileData.profileSingleMeshAttribute[this._name] += end - start || 0;
    if (attr.numItems < array.length / attr.itemSize) {
      this._resizeAttr(array, attr);
    }
    if (end > array.length) {
      if (CABLES.platform.isDevEnv())
        this._log.log(this._cgl.canvas.id + " " + attr.name + " buffersubdata out of bounds ?", array.length, end, start, attr);
      return;
    }
    if (this._cgl.glVersion == 1)
      this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, array);
    else
      this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, start * 4, array, start, end - start);
  };
  Mesh.prototype._resizeAttr = function(array, attr) {
    if (attr.buffer)
      this._cgl.gl.deleteBuffer(attr.buffer);
    attr.buffer = this._cgl.gl.createBuffer();
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
    this._bufferArray(array, attr);
    attr.numItems = array.length / attr.itemSize;
  };
  Mesh.prototype._bufferArray = function(array, attr) {
    let floatArray = attr.floatArray || null;
    if (!array)
      return;
    if (this._cgl.debugOneFrame) {
      console.log("_bufferArray", array.length, attr.name);
    }
    if (!(array instanceof Float32Array)) {
      if (attr && floatArray && floatArray.length == array.length) {
        floatArray.set(array);
      } else {
        floatArray = new Float32Array(array);
        if (this._cgl.debugOneFrame) {
          console.log("_bufferArray create new float32array", array.length, attr.name);
        }
        if (array.length > 1e4) {
          this._cgl.profileData.profileNonTypedAttrib++;
          this._cgl.profileData.profileNonTypedAttribNames = "(" + this._name + ":" + attr.name + ")";
        }
      }
    } else
      floatArray = array;
    attr.arrayLength = floatArray.length;
    attr.floatArray = null;
    this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);
  };
  Mesh.prototype.addAttribute = Mesh.prototype.updateAttribute = Mesh.prototype.setAttribute = function(name2, array, itemSize, options) {
    if (!array) {
      this._log.error("mesh addAttribute - no array given! " + name2);
      throw new Error();
    }
    let cb = null;
    let instanced = false;
    let i = 0;
    const numItems = array.length / itemSize;
    this._cgl.profileData.profileMeshAttributes += numItems || 0;
    if (typeof options == "function") {
      cb = options;
    }
    if (typeof options == "object") {
      if (options.cb)
        cb = options.cb;
      if (options.instanced)
        instanced = options.instanced;
    }
    if (name2 == constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX)
      instanced = true;
    for (i = 0; i < this._attributes.length; i++) {
      const attr2 = this._attributes[i];
      if (attr2.name == name2) {
        if (attr2.numItems === numItems) {
        } else {
          this._resizeAttr(array, attr2);
        }
        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr2.buffer);
        this._bufferArray(array, attr2);
        return attr2;
      }
    }
    const buffer = this._cgl.gl.createBuffer();
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, buffer);
    let type = this._cgl.gl.FLOAT;
    if (options && options.type)
      type = options.type;
    const attr = {
      "buffer": buffer,
      "name": name2,
      "cb": cb,
      "itemSize": itemSize,
      "numItems": numItems,
      "startItem": 0,
      "instanced": instanced,
      "type": type
    };
    this._bufferArray(array, attr);
    if (name2 == constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION)
      this._bufVertexAttrib = attr;
    this._attributes.push(attr);
    this._attribLocs = {};
    return attr;
  };
  Mesh.prototype.getAttributes = function() {
    return this._attributes;
  };
  Mesh.prototype.updateTexCoords = function(geom) {
    if (geom.texCoords && geom.texCoords.length > 0) {
      this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, geom.texCoords, 2);
    } else {
      const tcBuff = new Float32Array(Math.round(geom.vertices.length / 3 * 2));
      this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, tcBuff, 2);
    }
  };
  Mesh.prototype.updateNormals = function(geom) {
    if (geom.vertexNormals && geom.vertexNormals.length > 0) {
      this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, geom.vertexNormals, 3);
    } else {
      const tcBuff = new Float32Array(Math.round(geom.vertices.length));
      this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, tcBuff, 3);
    }
  };
  Mesh.prototype._setVertexNumbers = function(arr) {
    if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || arr) {
      if (arr)
        this._verticesNumbers = arr;
      else {
        this._verticesNumbers = new Float32Array(this._numVerts);
        for (let i = 0; i < this._numVerts; i++)
          this._verticesNumbers[i] = i;
      }
      this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (attr, geom, shader) => {
        if (!shader.uniformNumVertices)
          shader.uniformNumVertices = new Uniform(shader, "f", "numVertices", this._numVerts);
        shader.uniformNumVertices.setValue(this._numVerts);
      });
    }
  };
  Mesh.prototype.setVertexIndices = function(vertIndices) {
    if (!this._bufVerticesIndizes) {
      this._log.warn("no bufVerticesIndizes: " + this._name);
      return;
    }
    if (vertIndices.length > 0) {
      if (vertIndices instanceof Float32Array)
        this._log.warn("vertIndices float32Array: " + this._name);
      for (let i = 0; i < vertIndices.length; i++) {
        if (vertIndices[i] >= this._numVerts) {
          this._log.warn("invalid index in " + this._name, i, vertIndices[i]);
          return;
        }
      }
      this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);
      if (vertIndices.length > 65535) {
        this.vertIndicesTyped = new Uint32Array(vertIndices);
        this._indexType = this._cgl.gl.UNSIGNED_INT;
      } else if (vertIndices instanceof Uint32Array) {
        this.vertIndicesTyped = vertIndices;
        this._indexType = this._cgl.gl.UNSIGNED_INT;
      } else if (!(vertIndices instanceof Uint16Array)) {
        this.vertIndicesTyped = new Uint16Array(vertIndices);
        this._indexType = this._cgl.gl.UNSIGNED_SHORT;
      } else
        this.vertIndicesTyped = vertIndices;
      this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this._cgl.gl.DYNAMIC_DRAW);
      this._bufVerticesIndizes.itemSize = 1;
      this._bufVerticesIndizes.numItems = vertIndices.length;
    } else
      this._bufVerticesIndizes.numItems = 0;
  };
  Mesh.prototype.setGeom = function(geom, removeRef) {
    this._geom = geom;
    if (geom.glPrimitive != null)
      this._glPrimitive = geom.glPrimitive;
    if (this._geom && this._geom.name)
      this._name = "mesh " + this._geom.name;
    MESH.lastMesh = null;
    this._cgl.profileData.profileMeshSetGeom++;
    this._disposeAttributes();
    this.updateVertices(this._geom);
    this.setVertexIndices(this._geom.verticesIndices);
    if (this.addVertexNumbers)
      this._setVertexNumbers();
    const geomAttribs = this._geom.getAttributes();
    const attribAssoc = {
      "texCoords": constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,
      "vertexNormals": constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,
      "vertexColors": constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_COLOR,
      "tangents": "attrTangent",
      "biTangents": "attrBiTangent"
    };
    for (const index in geomAttribs)
      if (geomAttribs[index].data && geomAttribs[index].data.length)
        this.setAttribute(attribAssoc[index] || index, geomAttribs[index].data, geomAttribs[index].itemSize);
    if (removeRef) {
      this._geom = null;
    }
  };
  Mesh.prototype._preBind = function(shader) {
    for (let i = 0; i < this._attributes.length; i++)
      if (this._attributes[i].cb)
        this._attributes[i].cb(this._attributes[i], this._geom, shader);
  };
  Mesh.prototype._checkAttrLengths = function() {
    if (this.memFreed)
      return;
    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].arrayLength / this._attributes[i].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize) {
        let name2 = "unknown";
        if (this._geom)
          name2 = this._geom.name;
      }
    }
  };
  Mesh.prototype._bind = function(shader) {
    if (!shader.isValid())
      return;
    let attrLocs = [];
    if (this._attribLocs[shader.id])
      attrLocs = this._attribLocs[shader.id];
    else
      this._attribLocs[shader.id] = attrLocs;
    this._lastShader = shader;
    if (shader.lastCompile > this._lastAttrUpdate || attrLocs.length != this._attributes.length) {
      this._lastAttrUpdate = shader.lastCompile;
      for (let i = 0; i < this._attributes.length; i++)
        attrLocs[i] = -1;
    }
    for (let i = 0; i < this._attributes.length; i++) {
      const attribute = this._attributes[i];
      if (attrLocs[i] == -1) {
        if (attribute._attrLocationLastShaderTime != shader.lastCompile) {
          attribute._attrLocationLastShaderTime = shader.lastCompile;
          attrLocs[i] = this._cgl.glGetAttribLocation(shader.getProgram(), attribute.name);
          this._cgl.profileData.profileAttrLoc++;
        }
      }
      if (attrLocs[i] != -1) {
        this._cgl.gl.enableVertexAttribArray(attrLocs[i]);
        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attribute.buffer);
        if (attribute.instanced) {
          if (attribute.itemSize <= 4) {
            if (!attribute.itemSize || attribute.itemSize == 0)
              this._log.warn("instanced attrib itemsize error", this._geom.name, attribute);
            this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
          } else if (attribute.itemSize == 16) {
            const stride = 16 * 4;
            this._cgl.gl.vertexAttribPointer(attrLocs[i], 4, attribute.type, false, stride, 0);
            this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);
            this._cgl.gl.vertexAttribPointer(attrLocs[i] + 1, 4, attribute.type, false, stride, 4 * 4 * 1);
            this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);
            this._cgl.gl.vertexAttribPointer(attrLocs[i] + 2, 4, attribute.type, false, stride, 4 * 4 * 2);
            this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);
            this._cgl.gl.vertexAttribPointer(attrLocs[i] + 3, 4, attribute.type, false, stride, 4 * 4 * 3);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);
          } else {
            this._log.warn("unknown instance attrib size", attribute.name);
          }
        } else {
          if (!attribute.itemSize || attribute.itemSize == 0)
            this._log.warn("attrib itemsize error", this._name, attribute);
          this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);
          if (attribute.pointer) {
            for (let ip = 0; ip < attribute.pointer.length; ip++) {
              const pointer = attribute.pointer[ip];
              if (pointer.loc == -1)
                pointer.loc = this._cgl.glGetAttribLocation(shader.getProgram(), pointer.name);
              this._cgl.profileData.profileAttrLoc++;
              this._cgl.gl.enableVertexAttribArray(pointer.loc);
              this._cgl.gl.vertexAttribPointer(pointer.loc, attribute.itemSize, attribute.type, false, pointer.stride, pointer.offset);
            }
          }
          this.bindFeedback(attribute);
        }
      }
    }
    if (this._bufVerticesIndizes && this._bufVerticesIndizes.numItems !== 0)
      this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);
  };
  Mesh.prototype.unBind = function() {
    const shader = this._lastShader;
    this._lastShader = null;
    if (!shader)
      return;
    let attrLocs = [];
    if (this._attribLocs[shader.id])
      attrLocs = this._attribLocs[shader.id];
    else
      this._attribLocs[shader.id] = attrLocs;
    MESH.lastMesh = null;
    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].instanced) {
        if (this._attributes[i].itemSize <= 4) {
          if (attrLocs[i] != -1)
            this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
          if (attrLocs[i] >= 0)
            this._cgl.gl.disableVertexAttribArray(attrLocs[i]);
        } else {
          this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
          this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);
          this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);
          this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);
          this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);
          this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);
          this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);
        }
      }
      if (attrLocs[i] != -1)
        this._cgl.gl.disableVertexAttribArray(attrLocs[i]);
    }
  };
  Mesh.prototype.meshChanged = function() {
    return this._cgl.lastMesh && this._cgl.lastMesh != this;
  };
  Mesh.prototype.printDebug = function(shader) {
    console.log("--attributes");
    for (let i = 0; i < this._attributes.length; i++) {
      console.log("attribute " + i + " " + this._attributes[i].name);
    }
  };
  Mesh.prototype.setNumVertices = function(num) {
    this._bufVertexAttrib.numItems = num;
  };
  Mesh.prototype.getNumVertices = function() {
    return this._bufVertexAttrib.numItems;
  };
  Mesh.prototype.render = function(shader) {
    if (!shader || !shader.isValid() || this._cgl.aborted)
      return;
    this._checkAttrLengths();
    if (this._geom) {
      if (this._preWireframeGeom && !shader.wireframe && !this._geom.isIndexed()) {
        this.setGeom(this._preWireframeGeom);
        this._preWireframeGeom = null;
      }
      if (shader.wireframe) {
        let changed = false;
        if (this._geom.isIndexed()) {
          if (!this._preWireframeGeom) {
            this._preWireframeGeom = this._geom;
            this._geom = this._geom.copy();
          }
          this._geom.unIndex();
          changed = true;
        }
        if (!this._geom.getAttribute("attrBarycentric")) {
          if (!this._preWireframeGeom) {
            this._preWireframeGeom = this._geom;
            this._geom = this._geom.copy();
          }
          changed = true;
          this._geom.calcBarycentric();
        }
        if (changed)
          this.setGeom(this._geom);
      }
    }
    let needsBind = false;
    if (MESH.lastMesh != this) {
      if (MESH.lastMesh)
        MESH.lastMesh.unBind();
      needsBind = true;
    }
    if (needsBind)
      this._preBind(shader);
    if (!shader.bind())
      return;
    this._bind(shader);
    if (this.addVertexNumbers)
      this._setVertexNumbers();
    MESH.lastMesh = this;
    let prim = this._cgl.gl.TRIANGLES;
    if (this._glPrimitive !== void 0)
      prim = this._glPrimitive;
    if (shader.glPrimitive !== null)
      prim = shader.glPrimitive;
    let elementDiv = 1;
    let doQuery = this._cgl.profileData.doProfileGlQuery;
    let queryStarted = false;
    if (doQuery) {
      let id = this._name + " - " + shader.getName() + " #" + shader.id;
      if (this._numInstances)
        id += " instanced " + this._numInstances + "x";
      let queryProfilerData = this._cgl.profileData.glQueryData[id];
      if (!queryProfilerData)
        queryProfilerData = { "id": id, "num": 0 };
      if (shader.opId)
        queryProfilerData.shaderOp = shader.opId;
      if (this.opId)
        queryProfilerData.meshOp = this.opId;
      this._cgl.profileData.glQueryData[id] = queryProfilerData;
      if (!this._queryExt && this._queryExt !== false)
        this._queryExt = this._cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || false;
      if (this._queryExt) {
        if (queryProfilerData._drawQuery) {
          const available = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT_AVAILABLE);
          if (available) {
            const elapsedNanos = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT);
            const currentTimeGPU = elapsedNanos / 1e6;
            queryProfilerData._times = queryProfilerData._times || 0;
            queryProfilerData._times += currentTimeGPU;
            queryProfilerData._numcount++;
            queryProfilerData.when = performance.now();
            queryProfilerData._drawQuery = null;
            queryProfilerData.queryStarted = false;
          }
        }
        if (!queryProfilerData.queryStarted) {
          queryProfilerData._drawQuery = this._cgl.gl.createQuery();
          this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, queryProfilerData._drawQuery);
          queryStarted = queryProfilerData.queryStarted = true;
        }
      }
    }
    if (this.hasFeedbacks()) {
      this.drawFeedbacks(shader, prim);
    } else if (!this._bufVerticesIndizes || this._bufVerticesIndizes.numItems === 0) {
      if (prim == this._cgl.gl.TRIANGLES)
        elementDiv = 3;
      if (this._numInstances === 0)
        this._cgl.gl.drawArrays(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem);
      else
        this._cgl.gl.drawArraysInstanced(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances);
    } else {
      if (prim == this._cgl.gl.TRIANGLES)
        elementDiv = 3;
      if (this._numInstances === 0) {
        this._cgl.gl.drawElements(prim, this._bufVerticesIndizes.numItems, this._indexType, 0);
      } else {
        this._cgl.gl.drawElementsInstanced(prim, this._bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances);
      }
    }
    if (this._cgl.debugOneFrame && this._cgl.gl.getError() != this._cgl.gl.NO_ERROR) {
      this._log.error("mesh draw gl error");
      this._log.error("mesh", this);
      this._log.error("shader", shader);
      const attribNames = [];
      for (let i = 0; i < this._cgl.gl.getProgramParameter(shader.getProgram(), this._cgl.gl.ACTIVE_ATTRIBUTES); i++) {
        const name2 = this._cgl.gl.getActiveAttrib(shader.getProgram(), i).name;
        this._log.error("attrib ", name2);
      }
    }
    this._cgl.profileData.profileMeshNumElements += this._bufVertexAttrib.numItems / elementDiv * (this._numInstances || 1);
    this._cgl.profileData.profileMeshDraw++;
    if (doQuery && queryStarted) {
      this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);
    }
    this._cgl.printError("mesh render " + this._name);
    this.unBind();
  };
  Mesh.prototype.setNumInstances = function(n) {
    n = Math.max(0, n);
    if (this._numInstances != n) {
      this._numInstances = n;
      const indexArr = new Float32Array(n);
      for (let i = 0; i < n; i++)
        indexArr[i] = i;
      this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_INDEX, indexArr, 1, { "instanced": true });
    }
  };
  Mesh.prototype._disposeAttributes = function() {
    if (!this._attributes)
      return;
    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].buffer) {
        this._cgl.gl.deleteBuffer(this._attributes[i].buffer);
        this._attributes[i].buffer = null;
      }
    }
    this._attributes.length = 0;
  };
  Mesh.prototype.dispose = function() {
    if (this._bufVertexAttrib && this._bufVertexAttrib.buffer)
      this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);
    if (this._bufVerticesIndizes)
      this._cgl.gl.deleteBuffer(this._bufVerticesIndizes);
    this._bufVerticesIndizes = null;
    this._disposeAttributes();
  };
  extendMeshWithFeedback(Mesh);
  ;
  const MESHES = {};
  MESHES.getSimpleRect = function(cgl, name2) {
    const geom = new Geometry(name2);
    geom.vertices = [1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0];
    geom.texCoords = [1, 1, 0, 1, 1, 0, 0, 0];
    geom.verticesIndices = [0, 1, 2, 2, 1, 3];
    geom.vertexNormals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    return new Mesh(cgl, geom);
  };
  MESHES.getSimpleCube = function(cgl, name2) {
    const geom = new Geometry(name2);
    geom.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1];
    geom.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0]);
    geom.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    geom.vertexNormals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
    geom.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
    geom.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);
    return new Mesh(cgl, geom);
  };
  ;
  const TextureEffect = function(cgl, options) {
    this._cgl = cgl;
    this._log = new Logger("cgl_TextureEffect");
    if (!cgl.TextureEffectMesh)
      this.createMesh();
    this._textureSource = null;
    this._options = options;
    this.name = options.name || "unknown";
    this.imgCompVer = 0;
    this.aspectRatio = 1;
    this._textureTarget = null;
    this._frameBuf = this._cgl.gl.createFramebuffer();
    this._frameBuf2 = this._cgl.gl.createFramebuffer();
    this._renderbuffer = this._cgl.gl.createRenderbuffer();
    this._renderbuffer2 = this._cgl.gl.createRenderbuffer();
    this.switched = false;
    this.depth = false;
  };
  TextureEffect.prototype.dispose = function() {
    if (this._renderbuffer)
      this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
    if (this._frameBuf)
      this._cgl.gl.deleteFramebuffer(this._frameBuf);
    if (this._renderbuffer2)
      this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);
    if (this._frameBuf2)
      this._cgl.gl.deleteFramebuffer(this._frameBuf2);
  };
  TextureEffect.prototype.getWidth = function() {
    return this._textureSource.width;
  };
  TextureEffect.prototype.getHeight = function() {
    return this._textureSource.height;
  };
  TextureEffect.prototype.setSourceTexture = function(tex) {
    if (tex === null) {
      this._textureSource = new Texture(this._cgl);
      this._textureSource.setSize(16, 16);
    } else {
      this._textureSource = tex;
    }
    if (!this._textureSource.compareSettings(this._textureTarget)) {
      if (this._textureTarget)
        this._textureTarget.delete();
      this._textureTarget = this._textureSource.clone();
      this._cgl.profileData.profileEffectBuffercreate++;
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer);
      if (this.depth)
        this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
      this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);
      if (this.depth)
        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer);
      this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer2);
      if (this.depth)
        this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
      this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);
      if (this.depth)
        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer2);
      this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    }
    this.aspectRatio = this._textureSource.width / this._textureSource.height;
  };
  TextureEffect.prototype.continueEffect = function() {
    this._cgl.pushDepthTest(false);
    this._cgl.pushModelMatrix();
    this._cgl.pushPMatrix();
    this._cgl.pushViewPort(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height);
    mat4.perspective(this._cgl.pMatrix, 45, this.getCurrentTargetTexture().width / this.getCurrentTargetTexture().height, 0.1, 1100);
    this._cgl.pushPMatrix();
    mat4.identity(this._cgl.pMatrix);
    this._cgl.pushViewMatrix();
    mat4.identity(this._cgl.vMatrix);
    this._cgl.pushModelMatrix();
    mat4.identity(this._cgl.mMatrix);
  };
  TextureEffect.prototype.startEffect = function(bgTex) {
    if (!this._textureTarget) {
      this._log.warn("effect has no target");
      return;
    }
    this.switched = false;
    this.continueEffect();
    if (bgTex) {
      this._bgTex = bgTex;
    }
    this._countEffects = 0;
  };
  TextureEffect.prototype.endEffect = function() {
    this._cgl.popDepthTest();
    this._cgl.popModelMatrix();
    this._cgl.popPMatrix();
    this._cgl.popModelMatrix();
    this._cgl.popViewMatrix();
    this._cgl.popPMatrix();
    this._cgl.popViewPort();
  };
  TextureEffect.prototype.bind = function() {
    if (this._textureSource === null) {
      this._log.warn("no base texture set!");
      return;
    }
    if (!this.switched) {
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);
      this._cgl.pushGlFrameBuffer(this._frameBuf);
    } else {
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);
      this._cgl.pushGlFrameBuffer(this._frameBuf2);
    }
  };
  TextureEffect.prototype.finish = function() {
    if (this._textureSource === null) {
      this._log.warn("no base texture set!");
      return;
    }
    this._cgl.TextureEffectMesh.render(this._cgl.getShader());
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());
    this._cgl.profileData.profileTextureEffect++;
    if (this._textureTarget.filter == Texture.FILTER_MIPMAP) {
      if (!this.switched) {
        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureTarget.tex);
        this._textureTarget.updateMipMap();
      } else {
        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureSource.tex);
        this._textureSource.updateMipMap();
      }
      this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
    }
    this.switched = !this.switched;
    this._countEffects++;
  };
  TextureEffect.prototype.getCurrentTargetTexture = function() {
    if (this.switched)
      return this._textureSource;
    return this._textureTarget;
  };
  TextureEffect.prototype.getCurrentSourceTexture = function() {
    if (this._countEffects == 0 && this._bgTex)
      return this._bgTex;
    if (this.switched)
      return this._textureTarget;
    return this._textureSource;
  };
  TextureEffect.prototype.delete = function() {
    if (this._textureTarget)
      this._textureTarget.delete();
    if (this._textureSource)
      this._textureSource.delete();
    this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
    this._cgl.gl.deleteFramebuffer(this._frameBuf);
  };
  TextureEffect.prototype.createMesh = function() {
    this._cgl.TextureEffectMesh = MESHES.getSimpleRect(this._cgl, "texEffectRect");
  };
  TextureEffect.checkOpNotInTextureEffect = function(op) {
    if (!op.patch.cgl)
      return true;
    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect) {
      op.setUiError("textureeffect", null);
      return true;
    }
    if (!op.patch.cgl.currentTextureEffect)
      return true;
    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error) {
      op.setUiError("textureeffect", "This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.", 0);
      return false;
    }
    if (op.patch.cgl.currentTextureEffect)
      return false;
    return true;
  };
  TextureEffect.checkOpInEffect = function(op, minver) {
    minver = minver || 0;
    if (op.patch.cgl.currentTextureEffect) {
      if (op.uiAttribs.uierrors && op.patch.cgl.currentTextureEffect.imgCompVer >= minver) {
        op.setUiError("texeffect", null);
        return true;
      }
      if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver) {
        op.setUiError("texeffect", "This op must be a child of an ImageCompose op with version >=" + minver + ` <span class="button-small" onclick="gui.patchView.downGradeOp('` + op.id + "','" + op.name + `')">Downgrade</span> to previous version`, 1);
      }
    }
    if (op.patch.cgl.currentTextureEffect)
      return true;
    if (!op.patch.cgl.currentTextureEffect && (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0)) {
      op.setUiError("texeffect", 'This op must be a child of an ImageCompose op! More infos <a href="https://docs.cables.gl/image_composition/image_composition.html" target="_blank">here</a>. ', 1);
      return false;
    }
    if (!op.patch.cgl.currentTextureEffect)
      return false;
    return true;
  };
  TextureEffect.getBlendCode = function(ver) {
    let src = "".endl() + "vec3 _blend(vec3 base,vec3 blend)".endl() + "{".endl() + "   vec3 colNew=blend;".endl() + "   #ifdef BM_MULTIPLY".endl() + "       colNew=base*blend;".endl() + "   #endif".endl() + "   #ifdef BM_MULTIPLY_INV".endl() + "       colNew=base* vec3(1.0)-blend;".endl() + "   #endif".endl() + "   #ifdef BM_AVERAGE".endl() + "       colNew=((base + blend) / 2.0);".endl() + "   #endif".endl() + "   #ifdef BM_ADD".endl() + "       colNew=min(base + blend, vec3(1.0));".endl() + "   #endif".endl() + "   #ifdef BM_SUBTRACT_ONE".endl() + "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl() + "   #endif".endl() + "   #ifdef BM_SUBTRACT".endl() + "       colNew=base - blend;".endl() + "   #endif".endl() + "   #ifdef BM_DIFFERENCE".endl() + "       colNew=abs(base - blend);".endl() + "   #endif".endl() + "   #ifdef BM_NEGATION".endl() + "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl() + "   #endif".endl() + "   #ifdef BM_EXCLUSION".endl() + "       colNew=(base + blend - 2.0 * base * blend);".endl() + "   #endif".endl() + "   #ifdef BM_LIGHTEN".endl() + "       colNew=max(blend, base);".endl() + "   #endif".endl() + "   #ifdef BM_DARKEN".endl() + "       colNew=min(blend, base);".endl() + "   #endif".endl() + "   #ifdef BM_OVERLAY".endl() + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))".endl() + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_SCREEN".endl() + "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))".endl() + "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_SOFTLIGHT".endl() + "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))".endl() + "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_HARDLIGHT".endl() + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))".endl() + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_COLORDODGE".endl() + "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))".endl() + "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_COLORBURN".endl() + "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))".endl() + "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl() + "   #endif".endl() + "   return colNew;".endl() + "}".endl();
    if (!ver)
      src += "vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)".endl() + "{".endl() + "vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);".endl() + "col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);".endl() + "return col;".endl() + "}".endl();
    if (ver >= 3)
      src += "vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)".endl() + "{".endl() + "#ifdef BM_MATH_ADD".endl() + "   return vec4(base.rgb+col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifdef BM_MATH_SUB".endl() + "   return vec4(base.rgb-col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifdef BM_MATH_MUL".endl() + "   return vec4(base.rgb*col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifdef BM_MATH_DIV".endl() + "   return vec4(base.rgb/col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifndef BM_MATH".endl() + "vec3 colNew=_blend(base.rgb,col.rgb);".endl() + "float newA=clamp(base.a+(col.a*amount),0.,1.);".endl() + "#ifdef BM_ALPHAMASKED".endl() + "newA=base.a;".endl() + "#endif".endl() + "return vec4(".endl() + "mix(colNew,base.rgb,1.0-(amount*col.a)),".endl() + "newA);".endl() + "#endif".endl() + "}".endl();
    return src;
  };
  TextureEffect.onChangeBlendSelect = function(shader, blendName, maskAlpha = false) {
    blendName = String(blendName);
    shader.toggleDefine("BM_NORMAL", blendName == "normal");
    shader.toggleDefine("BM_MULTIPLY", blendName == "multiply");
    shader.toggleDefine("BM_MULTIPLY_INV", blendName == "multiply invert");
    shader.toggleDefine("BM_AVERAGE", blendName == "average");
    shader.toggleDefine("BM_ADD", blendName == "add");
    shader.toggleDefine("BM_SUBTRACT_ONE", blendName == "subtract one");
    shader.toggleDefine("BM_SUBTRACT", blendName == "subtract");
    shader.toggleDefine("BM_DIFFERENCE", blendName == "difference");
    shader.toggleDefine("BM_NEGATION", blendName == "negation");
    shader.toggleDefine("BM_EXCLUSION", blendName == "exclusion");
    shader.toggleDefine("BM_LIGHTEN", blendName == "lighten");
    shader.toggleDefine("BM_DARKEN", blendName == "darken");
    shader.toggleDefine("BM_OVERLAY", blendName == "overlay");
    shader.toggleDefine("BM_SCREEN", blendName == "screen");
    shader.toggleDefine("BM_SOFTLIGHT", blendName == "softlight");
    shader.toggleDefine("BM_HARDLIGHT", blendName == "hardlight");
    shader.toggleDefine("BM_COLORDODGE", blendName == "color dodge");
    shader.toggleDefine("BM_COLORBURN", blendName == "color burn");
    shader.toggleDefine("BM_MATH_ADD", blendName == "Math Add");
    shader.toggleDefine("BM_MATH_SUB", blendName == "Math Subtract");
    shader.toggleDefine("BM_MATH_MUL", blendName == "Math Multiply");
    shader.toggleDefine("BM_MATH_DIV", blendName == "Math Divide");
    shader.toggleDefine("BM_MATH", blendName.indexOf("Math ") == 0);
    shader.toggleDefine("BM_ALPHAMASKED", maskAlpha);
  };
  TextureEffect.AddBlendSelect = function(op, name2, defaultMode) {
    const p = op.inValueSelect(name2 || "Blend Mode", [
      "normal",
      "lighten",
      "darken",
      "multiply",
      "multiply invert",
      "average",
      "add",
      "subtract",
      "difference",
      "negation",
      "exclusion",
      "overlay",
      "screen",
      "color dodge",
      "color burn",
      "softlight",
      "hardlight",
      "subtract one",
      "Math Add",
      "Math Subtract",
      "Math Multiply",
      "Math Divide"
    ], defaultMode || "normal");
    return p;
  };
  TextureEffect.AddBlendAlphaMask = function(op, name2, defaultMode) {
    const p = op.inSwitch(name2 || "Alpha Mask", ["Off", "On"], defaultMode || "Off");
    return p;
  };
  TextureEffect.setupBlending = function(op, shader, blendPort, amountPort, alphaMaskPort) {
    const onChange = () => {
      let maskAlpha2 = false;
      if (alphaMaskPort)
        maskAlpha2 = alphaMaskPort.get() == "On";
      TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha2);
      let str = blendPort.get();
      if (str == "normal")
        str = null;
      else if (str == "multiply")
        str = "mul";
      else if (str == "multiply invert")
        str = "mulinv";
      else if (str == "lighten")
        str = "light";
      else if (str == "darken")
        str = "darken";
      else if (str == "average")
        str = "avg";
      else if (str == "subtract one")
        str = "sub one";
      else if (str == "subtract")
        str = "sub";
      else if (str == "difference")
        str = "diff";
      else if (str == "negation")
        str = "neg";
      else if (str == "exclusion")
        str = "exc";
      else if (str == "overlay")
        str = "ovl";
      else if (str == "color dodge")
        str = "dodge";
      else if (str == "color burn")
        str = "burn";
      else if (str == "softlight")
        str = "soft";
      else if (str == "hardlight")
        str = "hard";
      else if (str == "Math Add")
        str = "+";
      else if (str == "Math Subtract")
        str = "-";
      else if (str == "Math Multiply")
        str = "*";
      else if (str == "Math Divide")
        str = "/";
      op.setUiAttrib({ "extendTitle": str });
    };
    op.setPortGroup("Blending", [blendPort, amountPort, alphaMaskPort]);
    let maskAlpha = false;
    blendPort.onChange = onChange;
    if (alphaMaskPort) {
      alphaMaskPort.onChange = onChange;
      maskAlpha = alphaMaskPort.get() == "On";
    }
    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);
  };
  ;
  const ShaderLibMods = {
    "CGL.BLENDMODES": function() {
      this.name = "blendmodes";
      this.srcHeadFrag = TextureEffect.getBlendCode();
    },
    "CGL.BLENDMODES3": function() {
      this.name = "blendmodes3";
      this.srcHeadFrag = TextureEffect.getBlendCode(3);
    },
    "CGL.LUMINANCE": function() {
      this.name = "luminance";
      this.srcHeadFrag = "".endl() + "float cgl_luminance(vec3 c)".endl() + "{".endl() + "    return dot(vec3(0.2126,0.7152,0.0722),c);".endl() + "}".endl();
    },
    // quite good random numbers, but somehow don't work in ANGLE
    "CGL.RANDOM_OLD": function() {
      this.name = "randomNumber";
      this.srcHeadFrag = "".endl() + "float cgl_random(vec2 co)".endl() + "{".endl() + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);".endl() + "}".endl() + "vec3 cgl_random3(vec2 co)".endl() + "{".endl() + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() + "}";
    },
    // low quality generative ranodm numbers
    "CGL.RANDOM_LOW": function() {
      this.name = "randomNumber";
      this.srcHeadFrag = "".endl() + "float cgl_random(vec2 co)".endl() + "{".endl() + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);".endl() + "}".endl() + "vec3 cgl_random3(vec2 co)".endl() + "{".endl() + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() + "}";
    },
    // texture based random numbers
    "CGL.RANDOM_TEX": function() {
      this.name = "randomNumbertex";
      this.srcHeadFrag = "".endl() + "UNI sampler2D CGLRNDTEX;".endl() + "float cgl_random(vec2 co)".endl() + "{".endl() + "    return texture(CGLRNDTEX,co*5711.0).r;".endl() + "}".endl() + "vec3 cgl_random3(vec2 co)".endl() + "{".endl() + "    return texture(CGLRNDTEX,co*5711.0).rgb;".endl() + "}";
      this.initUniforms = function(shader) {
        return [new Uniform(shader, "t", "CGLRNDTEX", 7)];
      };
      this.onBind = function(cgl, shader) {
        Texture.getRandomTexture(cgl);
        cgl.setTexture(7, Texture.getRandomTexture(cgl).tex);
      };
    }
  };
  ;
  const cgl_utils_DEG2RAD = Math.PI / 180;
  const cgl_utils_RAD2DEG = 180 / Math.PI;
  const onLoadingAssetsFinished = null;
  const isWindows = window.navigator.userAgent.contains("Windows");
  const getWheelDelta_ = function(event2) {
    let normalized;
    if (event2.wheelDelta) {
      normalized = event2.wheelDelta % 120 - 0 == -0 ? event2.wheelDelta / 120 : event2.wheelDelta / 30;
      normalized *= -1.5;
      if (isWindows)
        normalized *= 2;
    } else {
      let d = event2.deltaY;
      if (event2.shiftKey)
        d = event2.deltaX;
      const rawAmmount = d || event2.detail;
      normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);
      normalized *= -3;
    }
    if (normalized > 20)
      normalized = 20;
    if (normalized < -20)
      normalized = -20;
    return normalized;
  };
  const getWheelSpeed = getWheelDelta_;
  const getWheelDelta = getWheelDelta_;
  const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  const reUnescapedHtml = /[&<>"']/g;
  const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  const escapeHTML = function(string) {
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, function(chr) {
      return htmlEscapes[chr];
    }) : string || "";
  };
  const cgl_shader_default_glsl = "{{MODULES_HEAD}}\nIN vec3 vPosition; //!@\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent,attrBiTangent;\n\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    vec3 tangent=attrTangent;\n    vec3 bitangent=attrBiTangent;\n    mat4 mMatrix=modelMatrix;\n    gl_PointSize=10.0;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 modelViewMatrix=viewMatrix*mMatrix;\n    {{MODULE_VERTEX_MOVELVIEW}}\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n}\n";
  ;
  let materialIdCounter = 0;
  const Shader = function(_cgl, _name, _op) {
    if (!_cgl)
      throw new Error("shader constructed without cgl " + _name);
    this._log = new Logger("cgl_shader");
    this._cgl = _cgl;
    if (!_name)
      this._log.stack("no shader name given");
    this._name = _name || "unknown";
    if (_op)
      this.opId = _op.id;
    this.glslVersion = 0;
    if (_cgl.glVersion > 1)
      this.glslVersion = 300;
    this._materialId = ++materialIdCounter;
    this.id = simpleId();
    this._isValid = true;
    this._program = null;
    this._uniforms = [];
    this._drawBuffers = [true];
    this._defines = [];
    this._needsRecompile = true;
    this._compileReason = "initial";
    this.ignoreMissingUniforms = false;
    this._projMatrixUniform = null;
    this._mvMatrixUniform = null;
    this._mMatrixUniform = null;
    this._vMatrixUniform = null;
    this._camPosUniform = null;
    this._normalMatrixUniform = null;
    this._inverseViewMatrixUniform = null;
    this._fromUserInteraction = false;
    this._attrVertexPos = -1;
    this.precision = _cgl.patch.config.glslPrecision || "highp";
    this._pMatrixState = -1;
    this._vMatrixState = -1;
    this._countMissingUniforms = 0;
    this._modGroupCount = 0;
    this._feedBackNames = [];
    this._attributes = [];
    this.glPrimitive = null;
    this.offScreenPass = false;
    this._extensions = [];
    this.srcVert = this.getDefaultVertexShader();
    this.srcFrag = this.getDefaultFragmentShader();
    this.lastCompile = 0;
    this._moduleNames = [];
    this._modules = [];
    this._moduleNumId = 0;
    this._libs = [];
    this._structNames = [];
    this._structUniformNames = [];
    this._textureStackUni = [];
    this._textureStackTex = [];
    this._textureStackType = [];
    this._textureStackTexCgl = [];
    this._tempNormalMatrix = mat4.create();
    this._tempCamPosMatrix = mat4.create();
    this._tempInverseViewMatrix = mat4.create();
    this._tempInverseProjMatrix = mat4.create();
    this.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MOVELVIEW"]);
  };
  Shader.prototype.isValid = function() {
    return this._isValid;
  };
  Shader.prototype.getCgl = function() {
    return this._cgl;
  };
  Shader.prototype.getName = function() {
    return this._name;
  };
  Shader.prototype.enableExtension = function(name2) {
    this.setWhyCompile("enable extension " + name2);
    this._needsRecompile = true;
    this._extensions.push(name2);
  };
  Shader.prototype.getAttrVertexPos = function() {
    return this._attrVertexPos;
  };
  Shader.prototype.hasTextureUniforms = function() {
    for (let i = 0; i < this._uniforms.length; i++)
      if (this._uniforms[i].getType() == "t")
        return true;
    return false;
  };
  Shader.prototype.setWhyCompile = function(why) {
    this._compileReason = why;
  };
  Shader.prototype.copyUniformValues = function(origShader) {
    for (let i = 0; i < origShader._uniforms.length; i++) {
      if (!this._uniforms[i]) {
        this._log.log("unknown uniform?!");
        continue;
      }
      this.getUniform(origShader._uniforms[i].getName()).set(origShader._uniforms[i].getValue());
    }
    this.popTextures();
    for (let i = 0; i < origShader._textureStackUni.length; i++) {
      this._textureStackUni[i] = origShader._textureStackUni[i];
      this._textureStackTex[i] = origShader._textureStackTex[i];
      this._textureStackType[i] = origShader._textureStackType[i];
      this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
    }
  };
  Shader.prototype.copy = function() {
    const shader = new Shader(this._cgl, this._name + " copy");
    shader.setSource(this.srcVert, this.srcFrag);
    shader._modules = JSON.parse(JSON.stringify(this._modules));
    shader._defines = JSON.parse(JSON.stringify(this._defines));
    shader._modGroupCount = this._modGroupCount;
    shader._moduleNames = this._moduleNames;
    shader.glPrimitive = this.glPrimitive;
    shader.offScreenPass = this.offScreenPass;
    shader._extensions = this._extensions;
    shader.wireframe = this.wireframe;
    shader._attributes = this._attributes;
    for (let i = 0; i < this._uniforms.length; i++) {
      const u = this._uniforms[i].copy(shader);
      u.resetLoc();
    }
    this.setWhyCompile("copy");
    shader._needsRecompile = true;
    return shader;
  };
  Shader.prototype.setSource = function(srcVert, srcFrag, fromUserInteraction) {
    this._fromUserInteraction = fromUserInteraction;
    this.srcVert = srcVert;
    this.srcFrag = srcFrag;
    this.setWhyCompile("Source changed");
    this._needsRecompile = true;
    this._isValid = true;
  };
  Shader.prototype._addLibs = function(src) {
    for (const id in ShaderLibMods) {
      if (src.contains(id)) {
        const lib = new ShaderLibMods[id]();
        src = src.replace("{{" + id + "}}", lib.srcHeadFrag);
        this._libs.push(lib);
        if (lib.initUniforms)
          lib.initUniforms(this);
      }
    }
    return src;
  };
  Shader.prototype.createStructUniforms = function() {
    let structStrFrag = "";
    let structStrVert = "";
    this._structNames = [];
    this._injectedStringsFrag = {};
    this._injectedStringsVert = {};
    this._structUniformNamesIndicesFrag = [];
    this._structUniformNamesIndicesVert = [];
    for (let i = 0; i < this._uniforms.length; i++) {
      if (this._uniforms[i].isStructMember()) {
        const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";
        if (!this._structNames.includes(this._uniforms[i]._structName)) {
          const structDefinition = "struct " + this._uniforms[i]._structName + " {".endl() + injectionString + "};".endl().endl();
          if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "frag")
            structStrFrag = structStrFrag.concat(structDefinition);
          if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "vert")
            structStrVert = structStrVert.concat(structDefinition);
          this._structNames.push(this._uniforms[i]._structName);
          this._injectedStringsFrag[this._uniforms[i]._structName] = [];
          this._injectedStringsVert[this._uniforms[i]._structName] = [];
        }
        let comment = "";
        if (this._uniforms[i].comment)
          comment = " // " + this._uniforms[i].comment;
        let stringToInsert = "";
        if (this._uniforms[i].getGlslTypeString() == void 0)
          stringToInsert += "//";
        stringToInsert += "  " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i]._propertyName + ";" + comment;
        if (this._uniforms[i].getShaderType() === "both") {
          if (!this._injectedStringsFrag[this._uniforms[i]._structName].contains(stringToInsert) && !this._injectedStringsVert[this._uniforms[i]._structName].contains(stringToInsert)) {
            const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);
            const insertionIndexVert = structStrVert.lastIndexOf(injectionString);
            structStrFrag = structStrFrag.slice(0, insertionIndexFrag) + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);
            structStrVert = structStrVert.slice(0, insertionIndexVert) + stringToInsert + structStrVert.slice(insertionIndexVert - 1);
            this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
            this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
          }
          if (!this._structUniformNamesIndicesFrag.includes(i))
            this._structUniformNamesIndicesFrag.push(i);
          if (!this._structUniformNamesIndicesVert.includes(i))
            this._structUniformNamesIndicesVert.push(i);
        } else if (this._uniforms[i].getShaderType() === "frag") {
          if (!this._injectedStringsFrag[this._uniforms[i]._structName].includes(stringToInsert)) {
            const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);
            structStrFrag = structStrFrag.slice(0, insertionIndexFrag) + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);
            this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
          }
          if (!this._structUniformNamesIndicesFrag.includes(i))
            this._structUniformNamesIndicesFrag.push(i);
        } else if (this._uniforms[i].getShaderType() === "vert") {
          if (!this._injectedStringsVert[this._uniforms[i]._structName].includes(stringToInsert)) {
            const insertionIndexVert = structStrVert.lastIndexOf(injectionString);
            structStrVert = structStrVert.slice(0, insertionIndexVert) + stringToInsert + structStrVert.slice(insertionIndexVert - 1);
            this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
          }
          if (!this._structUniformNamesIndicesVert.includes(i))
            this._structUniformNamesIndicesVert.push(i);
        }
      }
    }
    this._uniDeclarationsFrag = [];
    this._uniDeclarationsVert = [];
    for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1) {
      const index = this._structUniformNamesIndicesFrag[i];
      const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";".endl();
      if (!this._uniDeclarationsFrag.includes(uniDeclarationString)) {
        const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";
        structStrFrag = structStrFrag.replace(injectionString, "");
        structStrFrag += uniDeclarationString;
        this._uniDeclarationsFrag.push(uniDeclarationString);
      }
    }
    for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1) {
      const index = this._structUniformNamesIndicesVert[i];
      const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";".endl();
      if (!this._uniDeclarationsVert.includes(uniDeclarationString)) {
        const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";
        structStrVert = structStrVert.replace(injectionString, "");
        structStrVert += uniDeclarationString;
        this._uniDeclarationsVert.push(uniDeclarationString);
      }
    }
    return [structStrVert, structStrFrag];
  };
  Shader.prototype._getAttrSrc = function(attr, firstLevel) {
    const r = {};
    if (attr.name && attr.type) {
      r.srcHeadVert = "";
      if (!firstLevel)
        r.srcHeadVert += "#ifndef ATTRIB_" + attr.name.endl();
      r.srcHeadVert += "#define ATTRIB_" + attr.name.endl();
      r.srcHeadVert += "IN " + attr.type + " " + attr.name + ";".endl();
      if (!firstLevel)
        r.srcHeadVert += "#endif".endl();
      if (attr.nameFrag) {
        r.srcHeadVert += "";
        if (!firstLevel)
          r.srcHeadVert += "#ifndef ATTRIB_" + attr.nameFrag.endl();
        r.srcHeadVert += "#define ATTRIB_" + attr.nameFrag.endl();
        r.srcHeadVert += "OUT " + attr.type + " " + attr.nameFrag + ";".endl();
        if (!firstLevel)
          r.srcHeadVert += "#endif".endl();
        r.srcVert = "".endl() + attr.nameFrag + "=" + attr.name + ";";
        r.srcHeadFrag = "";
        if (!firstLevel)
          r.srcHeadFrag += "#ifndef ATTRIB_" + attr.nameFrag.endl();
        r.srcHeadFrag += "#define ATTRIB_" + attr.nameFrag.endl();
        r.srcHeadFrag += "IN " + attr.type + " " + attr.nameFrag + ";".endl();
        if (!firstLevel)
          r.srcHeadFrag += "#endif".endl();
      }
    }
    return r;
  };
  Shader.prototype.compile = function() {
    if (this._cgl.aborted)
      return;
    const startTime = performance.now();
    this._cgl.profileData.profileShaderCompiles++;
    this._cgl.profileData.profileShaderCompileName = this._name + " [" + this._compileReason + "]";
    let extensionString = "";
    if (this._extensions)
      for (let i = 0; i < this._extensions.length; i++)
        extensionString += "#extension " + this._extensions[i] + " : enable".endl();
    let definesStr = "";
    if (this._defines.length)
      definesStr = "\n// cgl generated".endl();
    for (let i = 0; i < this._defines.length; i++)
      definesStr += "#define " + this._defines[i][0] + " " + this._defines[i][1] + "".endl();
    const structStrings = this.createStructUniforms();
    this._cgl.profileData.addHeavyEvent("shader compile", this._name + " [" + this._compileReason + "]");
    this._compileReason = "";
    if (this._uniforms) {
      const uniNames = this._uniforms.map((uni) => {
        return uni._name;
      });
      const indicesToRemove = [];
      for (let i = 0; i < this._uniforms.length; i++) {
        const uni = this._uniforms[i];
        const nextIndex = uniNames.indexOf(uni._name, i + 1);
        if (nextIndex > -1)
          indicesToRemove.push(i);
      }
      for (let j = this._uniforms.length - 1; j >= 0; j -= 1) {
        if (indicesToRemove.includes(j))
          this._uniforms.splice(j, 1);
        else
          this._uniforms[j].resetLoc();
      }
    }
    this._cgl.printError("uniform resets");
    if (this.hasTextureUniforms())
      definesStr += "#define HAS_TEXTURES".endl();
    let vs = "";
    let fs = "";
    if (!this.srcFrag) {
      this._log.warn("[cgl shader] has no fragment source!", this._name, this);
      this.srcVert = this.getDefaultVertexShader();
      this.srcFrag = this.getDefaultFragmentShader();
    }
    if (this.glslVersion == 300) {
      vs = "#version 300 es".endl() + "// ".endl() + "// vertex shader " + this._name.endl() + "// ".endl() + "precision " + this.precision + " float;".endl() + "precision " + this.precision + " sampler2D;".endl() + "".endl() + "#define WEBGL2".endl() + "#define texture2D texture".endl() + "#define UNI uniform".endl() + "#define IN in".endl() + "#define OUT out".endl();
      fs = "#version 300 es".endl() + "// ".endl() + "// fragment shader " + this._name.endl() + "// ".endl() + "precision " + this.precision + " float;".endl() + "precision " + this.precision + " sampler2D;".endl() + "".endl() + "#define WEBGL2".endl() + "#define texture2D texture".endl() + "#define IN in".endl() + "#define OUT out".endl() + "#define UNI uniform".endl() + "{{DRAWBUFFER}}".endl();
    } else {
      fs = "".endl() + "// ".endl() + "// fragment shader " + this._name.endl() + "// ".endl() + "#define WEBGL1".endl() + "#define texture texture2D".endl() + "#define outColor gl_FragColor".endl() + "#define IN varying".endl() + "#define UNI uniform".endl();
      vs = "".endl() + "// ".endl() + "// vertex shader " + this._name.endl() + "// ".endl() + "#define WEBGL1".endl() + "#define texture texture2D".endl() + "#define OUT varying".endl() + "#define IN attribute".endl() + "#define UNI uniform".endl();
    }
    let uniformsStrVert = "\n// cgl generated".endl();
    let uniformsStrFrag = "\n// cgl generated".endl();
    fs += "\n// active mods: --------------- ";
    vs += "\n// active mods: --------------- ";
    let foundModsFrag = false;
    let foundModsVert = false;
    for (let i = 0; i < this._moduleNames.length; i++) {
      for (let j = 0; j < this._modules.length; j++) {
        if (this._modules[j].name == this._moduleNames[i]) {
          if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag) {
            foundModsFrag = true;
            fs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
          }
          if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert) {
            vs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
            foundModsVert = true;
          }
        }
      }
    }
    if (!foundModsVert)
      fs += "\n// no mods used...";
    if (!foundModsFrag)
      fs += "\n// no mods used...";
    fs += "\n";
    vs += "\n";
    for (let i = 0; i < this._uniforms.length; i++) {
      if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember()) {
        let uniStr = "";
        if (!this._uniforms[i].getGlslTypeString())
          uniStr += "// ";
        uniStr += "UNI " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName();
        let comment = "";
        if (this._uniforms[i].comment)
          comment = " // " + this._uniforms[i].comment;
        if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both") {
          if (!this.srcVert.contains(uniStr) && !this.srcVert.contains("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
            uniformsStrVert += uniStr + ";" + comment.endl();
        }
        if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both") {
          if (!this.srcFrag.contains(uniStr) && !this.srcFrag.contains("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
            uniformsStrFrag += uniStr + ";" + comment.endl();
        }
      }
    }
    let countUniFrag = 0;
    let countUniVert = 0;
    for (let i = 0; i < this._uniforms.length; i++) {
      if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember()) {
        if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both")
          countUniVert++;
        if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both")
          countUniFrag++;
      }
    }
    if (countUniFrag >= this._cgl.maxUniformsFrag)
      this._log.warn("[cgl_shader] num uniforms frag: " + countUniFrag + " / " + this._cgl.maxUniformsFrag);
    if (countUniVert >= this._cgl.maxUniformsVert)
      this._log.warn("[cgl_shader] num uniforms vert: " + countUniVert + " / " + this._cgl.maxUniformsVert);
    if (!fs.contains("precision"))
      fs = "precision " + this.precision + " float;".endl() + fs;
    if (!vs.contains("precision"))
      vs = "precision " + this.precision + " float;".endl() + vs;
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      fs += "#define MOBILE".endl();
      vs += "#define MOBILE".endl();
    }
    vs = extensionString + vs + definesStr + structStrings[0] + uniformsStrVert + "\n// -- \n" + this.srcVert;
    fs = extensionString + fs + definesStr + structStrings[1] + uniformsStrFrag + "\n// -- \n" + this.srcFrag;
    let srcHeadVert = "";
    let srcHeadFrag = "";
    this._modules.sort(function(a, b) {
      return a.group - b.group;
    });
    this._modules.sort(function(a, b) {
      return a.priority || 0 - b.priority || 0;
    });
    let addedAttribs = false;
    for (let i = 0; i < this._moduleNames.length; i++) {
      let srcVert = "";
      let srcFrag = "";
      if (!addedAttribs) {
        addedAttribs = true;
        for (let k = 0; k < this._attributes.length; k++) {
          const r = this._getAttrSrc(this._attributes[k], true);
          if (r.srcHeadVert)
            srcHeadVert += r.srcHeadVert;
          if (r.srcVert)
            srcVert += r.srcVert;
          if (r.srcHeadFrag)
            srcHeadFrag += r.srcHeadFrag;
        }
      }
      for (let j = 0; j < this._modules.length; j++) {
        const mod = this._modules[j];
        if (mod.name == this._moduleNames[i]) {
          srcHeadVert += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";
          srcHeadFrag += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";
          srcVert += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";
          srcFrag += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";
          if (mod.attributes)
            for (let k = 0; k < mod.attributes.length; k++) {
              const r = this._getAttrSrc(mod.attributes[k], false);
              if (r.srcHeadVert)
                srcHeadVert += r.srcHeadVert;
              if (r.srcVert)
                srcVert += r.srcVert;
              if (r.srcHeadFrag)
                srcHeadFrag += r.srcHeadFrag;
            }
          srcHeadVert += mod.srcHeadVert || "";
          srcHeadFrag += mod.srcHeadFrag || "";
          srcVert += mod.srcBodyVert || "";
          srcFrag += mod.srcBodyFrag || "";
          srcHeadVert += "\n//---- end mod ------\n";
          srcHeadFrag += "\n//---- end mod ------\n";
          srcVert += "\n//---- end mod ------\n";
          srcFrag += "\n//---- end mod ------\n";
          srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
          srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);
          srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);
          srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);
          srcVert = srcVert.replace(/MOD_/g, mod.prefix);
          srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);
          srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
          srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);
        }
      }
      vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
      fs = fs.replace("{{" + this._moduleNames[i] + "}}", srcFrag);
    }
    vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
    fs = fs.replace("{{MODULES_HEAD}}", srcHeadFrag);
    vs = this._addLibs(vs);
    fs = this._addLibs(fs);
    let drawBufferStr = "";
    for (let i = 0; i < 16; i++)
      if (fs.contains("outColor" + i))
        this._drawBuffers[i] = true;
    if (this._drawBuffers.length == 1) {
      drawBufferStr = "out vec4 outColor;".endl();
      drawBufferStr += "#define gl_FragColor outColor".endl();
    } else {
      drawBufferStr += "#define MULTI_COLORTARGETS".endl();
      drawBufferStr += "vec4 outColor;".endl();
      let count = 0;
      for (let i = 0; i < this._drawBuffers.length; i++) {
        if (count == 0)
          drawBufferStr += "#define gl_FragColor outColor" + i + "".endl();
        drawBufferStr += "layout(location = " + i + ") out vec4 outColor" + i + ";".endl();
        count++;
      }
    }
    fs = fs.replace("{{DRAWBUFFER}}", drawBufferStr);
    if (!this._program) {
      this._program = this._createProgram(vs, fs);
    } else {
      this._program = this._createProgram(vs, fs);
      this._projMatrixUniform = null;
      for (let i = 0; i < this._uniforms.length; i++)
        this._uniforms[i].resetLoc();
    }
    this.finalShaderFrag = fs;
    this.finalShaderVert = vs;
    MESH.lastMesh = null;
    MESH.lastShader = null;
    this._countMissingUniforms = 0;
    this._needsRecompile = false;
    this.lastCompile = now();
    this._cgl.profileData.shaderCompileTime += performance.now() - startTime;
  };
  Shader.hasChanged = function() {
    return this._needsRecompile;
  };
  Shader.prototype.bind = function() {
    if (!this._isValid || this._cgl.aborted)
      return;
    MESH.lastShader = this;
    if (!this._program || this._needsRecompile)
      this.compile();
    if (!this._isValid)
      return;
    if (!this._projMatrixUniform && !this.ignoreMissingUniforms) {
      this._countMissingUniforms++;
      if (this._countMissingUniforms < 10) {
        this._projMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_PROJMAT);
        this._attrVertexPos = this._cgl.glGetAttribLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION);
        this._mvMatrixUniform = this._cgl.gl.getUniformLocation(this._program, "mvMatrix");
        this._vMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_VIEWMAT);
        this._mMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_MODELMAT);
        this._camPosUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_VIEWPOS);
        this._normalMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_NORMALMAT);
        this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_INVVIEWMAT);
        this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_INVPROJMAT);
        this._materialIdUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_MATERIALID);
        this._objectIdUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_OBJECTID);
        for (let i = 0; i < this._uniforms.length; i++)
          this._uniforms[i].needsUpdate = true;
      }
    }
    if (this._cgl.currentProgram != this._program) {
      this._cgl.profileData.profileShaderBinds++;
      this._cgl.gl.useProgram(this._program);
      this._cgl.currentProgram = this._program;
    }
    for (let i = 0; i < this._uniforms.length; i++)
      if (this._uniforms[i].needsUpdate)
        this._uniforms[i].updateValue();
    if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount()) {
      this._pMatrixState = this._cgl.getProjectionMatrixStateCount();
      this._cgl.gl.uniformMatrix4fv(this._projMatrixUniform, false, this._cgl.pMatrix);
      this._cgl.profileData.profileMVPMatrixCount++;
    }
    if (this._objectIdUniform)
      this._cgl.gl.uniform1f(this._objectIdUniform, ++this._cgl.frameStore.objectIdCounter);
    if (this._materialIdUniform)
      this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);
    if (this._vMatrixUniform) {
      if (this._vMatrixState != this._cgl.getViewMatrixStateCount()) {
        this._cgl.gl.uniformMatrix4fv(this._vMatrixUniform, false, this._cgl.vMatrix);
        this._cgl.profileData.profileMVPMatrixCount++;
        this._vMatrixState = this._cgl.getViewMatrixStateCount();
        if (this._inverseViewMatrixUniform) {
          mat4.invert(this._tempInverseViewMatrix, this._cgl.vMatrix);
          this._cgl.gl.uniformMatrix4fv(this._inverseViewMatrixUniform, false, this._tempInverseViewMatrix);
          this._cgl.profileData.profileMVPMatrixCount++;
        }
        if (this._inverseProjMatrixUniform) {
          mat4.invert(this._tempInverseProjMatrix, this._cgl.pMatrix);
          this._cgl.gl.uniformMatrix4fv(this._inverseProjMatrixUniform, false, this._tempInverseProjMatrix);
          this._cgl.profileData.profileMVPMatrixCount++;
        }
      }
      this._cgl.gl.uniformMatrix4fv(this._mMatrixUniform, false, this._cgl.mMatrix);
      this._cgl.profileData.profileMVPMatrixCount++;
      if (this._camPosUniform) {
        mat4.invert(this._tempCamPosMatrix, this._cgl.vMatrix);
        this._cgl.gl.uniform3f(this._camPosUniform, this._tempCamPosMatrix[12], this._tempCamPosMatrix[13], this._tempCamPosMatrix[14]);
        this._cgl.profileData.profileMVPMatrixCount++;
      }
    } else {
      const tempmv = mat4.create();
      mat4.mul(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);
      this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);
      this._cgl.profileData.profileMVPMatrixCount++;
    }
    if (this._normalMatrixUniform) {
      mat4.invert(this._tempNormalMatrix, this._cgl.mMatrix);
      mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);
      this._cgl.gl.uniformMatrix4fv(this._normalMatrixUniform, false, this._tempNormalMatrix);
      this._cgl.profileData.profileMVPMatrixCount++;
    }
    for (let i = 0; i < this._libs.length; i++) {
      if (this._libs[i].onBind)
        this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);
    }
    this._bindTextures();
    return this._isValid;
  };
  Shader.prototype.unBind = function() {
  };
  Shader.prototype.toggleDefine = function(name2, enabled) {
    if (enabled && typeof enabled == "object" && enabled.addEventListener) {
      if (enabled.changeListener)
        enabled.removeEventListener(enabled.changeListener);
      enabled.onToggleDefine = (v) => {
        this.toggleDefine(name2, v);
      };
      enabled.changeListener = enabled.on("change", enabled.onToggleDefine);
      enabled = enabled.get();
    }
    if (enabled)
      this.define(name2);
    else
      this.removeDefine(name2);
  };
  Shader.prototype.define = function(name2, value) {
    if (value === null || value === void 0)
      value = "";
    if (typeof value == "object") {
      value.removeEventListener("change", value.onDefineChange);
      value.onDefineChange = (v) => {
        this.define(name2, v);
      };
      value.on("change", value.onDefineChange);
      value = value.get();
    }
    for (let i = 0; i < this._defines.length; i++) {
      if (this._defines[i][0] == name2 && this._defines[i][1] == value)
        return;
      if (this._defines[i][0] == name2) {
        this._defines[i][1] = value;
        this.setWhyCompile("define " + name2 + " " + value);
        this._needsRecompile = true;
        return;
      }
    }
    this.setWhyCompile("define " + name2 + " " + value);
    this._needsRecompile = true;
    this._defines.push([name2, value]);
  };
  Shader.prototype.getDefines = function() {
    return this._defines;
  };
  Shader.prototype.getDefine = function(name2) {
    for (let i = 0; i < this._defines.length; i++)
      if (this._defines[i][0] == name2)
        return this._defines[i][1];
    return null;
  };
  Shader.prototype.hasDefine = function(name2) {
    for (let i = 0; i < this._defines.length; i++)
      if (this._defines[i][0] == name2)
        return true;
  };
  Shader.prototype.removeDefine = function(name2) {
    for (let i = 0; i < this._defines.length; i++) {
      if (this._defines[i][0] == name2) {
        this._defines.splice(i, 1);
        this._needsRecompile = true;
        this.setWhyCompile("define removed:" + name2);
        return;
      }
    }
  };
  Shader.prototype.removeModule = function(mod) {
    for (let i = 0; i < this._modules.length; i++) {
      if (mod && mod.id) {
        if (this._modules[i].id == mod.id || !this._modules[i]) {
          let found = true;
          while (found) {
            found = false;
            for (let j = 0; j < this._uniforms.length; j++) {
              if (this._uniforms[j].getName().startsWith(mod.prefix)) {
                this._uniforms.splice(j, 1);
                found = true;
                continue;
              }
            }
          }
          this._needsRecompile = true;
          this.setWhyCompile("remove module " + mod.title);
          this._modules.splice(i, 1);
          break;
        }
      }
    }
  };
  Shader.prototype.getNumModules = function() {
    return this._modules.length;
  };
  Shader.prototype.getCurrentModules = function() {
    return this._modules;
  };
  Shader.prototype.addModule = function(mod, sibling) {
    if (this.hasModule(mod.id))
      return;
    if (!mod.id)
      mod.id = CABLES.simpleId();
    if (!mod.numId)
      mod.numId = this._moduleNumId;
    if (!mod.num)
      mod.num = this._modules.length;
    if (sibling && !sibling.group)
      sibling.group = simpleId();
    if (!mod.group)
      if (sibling)
        mod.group = sibling.group;
      else
        mod.group = simpleId();
    mod.prefix = "mod" + mod.group + "_";
    this._modules.push(mod);
    this._needsRecompile = true;
    this.setWhyCompile("add module " + mod.title);
    this._moduleNumId++;
    return mod;
  };
  Shader.prototype.hasModule = function(modId) {
    for (let i = 0; i < this._modules.length; i++) {
      if (this._modules[i].id == modId)
        return true;
    }
    return false;
  };
  Shader.prototype.setModules = function(names) {
    this._moduleNames = names;
  };
  Shader.prototype.dispose = function() {
    this._cgl.gl.deleteProgram(this._program);
  };
  Shader.prototype.needsRecompile = function() {
    return this._needsRecompile;
  };
  Shader.prototype.setDrawBuffers = function(arr) {
    console.log("useless drawbuffers...?!");
  };
  Shader.prototype.getUniforms = function() {
    return this._uniforms;
  };
  Shader.prototype.getUniform = function(name2) {
    for (let i = 0; i < this._uniforms.length; i++)
      if (this._uniforms[i].getName() == name2)
        return this._uniforms[i];
    return null;
  };
  Shader.prototype.removeAllUniforms = function() {
    this._uniforms = [];
  };
  Shader.prototype.removeUniform = function(name2) {
    for (let i = 0; i < this._uniforms.length; i++) {
      if (this._uniforms[i].getName() == name2) {
        this._uniforms.splice(i, 1);
      }
    }
    this._needsRecompile = true;
    this.setWhyCompile("remove uniform " + name2);
  };
  Shader.prototype._addUniform = function(uni) {
    this._uniforms.push(uni);
    this.setWhyCompile("add uniform " + name);
    this._needsRecompile = true;
  };
  Shader.prototype.addUniformFrag = function(type, name2, valueOrPort, p2, p3, p4) {
    const uni = new CGL.Uniform(this, type, name2, valueOrPort, p2, p3, p4);
    uni.shaderType = "frag";
    return uni;
  };
  Shader.prototype.addUniformVert = function(type, name2, valueOrPort, p2, p3, p4) {
    const uni = new CGL.Uniform(this, type, name2, valueOrPort, p2, p3, p4);
    uni.shaderType = "vert";
    return uni;
  };
  Shader.prototype.addUniformBoth = function(type, name2, valueOrPort, p2, p3, p4) {
    const uni = new CGL.Uniform(this, type, name2, valueOrPort, p2, p3, p4);
    uni.shaderType = "both";
    return uni;
  };
  Shader.prototype.addUniformStructFrag = function(structName, uniformName, members) {
    const uniforms = {};
    if (!members)
      return uniforms;
    for (let i = 0; i < members.length; i += 1) {
      const member = members[i];
      if (!this.hasUniform(uniformName + "." + member.name)) {
        const uni = new CGL.Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
        uni.shaderType = "frag";
        uniforms[uniformName + "." + member.name] = uni;
      }
    }
    return uniforms;
  };
  Shader.prototype.addUniformStructVert = function(structName, uniformName, members) {
    const uniforms = {};
    if (!members)
      return uniforms;
    for (let i = 0; i < members.length; i += 1) {
      const member = members[i];
      if (!this.hasUniform(uniformName + "." + member.name)) {
        const uni = new CGL.Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
        uni.shaderType = "vert";
        uniforms[uniformName + "." + member.name] = uni;
      }
    }
    return uniforms;
  };
  Shader.prototype.addUniformStructBoth = function(structName, uniformName, members) {
    const uniforms = {};
    if (!members)
      return uniforms;
    for (let i = 0; i < members.length; i += 1) {
      const member = members[i];
      if (member.type === "2i" || member.type === "i" || member.type === "3i")
        this._log.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", structName, " with member:", member.name, " of type:", member.type, ".");
      if (!this.hasUniform(uniformName + "." + member.name)) {
        const uni = new CGL.Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
        uni.shaderType = "both";
        uniforms[uniformName + "." + member.name] = uni;
      }
    }
    return uniforms;
  };
  Shader.prototype.hasUniform = function(name2) {
    for (let i = 0; i < this._uniforms.length; i++) {
      if (this._uniforms[i].getName() == name2)
        return true;
    }
    return false;
  };
  Shader.prototype._createProgram = function(vstr, fstr) {
    this._cgl.printError("before _createprogram");
    const program = this._cgl.gl.createProgram();
    this.vshader = Shader.createShader(this._cgl, vstr, this._cgl.gl.VERTEX_SHADER, this);
    this.fshader = Shader.createShader(this._cgl, fstr, this._cgl.gl.FRAGMENT_SHADER, this);
    if (this.vshader && this.fshader) {
      this._cgl.gl.attachShader(program, this.vshader);
      this._cgl.gl.attachShader(program, this.fshader);
      this._linkProgram(program, vstr, fstr);
    } else {
      this._isValid = false;
      this._cgl.printError("shader _createProgram");
      this._log.error("could not link shaderprogram");
      return null;
    }
    this._cgl.printError("shader _createProgram");
    return program;
  };
  Shader.prototype.hasErrors = function() {
    return this._hasErrors;
  };
  Shader.prototype._linkProgram = function(program, vstr, fstr) {
    this._cgl.printError("before _linkprogram");
    if (this._feedBackNames.length > 0) {
      this._cgl.gl.transformFeedbackVaryings(program, this._feedBackNames, this._cgl.gl.SEPARATE_ATTRIBS);
    }
    this._cgl.gl.linkProgram(program);
    this._cgl.printError("gl.linkprogram");
    this._isValid = true;
    this._hasErrors = false;
    if (this._cgl.patch.config.glValidateShader !== false) {
      this._cgl.gl.validateProgram(program);
      if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.VALIDATE_STATUS)) {
        console.log("shaderprogram validation failed...");
        console.log(this._name + " programinfo: ", this._cgl.gl.getProgramInfoLog(program));
      }
      if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS)) {
        this._hasErrors = true;
        const infoLogFrag = this._cgl.gl.getShaderInfoLog(this.fshader);
        const infoLogVert = this._cgl.gl.getShaderInfoLog(this.vshader);
        if (infoLogFrag)
          this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader));
        if (infoLogVert)
          this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader));
        this._log.error(this._name + " shader linking fail...");
        console.log(this._name + " programinfo: ", this._cgl.gl.getProgramInfoLog(program));
        console.log(this);
        this._isValid = false;
        this._name = "errorshader";
        this.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());
        this._cgl.printError("shader link err");
      }
    }
  };
  Shader.prototype.getProgram = function() {
    return this._program;
  };
  Shader.prototype.setFeedbackNames = function(names) {
    this.setWhyCompile("setFeedbackNames");
    this._needsRecompile = true;
    this._feedBackNames = names;
  };
  Shader.prototype.getDefaultVertexShader = Shader.getDefaultVertexShader = function() {
    return cgl_shader_default_glsl;
  };
  Shader.prototype.getDefaultFragmentShader = Shader.getDefaultFragmentShader = function(r, g, b) {
    if (r == void 0) {
      r = 0.5;
      g = 0.5;
      b = 0.5;
    }
    return "".endl() + "IN vec2 texCoord;".endl() + "{{MODULES_HEAD}}".endl() + "void main()".endl() + "{".endl() + "    vec4 col=vec4(" + r + "," + g + "," + b + ",1.0);".endl() + "    {{MODULE_COLOR}}".endl() + "    outColor = col;".endl() + "}";
  };
  Shader.prototype.addAttribute = function(attr) {
    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].name == attr.name && this._attributes[i].nameFrag == attr.nameFrag)
        return;
    }
    this._attributes.push(attr);
    this._needsRecompile = true;
    this.setWhyCompile("addAttribute");
  };
  Shader.prototype.bindTextures = Shader.prototype._bindTextures = function() {
    if (this._textureStackTex.length > this._cgl.maxTextureUnits) {
      this._log.warn("[shader._bindTextures] too many textures bound", this._textureStackTex.length + "/" + this._cgl.maxTextureUnits);
    }
    for (let i = 0; i < this._textureStackTex.length; i++) {
      if (!this._textureStackTex[i] && !this._textureStackTexCgl[i]) {
        this._log.warn("no texture for pushtexture", this._name);
      } else {
        let t = this._textureStackTex[i];
        if (this._textureStackTexCgl[i]) {
          t = this._textureStackTexCgl[i].tex || CGL.Texture.getEmptyTexture(this._cgl).tex;
        }
        let bindOk = true;
        if (!this._textureStackUni[i]) {
          this._log.warn("no uniform for pushtexture", this._name);
          bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);
        } else {
          this._textureStackUni[i].setValue(i);
          bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);
        }
        if (!bindOk)
          console.warn("tex bind failed", this.getName(), this._textureStackUni[i]);
      }
    }
  };
  Shader.prototype.setUniformTexture = function(uni, tex) {
    tex = tex || CGL.Texture.getTempTexture(this._cgl);
    for (let i = 0; i < this._textureStackUni.length; i++)
      if (this._textureStackUni[i] == uni) {
        const old = this._textureStackTex[i] || this._textureStackTexCgl[i];
        if (tex.hasOwnProperty("tex")) {
          this._textureStackTexCgl[i] = tex;
          this._textureStackTex[i] = null;
        } else {
          this._textureStackTexCgl[i] = null;
          this._textureStackTex[i] = tex;
        }
        return old;
      }
    return null;
  };
  Shader.prototype.pushTexture = function(uniform, t, type) {
    if (!uniform) {
      console.log("no uniform given to texturestack", uniform);
      return;
    }
    if (!t) {
      console.log("no tex...");
      return;
    }
    if (!t.hasOwnProperty("tex") && !(t instanceof WebGLTexture)) {
      this._log.warn(new Error("invalid texture").stack);
      this._log.warn("[cgl_shader] invalid texture...", t);
      return;
    }
    this._textureStackUni.push(uniform);
    if (t.hasOwnProperty("tex")) {
      this._textureStackTexCgl.push(t);
      this._textureStackTex.push(null);
    } else {
      this._textureStackTexCgl.push(null);
      this._textureStackTex.push(t);
    }
    this._textureStackType.push(type);
  };
  Shader.prototype.popTexture = function() {
    this._textureStackUni.pop();
    this._textureStackTex.pop();
    this._textureStackTexCgl.pop();
    this._textureStackType.pop();
  };
  Shader.prototype.popTextures = function() {
    this._textureStackTex.length = this._textureStackTexCgl.length = this._textureStackType.length = this._textureStackUni.length = 0;
  };
  Shader.prototype.getMaterialId = function() {
    return this._materialId;
  };
  Shader.prototype.getInfo = function() {
    const info = {};
    info.name = this._name;
    info.defines = this.getDefines();
    info.hasErrors = this.hasErrors();
    return info;
  };
  Shader.getErrorFragmentShader = function() {
    return "".endl() + "void main()".endl() + "{".endl() + "   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;".endl() + "   g= step(0.1,g);".endl() + "   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);".endl() + "}";
  };
  Shader.createShader = function(cgl, str, type, cglShader) {
    if (cgl.aborted)
      return;
    function getBadLines(infoLog) {
      const basLines = [];
      const lines = infoLog.split("\n");
      for (const i in lines) {
        const divide = lines[i].split(":");
        if (parseInt(divide[2], 10))
          basLines.push(parseInt(divide[2], 10));
      }
      return basLines;
    }
    const shader = cgl.gl.createShader(type);
    cgl.gl.shaderSource(shader, str);
    cgl.gl.compileShader(shader);
    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS)) {
      let infoLog = cgl.gl.getShaderInfoLog(shader);
      if (!infoLog) {
        console.warn("empty shader info log", this._name);
        return;
      }
      const badLines = getBadLines(infoLog);
      let htmlWarning = '<pre style="margin-bottom:0px;"><code class="shaderErrorCode language-glsl" style="padding-bottom:0px;max-height: initial;max-width: initial;">';
      const lines = str.match(/^.*((\r\n|\n|\r)|$)/gm);
      if (!cgl.aborted && infoLog) {
        if (type == cgl.gl.VERTEX_SHADER)
          console.log("VERTEX_SHADER");
        if (type == cgl.gl.FRAGMENT_SHADER)
          console.log("FRAGMENT_SHADER");
        for (const i in lines) {
          const j = parseInt(i, 10) + 1;
          const line = j + ": " + lines[i];
          let isBadLine = false;
          for (const bj in badLines)
            if (badLines[bj] == j)
              isBadLine = true;
          if (isBadLine) {
            htmlWarning += "</code></pre>";
            htmlWarning += '<pre style="margin:0"><code class="language-glsl" style="background-color:#660000;padding-top:0px;padding-bottom:0px">';
            cglShader._log.log("bad line: `" + line + "`");
          }
          htmlWarning += escapeHTML(line);
          if (isBadLine) {
            htmlWarning += "</code></pre>";
            htmlWarning += '<pre style="margin:0"><code class="language-glsl" style=";padding-top:0px;padding-bottom:0px">';
          }
        }
      }
      infoLog = infoLog.replace(/\n/g, "<br/>");
      if (cgl.patch.isEditorMode())
        console.log("Shader error ", cglShader._name, infoLog, this);
      htmlWarning = infoLog + "<br/>" + htmlWarning + "<br/><br/>";
      htmlWarning += "</code></pre>";
      if (this._fromUserInteraction) {
      }
      cglShader.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());
    } else {
    }
    return shader;
  };
  ;
  class ProfileData {
    constructor(cgl) {
      this._cgl = cgl;
      this._lastTime = 0;
      this.pause = false;
      this.profileUniformCount = 0;
      this.profileShaderBinds = 0;
      this.profileUniformCount = 0;
      this.profileShaderCompiles = 0;
      this.profileVideosPlaying = 0;
      this.profileMVPMatrixCount = 0;
      this.profileEffectBuffercreate = 0;
      this.profileShaderGetUniform = 0;
      this.profileFrameBuffercreate = 0;
      this.profileMeshSetGeom = 0;
      this.profileTextureNew = 0;
      this.profileGenMipMap = 0;
      this.profileOnAnimFrameOps = 0;
      this.profileFencedPixelRead = 0;
      this.profileMainloopMs = 0;
      this.profileMeshDraw = 0;
      this.profileTextureEffect = 0;
      this.profileTexPreviews = 0;
      this.shaderCompileTime = 0;
      this.profileMeshNumElements = 0;
      this.profileMeshAttributes = 0;
      this.profileSingleMeshAttribute = [];
      this.heavyEvents = [];
      this.doProfileGlQuery = false;
      this.glQueryData = {};
    }
    clear() {
      this.profileSingleMeshAttribute = {};
      this.profileMeshAttributes = 0;
      this.profileUniformCount = 0;
      this.profileShaderGetUniform = 0;
      this.profileShaderCompiles = 0;
      this.profileShaderBinds = 0;
      this.profileTextureResize = 0;
      this.profileFrameBuffercreate = 0;
      this.profileEffectBuffercreate = 0;
      this.profileTextureDelete = 0;
      this.profileMeshSetGeom = 0;
      this.profileVideosPlaying = 0;
      this.profileMVPMatrixCount = 0;
      this.profileNonTypedAttrib = 0;
      this.profileNonTypedAttribNames = "";
      this.profileTextureNew = 0;
      this.profileGenMipMap = 0;
      this.profileFramebuffer = 0;
      this.profileMeshDraw = 0;
      this.profileTextureEffect = 0;
      this.profileTexPreviews = 0;
      this.profileMeshNumElements = 0;
      this.profileFencedPixelRead = 0;
    }
    clearGlQuery() {
      for (let i in this.glQueryData) {
        if (!this.glQueryData[i].lastClear || performance.now() - this.glQueryData[i].lastClear > 1e3) {
          this.glQueryData[i].time = this.glQueryData[i]._times / this.glQueryData[i]._numcount;
          this.glQueryData[i].num = this.glQueryData[i]._numcount;
          this.glQueryData[i]._times = 0;
          this.glQueryData[i]._numcount = 0;
          this.glQueryData[i].lastClear = performance.now();
        }
      }
    }
    addHeavyEvent(event2, name2, info) {
      const e = { "event": event2, "name": name2, "info": info, "date": performance.now() };
      this.heavyEvents.push(e);
      this._cgl.emitEvent("heavyEvent", e);
    }
  }
  ;
  class Helper {
    constructor() {
      this._simpleIdCounter = 0;
    }
    /**
     * generate a random v4 uuid
     *
     * @return {string}
     */
    uuid() {
      let d = (/* @__PURE__ */ new Date()).getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : r & 3 | 8).toString(16);
      });
    }
    /**
     * checks value for !isNan and isFinite
     *
     * @param n
     * @return {boolean}
     */
    isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    /**
     * generate a simple ID using an internal counter
     *
     * @return {Number} new id
     * @static
     */
    simpleId() {
      this._simpleIdCounter++;
      return this._simpleIdCounter;
    }
    deletePropertyByPath(obj, path) {
      if (!obj || !path) {
        return;
      }
      if (typeof path === "string") {
        path = path.split(".");
      }
      for (let i = 0; i < path.length - 1; i++) {
        obj = obj[path[i]];
        if (typeof obj === "undefined") {
          return;
        }
      }
      delete obj[path.pop()];
    }
  }
  const helper = new Helper();
  ;
  class Events {
    constructor() {
      this._log = new Logger("eventtarget");
      this._eventCallbacks = {};
      this._logName = "";
      this._logEvents = false;
      this._listeners = {};
      this.on = this.addEventListener;
      this.off = this.removeEventListener;
    }
    /**
     * add event listener
     * @param which event name
     * @param cb callback
     * @param {string} idPrefix prefix for id, default empty
     * @return {string} event id
     */
    addEventListener(which, cb, idPrefix = "") {
      const event2 = {
        "id": (idPrefix || "") + helper.simpleId(),
        "name": which,
        "cb": cb
      };
      if (!this._eventCallbacks[which])
        this._eventCallbacks[which] = [event2];
      else
        this._eventCallbacks[which].push(event2);
      this._listeners[event2.id] = event2;
      return event2.id;
    }
    /**
     * check event listener registration
     * @param id event id
     * @param cb callback - deprecated
     * @return {boolean}
     */
    hasEventListener(id, cb = null) {
      if (id && !cb) {
        return !!this._listeners[id];
      } else {
        this._log.warn("old eventtarget function haseventlistener!");
        if (id && cb) {
          if (this._eventCallbacks[id]) {
            const idx = this._eventCallbacks[id].indexOf(cb);
            return idx !== -1;
          }
        }
      }
    }
    /**
     * check event listener by name
     * @param eventName event name
     * @return {boolean}
     */
    hasListenerForEventName(eventName) {
      return this._eventCallbacks[eventName] && this._eventCallbacks[eventName].length > 0;
    }
    /**
     * rempve event listener registration
     * @param id event id
     * @param cb callback - deprecated
     * @return
     */
    removeEventListener(id, cb = null) {
      if (id === null || id === void 0)
        return;
      if (!cb) {
        const event2 = this._listeners[id];
        if (!event2) {
          this._log.log("could not find event...");
          return;
        }
        let found = true;
        while (found) {
          found = false;
          let index2 = -1;
          for (let i = 0; i < this._eventCallbacks[event2.name].length; i++) {
            if (this._eventCallbacks[event2.name][i].id.indexOf(id) === 0) {
              found = true;
              index2 = i;
            }
          }
          if (index2 !== -1) {
            this._eventCallbacks[event2.name].splice(index2, 1);
            delete this._listeners[id];
          }
        }
        return;
      }
      this._log.info("[eventtaget] ", "old function signature: removeEventListener! use listener id");
      this._log.log(new Error().stack);
      let index = null;
      for (let i = 0; i < this._eventCallbacks[id].length; i++)
        if (this._eventCallbacks[id][i].cb === cb)
          index = i;
      if (index !== null) {
        delete this._eventCallbacks[index];
      } else
        this._log.warn("removeEventListener not found " + id);
    }
    /**
     * enable/disable logging of events for the class
     *
     * @param {boolean} enabled
     * @param {string} logName
     */
    logEvents(enabled, logName) {
      this._logEvents = enabled;
      this._logName = logName;
    }
    /**
     * emit event
     *
     * @param {string} which event name
     * @param {*} param1
     * @param {*} param2
     * @param {*} param3
     * @param {*} param4
     * @param {*} param5
     * @param {*} param6
     */
    emitEvent(which, param1 = null, param2 = null, param3 = null, param4 = null, param5 = null, param6 = null) {
      if (this._logEvents)
        this._log.log("[event] ", this._logName, which, this._eventCallbacks);
      if (this._eventCallbacks[which]) {
        for (let i = 0; i < this._eventCallbacks[which].length; i++) {
          if (this._eventCallbacks[which][i]) {
            this._eventCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6);
          }
        }
      } else {
        if (this._logEvents)
          this._log.log("[event] has no event callback", which, this._eventCallbacks);
      }
    }
  }
  ;
  class CgCanvas {
    constructor(options) {
      if (!options) {
        console.error("CgCanvas no options");
      } else {
        this._canvasEle = options.canvasEle;
      }
      if (!options.cg)
        console.error("CgCanvas options has no cg");
      if (!options.canvasEle)
        console.error("CgCanvas options has no canvasEle");
      this._cg = options.cg;
      this.pixelDensity = 1;
      this.canvasWidth = this.canvasEle.clientWidth;
      this.canvasHeight = this.canvasEle.clientHeight;
      this._oldWidthRp = -1;
      this._oldHeightRp = -1;
      this.setSize(this.canvasWidth, this.canvasHeight);
    }
    get canvasEle() {
      return this._canvasEle;
    }
    setSize(w, h, ignorestyle) {
      if (this._oldWidthRp != w * this.pixelDensity || this._oldHeightRp != h * this.pixelDensity) {
        this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;
        this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;
        if (!ignorestyle) {
          this.canvasEle.style.width = w + "px";
          this.canvasEle.style.height = h + "px";
        }
        this.updateSize();
        this._cg.emitEvent("resize");
      }
    }
    updateSize() {
      this.canvasEle.width = this.canvasWidth = this.canvasEle.clientWidth * this.pixelDensity;
      this.canvasEle.height = this.canvasHeight = this.canvasEle.clientHeight * this.pixelDensity;
    }
    dispose() {
      this._canvasEle.remove();
      this._canvasEle = null;
    }
  }
  ;
  const MatrixStack = function() {
    this._arr = [mat4.create()];
    this._index = 0;
    this.stateCounter = 0;
  };
  MatrixStack.prototype.push = function(m) {
    this._index++;
    this.stateCounter++;
    if (this._index == this._arr.length) {
      const copy = mat4.create();
      this._arr.push(copy);
    }
    mat4.copy(this._arr[this._index], m || this._arr[this._index - 1]);
    return this._arr[this._index];
  };
  MatrixStack.prototype.pop = function() {
    this.stateCounter++;
    this._index--;
    if (this._index < 0)
      this._index = 0;
    return this._arr[this._index];
  };
  MatrixStack.prototype.length = function() {
    return this._index;
  };
  ;
  class CGState extends Events {
    constructor(_patch) {
      super();
      this.fpsCounter = new CABLES.CG.FpsCounter();
      this._identView = vec3.create();
      this._ident = vec3.create();
      vec3.set(this._identView, 0, 0, -2);
      vec3.set(this._ident, 0, 0, 0);
      this.patch = _patch;
      this.DEPTH_COMPARE_FUNC_NEVER = 0;
      this.DEPTH_COMPARE_FUNC_LESS = 1;
      this.DEPTH_COMPARE_FUNC_EQUAL = 2;
      this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;
      this.DEPTH_COMPARE_FUNC_GREATER = 4;
      this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;
      this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;
      this.DEPTH_COMPARE_FUNC_ALWAYS = 7;
      this.pMatrix = mat4.create();
      this.mMatrix = mat4.create();
      this.vMatrix = mat4.create();
      this._textureslots = [];
      this._pMatrixStack = new MatrixStack();
      this._mMatrixStack = new MatrixStack();
      this._vMatrixStack = new MatrixStack();
      this.canvasScale = 1;
      mat4.identity(this.mMatrix);
      mat4.identity(this.vMatrix);
      window.matchMedia("screen and (min-resolution: 2dppx)").addEventListener("change", (e) => {
        this.emitEvent("resize");
      });
    }
    get canvasWidth() {
      return this.cgCanvas.canvasWidth;
    }
    get canvasHeight() {
      return this.cgCanvas.canvasHeight;
    }
    set pixelDensity(p) {
      if (this.cgCanvas.pixelDensity != p) {
        this.cgCanvas.pixelDensity = p;
        this.cgCanvas.updateSize();
        this.emitEvent("resize");
      }
    }
    get pixelDensity() {
      return this.cgCanvas.pixelDensity;
    }
    getGApiName() {
      return ["WebGL", "WebGPU"][this.gApi];
    }
    get canvas() {
      return this.cgCanvas.canvasEle;
    }
    setCanvas(canvEle) {
      if (this.cgCanvas && canvEle == this.cgCanvas.canvasEle)
        return;
      if (typeof canvEle === "string")
        canvEle = document.getElementById(canvEle);
      this.cgCanvas = new CgCanvas({ "canvasEle": canvEle, "cg": this });
      canvEle.parentElement.classList.add("cablesContainer");
      if (this._setCanvas)
        this._setCanvas(canvEle);
      this.updateSize();
    }
    updateSize() {
      this.cgCanvas.updateSize();
    }
    setSize(w, h, ignorestyle) {
      this.cgCanvas.setSize(w, h, ignorestyle);
    }
    _resizeToWindowSize() {
      this.setSize(window.innerWidth, window.innerHeight);
      this.updateSize();
    }
    _resizeToParentSize() {
      const p = this.canvas.parentElement;
      if (!p) {
        this._log.error("cables: can not resize to container element");
        return;
      }
      this.setSize(p.clientWidth, p.clientHeight);
      this.updateSize();
    }
    setAutoResize(parent) {
      window.removeEventListener("resize", this._resizeToWindowSize.bind(this));
      window.removeEventListener("resize", this._resizeToParentSize.bind(this));
      if (parent == "window") {
        window.addEventListener("resize", this._resizeToWindowSize.bind(this));
        window.addEventListener("orientationchange", this._resizeToWindowSize.bind(this));
        this._resizeToWindowSize();
      }
      if (parent == "parent") {
        window.addEventListener("resize", this._resizeToParentSize.bind(this));
        this._resizeToParentSize();
      }
    }
    /**
     * push a matrix to the projection matrix stack
     * @function pushPMatrix
     * @memberof Context
     * @instance
     */
    pushPMatrix() {
      this.pMatrix = this._pMatrixStack.push(this.pMatrix);
    }
    /**
      * pop projection matrix stack
      * @function popPMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current projectionmatrix
      */
    popPMatrix() {
      this.pMatrix = this._pMatrixStack.pop();
      return this.pMatrix;
    }
    getProjectionMatrixStateCount() {
      return this._pMatrixStack.stateCounter;
    }
    /**
      * push a matrix to the model matrix stack
      * @function pushModelMatrix
      * @memberof Context
      * @instance
      * @example
      * // see source code of translate op:
      * cgl.pushModelMatrix();
      * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);
      * trigger.trigger();
      * cgl.popModelMatrix();
      */
    pushModelMatrix() {
      this.mMatrix = this._mMatrixStack.push(this.mMatrix);
    }
    /**
      * pop model matrix stack
      * @function popModelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    popModelMatrix() {
      this.mMatrix = this._mMatrixStack.pop();
      return this.mMatrix;
    }
    /**
      * get model matrix
      * @function modelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    modelMatrix() {
      return this.mMatrix;
    }
    /**
     * push a matrix to the view matrix stack
     * @function pushviewMatrix
     * @memberof Context
     * @instance
     */
    pushViewMatrix() {
      this.vMatrix = this._vMatrixStack.push(this.vMatrix);
    }
    /**
      * pop view matrix stack
      * @function popViewMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current viewmatrix
      * @function
      */
    popViewMatrix() {
      this.vMatrix = this._vMatrixStack.pop();
    }
    getViewMatrixStateCount() {
      return this._vMatrixStack.stateCounter;
    }
    _startMatrixStacks(identTranslate, identTranslateView) {
      identTranslate = identTranslate || this._ident;
      identTranslateView = identTranslateView || this._identView;
      mat4.perspective(this.pMatrix, 45, this.canvasWidth / this.canvasHeight, 0.1, 1e3);
      mat4.identity(this.mMatrix);
      mat4.identity(this.vMatrix);
      mat4.translate(this.mMatrix, this.mMatrix, identTranslate);
      mat4.translate(this.vMatrix, this.vMatrix, identTranslateView);
      this.pushPMatrix();
      this.pushModelMatrix();
      this.pushViewMatrix();
    }
    _endMatrixStacks() {
      this.popViewMatrix();
      this.popModelMatrix();
      this.popPMatrix();
    }
    dispose() {
      this.aborted = true;
      if (this.cgCanvas)
        this.cgCanvas.dispose();
      if (this._dispose)
        this._dispose();
    }
  }
  ;
  class FpsCounter extends Events {
    constructor() {
      super();
      this._timeStartFrame = 0;
      this._timeStartSecond = 0;
      this._fpsCounter = 0;
      this._msCounter = 0;
      this._frameCount = 0;
      this.stats = { "ms": 0, "fps": 0 };
    }
    get frameCount() {
      return this._frameCount;
    }
    startFrame() {
      this._timeStartFrame = CABLES.now();
    }
    endFrame() {
      this._frameCount++;
      this._fpsCounter++;
      const timeFrame = CABLES.now() - this._timeStartFrame;
      this._msCounter += timeFrame;
      if (CABLES.now() - this._timeStartSecond > 1e3) {
        this.endSecond();
      }
    }
    endSecond() {
      this.stats.fps = this._fpsCounter;
      this.stats.ms = Math.round(this._msCounter / this._fpsCounter * 100) / 100;
      this.emitEvent("performance", this.stats);
      this._fpsCounter = 0;
      this._msCounter = 0;
      this._timeStartSecond = CABLES.now();
    }
  }
  ;
  const CG = {
    "GAPI_WEBGL": 0,
    "GAPI_WEBGPU": 1,
    "DEPTH_COMPARE_NEVER": 0,
    "DEPTH_COMPARE_LESS": 1,
    "DEPTH_COMPARE_EQUAL": 2,
    "DEPTH_COMPARE_LESSEQUAL": 3,
    "DEPTH_COMPARE_GREATER": 4,
    "DEPTH_COMPARE_NOTEQUAL": 5,
    "DEPTH_COMPARE_GREATEREQUAL": 6,
    "DEPTH_COMPARE_ALWAYS": 7,
    "CULL_NONE": 0,
    "CULL_BACK": 1,
    "CULL_FRONT": 2,
    "CULL_BOTH": 3,
    "Geometry": Geometry,
    "BoundingBox": BoundingBox,
    "FpsCounter": FpsCounter,
    "CgCanvas": CgCanvas
  };
  ;
  class Context extends CGState {
    constructor(_patch) {
      super(_patch);
      this.gApi = CG.GAPI_WEBGL;
      this.aborted = false;
      this.pushMvMatrix = this.pushModelMatrix;
      this.popMvMatrix = this.popmMatrix = this.popModelMatrix;
      this.profileData = new ProfileData(this);
      this._log = new Logger("cgl_context");
      this._viewPort = [0, 0, 0, 0];
      this.glVersion = 0;
      this.glUseHalfFloatTex = false;
      this.clearCanvasTransparent = true;
      this.clearCanvasDepth = true;
      this.debugOneFrame = false;
      this.checkGlErrors = false;
      this.maxTextureUnits = 0;
      this.maxVaryingVectors = 0;
      this.currentProgram = null;
      this._hadStackError = false;
      this.glSlowRenderer = false;
      this._isSafariCrap = false;
      this.temporaryTexture = null;
      this.frameStore = {};
      this._onetimeCallbacks = [];
      this.gl = null;
      this._cursor = "auto";
      this._currentCursor = "";
      this._viewPortStack = [];
      this._glFrameBufferStack = [];
      this._frameBufferStack = [];
      this._shaderStack = [];
      this._stackDepthTest = [];
      this.mainloopOp = null;
      this._simpleShader = new Shader(this, "simpleshader");
      this._simpleShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MOVELVIEW"]);
      this._simpleShader.setSource(Shader.getDefaultVertexShader(), Shader.getDefaultFragmentShader());
      this._currentShader = this._simpleShader;
      this._oldCanvasWidth = -1;
      this._oldCanvasHeight = -1;
      this._enabledExtensions = {};
    }
    // set pixelDensity(p)
    // {
    //     this._pixelDensity = p;
    // }
    // get pixelDensity()
    // {
    //     return this._pixelDensity;
    // }
    get viewPort() {
      if (this._viewPortStack.length > 3) {
        const l = this._viewPortStack.length;
        return [
          this._viewPortStack[l - 4],
          this._viewPortStack[l - 3],
          this._viewPortStack[l - 2],
          this._viewPortStack[l - 1]
        ];
      } else {
        return this._viewPort;
      }
    }
    get mvMatrix() {
      return this.mMatrix;
    }
    set mvMatrix(m) {
      this.mMatrix = m;
    }
    exitError(msgId, msg) {
      console.log(msgId, msg);
      this.patch.exitError(msgId, msg);
      this.aborted = true;
    }
    _setCanvas(canv) {
      if (!canv) {
        this._log.stack("_setCanvas undef");
      }
      if (!this.patch.config.canvas)
        this.patch.config.canvas = {};
      if (!this.patch.config.canvas.hasOwnProperty("preserveDrawingBuffer"))
        this.patch.config.canvas.preserveDrawingBuffer = false;
      if (!this.patch.config.canvas.hasOwnProperty("premultipliedAlpha"))
        this.patch.config.canvas.premultipliedAlpha = false;
      if (!this.patch.config.canvas.hasOwnProperty("alpha"))
        this.patch.config.canvas.alpha = false;
      this.patch.config.canvas.stencil = true;
      if (this.patch.config.hasOwnProperty("clearCanvasColor"))
        this.clearCanvasTransparent = this.patch.config.clearCanvasColor;
      if (this.patch.config.hasOwnProperty("clearCanvasDepth"))
        this.clearCanvasDepth = this.patch.config.clearCanvasDepth;
      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && navigator.userAgent.match(/iPhone/i)) {
        this._isSafariCrap = true;
        this.glUseHalfFloatTex = true;
      }
      if (!this.patch.config.canvas.forceWebGl1)
        this.gl = canv.getContext("webgl2", this.patch.config.canvas);
      if (!this.gl || this.gl.isContextLost()) {
        this.aborted = true;
        this.exitError("NO_WEBGL", "sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.");
        return;
      }
      if (this.gl.getParameter(this.gl.VERSION) != "WebGL 1.0") {
        this.glVersion = 2;
      } else {
        this.gl = canv.getContext("webgl", this.patch.config.canvas) || canv.getContext("experimental-webgl", this.patch.config.canvas);
        this.glVersion = 1;
        if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
          if (!this.patch.config.canvas.hasOwnProperty("powerPreference"))
            this.patch.config.canvas.powerPreference = "high-performance";
        }
        this.enableExtension("OES_standard_derivatives");
        const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;
        if (instancingExt.vertexAttribDivisorANGLE) {
          this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
          this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
        }
      }
      const dbgRenderInfo = this.enableExtension("WEBGL_debug_renderer_info");
      if (dbgRenderInfo) {
        this.glRenderer = this.gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL);
        if (this.glRenderer === "Google SwiftShader")
          this.glSlowRenderer = true;
      }
      this.canvas.addEventListener("webglcontextlost", (event2) => {
        if (this.aborted)
          return this._log.warn("[cgl_state] aborted context lost... can be ignored...");
        this._log.error("canvas lost...", event2);
        this.emitEvent("webglcontextlost");
        this.aborted = true;
      });
      this.maxAnisotropic = 0;
      if (this.enableExtension("EXT_texture_filter_anisotropic"))
        this.maxAnisotropic = this.gl.getParameter(this.enableExtension("EXT_texture_filter_anisotropic").MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);
      this.maxTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
      this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
      this.maxUniformsFrag = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS);
      this.maxUniformsVert = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);
      this.maxSamples = 0;
      if (this.gl.MAX_SAMPLES)
        this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);
      if (this.glVersion == 1) {
        this.enableExtension("OES_standard_derivatives");
        const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;
        if (instancingExt.vertexAttribDivisorANGLE) {
          this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
          this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
        }
      }
      this.DEPTH_FUNCS = [
        this.gl.NEVER,
        this.gl.ALWAYS,
        this.gl.LESS,
        this.gl.LEQUAL,
        this.gl.GREATER,
        this.gl.GEQUAL,
        this.gl.EQUAL,
        this.gl.NOTEQUAL
      ];
      this.CULL_MODES = [
        null,
        this.gl.BACK,
        this.gl.FRONT,
        this.gl.FRONT_AND_BACK
      ];
    }
    getInfo() {
      return {
        "glVersion": this.glVersion,
        "glRenderer": this.glRenderer,
        "glUseHalfFloatTex": this.glUseHalfFloatTex,
        "maxVaryingVectors": this.maxVaryingVectors,
        "maxTextureUnits": this.maxTextureUnits,
        "maxTexSize": this.maxTexSize,
        "maxUniformsFrag": this.maxUniformsFrag,
        "maxUniformsVert": this.maxUniformsVert,
        "maxSamples": this.maxSamples
      };
    }
    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */
    popViewPort() {
      this._viewPortStack.pop();
      this._viewPortStack.pop();
      this._viewPortStack.pop();
      this._viewPortStack.pop();
      if (this._viewPortStack.length == 0) {
        this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);
      } else {
        this.setViewPort(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);
      }
    }
    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */
    pushViewPort(x, y, w, h) {
      this._viewPortStack.push(x, y, w, h);
      this.setViewPort(x, y, w, h);
    }
    // old
    getViewPort() {
      return this._viewPort;
    }
    // old
    resetViewPort() {
      this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }
    // old
    setViewPort(x, y, w, h) {
      this._viewPort[0] = Math.round(x);
      this._viewPort[1] = Math.round(y);
      this._viewPort[2] = Math.round(w);
      this._viewPort[3] = Math.round(h);
      this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }
    screenShot(cb, doScreenshotClearAlpha, mimeType, quality) {
      if (doScreenshotClearAlpha) {
        this.gl.clearColor(1, 1, 1, 1);
        this.gl.colorMask(false, false, false, true);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.colorMask(true, true, true, true);
      }
      if (this.canvas && this.canvas.toBlob) {
        this.canvas.toBlob((blob) => {
          if (cb)
            cb(blob);
          else
            this._log.log("no screenshot callback...");
        }, mimeType, quality);
      }
    }
    endFrame() {
      if (this.patch.isEditorMode())
        CABLES.GL_MARKER.drawMarkerLayer(this);
      this.setPreviousShader();
      if (this._vMatrixStack.length() > 0)
        this.logStackError("view matrix stack length !=0 at end of rendering...");
      if (this._mMatrixStack.length() > 0)
        this.logStackError("mvmatrix stack length !=0 at end of rendering...");
      if (this._pMatrixStack.length() > 0)
        this.logStackError("pmatrix stack length !=0 at end of rendering...");
      if (this._glFrameBufferStack.length > 0)
        this.logStackError("glFrameBuffer stack length !=0 at end of rendering...");
      if (this._stackDepthTest.length > 0)
        this.logStackError("depthtest stack length !=0 at end of rendering...");
      if (this._stackDepthWrite.length > 0)
        this.logStackError("depthwrite stack length !=0 at end of rendering...");
      if (this._stackDepthFunc.length > 0)
        this.logStackError("depthfunc stack length !=0 at end of rendering...");
      if (this._stackBlend.length > 0)
        this.logStackError("blend stack length !=0 at end of rendering...");
      if (this._stackBlendMode.length > 0)
        this.logStackError("blendMode stack length !=0 at end of rendering...");
      if (this._shaderStack.length > 0)
        this.logStackError("this._shaderStack length !=0 at end of rendering...");
      if (this._stackCullFace.length > 0)
        this.logStackError("this._stackCullFace length !=0 at end of rendering...");
      if (this._stackCullFaceFacing.length > 0)
        this.logStackError("this._stackCullFaceFacing length !=0 at end of rendering...");
      if (this._viewPortStack.length > 0)
        this.logStackError("viewport stack length !=0 at end of rendering...");
      this._frameStarted = false;
      if (this._oldCanvasWidth != this.canvasWidth || this._oldCanvasHeight != this.canvasHeight) {
        this._oldCanvasWidth = this.canvasWidth;
        this._oldCanvasHeight = this.canvasHeight;
        this.emitEvent("resize");
      }
      if (this._cursor != this._currentCursor) {
        this._currentCursor = this.canvas.style.cursor = this._cursor;
      }
      this.emitEvent("endframe");
      this.fpsCounter.endFrame();
    }
    logStackError(str) {
      if (!this._hadStackError) {
        this._hadStackError = true;
        this._log.warn("[" + this.canvas.id + "]: ", str);
      }
    }
    // shader stack
    getShader() {
      if (this._currentShader) {
        if (!this.frameStore || this.frameStore.renderOffscreen === true == this._currentShader.offScreenPass === true)
          return this._currentShader;
      }
      for (let i = this._shaderStack.length - 1; i >= 0; i--)
        if (this._shaderStack[i]) {
          if (this.frameStore.renderOffscreen == this._shaderStack[i].offScreenPass)
            return this._shaderStack[i];
        }
    }
    getDefaultShader() {
      return this._simpleShader;
    }
    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
     */
    pushShader(shader) {
      if (this.frameStore.forceShaderMods) {
        for (let i = 0; i < this.frameStore.forceShaderMods.length; i++) {
          shader = this.frameStore.forceShaderMods[i].bind(shader, false);
        }
      }
      this._shaderStack.push(shader);
      this._currentShader = shader;
    }
    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    setPreviousShader() {
      if (this.frameStore.forceShaderMods) {
        for (let i = 0; i < this.frameStore.forceShaderMods.length; i++) {
          this.frameStore.forceShaderMods[i].unbind(false);
        }
      }
      if (this._shaderStack.length === 0)
        throw new Error("Invalid shader stack pop!");
      this._shaderStack.pop();
      this._currentShader = this._shaderStack[this._shaderStack.length - 1];
    }
    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Object} fb framebuffer
     * @function
     */
    pushGlFrameBuffer(fb) {
      this._glFrameBufferStack.push(fb);
    }
    /**
     * pop framebuffer stack
     * @function popGlFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    popGlFrameBuffer() {
      if (this._glFrameBufferStack.length == 0)
        return null;
      this._glFrameBufferStack.pop();
      return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }
    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    getCurrentGlFrameBuffer() {
      if (this._glFrameBufferStack.length === 0)
        return null;
      return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }
    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Framebuffer} fb framebuffer
     */
    pushFrameBuffer(fb) {
      this._frameBufferStack.push(fb);
    }
    /**
     * pop framebuffer stack
     * @function popFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer} current framebuffer or null
     */
    popFrameBuffer() {
      if (this._frameBufferStack.length == 0)
        return null;
      this._frameBufferStack.pop();
      return this._frameBufferStack[this._frameBufferStack.length - 1];
    }
    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer} current framebuffer or null
     */
    getCurrentFrameBuffer() {
      if (this._frameBufferStack.length === 0)
        return null;
      return this._frameBufferStack[this._frameBufferStack.length - 1];
    }
    renderStart(cgl, identTranslate, identTranslateView) {
      this.fpsCounter.startFrame();
      this.pushDepthTest(true);
      this.pushDepthWrite(true);
      this.pushDepthFunc(cgl.gl.LEQUAL);
      this.pushCullFaceFacing(cgl.gl.BACK);
      this.pushCullFace(false);
      cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);
      this._startMatrixStacks(identTranslate, identTranslateView);
      cgl.pushBlendMode(constants_CONSTANTS.BLEND_MODES.BLEND_NORMAL, false);
      for (let i = 0; i < this._textureslots.length; i++)
        this._textureslots[i] = null;
      this.pushShader(this._simpleShader);
      this._frameStarted = true;
      if (this._onetimeCallbacks.length > 0) {
        for (let i = 0; i < this._onetimeCallbacks.length; i++)
          this._onetimeCallbacks[i]();
        this._onetimeCallbacks.length = 0;
      }
      for (let i = 0; i < this._textureslots.length; i++) {
        this.gl.activeTexture(this.gl.TEXTURE0 + i);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this._textureslots[i] = null;
      }
      this.emitEvent("beginFrame");
    }
    renderEnd(cgl) {
      this._endMatrixStacks();
      this.popDepthTest();
      this.popDepthWrite();
      this.popDepthFunc();
      this.popCullFaceFacing();
      this.popCullFace();
      this.popBlend();
      this.popBlendMode();
      cgl.endFrame();
      this.emitEvent("endFrame");
    }
    getTexture(slot) {
      return this._textureslots[slot];
    }
    hasFrameStarted() {
      return this._frameStarted;
    }
    /**
     * log warning to console if the rendering of one frame has not been started / handy to check for async problems
     * @function checkFrameStarted
     * @memberof Context
     * @param string
     * @instance
     */
    checkFrameStarted(string) {
      if (!this._frameStarted) {
        this._log.warn("frame not started " + string);
        this.patch.printTriggerStack();
      }
    }
    setTexture(slot, t, type) {
      this.checkFrameStarted("cgl setTexture");
      if (t === null)
        t = CGL.Texture.getEmptyTexture(this).tex;
      if (this._textureslots[slot] != t) {
        this.gl.activeTexture(this.gl.TEXTURE0 + slot);
        this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);
        this._textureslots[slot] = t;
      }
      return true;
    }
    fullScreen() {
      if (this.canvas.requestFullscreen)
        this.canvas.requestFullscreen();
      else if (this.canvas.mozRequestFullScreen)
        this.canvas.mozRequestFullScreen();
      else if (this.canvas.webkitRequestFullscreen)
        this.canvas.webkitRequestFullscreen();
      else if (this.canvas.msRequestFullscreen)
        this.canvas.msRequestFullscreen();
    }
    printError(str) {
      if (!this.checkGlErrors)
        return;
      let found = false;
      let error = this.gl.getError();
      if (error != this.gl.NO_ERROR) {
        let errStr = "";
        if (error == this.gl.OUT_OF_MEMORY)
          errStr = "OUT_OF_MEMORY";
        if (error == this.gl.INVALID_ENUM)
          errStr = "INVALID_ENUM";
        if (error == this.gl.INVALID_OPERATION)
          errStr = "INVALID_OPERATION";
        if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION)
          errStr = "INVALID_FRAMEBUFFER_OPERATION";
        if (error == this.gl.INVALID_VALUE)
          errStr = "INVALID_VALUE";
        if (error == this.gl.CONTEXT_LOST_WEBGL) {
          this.aborted = true;
          errStr = "CONTEXT_LOST_WEBGL";
        }
        if (error == this.gl.NO_ERROR)
          errStr = "NO_ERROR";
        found = true;
        this._log.warn("gl error [" + this.canvas.id + "]: ", str, error, errStr);
        if (this.canvas.id.contains("glGuiCanvas")) {
          if (!this._loggedGlError) {
            this.patch.printTriggerStack();
            this._log.stack("glerror");
            this._loggedGlError = true;
          }
        }
      }
      error = this.gl.getError();
      return found;
    }
    saveScreenshot(filename2, cb, pw, ph, noclearalpha) {
      this.patch.renderOneFrame();
      let w = this.canvas.clientWidth * this.pixelDensity;
      let h = this.canvas.clientHeight * this.pixelDensity;
      if (pw) {
        this.canvas.width = pw;
        w = pw;
      }
      if (ph) {
        this.canvas.height = ph;
        h = ph;
      }
      function padLeft(nr, n, str) {
        return Array(n - String(nr).length + 1).join(str || "0") + nr;
      }
      const d = /* @__PURE__ */ new Date();
      const dateStr = "".concat(String(d.getFullYear()) + String(d.getMonth() + 1) + String(d.getDate()), "_").concat(padLeft(d.getHours(), 2)).concat(padLeft(d.getMinutes(), 2)).concat(padLeft(d.getSeconds(), 2));
      if (!filename2)
        filename2 = "cables_" + dateStr + ".png";
      else
        filename2 += ".png";
      this.patch.cgl.screenShot(function(blob) {
        this.canvas.width = w;
        this.canvas.height = h;
        if (blob) {
          const anchor = document.createElement("a");
          anchor.download = filename2;
          anchor.href = URL.createObjectURL(blob);
          setTimeout(function() {
            anchor.click();
            if (cb)
              cb(blob);
          }, 100);
        } else {
          this._log.log("screenshot: no blob");
        }
      }.bind(this), noclearalpha);
    }
    _dispose() {
      this._simpleShader.dispose();
      this.gl = null;
    }
  }
  Context.prototype.popShader = Context.prototype.setPreviousShader;
  Context.prototype.setShader = Context.prototype.pushShader;
  Context.prototype.addNextFrameOnceCallback = function(cb) {
    if (cb && this._onetimeCallbacks.indexOf(cb) == -1)
      this._onetimeCallbacks.push(cb);
  };
  Context.prototype._stackDepthTest = [];
  Context.prototype.pushDepthTest = function(b) {
    this._stackDepthTest.push(b);
    if (!b)
      this.gl.disable(this.gl.DEPTH_TEST);
    else
      this.gl.enable(this.gl.DEPTH_TEST);
  };
  Context.prototype.stateDepthTest = function() {
    return this._stackDepthTest[this._stackDepthTest.length - 1];
  };
  Context.prototype.popDepthTest = function() {
    this._stackDepthTest.pop();
    if (!this._stackDepthTest[this._stackDepthTest.length - 1])
      this.gl.disable(this.gl.DEPTH_TEST);
    else
      this.gl.enable(this.gl.DEPTH_TEST);
  };
  Context.prototype._stackDepthWrite = [];
  Context.prototype.pushDepthWrite = function(b) {
    b = b || false;
    this._stackDepthWrite.push(b);
    this.gl.depthMask(b);
  };
  Context.prototype.stateDepthWrite = function() {
    return this._stackDepthWrite[this._stackDepthWrite.length - 1];
  };
  Context.prototype.popDepthWrite = function() {
    this._stackDepthWrite.pop();
    this.gl.depthMask(this._stackDepthWrite[this._stackDepthWrite.length - 1] || false);
  };
  Context.prototype._stackCullFace = [];
  Context.prototype.pushCullFace = function(b) {
    this._stackCullFace.push(b);
    if (b)
      this.gl.enable(this.gl.CULL_FACE);
    else
      this.gl.disable(this.gl.CULL_FACE);
  };
  Context.prototype.stateCullFace = function() {
    return this._stackCullFace[this._stackCullFace.length - 1];
  };
  Context.prototype.popCullFace = function() {
    this._stackCullFace.pop();
    if (this._stackCullFace[this._stackCullFace.length - 1])
      this.gl.enable(this.gl.CULL_FACE);
    else
      this.gl.disable(this.gl.CULL_FACE);
  };
  Context.prototype._stackCullFaceFacing = [];
  Context.prototype.pushCullFaceFacing = function(b) {
    this._stackCullFaceFacing.push(b);
    this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
  };
  Context.prototype.stateCullFaceFacing = function() {
    return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
  };
  Context.prototype.popCullFaceFacing = function() {
    this._stackCullFaceFacing.pop();
    if (this._stackCullFaceFacing.length > 0)
      this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
  };
  Context.prototype._stackDepthFunc = [];
  Context.prototype.pushDepthFunc = function(f) {
    this._stackDepthFunc.push(f);
    this.gl.depthFunc(f);
  };
  Context.prototype.stateDepthFunc = function() {
    if (this._stackDepthFunc.length > 0)
      return this._stackDepthFunc[this._stackDepthFunc.length - 1];
    return false;
  };
  Context.prototype.popDepthFunc = function() {
    this._stackDepthFunc.pop();
    if (this._stackDepthFunc.length > 0)
      this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);
  };
  Context.prototype._stackBlend = [];
  Context.prototype.pushBlend = function(b) {
    this._stackBlend.push(b);
    if (!b)
      this.gl.disable(this.gl.BLEND);
    else
      this.gl.enable(this.gl.BLEND);
  };
  Context.prototype.popBlend = function() {
    this._stackBlend.pop();
    if (!this._stackBlend[this._stackBlend.length - 1])
      this.gl.disable(this.gl.BLEND);
    else
      this.gl.enable(this.gl.BLEND);
  };
  Context.prototype.stateBlend = function() {
    return this._stackBlend[this._stackBlend.length - 1];
  };
  const BLENDS = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4
  };
  Context.prototype._stackBlendMode = [];
  Context.prototype._stackBlendModePremul = [];
  Context.prototype.pushBlendMode = function(blendMode, premul) {
    this._stackBlendMode.push(blendMode);
    this._stackBlendModePremul.push(premul);
    const n = this._stackBlendMode.length - 1;
    this.pushBlend(this._stackBlendMode[n] !== constants_CONSTANTS.BLEND_MODES.BLEND_NONE);
    this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
  };
  Context.prototype.popBlendMode = function() {
    this._stackBlendMode.pop();
    this._stackBlendModePremul.pop();
    const n = this._stackBlendMode.length - 1;
    this.popBlend(this._stackBlendMode[n] !== constants_CONSTANTS.BLEND_MODES.BLEND_NONE);
    if (n >= 0)
      this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
  };
  Context.prototype._stackStencil = [];
  Context.prototype.pushStencil = function(b) {
    this._stackStencil.push(b);
    if (!b)
      this.gl.disable(this.gl.STENCIL_TEST);
    else
      this.gl.enable(this.gl.STENCIL_TEST);
  };
  Context.prototype.popStencil = function() {
    this._stackStencil.pop();
    if (!this._stackStencil[this._stackStencil.length - 1])
      this.gl.disable(this.gl.STENCIL_TEST);
    else
      this.gl.enable(this.gl.STENCIL_TEST);
  };
  Context.prototype.glGetAttribLocation = function(prog, name2) {
    const l = this.gl.getAttribLocation(prog, name2);
    return l;
  };
  Context.prototype.shouldDrawHelpers = function(op) {
    if (this.frameStore.shadowPass)
      return false;
    if (!op.patch.isEditorMode())
      return false;
    return gui.shouldDrawOverlay;
  };
  Context.prototype._setBlendMode = function(blendMode, premul) {
    const gl = this.gl;
    if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_NONE) {
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_ADD) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
      }
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_SUB) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
      }
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_MUL) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
      }
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_NORMAL) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      }
    } else {
      this._log.log("setblendmode: unknown blendmode");
    }
  };
  Context.prototype.createMesh = function(geom, options) {
    if (CABLES.UTILS.isNumeric(options))
      options = { "glPrimitive": options };
    return new CGL.Mesh(this, geom, options);
  };
  Context.prototype.setCursor = function(str) {
    this._cursor = str;
  };
  Context.prototype.enableExtension = function(name2) {
    if (!this.gl)
      return null;
    if (this._enabledExtensions.hasOwnProperty(name2))
      return this._enabledExtensions[name2];
    const o = this.gl.getExtension(name2);
    this._enabledExtensions[name2] = o;
    if (!o)
      this._log.warn("[cgl_state] extension not available " + name2);
    return o;
  };
  Context.prototype.checkTextureSize = function(x) {
    x = x || 1;
    x = Math.floor(x);
    x = Math.min(x, this.maxTexSize);
    x = Math.max(x, 1);
    return x;
  };
  ;
  class PatchVariable extends Events {
    constructor(name2, val, type) {
      super();
      this._name = name2;
      this.type = type;
      this.setValue(val);
    }
    /**
     * keeping this for backwards compatibility in older
     * exports before using eventtarget
     *
     * @param cb
     */
    addListener(cb) {
      this.on("change", cb, "var");
    }
    /**
     * @function Variable.getValue
     * @memberof PatchVariable
     * @returns {String|Number|Boolean}
     */
    getValue() {
      return this._v;
    }
    /**
     * @function getName
     * @memberof PatchVariable
     * @instance
     * @returns {String|Number|Boolean}
     * @function
     */
    getName() {
      return this._name;
    }
    /**
     * @function setValue
     * @memberof PatchVariable
     * @instance
     * @param v
     * @returns {String|Number|Boolean}
     * @function
     */
    setValue(v) {
      this._v = v;
      this.emitEvent("change", v, this);
    }
  }
  const core_variable = PatchVariable;
  ;
  const Patch = function(cfg) {
    EventTarget.apply(this);
    this._log = new Logger("core_patch");
    this.ops = [];
    this.settings = {};
    this.config = cfg || {
      "glCanvasResizeToWindow": false,
      "prefixAssetPath": "",
      "prefixJsPath": "",
      "silent": true,
      "onError": null,
      "onFinishedLoading": null,
      "onFirstFrameRendered": null,
      "onPatchLoaded": null,
      "fpsLimit": 0
    };
    this.timer = new Timer();
    this.freeTimer = new Timer();
    this.animFrameOps = [];
    this.animFrameCallbacks = [];
    this.gui = false;
    CABLES.logSilent = this.silent = true;
    this.profiler = null;
    this.aborted = false;
    this._crashedOps = [];
    this._renderOneFrame = false;
    this._animReq = null;
    this._opIdCache = {};
    this._triggerStack = [];
    this.storeObjNames = false;
    this.loading = new LoadingStatus(this);
    this._volumeListeners = [];
    this._paused = false;
    this._frameNum = 0;
    this.instancing = new Instancing();
    this.onOneFrameRendered = null;
    this.namedTriggers = {};
    this._origData = null;
    this._frameNext = 0;
    this._frameInterval = 0;
    this._lastFrameTime = 0;
    this._frameWasdelayed = true;
    this.frameStore = {};
    this.deSerialized = false;
    this.reqAnimTimeStamp = 0;
    this.cgCanvas = null;
    if (!function() {
      return !this;
    }())
      console.log("not in strict mode: core patch");
    this._isLocal = document.location.href.indexOf("file:") === 0;
    if (this.config.hasOwnProperty("silent"))
      this.silent = CABLES.logSilent = this.config.silent;
    if (!this.config.hasOwnProperty("doRequestAnimation"))
      this.config.doRequestAnimation = true;
    if (!this.config.prefixAssetPath)
      this.config.prefixAssetPath = "";
    if (!this.config.prefixJsPath)
      this.config.prefixJsPath = "";
    if (!this.config.masterVolume)
      this.config.masterVolume = 1;
    this._variables = {};
    this._variableListeners = [];
    this.vars = {};
    if (cfg && cfg.vars)
      this.vars = cfg.vars;
    this.cgl = new Context(this);
    this.cgp = null;
    this._subpatchOpCache = {};
    this.cgl.setCanvas(this.config.glCanvasId || this.config.glCanvas || "glcanvas");
    if (this.config.glCanvasResizeToWindow === true)
      this.cgl.setAutoResize("window");
    if (this.config.glCanvasResizeToParent === true)
      this.cgl.setAutoResize("parent");
    this.loading.setOnFinishedLoading(this.config.onFinishedLoading);
    if (this.cgl.aborted)
      this.aborted = true;
    if (this.cgl.silent)
      this.silent = true;
    this.freeTimer.play();
    this.exec();
    if (!this.aborted) {
      if (this.config.patch) {
        this.deSerialize(this.config.patch);
      } else if (this.config.patchFile) {
        ajax(
          this.config.patchFile,
          (err, _data) => {
            const data = JSON.parse(_data);
            if (err) {
              const txt = "";
              this._log.error("err", err);
              this._log.error("data", data);
              this._log.error("data", data.msg);
              return;
            }
            this.deSerialize(data);
          }
        );
      }
      this.timer.play();
    }
    console.log("made with https://cables.gl");
  };
  Patch.prototype.isPlaying = function() {
    return !this._paused;
  };
  Patch.prototype.isRenderingOneFrame = function() {
    return this._renderOneFrame;
  };
  Patch.prototype.renderOneFrame = function() {
    this._paused = true;
    this._renderOneFrame = true;
    this.exec();
    this._renderOneFrame = false;
  };
  Patch.prototype.getFPS = function() {
    this._log.error("deprecated getfps");
    return 0;
  };
  Patch.prototype.isEditorMode = function() {
    return this.config.editorMode === true;
  };
  Patch.prototype.pause = function() {
    cancelAnimationFrame(this._animReq);
    this.emitEvent("pause");
    this._animReq = null;
    this._paused = true;
    this.freeTimer.pause();
  };
  Patch.prototype.resume = function() {
    if (this._paused) {
      cancelAnimationFrame(this._animReq);
      this._paused = false;
      this.freeTimer.play();
      this.emitEvent("resume");
      this.exec();
    }
  };
  Patch.prototype.setVolume = function(v) {
    this.config.masterVolume = v;
    for (let i = 0; i < this._volumeListeners.length; i++)
      this._volumeListeners[i].onMasterVolumeChanged(v);
  };
  Patch.prototype.getAssetPath = function(patchId = null) {
    if (this.isEditorMode()) {
      let id = patchId || gui.project()._id;
      return "/assets/" + id + "/";
    } else if (document.location.href.indexOf("cables.gl") > 0 || document.location.href.indexOf("cables.local") > 0) {
      const parts = document.location.pathname.split("/");
      let id = patchId || parts[parts.length - 1];
      return "/assets/" + id + "/";
    } else if (this.config.hasOwnProperty("assetPath")) {
      return this.config.assetPath;
    } else {
      return "assets/";
    }
  };
  Patch.prototype.getJsPath = function() {
    if (this.config.hasOwnProperty("jsPath")) {
      return this.config.jsPath;
    } else {
      return "js/";
    }
  };
  Patch.prototype.getFilePath = function(filename2) {
    if (!filename2)
      return filename2;
    filename2 = String(filename2);
    if (filename2.indexOf("https:") === 0 || filename2.indexOf("http:") === 0)
      return filename2;
    if (filename2.indexOf("data:") === 0)
      return filename2;
    if (filename2.indexOf("file:") === 0)
      return filename2;
    filename2 = filename2.replace("//", "/");
    if (filename2.startsWith(this.config.prefixAssetPath))
      filename2 = filename2.replace(this.config.prefixAssetPath, "");
    return this.config.prefixAssetPath + filename2 + (this.config.suffixAssetPath || "");
  };
  Patch.prototype.clear = function() {
    this.emitEvent("patchClearStart");
    this.cgl.TextureEffectMesh = null;
    this.animFrameOps.length = 0;
    this.timer = new Timer();
    while (this.ops.length > 0)
      this.deleteOp(this.ops[0].id);
    this._opIdCache = {};
    this.emitEvent("patchClearEnd");
  };
  Patch.getOpClass = function(objName) {
    const parts = objName.split(".");
    let opObj = null;
    try {
      if (parts.length == 2)
        opObj = window[parts[0]][parts[1]];
      else if (parts.length == 3)
        opObj = window[parts[0]][parts[1]][parts[2]];
      else if (parts.length == 4)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]];
      else if (parts.length == 5)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]];
      else if (parts.length == 6)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]];
      else if (parts.length == 7)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]];
      else if (parts.length == 8)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]];
      else if (parts.length == 9)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]];
      else if (parts.length == 10)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]];
      return opObj;
    } catch (e) {
      return null;
    }
  };
  Patch.prototype.createOp = function(identifier, id, opName = null) {
    let op = null;
    let objName = "";
    try {
      if (!identifier) {
        console.error("createop identifier false", identifier);
        console.log(new Error().stack);
        return;
      }
      if (identifier.indexOf("Ops.") === -1) {
        const opId = identifier;
        if (CABLES.OPS[opId]) {
          objName = CABLES.OPS[opId].objName;
          op = new CABLES.OPS[opId].f(this, objName, id, opId);
          op.opId = opId;
        } else {
          if (opName) {
            identifier = opName;
            this._log.warn("could not find op by id: " + opId);
          } else {
            throw new Error("could not find op by id: " + opId, { "cause": "opId:" + opId });
          }
        }
      }
      if (!op) {
        objName = identifier;
        const parts = identifier.split(".");
        const opObj = Patch.getOpClass(objName);
        if (!opObj) {
          this.emitEvent("criticalError", { "title": "unknown op" + objName, "text": "unknown op: " + objName });
          this._log.error("unknown op: " + objName);
          throw new Error("unknown op: " + objName);
        } else {
          if (parts.length == 2)
            op = new window[parts[0]][parts[1]](this, objName, id);
          else if (parts.length == 3)
            op = new window[parts[0]][parts[1]][parts[2]](this, objName, id);
          else if (parts.length == 4)
            op = new window[parts[0]][parts[1]][parts[2]][parts[3]](this, objName, id);
          else if (parts.length == 5)
            op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]](this, objName, id);
          else if (parts.length == 6)
            op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]](this, objName, id);
          else if (parts.length == 7)
            op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]](this, objName, id);
          else if (parts.length == 8)
            op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]](this, objName, id);
          else if (parts.length == 9)
            op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]](this, objName, id);
          else if (parts.length == 10)
            op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]](this, objName, id);
          else
            console.log("parts.length", parts.length);
        }
        if (op) {
          op.opId = null;
          for (const i in CABLES.OPS) {
            if (CABLES.OPS[i].objName == objName)
              op.opId = i;
          }
        }
      }
    } catch (e) {
      this._crashedOps.push(objName);
      this._log.error(e);
      this._log.error("[instancing error] " + objName, e);
      if (!this.isEditorMode()) {
        this.exitError("INSTANCE_ERR", "Instancing Error: " + objName, e);
        throw new Error("instancing error 1" + objName);
      }
    }
    if (op) {
      op._objName = objName;
      op.patch = this;
    } else {
      this._log.log("no op was created!?", identifier, id);
    }
    return op;
  };
  Patch.prototype.addOp = function(opIdentifier, uiAttribs, id, fromDeserialize, opName) {
    const op = this.createOp(opIdentifier, id, opName);
    if (op) {
      uiAttribs = uiAttribs || {};
      if (uiAttribs.hasOwnProperty("errors"))
        delete uiAttribs.errors;
      if (uiAttribs.hasOwnProperty("error"))
        delete uiAttribs.error;
      uiAttribs.subPatch = uiAttribs.subPatch || 0;
      op.setUiAttribs(uiAttribs);
      if (op.onCreate)
        op.onCreate();
      if (op.hasOwnProperty("onAnimFrame"))
        this.addOnAnimFrame(op);
      if (op.hasOwnProperty("onMasterVolumeChanged"))
        this._volumeListeners.push(op);
      if (this._opIdCache[op.id]) {
        this._log.warn("opid with id " + op.id + " already exists in patch!");
        this.deleteOp(op.id);
      }
      this.ops.push(op);
      this._opIdCache[op.id] = op;
      if (this._subPatchCacheAdd)
        this._subPatchCacheAdd(uiAttribs.subPatch, op);
      this.emitEvent("onOpAdd", op, fromDeserialize);
      if (op.init)
        op.init();
      op.emitEvent("init", fromDeserialize);
    } else {
      this._log.error("addop: op could not be created: ", opIdentifier);
    }
    return op;
  };
  Patch.prototype.addOnAnimFrame = function(op) {
    for (let i = 0; i < this.animFrameOps.length; i++)
      if (this.animFrameOps[i] == op) {
        return;
      }
    this.animFrameOps.push(op);
  };
  Patch.prototype.removeOnAnimFrame = function(op) {
    for (let i = 0; i < this.animFrameOps.length; i++) {
      if (this.animFrameOps[i] == op) {
        this.animFrameOps.splice(i, 1);
        return;
      }
    }
  };
  Patch.prototype.addOnAnimFrameCallback = function(cb) {
    this.animFrameCallbacks.push(cb);
  };
  Patch.prototype.removeOnAnimCallback = function(cb) {
    for (let i = 0; i < this.animFrameCallbacks.length; i++) {
      if (this.animFrameCallbacks[i] == cb) {
        this.animFrameCallbacks.splice(i, 1);
        return;
      }
    }
  };
  Patch.prototype.deleteOp = function(opid, tryRelink, reloadingOp) {
    let found = false;
    for (const i in this.ops) {
      if (this.ops[i].id == opid) {
        const op = this.ops[i];
        let reLinkP1 = null;
        let reLinkP2 = null;
        if (op) {
          found = true;
          if (tryRelink) {
            if (op.portsIn.length > 0 && op.portsIn[0].isLinked() && (op.portsOut.length > 0 && op.portsOut[0].isLinked())) {
              if (op.portsIn[0].getType() == op.portsOut[0].getType() && op.portsIn[0].links[0]) {
                reLinkP1 = op.portsIn[0].links[0].getOtherPort(op.portsIn[0]);
                reLinkP2 = op.portsOut[0].links[0].getOtherPort(op.portsOut[0]);
              }
            }
          }
          const opToDelete = this.ops[i];
          opToDelete.removeLinks();
          if (this.onDelete) {
            this._log.warn("deprecated this.onDelete", this.onDelete);
            this.onDelete(opToDelete);
          }
          this.ops.splice(i, 1);
          opToDelete.emitEvent("delete", opToDelete);
          this.emitEvent("onOpDelete", opToDelete, reloadingOp);
          if (this.clearSubPatchCache)
            this.clearSubPatchCache(opToDelete.uiAttribs.subPatch);
          if (opToDelete.onDelete)
            opToDelete.onDelete(reloadingOp);
          opToDelete.cleanUp();
          if (reLinkP1 !== null && reLinkP2 !== null) {
            this.link(reLinkP1.op, reLinkP1.getName(), reLinkP2.op, reLinkP2.getName());
          }
          delete this._opIdCache[opid];
          break;
        }
      }
    }
    if (!found)
      this._log.warn("core patch deleteop: not found...", opid);
  };
  Patch.prototype.getFrameNum = function() {
    return this._frameNum;
  };
  Patch.prototype.emitOnAnimFrameEvent = function(time, delta) {
    time = time || this.timer.getTime();
    for (let i = 0; i < this.animFrameCallbacks.length; ++i)
      if (this.animFrameCallbacks[i])
        this.animFrameCallbacks[i](time, this._frameNum, delta);
    for (let i = 0; i < this.animFrameOps.length; ++i)
      if (this.animFrameOps[i].onAnimFrame)
        this.animFrameOps[i].onAnimFrame(time, this._frameNum, delta);
  };
  Patch.prototype.renderFrame = function(timestamp) {
    this.timer.update(this.reqAnimTimeStamp);
    this.freeTimer.update(this.reqAnimTimeStamp);
    const time = this.timer.getTime();
    const startTime = performance.now();
    this.cgl.frameStartTime = this.timer.getTime();
    const delta = timestamp - this.reqAnimTimeStamp || timestamp;
    this.emitOnAnimFrameEvent(null, delta);
    this.cgl.profileData.profileFrameDelta = delta;
    this.reqAnimTimeStamp = timestamp;
    this.cgl.profileData.profileOnAnimFrameOps = performance.now() - startTime;
    this.emitEvent("onRenderFrame", time);
    this._frameNum++;
    if (this._frameNum == 1) {
      if (this.config.onFirstFrameRendered)
        this.config.onFirstFrameRendered();
    }
  };
  Patch.prototype.exec = function(timestamp) {
    if (!this._renderOneFrame && (this._paused || this.aborted))
      return;
    this.emitEvent("reqAnimFrame");
    cancelAnimationFrame(this._animReq);
    this.config.fpsLimit = this.config.fpsLimit || 0;
    if (this.config.fpsLimit) {
      this._frameInterval = 1e3 / this.config.fpsLimit;
    }
    const now2 = CABLES.now();
    const frameDelta = now2 - this._frameNext;
    if (this.isEditorMode()) {
      if (!this._renderOneFrame) {
        if (now2 - this._lastFrameTime >= 500 && this._lastFrameTime !== 0 && !this._frameWasdelayed) {
          this._lastFrameTime = 0;
          setTimeout(this.exec.bind(this), 500);
          this.emitEvent("renderDelayStart");
          this._frameWasdelayed = true;
          return;
        }
      }
    }
    if (this._renderOneFrame || this.config.fpsLimit === 0 || frameDelta > this._frameInterval || this._frameWasdelayed) {
      this.renderFrame(timestamp);
      if (this._frameInterval)
        this._frameNext = now2 - frameDelta % this._frameInterval;
    }
    if (this._frameWasdelayed) {
      this.emitEvent("renderDelayEnd");
      this._frameWasdelayed = false;
    }
    if (this._renderOneFrame) {
      if (this.onOneFrameRendered)
        this.onOneFrameRendered();
      this.emitEvent("renderedOneFrame");
      this._renderOneFrame = false;
    }
    if (this.config.doRequestAnimation)
      this._animReq = this.cgl.canvas.ownerDocument.defaultView.requestAnimationFrame(this.exec.bind(this));
  };
  Patch.prototype.link = function(op1, port1Name, op2, port2Name, lowerCase, fromDeserialize) {
    if (!op1)
      return this._log.warn("link: op1 is null ");
    if (!op2)
      return this._log.warn("link: op2 is null");
    const port1 = op1.getPort(port1Name, lowerCase);
    const port2 = op2.getPort(port2Name, lowerCase);
    if (!port1)
      return op1._log.warn("port1 not found! " + port1Name + "(" + op1.objName + ")");
    if (!port2)
      return op1._log.warn("port2 not found! " + port2Name + " of " + op2.name + "(" + op2.objName + ")", op2);
    if (!port1.shouldLink(port1, port2) || !port2.shouldLink(port1, port2))
      return false;
    if (Link.canLink(port1, port2)) {
      const link = new Link(this);
      link.link(port1, port2);
      this.emitEvent("onLink", port1, port2, link, fromDeserialize);
      return link;
    }
  };
  Patch.prototype.serialize = function(options) {
    const obj = {};
    options = options || {};
    obj.ops = [];
    obj.settings = this.settings;
    for (const i in this.ops) {
      const op = this.ops[i];
      obj.ops.push(op.getSerialized());
    }
    cleanJson(obj);
    if (options.asObject)
      return obj;
    return JSON.stringify(obj);
  };
  Patch.prototype.getOpsByRefId = function(refId) {
    const perf = CABLES.UI.uiProfiler.start("[corepatchetend] getOpsByRefId");
    const refOps = [];
    const ops = gui.corePatch().ops;
    for (let i = 0; i < ops.length; i++)
      if (ops[i].storage && ops[i].storage.ref == refId)
        refOps.push(ops[i]);
    perf.finish();
    return refOps;
  };
  Patch.prototype.getOpById = function(opid) {
    return this._opIdCache[opid];
  };
  Patch.prototype.getOpsByName = function(name2) {
    const arr = [];
    for (const i in this.ops)
      if (this.ops[i].name == name2)
        arr.push(this.ops[i]);
    return arr;
  };
  Patch.prototype.getOpsByObjName = function(name2) {
    const arr = [];
    for (const i in this.ops)
      if (this.ops[i].objName == name2)
        arr.push(this.ops[i]);
    return arr;
  };
  Patch.prototype.getOpsByOpId = function(opid) {
    const arr = [];
    for (const i in this.ops)
      if (this.ops[i].opId == opid)
        arr.push(this.ops[i]);
    return arr;
  };
  Patch.prototype.loadLib = function(which) {
    ajaxSync(
      "/ui/libs/" + which + ".js",
      (err, res) => {
        const se = document.createElement("script");
        se.type = "text/javascript";
        se.text = res;
        document.getElementsByTagName("head")[0].appendChild(se);
      },
      "GET"
    );
  };
  Patch.prototype.getSubPatchOp = function(patchId, objName) {
    for (const i in this.ops)
      if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == patchId && this.ops[i].objName == objName)
        return this.ops[i];
    return false;
  };
  Patch.prototype._addLink = function(opinid, opoutid, inName, outName) {
    return this.link(this.getOpById(opinid), inName, this.getOpById(opoutid), outName, false, true);
  };
  Patch.prototype.deSerialize = function(obj, options) {
    options = options || { "genIds": false, "createRef": false };
    if (this.aborted)
      return;
    const newOps = [];
    const loadingId = this.loading.start("core", "deserialize");
    this.namespace = obj.namespace || "";
    this.name = obj.name || "";
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    this.settings = obj.settings;
    this.emitEvent("patchLoadStart");
    if (window.logStartup)
      logStartup("add " + obj.ops.length + " ops... ");
    const addedOps = [];
    for (let iop = 0; iop < obj.ops.length; iop++) {
      const start = CABLES.now();
      const opData = obj.ops[iop];
      let op = null;
      try {
        if (opData.opId)
          op = this.addOp(opData.opId, opData.uiAttribs, opData.id, true, opData.objName);
        else
          op = this.addOp(opData.objName, opData.uiAttribs, opData.id, true);
      } catch (e) {
        this._log.error("[instancing error] op data:", opData, e);
      }
      if (op) {
        addedOps.push(op);
        if (options.genIds)
          op.id = shortId();
        op.portsInData = opData.portsIn;
        op._origData = JSON.parse(JSON.stringify(opData));
        op.storage = opData.storage;
        for (const ipi in opData.portsIn) {
          const objPort = opData.portsIn[ipi];
          if (objPort && objPort.hasOwnProperty("name")) {
            const port = op.getPort(objPort.name);
            if (port && (port.uiAttribs.display == "bool" || port.uiAttribs.type == "bool") && !isNaN(objPort.value))
              objPort.value = objPort.value == true ? 1 : 0;
            if (port && objPort.value !== void 0 && port.type != CONSTANTS2.OP.OP_PORT_TYPE_TEXTURE)
              port.set(objPort.value);
            if (port) {
              port.deSerializeSettings(objPort);
            } else {
              op.preservedPortValues = op.preservedPortValues || {};
              op.preservedPortValues[objPort.name] = objPort.value;
            }
          }
        }
        for (const ipo in opData.portsOut) {
          const objPort = opData.portsOut[ipo];
          if (objPort && objPort.hasOwnProperty("name")) {
            const port2 = op.getPort(objPort.name);
            if (port2) {
              port2.deSerializeSettings(objPort);
              if (port2.uiAttribs.hasOwnProperty("title")) {
                op.preservedPortTitles = op.preservedPortTitles || {};
                op.preservedPortTitles[port2.name] = port2.uiAttribs.title;
              }
              if (port2.type != CONSTANTS2.OP.OP_PORT_TYPE_TEXTURE && objPort.hasOwnProperty("value"))
                port2.set(obj.ops[iop].portsOut[ipo].value);
              if (objPort.expose)
                port2.setUiAttribs({ "expose": true });
            }
          }
        }
        newOps.push(op);
      }
      const timeused = Math.round(100 * (CABLES.now() - start)) / 100;
      if (!this.silent && timeused > 5)
        console.log("long op init ", obj.ops[iop].objName, timeused);
    }
    if (window.logStartup)
      logStartup("add ops done");
    for (const i in this.ops) {
      if (this.ops[i].onLoadedValueSet) {
        this.ops[i].onLoadedValueSet(this.ops[i]._origData);
        this.ops[i].onLoadedValueSet = null;
        this.ops[i]._origData = null;
      }
      this.ops[i].emitEvent("loadedValueSet");
    }
    if (window.logStartup)
      logStartup("creating links");
    if (options.opsCreated)
      options.opsCreated(addedOps);
    if (obj.ops) {
      for (let iop = 0; iop < obj.ops.length; iop++) {
        if (obj.ops[iop].portsIn) {
          for (let ipi2 = 0; ipi2 < obj.ops[iop].portsIn.length; ipi2++) {
            if (obj.ops[iop].portsIn[ipi2] && obj.ops[iop].portsIn[ipi2].links) {
              for (let ili = 0; ili < obj.ops[iop].portsIn[ipi2].links.length; ili++) {
                const l = this._addLink(
                  obj.ops[iop].portsIn[ipi2].links[ili].objIn,
                  obj.ops[iop].portsIn[ipi2].links[ili].objOut,
                  obj.ops[iop].portsIn[ipi2].links[ili].portIn,
                  obj.ops[iop].portsIn[ipi2].links[ili].portOut
                );
              }
            }
          }
        }
        if (obj.ops[iop].portsOut) {
          for (let ipi2 = 0; ipi2 < obj.ops[iop].portsOut.length; ipi2++)
            if (obj.ops[iop].portsOut[ipi2] && obj.ops[iop].portsOut[ipi2].links) {
              for (let ili = 0; ili < obj.ops[iop].portsOut[ipi2].links.length; ili++) {
                if (obj.ops[iop].portsOut[ipi2].links[ili]) {
                  if (obj.ops[iop].portsOut[ipi2].links[ili].subOpRef) {
                    const outOp = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);
                    let dstOp = null;
                    let theSubPatch = 0;
                    for (let i = 0; i < this.ops.length; i++) {
                      if (this.ops[i].storage && this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].subOpRef && outOp.uiAttribs.subPatch == this.ops[i].uiAttribs.subPatch) {
                        theSubPatch = this.ops[i].patchId.get();
                        break;
                      }
                    }
                    for (let i = 0; i < this.ops.length; i++) {
                      if (this.ops[i].storage && this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].refOp && this.ops[i].uiAttribs.subPatch == theSubPatch) {
                        dstOp = this.ops[i];
                        break;
                      }
                    }
                    if (!dstOp)
                      this._log.warn("could not find op for lost link");
                    else {
                      const l = this._addLink(
                        dstOp.id,
                        obj.ops[iop].portsOut[ipi2].links[ili].objOut,
                        obj.ops[iop].portsOut[ipi2].links[ili].portIn,
                        obj.ops[iop].portsOut[ipi2].links[ili].portOut
                      );
                    }
                  } else {
                    const l = this._addLink(obj.ops[iop].portsOut[ipi2].links[ili].objIn, obj.ops[iop].portsOut[ipi2].links[ili].objOut, obj.ops[iop].portsOut[ipi2].links[ili].portIn, obj.ops[iop].portsOut[ipi2].links[ili].portOut);
                    if (!l) {
                      const op1 = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objIn);
                      const op2 = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);
                      if (!op1)
                        console.log("could not find link op1");
                      if (!op2)
                        console.log("could not find link op2");
                      const p1Name = obj.ops[iop].portsOut[ipi2].links[ili].portIn;
                      if (op1 && !op1.getPort(p1Name)) {
                        op1.preservedPortLinks[p1Name] = op1.preservedPortLinks[p1Name] || [];
                        op1.preservedPortLinks[p1Name].push(obj.ops[iop].portsOut[ipi2].links[ili]);
                      }
                      const p2Name = obj.ops[iop].portsOut[ipi2].links[ili].portOut;
                      if (op2 && !op2.getPort(p2Name)) {
                        op2.preservedPortLinks[p1Name] = op2.preservedPortLinks[p1Name] || [];
                        op2.preservedPortLinks[p1Name].push(obj.ops[iop].portsOut[ipi2].links[ili]);
                      }
                    }
                  }
                }
              }
            }
        }
      }
    }
    if (window.logStartup)
      logStartup("calling ops onloaded");
    for (const i in this.ops) {
      if (this.ops[i].onLoaded) {
        this.ops[i].onLoaded();
        this.ops[i].onLoaded = null;
      }
    }
    if (window.logStartup)
      logStartup("initializing ops...");
    for (const i in this.ops) {
      if (this.ops[i].init) {
        try {
          this.ops[i].init();
          this.ops[i].init = null;
        } catch (e) {
          console.error("op.init crash", e);
        }
      }
    }
    if (window.logStartup)
      logStartup("initializing vars...");
    if (this.config.variables)
      for (const varName in this.config.variables)
        this.setVarValue(varName, this.config.variables[varName]);
    if (window.logStartup)
      logStartup("initializing var ports");
    for (const i in this.ops) {
      this.ops[i].initVarPorts();
      delete this.ops[i].uiAttribs.pasted;
    }
    setTimeout(() => {
      this.loading.finished(loadingId);
    }, 100);
    if (this.config.onPatchLoaded)
      this.config.onPatchLoaded(this);
    this.deSerialized = true;
    this.emitEvent("patchLoadEnd", newOps, obj, options.genIds);
  };
  Patch.prototype.profile = function(enable) {
    this.profiler = new Profiler(this);
    for (const i in this.ops) {
      this.ops[i].profile(enable);
    }
  };
  Patch.prototype.setVariable = function(name2, val) {
    if (this._variables[name2] !== void 0) {
      this._variables[name2].setValue(val);
    } else {
      this._log.warn("variable " + name2 + " not found!");
    }
  };
  Patch.prototype._sortVars = function() {
    if (!this.isEditorMode())
      return;
    const ordered = {};
    Object.keys(this._variables).sort(
      (a, b) => {
        return a.localeCompare(b, "en", { "sensitivity": "base" });
      }
    ).forEach((key) => {
      ordered[key] = this._variables[key];
    });
    this._variables = ordered;
  };
  Patch.prototype.hasVar = function(name2) {
    return this._variables[name2] !== void 0;
  };
  Patch.prototype.setVarValue = function(name2, val, type) {
    if (this.hasVar(name2)) {
      this._variables[name2].setValue(val);
    } else {
      this._variables[name2] = new core_variable(name2, val, type);
      this._sortVars();
      this.emitEvent("variablesChanged");
    }
    return this._variables[name2];
  };
  Patch.prototype.getVarValue = function(name2, val) {
    if (this._variables.hasOwnProperty(name2))
      return this._variables[name2].getValue();
  };
  Patch.prototype.getVar = function(name2) {
    if (this._variables.hasOwnProperty(name2))
      return this._variables[name2];
  };
  Patch.prototype.deleteVar = function(name2) {
    for (let i = 0; i < this.ops.length; i++)
      for (let j = 0; j < this.ops[i].portsIn.length; j++)
        if (this.ops[i].portsIn[j].getVariableName() == name2)
          this.ops[i].portsIn[j].setVariable(null);
    delete this._variables[name2];
    this.emitEvent("variableDeleted", name2);
    this.emitEvent("variablesChanged");
  };
  Patch.prototype.getVars = function(t) {
    if (t === void 0)
      return this._variables;
    const vars = [];
    if (t == CABLES.OP_PORT_TYPE_STRING)
      t = "string";
    if (t == CABLES.OP_PORT_TYPE_VALUE)
      t = "number";
    if (t == CABLES.OP_PORT_TYPE_ARRAY)
      t = "array";
    if (t == CABLES.OP_PORT_TYPE_OBJECT)
      t = "object";
    for (const i in this._variables) {
      if (!this._variables[i].type || this._variables[i].type == t)
        vars.push(this._variables[i]);
    }
    return vars;
  };
  Patch.prototype.exitError = function(errorId, errorMessage, ex) {
    this.aborted = true;
    if (this && this.config && this.config.onError) {
      this.config.onError(errorId, errorMessage);
    } else {
      if (!this.isEditorMode()) {
        const newDiv = document.createElement("div");
        const rect = this.cgl.canvas.getBoundingClientRect();
        newDiv.setAttribute("style", "position:absolute;border:5px solid red;padding:15px;background-color:black;color:white;font-family:monospace;");
        newDiv.style.top = rect.top + "px";
        newDiv.style.left = rect.left + "px";
        let str = "cables - An error occured:<br/>";
        str += "[" + errorId + "] - " + errorMessage;
        if (ex)
          str += "<br/>Exception: " + ex.message;
        newDiv.innerHTML = str;
        console.log(ex);
        const pe = this.cgl.canvas.parentElement;
        while (pe.hasChildNodes())
          pe.removeChild(pe.lastChild);
        document.body.appendChild(newDiv);
      }
    }
  };
  Patch.prototype.preRenderOps = function() {
    this._log.log("prerendering...");
    for (let i = 0; i < this.ops.length; i++) {
      if (this.ops[i].preRender) {
        this.ops[i].preRender();
        this._log.log("prerender " + this.ops[i].objName);
      }
    }
  };
  Patch.prototype.dispose = function() {
    this.pause();
    this.clear();
    this.cgl.dispose();
  };
  Patch.prototype.pushTriggerStack = function(p) {
    this._triggerStack.push(p);
  };
  Patch.prototype.popTriggerStack = function() {
    this._triggerStack.pop();
  };
  Patch.prototype.printTriggerStack = function() {
    if (this._triggerStack.length == 0) {
      return;
    }
    console.groupCollapsed(
      // eslint-disable-line
      "trigger port stack " + this._triggerStack[this._triggerStack.length - 1].op.objName + "." + this._triggerStack[this._triggerStack.length - 1].name
    );
    const rows = [];
    for (let i = 0; i < this._triggerStack.length; i++) {
      rows.push(i + ". " + this._triggerStack[i].op.objName + " " + this._triggerStack[i].name);
    }
    console.table(rows);
    console.groupEnd();
  };
  Patch.prototype.getDocument = function() {
    return this.cgl.canvas.ownerDocument;
  };
  Patch.replaceOpIds = function(json, options) {
    const opids = {};
    for (const i in json.ops) {
      opids[json.ops[i].id] = json.ops[i];
    }
    for (const j in json.ops) {
      for (const k in json.ops[j].portsOut) {
        const links = json.ops[j].portsOut[k].links;
        if (links) {
          let l = links.length;
          while (l--) {
            if (links[l] && (!opids[links[l].objIn] || !opids[links[l].objOut])) {
              if (!options.doNotUnlinkLostLinks) {
                links.splice(l, 1);
              } else {
                if (options.fixLostLinks) {
                  const op = gui.corePatch().getOpById(links[l].objIn);
                  if (!op)
                    console.log("op not found!");
                  else {
                    const outerOp = gui.patchView.getSubPatchOuterOp(op.uiAttribs.subPatch);
                    if (outerOp) {
                      op.storage = op.storage || {};
                      op.storage.ref = op.storage.ref || CABLES.shortId();
                      links[l].refOp = op.storage.ref;
                      links[l].subOpRef = outerOp.storage.ref;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    for (const i in json.ops) {
      const op = json.ops[i];
      const oldId = op.id;
      let newId = CABLES.shortId();
      if (options.prefixHash)
        newId = prefixedHash(options.prefixHash + oldId);
      else if (options.prefixId)
        newId = options.prefixId + oldId;
      else if (options.refAsId) {
        if (op.storage && op.storage.ref) {
          newId = op.storage.ref;
          delete op.storage.ref;
        } else {
          op.storage = op.storage || {};
          op.storage.ref = newId = CABLES.shortId();
        }
      }
      const newID = op.id = newId;
      if (options.oldIdAsRef) {
        op.storage = op.storage || {};
        op.storage.ref = oldId;
      }
      for (const j in json.ops) {
        if (json.ops[j].portsIn)
          for (const k in json.ops[j].portsIn) {
            if (json.ops[j].portsIn[k].links) {
              let l = json.ops[j].portsIn[k].links.length;
              while (l--)
                if (json.ops[j].portsIn[k].links[l] === null)
                  json.ops[j].portsIn[k].links.splice(l, 1);
              for (l in json.ops[j].portsIn[k].links) {
                if (json.ops[j].portsIn[k].links[l].objIn === oldId)
                  json.ops[j].portsIn[k].links[l].objIn = newID;
                if (json.ops[j].portsIn[k].links[l].objOut === oldId)
                  json.ops[j].portsIn[k].links[l].objOut = newID;
              }
            }
          }
        if (json.ops[j].portsOut)
          for (const k in json.ops[j].portsOut) {
            if (json.ops[j].portsOut[k].links) {
              let l = json.ops[j].portsOut[k].links.length;
              while (l--)
                if (json.ops[j].portsOut[k].links[l] === null)
                  json.ops[j].portsOut[k].links.splice(l, 1);
              for (l in json.ops[j].portsOut[k].links) {
                if (json.ops[j].portsOut[k].links[l].objIn === oldId)
                  json.ops[j].portsOut[k].links[l].objIn = newID;
                if (json.ops[j].portsOut[k].links[l].objOut === oldId)
                  json.ops[j].portsOut[k].links[l].objOut = newID;
              }
            }
          }
      }
    }
    const subpatchIds = [];
    const fixedSubPatches = [];
    for (let i = 0; i < json.ops.length; i++) {
      if (json.ops[i].storage && json.ops[i].storage.subPatchVer) {
        for (const k in json.ops[i].portsIn) {
          if (json.ops[i].portsIn[k].name === "patchId") {
            let newId = shortId();
            if (options.prefixHash)
              newId = prefixedHash(options.prefixHash + json.ops[i].portsIn[k].value);
            const oldSubPatchId = json.ops[i].portsIn[k].value;
            const newSubPatchId = json.ops[i].portsIn[k].value = newId;
            subpatchIds.push(newSubPatchId);
            for (let j = 0; j < json.ops.length; j++) {
              if (json.ops[j].uiAttribs) {
                if (json.ops[j].uiAttribs.subPatch === oldSubPatchId) {
                  json.ops[j].uiAttribs.subPatch = newSubPatchId;
                  fixedSubPatches.push(json.ops[j].id);
                }
              }
            }
          }
        }
      }
    }
    for (const kk in json.ops) {
      let found = false;
      for (let j = 0; j < fixedSubPatches.length; j++) {
        if (json.ops[kk].id === fixedSubPatches[j]) {
          found = true;
          break;
        }
      }
      if (!found && json.ops[kk].uiAttribs && options.parentSubPatchId != null)
        json.ops[kk].uiAttribs.subPatch = options.parentSubPatchId;
    }
    return json;
  };
  const core_patch = Patch;
  ;
  const EMBED = {};
  EMBED.addPatch = function(_element, options) {
    let el = _element;
    let id = generateUUID();
    if (typeof _element == "string") {
      id = _element;
      el = document.getElementById(id);
      if (!el) {
        console.error(id + " Polyshape Container Element not found!");
        return;
      }
    }
    const canvEl = document.createElement("canvas");
    canvEl.id = "glcanvas_" + id;
    canvEl.width = el.clientWidth;
    canvEl.height = el.clientHeight;
    window.addEventListener(
      "resize",
      function() {
        this.setAttribute("width", el.clientWidth);
        this.height = el.clientHeight;
      }.bind(canvEl)
    );
    el.appendChild(canvEl);
    options = options || {};
    options.glCanvasId = canvEl.id;
    if (!options.onError) {
      options.onError = function(err) {
        console.error(err);
      };
    }
    CABLES.patch = new core_patch(options);
    return canvEl;
  };
  ;
  const WEBAUDIO = {};
  WEBAUDIO.toneJsInitialized = false;
  WEBAUDIO.createAudioContext = function(op) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    if (window.AudioContext) {
      if (!window.audioContext) {
        window.audioContext = new AudioContext();
      }
      if (window.Tone && !WEBAUDIO.toneJsInitialized) {
        Tone.setContext(window.audioContext);
        WEBAUDIO.toneJsInitialized = true;
      }
    } else {
      op.patch.config.onError("NO_WEBAUDIO", "Web Audio is not supported in this browser.");
      return;
    }
    return window.audioContext;
  };
  WEBAUDIO.getAudioContext = function() {
    return window.audioContext;
  };
  WEBAUDIO.createAudioInPort = function(op, portName, audioNode, inputChannelIndex) {
    if (!op || !portName || !audioNode) {
      const msg = "ERROR: createAudioInPort needs three parameters, op, portName and audioNode";
      op.log(msg);
      throw new Error(msg);
    }
    if (!inputChannelIndex) {
      inputChannelIndex = 0;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    const port = op.inObject(portName);
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;
    op.webAudio.audioInPorts[portName] = port;
    port.onChange = function() {
      const audioInNode = port.get();
      if (!audioInNode) {
        if (port.webAudio.previousAudioInNode) {
          try {
            if (port.webAudio.previousAudioInNode.disconnect)
              port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode, 0, inputChannelIndex);
            op.setUiError("audioCtx", null);
          } catch (e) {
            try {
              port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode);
            } catch (er) {
              op.log(
                "Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work ",
                e
              );
              if (e.printStackTrace) {
                e.printStackTrace();
              }
              throw e;
            }
          }
        }
      } else {
        try {
          if (audioInNode.connect) {
            audioInNode.connect(port.webAudio.audioNode, 0, inputChannelIndex);
            op.setUiError("audioCtx", null);
          } else
            op.setUiError("audioCtx", "The passed input is not an audio context. Please make sure you connect an audio context to the input.", 2);
        } catch (e) {
          op.log("Error: Failed to connect web audio node!", e);
          op.log("port.webAudio.audioNode", port.webAudio.audioNode);
          op.log("audioInNode: ", audioInNode);
          op.log("inputChannelIndex:", inputChannelIndex);
          op.log("audioInNode.connect: ", audioInNode.connect);
          throw e;
        }
      }
      port.webAudio.previousAudioInNode = audioInNode;
    };
    return port;
  };
  WEBAUDIO.replaceNodeInPort = function(port, oldNode, newNode) {
    const connectedNode = port.webAudio.previousAudioInNode;
    if (connectedNode && connectedNode.disconnect) {
      try {
        connectedNode.disconnect(oldNode);
      } catch (e) {
        if (e.printStackTrace) {
          e.printStackTrace();
        }
        throw new Error("replaceNodeInPort: Could not disconnect old audio node. " + e.name + " " + e.message);
      }
      port.webAudio.audioNode = newNode;
      try {
        connectedNode.connect(newNode);
      } catch (e) {
        if (e.printStackTrace) {
          e.printStackTrace();
        }
        throw new Error("replaceNodeInPort: Could not connect to new node. " + e.name + " " + e.message);
      }
    }
  };
  WEBAUDIO.createAudioOutPort = function(op, portName, audioNode) {
    if (!op || !portName || !audioNode) {
      const msg = "ERROR: createAudioOutPort needs three parameters, op, portName and audioNode";
      op.log(msg);
      throw new Error(msg);
    }
    const port = op.outObject(portName);
    port.set(audioNode);
    return port;
  };
  WEBAUDIO.createAudioParamInPort = function(op, portName, audioNode, options, defaultValue) {
    if (!op || !portName || !audioNode) {
      op.log("ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode");
      if (op && op.name)
        op.log("opname: ", op.name);
      op.log("portName", portName);
      op.log("audioNode: ", audioNode);
      return;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    const port = op.inDynamic(
      portName,
      [CONSTANTS2.OP.OP_PORT_TYPE_VALUE, CONSTANTS2.OP.OP_PORT_TYPE_OBJECT],
      options,
      defaultValue
    );
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;
    op.webAudio.audioInPorts[portName] = port;
    port.onChange = function() {
      const audioInNode = port.get();
      const node = port.webAudio.audioNode;
      const audioCtx = WEBAUDIO.getAudioContext();
      if (audioInNode != void 0) {
        if (typeof audioInNode === "object" && audioInNode.connect) {
          try {
            audioInNode.connect(node);
          } catch (e) {
            op.log("Could not connect audio node: ", e);
            if (e.printStackTrace) {
              e.printStackTrace();
            }
            throw e;
          }
          port.webAudio.previousAudioInNode = audioInNode;
        } else {
          if (node._param && node._param.minValue && node._param.maxValue) {
            if (audioInNode >= node._param.minValue && audioInNode <= node._param.maxValue) {
              try {
                if (node.setValueAtTime) {
                  node.setValueAtTime(audioInNode, audioCtx.currentTime);
                } else {
                  node.value = audioInNode;
                }
              } catch (e) {
                op.log("Possible AudioParam problem with tone.js op: ", e);
                if (e.printStackTrace) {
                  e.printStackTrace();
                }
                throw e;
              }
            } else {
              op.log("Warning: The value for an audio parameter is out of range!");
            }
          } else if (node.minValue && node.maxValue) {
            if (audioInNode >= node.minValue && audioInNode <= node.maxValue) {
              try {
                if (node.setValueAtTime) {
                  node.setValueAtTime(audioInNode, audioCtx.currentTime);
                } else {
                  node.value = audioInNode;
                }
              } catch (e) {
                op.log(
                  "AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! ",
                  e
                );
                if (e.printStackTrace) {
                  e.printStackTrace();
                }
                throw e;
              }
            } else {
              op.log("Warning: The value for an audio parameter is out of range!");
            }
          } else {
            try {
              if (node.setValueAtTime) {
                node.setValueAtTime(audioInNode, audioCtx.currentTime);
              } else {
                node.value = audioInNode;
              }
            } catch (e) {
              op.log("Possible AudioParam problem (without minValue / maxValue): ", e);
              if (e.printStackTrace) {
                e.printStackTrace();
              }
              throw e;
            }
          }
          if (port.webAudio.previousAudioInNode && port.webAudio.previousAudioInNode.disconnect) {
            try {
              port.webAudio.previousAudioInNode.disconnect(node);
            } catch (e) {
              op.log("Could not disconnect previous audio node: ", e);
              throw e;
            }
            port.webAudio.previousAudioInNode = void 0;
          }
        }
      } else {
        if (port.webAudio.previousAudioInNode) {
        }
      }
    };
    return port;
  };
  WEBAUDIO.loadAudioFile = function(patch, url, onFinished, onError, loadingTask) {
    const audioContext = WEBAUDIO.createAudioContext();
    if (!audioContext)
      onError(new Error("No Audiocontext"));
    let loadingId = null;
    if (loadingTask || loadingTask === void 0) {
      loadingId = patch.loading.start("audio", url);
      if (patch.isEditorMode())
        gui.jobs().start({ "id": "loadaudio" + loadingId, "title": " loading audio (" + url + ")" });
    }
    const request2 = new XMLHttpRequest();
    if (!url)
      return;
    request2.open("GET", url, true);
    request2.responseType = "arraybuffer";
    request2.onload = function() {
      patch.loading.finished(loadingId);
      if (patch.isEditorMode())
        gui.jobs().finish("loadaudio" + loadingId);
      audioContext.decodeAudioData(request2.response, onFinished, onError).catch((e) => {
        onError(e);
      });
    };
    request2.send();
  };
  WEBAUDIO.isValidToneTime = function(t) {
    try {
      const time = new Tone.Time(t);
    } catch (e) {
      return false;
    }
    return true;
  };
  WEBAUDIO.isValidToneNote = function(note) {
    try {
      Tone.Frequency(note);
    } catch (e) {
      return false;
    }
    return true;
  };
  ;
  const Variable = function() {
    let value = null;
    const changedCallbacks = [];
    this.onChanged = function(f) {
      changedCallbacks.push(f);
    };
    this.getValue = function() {
      return value;
    };
    this.setValue = function(v) {
      value = v;
      this.emitChanged();
    };
    this.emitChanged = function() {
      for (let i = 0; i < changedCallbacks.length; i++) {
        changedCallbacks[i]();
      }
    };
  };
  ;
  class Branch {
    constructor(name2) {
      this.name = name2;
      this.dur = 0;
      this._startTime = 0;
      this.childs = [];
    }
    start() {
      this._startTime = performance.now();
    }
    end() {
      this.dur = performance.now() - this._startTime;
    }
    push(name2) {
      const b = new Branch(name2);
      this.childs.push(b);
      b.start();
      return b;
    }
    print(level) {
      level = level || 0;
      let str = "";
      for (let i = 0; i < level; i++)
        str += "  ";
      for (let i = 0; i < this.childs.length; i++) {
        this.childs[i].print(level + 1);
      }
    }
  }
  class BranchStack {
    constructor() {
    }
    start() {
      this.root = new Branch("Root");
      this.root.start();
      this.current = this.root;
    }
    push(name2) {
      if (!this.current)
        this.start();
      const prev = this.current;
      this.current = this.current.push(name2);
      this.current.prev = prev;
      this.current.start();
      return this.current;
    }
    pop() {
      if (!this.current)
        return;
      this.current.end();
      this.current = this.current.prev;
    }
    finish() {
      this.current.end();
      this.root.print();
      this.current = null;
    }
  }
  ;
  class cgp_uniform_Uniform extends cg_uniform {
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName) {
      super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);
      this._loc = -1;
      this._cgl = __shader._cgl;
    }
    updateValueF() {
    }
    setValueF(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValue2F() {
    }
    setValue2F(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValue3F() {
    }
    setValue3F(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    updateValue4F() {
    }
    setValue4F(v) {
      this.needsUpdate = true;
      this._value = v;
    }
    getSizeBytes() {
      if (this._type == "f")
        return 1 * 4;
      if (this._type == "i")
        return 1 * 4;
      if (this._type == "2i")
        return 2 * 4;
      if (this._type == "2f")
        return 2 * 4;
      if (this._type == "3f")
        return 3 * 4;
      if (this._type == "4f")
        return 4 * 4;
      if (this._type == "m4")
        return 4 * 4 * 4;
      this._log.warn("unknown type getSizeBytes");
    }
  }
  ;
  class cgp_shader_Shader {
    constructor(_cgp, _name) {
      if (!_cgp)
        throw new Error("shader constructed without cgp " + _name);
      this._log = new Logger("cgp_shader");
      this._cgp = _cgp;
      this._name = _name;
      this._uniforms = [];
      if (!_name)
        this._log.stack("no shader name given");
      this._name = _name || "unknown";
      this.id = simpleId();
      this._isValid = true;
      this._compileReason = "";
      this.shaderModule = null;
      this._needsRecompile = true;
      this._src = "";
    }
    get isValid() {
      return this._isValid;
    }
    get uniforms() {
      return this._uniforms;
    }
    getName() {
      return this._name;
    }
    setWhyCompile(why) {
      this._compileReason = why;
    }
    setSource(src) {
      this._src = src;
      this.setWhyCompile("Source changed");
      this._needsRecompile = true;
    }
    compile() {
      this._isValid = true;
      console.log("compiling shader...", this._compileReason);
      this._cgp.pushErrorScope();
      this.shaderModule = this._cgp.device.createShaderModule({ "code": this._src });
      this._cgp.popErrorScope("cgp_shader " + this._name, this.error.bind(this));
      this._needsRecompile = false;
    }
    error(e) {
      this._isValid = false;
    }
    bind() {
      let sizes = {};
      for (let i = 0; i < this._uniforms.length; i++) {
      }
      if (this._needsRecompile)
        this.compile();
    }
    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformFrag
     * @returns {Uniform}
     */
    addUniformFrag(type, name2, valueOrPort, p2, p3, p4) {
      const uni = new cgp_uniform_Uniform(this, type, name2, valueOrPort, p2, p3, p4);
      uni.shaderType = "frag";
      return uni;
    }
    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformVert
     * @returns {Uniform}
     */
    addUniformVert(type, name2, valueOrPort, p2, p3, p4) {
      const uni = new cgp_uniform_Uniform(this, type, name2, valueOrPort, p2, p3, p4);
      uni.shaderType = "vert";
      return uni;
    }
    /**
     * add a uniform to all shader programs
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniform
     * @returns {Uniform}
     */
    addUniform(type, name2, valueOrPort, p2, p3, p4) {
      const uni = new cgp_uniform_Uniform(this, type, name2, valueOrPort, p2, p3, p4);
      uni.shaderType = "both";
      return uni;
    }
    _addUniform(uni) {
      this._uniforms.push(uni);
      this.setWhyCompile("add uniform " + name);
      this._needsRecompile = true;
    }
  }
  ;
  const cgl_shader_default = "struct VSUniforms\n{\n    modelMatrix: mat4x4<f32>,\n    viewMatrix: mat4x4<f32>,\n    projMatrix: mat4x4<f32>,\n};\n\nstruct FSUniforms\n{\n    color:vec4<f32>\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\n\nstruct MyVSInput\n{\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @location(2) texcoord: vec2<f32>,\n};\n\nstruct MyVSOutput\n{\n    @builtin(position) position: vec4<f32>,\n    @location(0) normal: vec3<f32>,\n    @location(1) texcoord: vec2<f32>,\n};\n\n@vertex\nfn myVSMain(v: MyVSInput) -> MyVSOutput\n{\n    var vsOut: MyVSOutput;\n    var pos =vec4<f32>(v.position, 1.0);\n\n    var mvMatrix=vsUniforms.viewMatrix * vsUniforms.modelMatrix;\n    vsOut.position = vsUniforms.projMatrix * mvMatrix * pos;\n\n    vsOut.normal = v.normal;\n    vsOut.texcoord = v.texcoord;\n    return vsOut;\n}\n\n@fragment\nfn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>\n{\n    return fsUniforms.color+vec4<f32>(.5,.5,.5,1.0);\n}\n\n";
  ;
  class WebGpuContext extends CGState {
    constructor(_patch) {
      super();
      this.patch = _patch;
      this.gApi = CG.GAPI_WEBGPU;
      this._viewport = [0, 0, 256, 256];
      this._shaderStack = [];
      this._simpleShader = null;
      this._stackCullFaceFacing = [];
      this._stackDepthTest = [];
      this._stackCullFace = [];
      this._stackDepthFunc = [];
      this._stackDepthWrite = [];
      this.DEPTH_FUNCS = [
        "never",
        "always",
        "less",
        "less-equal",
        "greater",
        "greater-equal",
        "equal",
        "not-equal"
      ];
      this.CULL_MODES = [
        "none",
        "back",
        "front",
        "none"
        // both does not exist in webgpu
      ];
    }
    /// ////////////////////
    getViewPort() {
      return [0, 0, this.canvasWidth, this.canvasHeight];
    }
    renderStart(cgp, identTranslate, identTranslateView) {
      if (!this._simpleShader) {
        this._simpleShader = new cgp_shader_Shader(this, "simple default shader");
        this._simpleShader.setSource(cgl_shader_default);
        this._simpleShader.addUniformFrag("4f", "color", 1, 1, 0, 1);
      }
      this.fpsCounter.startFrame();
      this._startMatrixStacks(identTranslate, identTranslateView);
      this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);
      this.pushShader(this._simpleShader);
      this.pushDepthTest(true);
      this.pushDepthWrite(true);
      this.pushDepthFunc("less-equal");
      this.emitEvent("beginFrame");
    }
    renderEnd() {
      this._endMatrixStacks();
      this.popShader();
      this.popDepthFunc();
      this.popDepthWrite();
      this.popDepthTest();
      this.emitEvent("endFrame");
      this.fpsCounter.endFrame();
    }
    setViewPort(x, y, w, h) {
      this._viewport = [x, y, w, h];
    }
    /**
     * @function getViewPort
     * @memberof Context
     * @instance
     * @description get current gl viewport
     * @returns {Array} array [x,y,w,h]
     */
    getViewPort() {
      return this._viewPort;
    }
    createMesh(geom, glPrimitive) {
      return new CGP.Mesh(this, geom, glPrimitive);
    }
    getShader() {
      return {};
    }
    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
    */
    pushShader(shader) {
      this._shaderStack.push(shader);
    }
    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    popShader() {
      if (this._shaderStack.length === 0)
        throw new Error("Invalid shader stack pop!");
      this._shaderStack.pop();
    }
    getShader() {
      return this._shaderStack[this._shaderStack.length - 1];
    }
    pushErrorScope() {
      this.device.pushErrorScope("validation");
    }
    popErrorScope(name2, cb) {
      this.device.popErrorScope().then((error) => {
        if (error) {
          this.patch.emitEvent("criticalError", { "title": 'WebGPU error "' + name2 + '"', "codeText": error.message });
          console.warn("[cgp]", name2, error.message, error, cb);
          if (cb)
            cb(error);
        }
      });
    }
    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthTest(b) {
      this._stackDepthTest.push(b);
    }
    /**
     * current state of depth testing
     * @function stateDepthTest
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest() {
      return this._stackDepthTest[this._stackDepthTest.length - 1];
    }
    /**
     * pop depth testing state
     * @function popDepthTest
     * @memberof Context
     * @instance
     */
    popDepthTest() {
      this._stackDepthTest.pop();
    }
    // --------------------------------------
    // state depthwrite
    /**
     * push depth write enabled state
     * @function pushDepthWrite
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(b) {
      b = b || false;
      this._stackDepthWrite.push(b);
    }
    /**
     * current state of depth writing
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite() {
      return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }
    /**
     * pop depth writing state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popDepthWrite() {
      this._stackDepthWrite.pop();
    }
    // --------------------------------------
    // state depthfunc
    /**
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {string} f depth compare func
     */
    pushDepthFunc(f) {
      this._stackDepthFunc.push(f);
    }
    /**
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {string}
     */
    stateDepthFunc() {
      if (this._stackDepthFunc.length > 0)
        return this._stackDepthFunc[this._stackDepthFunc.length - 1];
      return false;
    }
    /**
     * pop depth compare func
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc() {
      this._stackDepthFunc.pop();
    }
    // --------------------------------------
    // state CullFace
    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(b) {
      this._stackCullFace.push(b);
    }
    /**
     * current state of face culling
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFace() {
      return this._stackCullFace[this._stackCullFace.length - 1];
    }
    /**
    * pop face culling enabled state
    * @function popCullFace
    * @memberof Context
    * @instance
    */
    popCullFace() {
      this._stackCullFace.pop();
    }
    // --------------------------------------
    // state CullFace Facing
    /**
     * push face culling face side
     * @function pushCullFaceFacing
     * @memberof Context
     * @param b
     * @instance
     */
    pushCullFaceFacing(b) {
      this._stackCullFaceFacing.push(b);
    }
    /**
     * current state of face culling side
     * @function stateCullFaceFacing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFaceFacing() {
      return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }
    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing() {
      this._stackCullFaceFacing.pop();
    }
  }
  ;
  class UniformBuffer {
    constructor(shader, shaderType) {
      this._shaderType = shaderType;
      this._shader = shader;
      this._cgp = shader._cgp;
      this._gpuBuffer = null;
      this._values = null;
      this._sizeBytes = 0;
      this.update();
    }
    update() {
      this._sizeBytes = 0;
      for (let i = 0; i < this._shader.uniforms.length; i++) {
        const uni = this._shader.uniforms[i];
        if (this._shaderType == uni.shaderType)
          this._sizeBytes += uni.getSizeBytes();
      }
      this._gpuBuffer = this._cgp.device.createBuffer(
        {
          "size": this._sizeBytes,
          "usage": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        }
      );
      this._values = new Float32Array(this._sizeBytes / 4);
      this.updateUniformValues();
    }
    updateUniformValues() {
      let count = 0;
      for (let i = 0; i < this._shader.uniforms.length; i++) {
        const uni = this._shader.uniforms[i];
        if (uni.shaderType == this._shaderType) {
          if (uni.getSizeBytes() / 4 > 1) {
            for (let j = 0; j < uni.getValue().length; j++) {
              this._values[count] = uni.getValue()[j];
              count++;
            }
          } else {
            this._values[count] = uni.getValue();
            count++;
          }
        }
      }
      this._cgp.device.queue.writeBuffer(
        this._gpuBuffer,
        0,
        this._values.buffer,
        this._values.byteOffset,
        this._values.byteLength
      );
    }
  }
  ;
  class Pipeline {
    constructor(_cgp, _name) {
      if (!_cgp)
        throw new Error("Pipeline constructed without cgp " + _name);
      this._cgp = _cgp;
      this._isValid = true;
      this._pipeCfg = null;
      this._renderPipeline = null;
      this._fsUniformBuffer = null;
      this._vsUniformBuffer = null;
      this._old = {};
      this.DEPTH_COMPARE_FUNCS_STRINGS = [
        "never",
        "less",
        "equal",
        "lessequal",
        "greater",
        "notequal",
        "greaterequal",
        "always"
      ];
    }
    get isValid() {
      return this._isValid;
    }
    setPipeline(shader, mesh) {
      if (!mesh || !shader) {
        console.log("pipeline unknown shader/mesh");
        return;
      }
      let needsRebuild = !this._renderPipeline || !this._pipeCfg || this._old.mesh != mesh || this._old.shader != shader || mesh.needsPipelineUpdate || shader.needsPipelineUpdate;
      if (this._pipeCfg) {
        if (this._pipeCfg.depthStencil.depthWriteEnabled != this._cgp.stateDepthWrite()) {
          needsRebuild = true;
          this._pipeCfg.depthStencil.depthWriteEnabled = this._cgp.stateDepthWrite();
        }
        if (this._cgp.stateDepthTest() === false) {
          if (this._pipeCfg.depthStencil.depthCompare != "never") {
            this._pipeCfg.depthStencil.depthCompare = "never";
            needsRebuild = true;
          }
        } else if (this._pipeCfg.depthStencil.depthCompare != this._cgp.stateDepthFunc()) {
          needsRebuild = true;
          this._pipeCfg.depthStencil.depthCompare = this._cgp.stateDepthFunc();
        }
        if (this._cgp.stateCullFace() === false) {
          if (this._pipeCfg.primitive.cullMode != "none") {
            needsRebuild = true;
            this._pipeCfg.primitive.cullMode = "none";
          }
        } else {
          needsRebuild = true;
          this._pipeCfg.primitive.cullMode = this._cgp.stateCullFaceFacing();
        }
      }
      if (needsRebuild) {
        if (!this._pipeCfg || this._old.shader != shader)
          this._pipeCfg = this.getPiplelineObject(shader, mesh);
        this._old.shader = shader;
        this._old.mesh = mesh;
        this._renderPipeline = this._cgp.device.createRenderPipeline(this._pipeCfg);
        this._bindUniforms(shader);
      }
      if (this._renderPipeline && this._isValid) {
        mat4.copy(this._matModel, this._cgp.mMatrix);
        mat4.copy(this._matView, this._cgp.vMatrix);
        mat4.copy(this._matProj, this._cgp.pMatrix);
        this._cgp.device.queue.writeBuffer(
          this._vsUniformBuffer,
          0,
          this._vsUniformValues.buffer,
          this._vsUniformValues.byteOffset,
          this._vsUniformValues.byteLength
        );
        this._uniBufFrag.updateUniformValues();
        this._cgp.passEncoder.setPipeline(this._renderPipeline);
        this._cgp.passEncoder.setBindGroup(0, this._bindGroup);
      }
    }
    getPiplelineObject(shader, mesh) {
      const pipeCfg = {
        "layout": "auto",
        "vertex": {
          "module": shader.shaderModule,
          "entryPoint": "myVSMain",
          "buffers": [
            // position
            {
              "arrayStride": 3 * 4,
              // 3 floats, 4 bytes each
              "attributes": [
                { "shaderLocation": 0, "offset": 0, "format": "float32x3" }
              ]
            },
            // normals
            {
              "arrayStride": 3 * 4,
              // 3 floats, 4 bytes each
              "attributes": [
                { "shaderLocation": 1, "offset": 0, "format": "float32x3" }
              ]
            },
            // texcoords
            {
              "arrayStride": 2 * 4,
              // 2 floats, 4 bytes each
              "attributes": [
                { "shaderLocation": 2, "offset": 0, "format": "float32x2" }
              ]
            }
          ]
        },
        "fragment": {
          "module": shader.shaderModule,
          "entryPoint": "myFSMain",
          "targets": [
            { "format": this._cgp.presentationFormat }
          ]
        },
        "primitive": {
          "topology": "triangle-list",
          "cullMode": "back"
          // back/none/front
          // "point-list",
          // "line-list",
          // "line-strip",
          // "triangle-list",
          // "triangle-strip"
        },
        "depthStencil": {
          "depthWriteEnabled": true,
          "depthCompare": "less",
          "format": "depth24plus"
        }
      };
      return pipeCfg;
    }
    _bindUniforms(shader) {
      this._cgp.pushErrorScope();
      const counts = {};
      this._uniBufFrag = new UniformBuffer(shader, "frag");
      const vUniformBufferSize = 3 * 16 * 4;
      this._vsUniformBuffer = this._cgp.device.createBuffer({
        "size": vUniformBufferSize,
        "usage": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this._vsUniformValues = new Float32Array(vUniformBufferSize / 4);
      this._matModel = this._vsUniformValues.subarray(0, 16);
      this._matView = this._vsUniformValues.subarray(16, 32);
      this._matProj = this._vsUniformValues.subarray(32, 48);
      this._bindGroup = this._cgp.device.createBindGroup(
        {
          "layout": this._renderPipeline.getBindGroupLayout(0),
          "entries": [
            { "binding": 0, "resource": { "buffer": this._vsUniformBuffer } },
            { "binding": 1, "resource": { "buffer": this._uniBufFrag._gpuBuffer } }
            //   { binding: 2, resource: sampler },
            //   { binding: 3, resource: tex.createView() },
          ]
        }
      );
      this._cgp.device.queue.writeBuffer(
        this._vsUniformBuffer,
        0,
        this._vsUniformValues.buffer,
        this._vsUniformValues.byteOffset,
        this._vsUniformValues.byteLength
      );
      this._uniBufFrag.updateUniformValues();
      this._cgp.popErrorScope("cgp_pipeline end", (e) => {
        this._isValid = false;
      });
    }
  }
  ;
  class cgp_mesh_Mesh {
    constructor(_cgp, __geom) {
      this._log = new Logger("cgl_mesh");
      this._cgp = _cgp;
      this._geom = null;
      this.numIndex = 0;
      this._pipe = new Pipeline(this._cgp);
      this._numNonIndexed = 0;
      this._positionBuffer = null;
      this._bufVerticesIndizes = null;
      this._attributes = [];
      this._needsPipelineUpdate = false;
      if (__geom)
        this.setGeom(__geom);
    }
    _createBuffer(device, data, usage) {
      const buffer = device.createBuffer({
        "size": data.byteLength,
        "usage": usage,
        "mappedAtCreation": true
      });
      const dst = new data.constructor(buffer.getMappedRange());
      dst.set(data);
      buffer.unmap();
      return buffer;
    }
    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom geometry
     * @param {boolean} removeRef
     */
    setGeom(geom, removeRef) {
      this._needsPipelineUpdate = true;
      this._geom = geom;
      this._disposeAttributes();
      this._positionBuffer = this._createBuffer(this._cgp.device, new Float32Array(geom.vertices), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
      let vi = geom.verticesIndices;
      if (!geom.isIndexed())
        vi = Array.from(Array(geom.vertices.length / 3).keys());
      this._numIndices = vi.length;
      this._indicesBuffer = this._createBuffer(this._cgp.device, new Uint32Array(vi), GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);
      if (geom.texCoords && geom.texCoords.length)
        this.setAttribute("texCoords", geom.texCoords, 2);
      if (geom.vertexNormals && geom.vertexNormals.length)
        this.setAttribute("normals", geom.vertexNormals, 3);
    }
    _disposeAttributes() {
      this._needsPipelineUpdate = true;
      for (let i = 0; i < this._attributes.length; i++) {
        this._attributes[i].buffer.destroy();
      }
      this._attributes.length = 0;
    }
    dispose() {
      this._disposeAttributes();
    }
    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name attribute name
     * @param {Array} array data
     * @param {Number} itemSize
     * @param {Object} options
     */
    setAttribute(name2, array, itemSize, options) {
      if (!array) {
        this._log.error("mesh addAttribute - no array given! " + name2);
        throw new Error();
      }
      for (let i = 0; i < this._attributes.length; i++) {
        const attr2 = this._attributes[i];
        if (attr2.name == name2) {
          return attr2;
        }
      }
      const buffer = this._createBuffer(this._cgp.device, new Float32Array(array), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
      const attr = {
        "buffer": buffer,
        "name": name2
        // "cb": cb,
        // "itemSize": itemSize,
        // "numItems": numItems,
        // "startItem": 0,
        // "instanced": instanced,
        // "type": type
      };
      this._attributes.push(attr);
      return attr;
    }
    // setPipeline()
    // {
    //     this._cgp.passEncoder.setPipeline(this._pipe.getPiplelineObject(this._cgp.getShader(),this));
    // }
    render() {
      if (!this._positionBuffer)
        return;
      const shader = this._cgp.getShader();
      if (shader)
        shader.bind();
      if (!this._cgp.getShader() || !this._cgp.getShader().isValid) {
        return;
      }
      this._pipe.setPipeline(this._cgp.getShader(), this);
      if (!this._pipe.isValid) {
        return;
      }
      this._cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);
      for (let i = 0; i < this._attributes.length; i++) {
        this._cgp.passEncoder.setVertexBuffer(i + 1, this._attributes[i].buffer);
      }
      this._cgp.passEncoder.setIndexBuffer(this._indicesBuffer, "uint32");
      if (this._numNonIndexed)
        this._cgp.passEncoder.draw(this._numIndices);
      else
        this._cgp.passEncoder.drawIndexed(this._numIndices);
    }
  }
  ;
  class cgp_texture_Texture {
    constructor(_cgp, options) {
      if (!_cgp)
        throw new Error("no cgp");
      this._log = new Logger("cgp_texture");
      this._cgp = _cgp;
      this.id = CABLES.uuid();
      options = options || {};
      this.name = options.name || "unknown";
    }
    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter) {
      this.width = img.width;
      this.height = img.height;
      this.textureType = "rgba8unorm";
      const textureDescriptor = {
        // Unlike in WebGL, the size of our texture must be set at texture creation time.
        // This means we have to wait until the image is loaded to create the texture, since we won't
        // know the size until then.
        "size": { "width": img.width, "height": img.height },
        "format": this.textureType,
        "usage": GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      };
      const texture = this._cgp.device.createTexture(textureDescriptor);
      this._cgp.device.queue.copyExternalImageToTexture({ "source": img }, { "texture": texture }, textureDescriptor.size);
      return texture;
    }
    getInfo() {
      const tex = this;
      const obj = {};
      obj.name = tex.name;
      obj.size = tex.width + " x " + tex.height;
      obj.textureType = tex.textureType;
      return obj;
    }
  }
  cgp_texture_Texture.load = function(cgp, url, onFinished, settings) {
    fetch(url).then((response) => {
      response.blob().then((blob) => {
        createImageBitmap(blob).then((imgBitmap) => {
          const texture = new cgp_texture_Texture(cgp, { "name": url });
          texture.initTexture(imgBitmap);
          if (onFinished)
            onFinished(texture);
          else
            console.log("Texture.load no onFinished callback");
        });
      });
    });
  };
  ;
  const cgp_CGP = {
    "Context": WebGpuContext,
    "Shader": cgp_shader_Shader,
    "Mesh": cgp_mesh_Mesh,
    "Pipeline": Pipeline,
    "Texture": cgp_texture_Texture
  };
  window.CGP = cgp_CGP;
  ;
  const Framebuffer = function(_cgl, _w, _h, options) {
    const cgl = _cgl;
    this._log = new Logger("Framebuffer");
    this.valid = true;
    let depthTextureExt = cgl.gl.DEPTH_TEXTURE;
    if (!depthTextureExt)
      depthTextureExt = cgl.enableExtension("WEBGL_depth_texture");
    if (!depthTextureExt)
      depthTextureExt = cgl.enableExtension("WEBKIT_WEBGL_depth_texture");
    if (!depthTextureExt)
      depthTextureExt = cgl.enableExtension("MOZ_WEBGL_depth_texture");
    if (!depthTextureExt) {
      cgl.exitError("NO_DEPTH_TEXTURE", "no depth texture support");
    }
    let width = _w || 512;
    let height = _h || 512;
    options = options || {
      "isFloatingPointTexture": false
    };
    if (!options.hasOwnProperty("clear"))
      options.clear = true;
    if (!options.hasOwnProperty("filter"))
      options.filter = Texture.FILTER_LINEAR;
    const texture = new Texture(cgl, {
      "isFloatingPointTexture": options.isFloatingPointTexture,
      "filter": options.filter,
      "wrap": options.wrap || Texture.CLAMP_TO_EDGE
    });
    let textureDepth = null;
    if (depthTextureExt) {
      textureDepth = new Texture(cgl, {
        "isDepthTexture": true
      });
    }
    this._options = options;
    const frameBuf = cgl.gl.createFramebuffer();
    const depthBuffer = cgl.gl.createRenderbuffer();
    this.getWidth = function() {
      return width;
    };
    this.getHeight = function() {
      return height;
    };
    this.getGlFrameBuffer = function() {
      return frameBuf;
    };
    this.getDepthRenderBuffer = function() {
      return depthBuffer;
    };
    this.getTextureColor = function() {
      return texture;
    };
    this.getTextureDepth = function() {
      return textureDepth;
    };
    this.setFilter = function(f) {
      texture.filter = f;
      texture.setSize(width, height);
    };
    this.setSize = function(w, h) {
      if (w < 2)
        w = 2;
      if (h < 2)
        h = 2;
      width = Math.ceil(w);
      height = Math.ceil(h);
      cgl.profileData.profileFrameBuffercreate++;
      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
      cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, depthBuffer);
      texture.setSize(width, height);
      if (textureDepth)
        textureDepth.setSize(width, height);
      if (depthTextureExt)
        cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width, height);
      cgl.gl.framebufferTexture2D(cgl.gl.FRAMEBUFFER, cgl.gl.COLOR_ATTACHMENT0, cgl.gl.TEXTURE_2D, texture.tex, 0);
      if (depthTextureExt) {
        cgl.gl.framebufferRenderbuffer(cgl.gl.FRAMEBUFFER, cgl.gl.DEPTH_ATTACHMENT, cgl.gl.RENDERBUFFER, depthBuffer);
        cgl.gl.framebufferTexture2D(
          cgl.gl.FRAMEBUFFER,
          cgl.gl.DEPTH_ATTACHMENT,
          // safari needs DEPTH_ATTACHMENT NOT DEPTH_ATTACHMENT16
          // cgl.gl.DEPTH_COMPONENT16,
          cgl.gl.TEXTURE_2D,
          textureDepth.tex,
          0
        );
      }
      if (!cgl.gl.isFramebuffer(frameBuf))
        throw new Error("Invalid framebuffer");
      const status = cgl.gl.checkFramebufferStatus(cgl.gl.FRAMEBUFFER);
      switch (status) {
        case cgl.gl.FRAMEBUFFER_COMPLETE:
          break;
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", width, height, texture.tex, depthBuffer);
          this.valid = false;
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
          this.valid = false;
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
          this.valid = false;
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
        case cgl.gl.FRAMEBUFFER_UNSUPPORTED:
          this._log.warn("FRAMEBUFFER_UNSUPPORTED");
          this.valid = false;
          this._log.warn(width, height, options);
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
        case 36059:
          this._log.warn("Incomplete: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER from ext. Or Safari/iOS undefined behaviour.");
          this.valid = false;
          break;
        default:
          this._log.warn("incomplete framebuffer", status);
          this.valid = false;
          throw new Error("Incomplete framebuffer: " + status);
      }
      cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, null);
      cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, null);
      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, null);
    };
    this.renderStart = function() {
      cgl.pushModelMatrix();
      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
      cgl.pushGlFrameBuffer(frameBuf);
      cgl.pushFrameBuffer(this);
      cgl.pushPMatrix();
      cgl.gl.viewport(0, 0, width, height);
      if (this._options.clear) {
        cgl.gl.clearColor(0, 0, 0, 0);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
      }
    };
    this.renderEnd = function() {
      cgl.popPMatrix();
      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, cgl.popGlFrameBuffer());
      cgl.popFrameBuffer();
      cgl.popModelMatrix();
      cgl.resetViewPort();
    };
    this.delete = function() {
      texture.delete();
      this.valid = false;
      if (textureDepth)
        textureDepth.delete();
      cgl.gl.deleteRenderbuffer(depthBuffer);
      cgl.gl.deleteFramebuffer(frameBuf);
    };
    this.dispose = this.delete;
    this.setSize(width, height);
  };
  ;
  const Framebuffer2 = function(cgl, w, h, options) {
    this._log = new Logger("cgl_framebuffer2");
    if (cgl.glVersion == 1)
      return this._log.error("framebuffer2 used on webgl1");
    this.Framebuffer2DrawTargetsDefault = null;
    this.Framebuffer2BlittingFramebuffer = null;
    this.Framebuffer2FinalFramebuffer = null;
    this._cgl = cgl;
    this._cgl.printError("before framebuffer2 constructor");
    this._width = 0;
    this._height = 0;
    this.valid = true;
    this._depthRenderbuffer = null;
    this._frameBuffer = null;
    this._textureFrameBuffer = null;
    this._colorRenderbuffers = [];
    this._drawTargetArray = [];
    this._disposed = false;
    if (!this.Framebuffer2BlittingFramebuffer)
      this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();
    if (!this.Framebuffer2FinalFramebuffer)
      this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();
    if (!this.Framebuffer2DrawTargetsDefault)
      this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];
    this._options = options || {
      "isFloatingPointTexture": false
    };
    this.name = this._options.name || "unknown";
    this._cgl.profileData.addHeavyEvent("framebuffer create", this.name);
    if (!this._options.hasOwnProperty("numRenderBuffers"))
      this._options.numRenderBuffers = 1;
    if (!this._options.hasOwnProperty("depth"))
      this._options.depth = true;
    if (!this._options.hasOwnProperty("clear"))
      this._options.clear = true;
    if (!this._options.hasOwnProperty("multisampling")) {
      this._options.multisampling = false;
      this._options.multisamplingSamples = 0;
    }
    if (this._options.multisamplingSamples) {
      if (this._cgl.glSlowRenderer)
        this._options.multisamplingSamples = 0;
      if (!this._cgl.gl.MAX_SAMPLES)
        this._options.multisamplingSamples = 0;
      else
        this._options.multisamplingSamples = Math.min(this._cgl.maxSamples, this._options.multisamplingSamples);
    }
    if (!this._options.hasOwnProperty("filter"))
      this._options.filter = Texture.FILTER_LINEAR;
    if (!this._options.hasOwnProperty("wrap"))
      this._options.wrap = Texture.WRAP_REPEAT;
    this._numRenderBuffers = this._options.numRenderBuffers;
    this._colorTextures = [];
    this.clearColors = [];
    for (let i = 0; i < this._numRenderBuffers; i++)
      this.clearColors.push([0, 0, 0, 1]);
    if (!options.pixelFormat) {
      if (options.isFloatingPointTexture)
        this._options.pixelFormat = Texture.PFORMATSTR_RGBA32F;
      else
        this._options.pixelFormat = Texture.PFORMATSTR_RGBA8UB;
    }
    for (let i = 0; i < this._numRenderBuffers; i++) {
      this._colorTextures[i] = new Texture(cgl, {
        "name": "fb2 " + this.name + " " + i,
        "isFloatingPointTexture": this._options.isFloatingPointTexture,
        "anisotropic": this._options.anisotropic || 0,
        "pixelFormat": this._options.pixelFormat,
        "filter": this._options.filter,
        "wrap": this._options.wrap
      });
    }
    let fil = Texture.FILTER_NEAREST;
    if (this._options.shadowMap)
      fil = Texture.FILTER_LINEAR;
    const defaultTexSize = 512;
    if (this._options.depth) {
      this._textureDepth = new Texture(
        cgl,
        {
          "name": "fb2 depth " + this.name,
          "isDepthTexture": true,
          "filter": fil,
          "shadowMap": this._options.shadowMap || false,
          "width": w || defaultTexSize,
          "height": h || defaultTexSize
        }
      );
    }
    if (cgl.aborted)
      return;
    this.setSize(w || defaultTexSize, h || defaultTexSize);
    this._cgl.printError("framebuffer2 constructor");
  };
  Framebuffer2.prototype.getWidth = function() {
    return this._width;
  };
  Framebuffer2.prototype.getHeight = function() {
    return this._height;
  };
  Framebuffer2.prototype.getGlFrameBuffer = function() {
    return this._frameBuffer;
  };
  Framebuffer2.prototype.getDepthRenderBuffer = function() {
    return this._depthRenderbuffer;
  };
  Framebuffer2.prototype.getTextureColor = function() {
    return this._colorTextures[0];
  };
  Framebuffer2.prototype.getTextureColorNum = function(i) {
    return this._colorTextures[i];
  };
  Framebuffer2.prototype.getTextureDepth = function() {
    return this._textureDepth;
  };
  Framebuffer2.prototype.setFilter = function(f) {
    for (let i = 0; i < this._numRenderBuffers; i++) {
      this._colorTextures[i].filter = f;
      this._colorTextures[i].setSize(this._width, this._height);
    }
  };
  Framebuffer2.prototype.delete = Framebuffer2.prototype.dispose = function() {
    this._disposed = true;
    let i = 0;
    for (i = 0; i < this._numRenderBuffers; i++)
      this._colorTextures[i].delete();
    if (this._textureDepth)
      this._textureDepth.delete();
    for (i = 0; i < this._numRenderBuffers; i++)
      this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
    this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
    this._cgl.gl.deleteFramebuffer(this._frameBuffer);
    this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
  };
  Framebuffer2.prototype.setSize = function(w, h) {
    if (this._disposed)
      return this._log.warn("disposed framebuffer setsize...");
    this._cgl.profileData.addHeavyEvent("framebuffer resize", this.name);
    let i = 0;
    this._width = this._cgl.checkTextureSize(w);
    this._height = this._cgl.checkTextureSize(h);
    this._cgl.profileData.profileFrameBuffercreate++;
    if (this._frameBuffer) {
      for (i = 0; i < this._numRenderBuffers; i++)
        this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
      this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
      this._cgl.gl.deleteFramebuffer(this._frameBuffer);
      this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
    }
    this._frameBuffer = this._cgl.gl.createFramebuffer();
    this._textureFrameBuffer = this._cgl.gl.createFramebuffer();
    const depth = this._options.depth;
    for (i = 0; i < this._numRenderBuffers; i++) {
      this._colorTextures[i].setSize(this._width, this._height);
    }
    for (i = 0; i < this._numRenderBuffers; i++) {
      const renderBuffer = this._cgl.gl.createRenderbuffer();
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);
      const info = Texture.setUpGlPixelFormat(this._cgl, this._options.pixelFormat);
      let internFormat = info.glInternalFormat;
      if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat)) {
        if (!this._cgl.enableExtension("OES_texture_float_linear")) {
          this._options.filter = Texture.FILTER_NEAREST;
          this.setFilter(this._options.filter);
        }
      } else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat)) {
        if (!this._cgl.enableExtension("OES_texture_float_linear")) {
          this._log.warn("no linear pixelformat,using nearest");
          this._options.filter = Texture.FILTER_NEAREST;
          this.setFilter(this._options.filter);
        }
      }
      if (this._options.multisampling && this._options.multisamplingSamples) {
        this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, internFormat, this._width, this._height);
      } else {
        this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, internFormat, this._width, this._height);
      }
      this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, renderBuffer);
      this._colorRenderbuffers[i] = renderBuffer;
    }
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);
    for (i = 0; i < this._numRenderBuffers; i++) {
      this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
    }
    if (this._options.depth) {
      this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);
    }
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
    let depthType = this._cgl.gl.DEPTH_COMPONENT32F;
    if (this._cgl.glSlowRenderer)
      depthType = this._cgl.gl.DEPTH_COMPONENT16;
    if (depth) {
      this._textureDepth.setSize(this._width, this._height);
      this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
      if (this._options.isFloatingPointTexture) {
        if (this._options.multisampling)
          this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
        else
          this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
      } else if (this._options.multisampling) {
        this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
      } else {
        this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
      }
      this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
    }
    this._drawTargetArray.length = 0;
    for (i = 0; i < this._numRenderBuffers; i++)
      this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);
    if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer))
      this._log.warn("invalid framebuffer");
    const status = this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);
    if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE) {
      this._log.error("framebuffer incomplete: " + this.name, this);
      this._log.log("options", this._options);
      this._log.log("options pixelformat", this._options.pixelFormat);
      switch (status) {
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", this);
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
        case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:
          this._log.warn("FRAMEBUFFER_UNSUPPORTED");
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
        default:
          this.valid = false;
          this._log.warn("incomplete framebuffer", status, this._frameBuffer);
          this._cgl.printError();
          this._cgl.exitError("Framebuffer incomplete...");
          this._frameBuffer = null;
          throw new Error("Incomplete framebuffer: " + status);
      }
    }
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
  };
  Framebuffer2.prototype.renderStart = function() {
    if (this._disposed)
      return this._log.warn("disposed framebuffer renderStart...");
    this._cgl.checkFrameStarted("fb2 renderstart");
    this._cgl.pushModelMatrix();
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
    this._cgl.pushGlFrameBuffer(this._frameBuffer);
    this._cgl.pushFrameBuffer(this);
    this._cgl.pushPMatrix();
    this._cgl.pushViewPort(0, 0, this._width, this._height);
    this._cgl.gl.drawBuffers(this._drawTargetArray);
    if (this._options.clear) {
      this._cgl.gl.clearColor(0, 0, 0, 0);
      this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT);
    }
  };
  Framebuffer2.prototype.clear = function() {
    if (this._numRenderBuffers <= 1) {
      this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
    } else
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
    this._cgl.gl.drawBuffers(this._drawTargetArray);
    for (let i = 0; i < this._numRenderBuffers; i++) {
      this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
      this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, this.clearColors[i]);
    }
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
  };
  Framebuffer2.prototype.renderEnd = function() {
    if (this._disposed)
      return this._log.warn("disposed framebuffer renderEnd...");
    this._cgl.popPMatrix();
    this._cgl.profileData.profileFramebuffer++;
    if (this._numRenderBuffers <= 1) {
      this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
      this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0, 0, 0, 1]);
      this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT, this._cgl.gl.NEAREST);
    } else {
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
      this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
      this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);
      for (let i = 0; i < this._numRenderBuffers; i++) {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
        let flags = this._cgl.gl.COLOR_BUFFER_BIT;
        if (i == 0)
          flags |= this._cgl.gl.DEPTH_BUFFER_BIT;
        this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, flags, this._cgl.gl.NEAREST);
      }
    }
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());
    this._cgl.popFrameBuffer();
    this._cgl.popModelMatrix();
    this._cgl.popViewPort();
    if (this._colorTextures[0].filter == Texture.FILTER_MIPMAP) {
      for (let i = 0; i < this._numRenderBuffers; i++) {
        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex);
        this._colorTextures[i].updateMipMap();
        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
      }
    }
  };
  ;
  const Marker = function(_cgl) {
    this.draw = function(cgl, _size, depthTest) {
    };
  };
  const WirePoint = function(cgl) {
    this.render = function(_cgl, _size) {
    };
  };
  const WireCube = function(cgl) {
    this.render = function(_cgl, sizeX, sizeY, sizeZ) {
    };
  };
  ;
  class UniColorShader {
    constructor(_cgl) {
      this.shader = new CGL.Shader(_cgl, "markermaterial");
      const frag = "".endl() + "void main()".endl() + "{".endl() + "    outColor = vec4(color.rgb,1.0);".endl() + "}";
      const vert = "".endl() + "IN vec3 vPosition;".endl() + "UNI mat4 projMatrix;".endl() + "UNI mat4 mvMatrix;".endl() + "void main()".endl() + "{".endl() + "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);".endl() + "}";
      this.shader.setSource(vert, frag);
      this.coloruni = this.shader.addUniformFrag("4f", "color", [1, 0.777, 1, 1]);
    }
    setColor(r, g, b, a) {
      this.coloruni.set(r, g, b, a);
    }
  }
  ;
  const cgl_CGL = {
    "Framebuffer": Framebuffer,
    "Framebuffer2": Framebuffer2,
    "Geometry": Geometry,
    "BoundingBox": BoundingBox,
    "Marker": Marker,
    "WirePoint": WirePoint,
    "WireCube": WireCube,
    "MatrixStack": MatrixStack,
    "Mesh": Mesh,
    "MESH": MESH,
    "ShaderLibMods": ShaderLibMods,
    "Shader": Shader,
    "Uniform": Uniform,
    "MESHES": MESHES,
    "Context": Context,
    "Texture": Texture,
    "TextureEffect": TextureEffect,
    "isWindows": isWindows,
    "getWheelSpeed": getWheelSpeed,
    "getWheelDelta": getWheelDelta,
    "onLoadingAssetsFinished": onLoadingAssetsFinished,
    "ProfileData": ProfileData,
    "UniColorShader": UniColorShader,
    ...constants_CONSTANTS.BLEND_MODES,
    ...constants_CONSTANTS.SHADER,
    ...constants_CONSTANTS.MATH,
    ...constants_CONSTANTS.BLEND_MODES
  };
  window.CGL = cgl_CGL;
  ;
  window.CABLES = window.CABLES || {};
  CABLES.CGL = cgl_CGL;
  CABLES.CG = CG;
  CABLES.CGP = cgp_CGP;
  CABLES.EMBED = EMBED;
  CABLES.Link = Link;
  CABLES.Port = Port;
  CABLES.Op = Op;
  CABLES.Profiler = Profiler;
  CABLES.Patch = core_patch;
  CABLES.Instancing = Instancing;
  CABLES.Timer = Timer;
  CABLES.WEBAUDIO = WEBAUDIO;
  CABLES.Variable = Variable;
  CABLES.LoadingStatus = LoadingStatus;
  CABLES.now = now;
  CABLES.internalNow = internalNow;
  CABLES.BranchStack = BranchStack;
  CABLES.Branch = Branch;
  CABLES = Object.assign(
    CABLES,
    base64_namespaceObject,
    utils_namespaceObject,
    anim_namespaceObject,
    CONSTANTS2.PORT,
    CONSTANTS2.PACO,
    CONSTANTS2.ANIM,
    CONSTANTS2.OP
  );
  const core = CABLES;
  if (!function() {
    return !this;
  }())
    console.warn("not in strict mode: index core");
  CABLES = __webpack_exports__["default"];
})();
var CABLES = CABLES || {};
CABLES.build = { "timestamp": 1723710716430, "created": "2024-08-15T08:31:56.430Z", "git": { "branch": "master", "commit": "22a0542307b9bba8a1e76e6acb27443d5e25af98", "date": "1723443356", "message": "better log" } };
(() => {
  "use strict";
  var t = { d: (n2, a2) => {
    for (var r2 in a2)
      t.o(a2, r2) && !t.o(n2, r2) && Object.defineProperty(n2, r2, { enumerable: true, get: a2[r2] });
  }, o: (t2, n2) => Object.prototype.hasOwnProperty.call(t2, n2), r: (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  } }, n = {};
  t.r(n), t.d(n, { ARRAY_TYPE: () => f, EPSILON: () => M, RANDOM: () => l, equals: () => d, setMatrixArrayType: () => v, toRadian: () => m });
  var a = {};
  t.r(a), t.d(a, { LDU: () => j, add: () => z, adjoint: () => S, clone: () => y, copy: () => p, create: () => x, determinant: () => R, equals: () => Y, exactEquals: () => Q, frob: () => V, fromRotation: () => D, fromScaling: () => F, fromValues: () => w, identity: () => q, invert: () => P, mul: () => _, multiply: () => T, multiplyScalar: () => X, multiplyScalarAndAdd: () => Z, rotate: () => I, scale: () => E, set: () => g, str: () => L, sub: () => B, subtract: () => O, transpose: () => A });
  var r = {};
  t.r(r), t.d(r, { add: () => it, clone: () => k, copy: () => U, create: () => N, determinant: () => J, equals: () => ft, exactEquals: () => Mt, frob: () => ot, fromRotation: () => at, fromScaling: () => rt, fromTranslation: () => ut, fromValues: () => C, identity: () => W, invert: () => H, mul: () => lt, multiply: () => K, multiplyScalar: () => ct, multiplyScalarAndAdd: () => st, rotate: () => $, scale: () => tt, set: () => G, str: () => et, sub: () => vt, subtract: () => ht, translate: () => nt });
  var u = {};
  t.r(u), t.d(u, { add: () => Yt, adjoint: () => At, clone: () => dt, copy: () => xt, create: () => bt, determinant: () => Pt, equals: () => Nt, exactEquals: () => Bt, frob: () => Qt, fromMat2d: () => Lt, fromMat4: () => mt, fromQuat: () => Vt, fromRotation: () => Dt, fromScaling: () => Ft, fromTranslation: () => Et, fromValues: () => yt, identity: () => qt, invert: () => gt, mul: () => kt, multiply: () => St, multiplyScalar: () => Zt, multiplyScalarAndAdd: () => _t, normalFromMat4: () => jt, projection: () => zt, rotate: () => Tt, scale: () => It, set: () => pt, str: () => Ot, sub: () => Ut, subtract: () => Xt, translate: () => Rt, transpose: () => wt });
  var e = {};
  t.r(e), t.d(e, { add: () => Ln, adjoint: () => nn, clone: () => Ct, copy: () => Gt, create: () => Wt, determinant: () => an, equals: () => Qn, exactEquals: () => On, frob: () => Fn, fromQuat: () => An, fromQuat2: () => xn, fromRotation: () => ln, fromRotationTranslation: () => dn, fromRotationTranslationScale: () => wn, fromRotationTranslationScaleOrigin: () => gn, fromScaling: () => fn, fromTranslation: () => Mn, fromValues: () => Ht, fromXRotation: () => vn, fromYRotation: () => bn, fromZRotation: () => mn, frustum: () => Pn, getRotation: () => qn, getScaling: () => pn, getTranslation: () => yn, identity: () => Kt, invert: () => tn, lookAt: () => In, mul: () => Yn, multiply: () => rn, multiplyScalar: () => jn, multiplyScalarAndAdd: () => zn, ortho: () => Tn, perspective: () => Sn, perspectiveFromFieldOfView: () => Rn, rotate: () => on, rotateX: () => hn, rotateY: () => cn, rotateZ: () => sn, scale: () => en, set: () => Jt, str: () => Dn, sub: () => Xn, subtract: () => Vn, targetTo: () => En, translate: () => un, transpose: () => $t });
  var o = {};
  t.r(o), t.d(o, { add: () => Wn, angle: () => wa, bezier: () => va, ceil: () => Jn, clone: () => _n, copy: () => kn, create: () => Zn, cross: () => Ma, dist: () => Da, distance: () => ua, div: () => Ea, divide: () => Hn, dot: () => sa, equals: () => Sa, exactEquals: () => Pa, floor: () => Kn, forEach: () => ja, fromValues: () => Nn, hermite: () => la, inverse: () => ha, len: () => La, length: () => Bn, lerp: () => fa, max: () => ta, min: () => $n, mul: () => Ia, multiply: () => Gn, negate: () => ia, normalize: () => ca, random: () => ba, rotateX: () => ya, rotateY: () => pa, rotateZ: () => qa, round: () => na, scale: () => aa, scaleAndAdd: () => ra, set: () => Un, sqrDist: () => Fa, sqrLen: () => Va, squaredDistance: () => ea, squaredLength: () => oa, str: () => Aa, sub: () => Ta, subtract: () => Cn, transformMat3: () => da, transformMat4: () => ma, transformQuat: () => xa, zero: () => ga });
  var i = {};
  t.r(i), t.d(i, { add: () => Za, ceil: () => ka, clone: () => Oa, copy: () => Ya, create: () => za, cross: () => or, dist: () => xr, distance: () => Ka, div: () => dr, divide: () => Na, dot: () => er, equals: () => vr, exactEquals: () => lr, floor: () => Ua, forEach: () => wr, fromValues: () => Qa, inverse: () => rr, len: () => pr, length: () => tr, lerp: () => ir, max: () => Ca, min: () => Wa, mul: () => mr, multiply: () => Ba, negate: () => ar, normalize: () => ur, random: () => hr, round: () => Ga, scale: () => Ha, scaleAndAdd: () => Ja, set: () => Xa, sqrDist: () => yr, sqrLen: () => qr, squaredDistance: () => $a, squaredLength: () => nr, str: () => fr, sub: () => br, subtract: () => _a, transformMat4: () => cr, transformQuat: () => sr, zero: () => Mr });
  var h = {};
  t.r(h), t.d(h, { add: () => $r, calculateW: () => Fr, clone: () => Gr, conjugate: () => Yr, copy: () => Jr, create: () => gr, dot: () => au, equals: () => su, exactEquals: () => cu, exp: () => Lr, fromEuler: () => Zr, fromMat3: () => Xr, fromValues: () => Hr, getAngle: () => Rr, getAxisAngle: () => Sr, identity: () => Ar, invert: () => Qr, len: () => eu, length: () => uu, lerp: () => ru, ln: () => Vr, mul: () => tu, multiply: () => Tr, normalize: () => hu, pow: () => jr, random: () => Or, rotateX: () => Ir, rotateY: () => Er, rotateZ: () => Dr, rotationTo: () => Mu, scale: () => nu, set: () => Kr, setAxes: () => lu, setAxisAngle: () => Pr, slerp: () => zr, sqlerp: () => fu, sqrLen: () => iu, squaredLength: () => ou, str: () => _r });
  var c = {};
  t.r(c), t.d(c, { add: () => Ou, clone: () => bu, conjugate: () => Nu, copy: () => wu, create: () => vu, dot: () => Zu, equals: () => Ku, exactEquals: () => Ju, fromMat4: () => qu, fromRotation: () => pu, fromRotationTranslation: () => xu, fromRotationTranslationValues: () => du, fromTranslation: () => yu, fromValues: () => mu, getDual: () => Su, getReal: () => Pu, getTranslation: () => Iu, identity: () => gu, invert: () => Bu, len: () => Uu, length: () => ku, lerp: () => _u, mul: () => Yu, multiply: () => Qu, normalize: () => Gu, rotateAroundAxis: () => zu, rotateByQuatAppend: () => Vu, rotateByQuatPrepend: () => ju, rotateX: () => Du, rotateY: () => Fu, rotateZ: () => Lu, scale: () => Xu, set: () => Au, setDual: () => Tu, setReal: () => Ru, sqrLen: () => Cu, squaredLength: () => Wu, str: () => Hu, translate: () => Eu });
  var s = {};
  t.r(s), t.d(s, { add: () => ue, angle: () => De, ceil: () => he, clone: () => te, copy: () => ae, create: () => $u, cross: () => ge, dist: () => Xe, distance: () => be, div: () => Ye, divide: () => ie, dot: () => we, equals: () => je, exactEquals: () => Ve, floor: () => ce, forEach: () => Be, fromValues: () => ne, inverse: () => pe, len: () => ze, length: () => de, lerp: () => Ae, max: () => Me, min: () => se, mul: () => Qe, multiply: () => oe, negate: () => ye, normalize: () => qe, random: () => Pe, rotate: () => Ee, round: () => fe, scale: () => le, scaleAndAdd: () => ve, set: () => re, sqrDist: () => Ze, sqrLen: () => _e, squaredDistance: () => me, squaredLength: () => xe, str: () => Le, sub: () => Oe, subtract: () => ee, transformMat2: () => Se, transformMat2d: () => Re, transformMat3: () => Te, transformMat4: () => Ie, zero: () => Fe });
  var M = 1e-6, f = "undefined" != typeof Float32Array ? Float32Array : Array, l = Math.random;
  function v(t2) {
    f = t2;
  }
  var b = Math.PI / 180;
  function m(t2) {
    return t2 * b;
  }
  function d(t2, n2) {
    return Math.abs(t2 - n2) <= M * Math.max(1, Math.abs(t2), Math.abs(n2));
  }
  function x() {
    var t2 = new f(4);
    return f != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
  }
  function y(t2) {
    var n2 = new f(4);
    return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2;
  }
  function p(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2;
  }
  function q(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
  }
  function w(t2, n2, a2, r2) {
    var u2 = new f(4);
    return u2[0] = t2, u2[1] = n2, u2[2] = a2, u2[3] = r2, u2;
  }
  function g(t2, n2, a2, r2, u2) {
    return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = u2, t2;
  }
  function A(t2, n2) {
    if (t2 === n2) {
      var a2 = n2[1];
      t2[1] = n2[2], t2[2] = a2;
    } else
      t2[0] = n2[0], t2[1] = n2[2], t2[2] = n2[1], t2[3] = n2[3];
    return t2;
  }
  function P(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = a2 * e2 - u2 * r2;
    return o2 ? (o2 = 1 / o2, t2[0] = e2 * o2, t2[1] = -r2 * o2, t2[2] = -u2 * o2, t2[3] = a2 * o2, t2) : null;
  }
  function S(t2, n2) {
    var a2 = n2[0];
    return t2[0] = n2[3], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = a2, t2;
  }
  function R(t2) {
    return t2[0] * t2[3] - t2[2] * t2[1];
  }
  function T(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = a2[0], h2 = a2[1], c2 = a2[2], s2 = a2[3];
    return t2[0] = r2 * i2 + e2 * h2, t2[1] = u2 * i2 + o2 * h2, t2[2] = r2 * c2 + e2 * s2, t2[3] = u2 * c2 + o2 * s2, t2;
  }
  function I(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = Math.sin(a2), h2 = Math.cos(a2);
    return t2[0] = r2 * h2 + e2 * i2, t2[1] = u2 * h2 + o2 * i2, t2[2] = r2 * -i2 + e2 * h2, t2[3] = u2 * -i2 + o2 * h2, t2;
  }
  function E(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = a2[0], h2 = a2[1];
    return t2[0] = r2 * i2, t2[1] = u2 * i2, t2[2] = e2 * h2, t2[3] = o2 * h2, t2;
  }
  function D(t2, n2) {
    var a2 = Math.sin(n2), r2 = Math.cos(n2);
    return t2[0] = r2, t2[1] = a2, t2[2] = -a2, t2[3] = r2, t2;
  }
  function F(t2, n2) {
    return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = n2[1], t2;
  }
  function L(t2) {
    return "mat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
  }
  function V(t2) {
    return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
  }
  function j(t2, n2, a2, r2) {
    return t2[2] = r2[2] / r2[0], a2[0] = r2[0], a2[1] = r2[1], a2[3] = r2[3] - t2[2] * a2[1], [t2, n2, a2];
  }
  function z(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2;
  }
  function O(t2, n2, a2) {
    return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2[3] = n2[3] - a2[3], t2;
  }
  function Q(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3];
  }
  function Y(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = t2[2], e2 = t2[3], o2 = n2[0], i2 = n2[1], h2 = n2[2], c2 = n2[3];
    return Math.abs(a2 - o2) <= M * Math.max(1, Math.abs(a2), Math.abs(o2)) && Math.abs(r2 - i2) <= M * Math.max(1, Math.abs(r2), Math.abs(i2)) && Math.abs(u2 - h2) <= M * Math.max(1, Math.abs(u2), Math.abs(h2)) && Math.abs(e2 - c2) <= M * Math.max(1, Math.abs(e2), Math.abs(c2));
  }
  function X(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2;
  }
  function Z(t2, n2, a2, r2) {
    return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2[3] = n2[3] + a2[3] * r2, t2;
  }
  Math.hypot || (Math.hypot = function() {
    for (var t2 = 0, n2 = arguments.length; n2--; )
      t2 += arguments[n2] * arguments[n2];
    return Math.sqrt(t2);
  });
  var _ = T, B = O;
  function N() {
    var t2 = new f(6);
    return f != Float32Array && (t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0), t2[0] = 1, t2[3] = 1, t2;
  }
  function k(t2) {
    var n2 = new f(6);
    return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2;
  }
  function U(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2;
  }
  function W(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2;
  }
  function C(t2, n2, a2, r2, u2, e2) {
    var o2 = new f(6);
    return o2[0] = t2, o2[1] = n2, o2[2] = a2, o2[3] = r2, o2[4] = u2, o2[5] = e2, o2;
  }
  function G(t2, n2, a2, r2, u2, e2, o2) {
    return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = u2, t2[4] = e2, t2[5] = o2, t2;
  }
  function H(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = n2[4], i2 = n2[5], h2 = a2 * e2 - r2 * u2;
    return h2 ? (h2 = 1 / h2, t2[0] = e2 * h2, t2[1] = -r2 * h2, t2[2] = -u2 * h2, t2[3] = a2 * h2, t2[4] = (u2 * i2 - e2 * o2) * h2, t2[5] = (r2 * o2 - a2 * i2) * h2, t2) : null;
  }
  function J(t2) {
    return t2[0] * t2[3] - t2[1] * t2[2];
  }
  function K(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = a2[0], s2 = a2[1], M2 = a2[2], f2 = a2[3], l2 = a2[4], v2 = a2[5];
    return t2[0] = r2 * c2 + e2 * s2, t2[1] = u2 * c2 + o2 * s2, t2[2] = r2 * M2 + e2 * f2, t2[3] = u2 * M2 + o2 * f2, t2[4] = r2 * l2 + e2 * v2 + i2, t2[5] = u2 * l2 + o2 * v2 + h2, t2;
  }
  function $(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = Math.sin(a2), s2 = Math.cos(a2);
    return t2[0] = r2 * s2 + e2 * c2, t2[1] = u2 * s2 + o2 * c2, t2[2] = r2 * -c2 + e2 * s2, t2[3] = u2 * -c2 + o2 * s2, t2[4] = i2, t2[5] = h2, t2;
  }
  function tt(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = a2[0], s2 = a2[1];
    return t2[0] = r2 * c2, t2[1] = u2 * c2, t2[2] = e2 * s2, t2[3] = o2 * s2, t2[4] = i2, t2[5] = h2, t2;
  }
  function nt(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = a2[0], s2 = a2[1];
    return t2[0] = r2, t2[1] = u2, t2[2] = e2, t2[3] = o2, t2[4] = r2 * c2 + e2 * s2 + i2, t2[5] = u2 * c2 + o2 * s2 + h2, t2;
  }
  function at(t2, n2) {
    var a2 = Math.sin(n2), r2 = Math.cos(n2);
    return t2[0] = r2, t2[1] = a2, t2[2] = -a2, t2[3] = r2, t2[4] = 0, t2[5] = 0, t2;
  }
  function rt(t2, n2) {
    return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = n2[1], t2[4] = 0, t2[5] = 0, t2;
  }
  function ut(t2, n2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = n2[0], t2[5] = n2[1], t2;
  }
  function et(t2) {
    return "mat2d(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ")";
  }
  function ot(t2) {
    return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], 1);
  }
  function it(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2[4] = n2[4] + a2[4], t2[5] = n2[5] + a2[5], t2;
  }
  function ht(t2, n2, a2) {
    return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2[3] = n2[3] - a2[3], t2[4] = n2[4] - a2[4], t2[5] = n2[5] - a2[5], t2;
  }
  function ct(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2[4] = n2[4] * a2, t2[5] = n2[5] * a2, t2;
  }
  function st(t2, n2, a2, r2) {
    return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2[3] = n2[3] + a2[3] * r2, t2[4] = n2[4] + a2[4] * r2, t2[5] = n2[5] + a2[5] * r2, t2;
  }
  function Mt(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5];
  }
  function ft(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = t2[2], e2 = t2[3], o2 = t2[4], i2 = t2[5], h2 = n2[0], c2 = n2[1], s2 = n2[2], f2 = n2[3], l2 = n2[4], v2 = n2[5];
    return Math.abs(a2 - h2) <= M * Math.max(1, Math.abs(a2), Math.abs(h2)) && Math.abs(r2 - c2) <= M * Math.max(1, Math.abs(r2), Math.abs(c2)) && Math.abs(u2 - s2) <= M * Math.max(1, Math.abs(u2), Math.abs(s2)) && Math.abs(e2 - f2) <= M * Math.max(1, Math.abs(e2), Math.abs(f2)) && Math.abs(o2 - l2) <= M * Math.max(1, Math.abs(o2), Math.abs(l2)) && Math.abs(i2 - v2) <= M * Math.max(1, Math.abs(i2), Math.abs(v2));
  }
  var lt = K, vt = ht;
  function bt() {
    var t2 = new f(9);
    return f != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
  }
  function mt(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[4], t2[4] = n2[5], t2[5] = n2[6], t2[6] = n2[8], t2[7] = n2[9], t2[8] = n2[10], t2;
  }
  function dt(t2) {
    var n2 = new f(9);
    return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2[6] = t2[6], n2[7] = t2[7], n2[8] = t2[8], n2;
  }
  function xt(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2;
  }
  function yt(t2, n2, a2, r2, u2, e2, o2, i2, h2) {
    var c2 = new f(9);
    return c2[0] = t2, c2[1] = n2, c2[2] = a2, c2[3] = r2, c2[4] = u2, c2[5] = e2, c2[6] = o2, c2[7] = i2, c2[8] = h2, c2;
  }
  function pt(t2, n2, a2, r2, u2, e2, o2, i2, h2, c2) {
    return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = u2, t2[4] = e2, t2[5] = o2, t2[6] = i2, t2[7] = h2, t2[8] = c2, t2;
  }
  function qt(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
  }
  function wt(t2, n2) {
    if (t2 === n2) {
      var a2 = n2[1], r2 = n2[2], u2 = n2[5];
      t2[1] = n2[3], t2[2] = n2[6], t2[3] = a2, t2[5] = n2[7], t2[6] = r2, t2[7] = u2;
    } else
      t2[0] = n2[0], t2[1] = n2[3], t2[2] = n2[6], t2[3] = n2[1], t2[4] = n2[4], t2[5] = n2[7], t2[6] = n2[2], t2[7] = n2[5], t2[8] = n2[8];
    return t2;
  }
  function gt(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = n2[4], i2 = n2[5], h2 = n2[6], c2 = n2[7], s2 = n2[8], M2 = s2 * o2 - i2 * c2, f2 = -s2 * e2 + i2 * h2, l2 = c2 * e2 - o2 * h2, v2 = a2 * M2 + r2 * f2 + u2 * l2;
    return v2 ? (v2 = 1 / v2, t2[0] = M2 * v2, t2[1] = (-s2 * r2 + u2 * c2) * v2, t2[2] = (i2 * r2 - u2 * o2) * v2, t2[3] = f2 * v2, t2[4] = (s2 * a2 - u2 * h2) * v2, t2[5] = (-i2 * a2 + u2 * e2) * v2, t2[6] = l2 * v2, t2[7] = (-c2 * a2 + r2 * h2) * v2, t2[8] = (o2 * a2 - r2 * e2) * v2, t2) : null;
  }
  function At(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = n2[4], i2 = n2[5], h2 = n2[6], c2 = n2[7], s2 = n2[8];
    return t2[0] = o2 * s2 - i2 * c2, t2[1] = u2 * c2 - r2 * s2, t2[2] = r2 * i2 - u2 * o2, t2[3] = i2 * h2 - e2 * s2, t2[4] = a2 * s2 - u2 * h2, t2[5] = u2 * e2 - a2 * i2, t2[6] = e2 * c2 - o2 * h2, t2[7] = r2 * h2 - a2 * c2, t2[8] = a2 * o2 - r2 * e2, t2;
  }
  function Pt(t2) {
    var n2 = t2[0], a2 = t2[1], r2 = t2[2], u2 = t2[3], e2 = t2[4], o2 = t2[5], i2 = t2[6], h2 = t2[7], c2 = t2[8];
    return n2 * (c2 * e2 - o2 * h2) + a2 * (-c2 * u2 + o2 * i2) + r2 * (h2 * u2 - e2 * i2);
  }
  function St(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = n2[8], f2 = a2[0], l2 = a2[1], v2 = a2[2], b2 = a2[3], m2 = a2[4], d2 = a2[5], x2 = a2[6], y2 = a2[7], p2 = a2[8];
    return t2[0] = f2 * r2 + l2 * o2 + v2 * c2, t2[1] = f2 * u2 + l2 * i2 + v2 * s2, t2[2] = f2 * e2 + l2 * h2 + v2 * M2, t2[3] = b2 * r2 + m2 * o2 + d2 * c2, t2[4] = b2 * u2 + m2 * i2 + d2 * s2, t2[5] = b2 * e2 + m2 * h2 + d2 * M2, t2[6] = x2 * r2 + y2 * o2 + p2 * c2, t2[7] = x2 * u2 + y2 * i2 + p2 * s2, t2[8] = x2 * e2 + y2 * h2 + p2 * M2, t2;
  }
  function Rt(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = n2[8], f2 = a2[0], l2 = a2[1];
    return t2[0] = r2, t2[1] = u2, t2[2] = e2, t2[3] = o2, t2[4] = i2, t2[5] = h2, t2[6] = f2 * r2 + l2 * o2 + c2, t2[7] = f2 * u2 + l2 * i2 + s2, t2[8] = f2 * e2 + l2 * h2 + M2, t2;
  }
  function Tt(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = n2[8], f2 = Math.sin(a2), l2 = Math.cos(a2);
    return t2[0] = l2 * r2 + f2 * o2, t2[1] = l2 * u2 + f2 * i2, t2[2] = l2 * e2 + f2 * h2, t2[3] = l2 * o2 - f2 * r2, t2[4] = l2 * i2 - f2 * u2, t2[5] = l2 * h2 - f2 * e2, t2[6] = c2, t2[7] = s2, t2[8] = M2, t2;
  }
  function It(t2, n2, a2) {
    var r2 = a2[0], u2 = a2[1];
    return t2[0] = r2 * n2[0], t2[1] = r2 * n2[1], t2[2] = r2 * n2[2], t2[3] = u2 * n2[3], t2[4] = u2 * n2[4], t2[5] = u2 * n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2;
  }
  function Et(t2, n2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = n2[0], t2[7] = n2[1], t2[8] = 1, t2;
  }
  function Dt(t2, n2) {
    var a2 = Math.sin(n2), r2 = Math.cos(n2);
    return t2[0] = r2, t2[1] = a2, t2[2] = 0, t2[3] = -a2, t2[4] = r2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
  }
  function Ft(t2, n2) {
    return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = n2[1], t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
  }
  function Lt(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = 0, t2[3] = n2[2], t2[4] = n2[3], t2[5] = 0, t2[6] = n2[4], t2[7] = n2[5], t2[8] = 1, t2;
  }
  function Vt(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = a2 + a2, i2 = r2 + r2, h2 = u2 + u2, c2 = a2 * o2, s2 = r2 * o2, M2 = r2 * i2, f2 = u2 * o2, l2 = u2 * i2, v2 = u2 * h2, b2 = e2 * o2, m2 = e2 * i2, d2 = e2 * h2;
    return t2[0] = 1 - M2 - v2, t2[3] = s2 - d2, t2[6] = f2 + m2, t2[1] = s2 + d2, t2[4] = 1 - c2 - v2, t2[7] = l2 - b2, t2[2] = f2 - m2, t2[5] = l2 + b2, t2[8] = 1 - c2 - M2, t2;
  }
  function jt(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = n2[4], i2 = n2[5], h2 = n2[6], c2 = n2[7], s2 = n2[8], M2 = n2[9], f2 = n2[10], l2 = n2[11], v2 = n2[12], b2 = n2[13], m2 = n2[14], d2 = n2[15], x2 = a2 * i2 - r2 * o2, y2 = a2 * h2 - u2 * o2, p2 = a2 * c2 - e2 * o2, q2 = r2 * h2 - u2 * i2, w2 = r2 * c2 - e2 * i2, g2 = u2 * c2 - e2 * h2, A2 = s2 * b2 - M2 * v2, P2 = s2 * m2 - f2 * v2, S2 = s2 * d2 - l2 * v2, R2 = M2 * m2 - f2 * b2, T2 = M2 * d2 - l2 * b2, I2 = f2 * d2 - l2 * m2, E2 = x2 * I2 - y2 * T2 + p2 * R2 + q2 * S2 - w2 * P2 + g2 * A2;
    return E2 ? (E2 = 1 / E2, t2[0] = (i2 * I2 - h2 * T2 + c2 * R2) * E2, t2[1] = (h2 * S2 - o2 * I2 - c2 * P2) * E2, t2[2] = (o2 * T2 - i2 * S2 + c2 * A2) * E2, t2[3] = (u2 * T2 - r2 * I2 - e2 * R2) * E2, t2[4] = (a2 * I2 - u2 * S2 + e2 * P2) * E2, t2[5] = (r2 * S2 - a2 * T2 - e2 * A2) * E2, t2[6] = (b2 * g2 - m2 * w2 + d2 * q2) * E2, t2[7] = (m2 * p2 - v2 * g2 - d2 * y2) * E2, t2[8] = (v2 * w2 - b2 * p2 + d2 * x2) * E2, t2) : null;
  }
  function zt(t2, n2, a2) {
    return t2[0] = 2 / n2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = -2 / a2, t2[5] = 0, t2[6] = -1, t2[7] = 1, t2[8] = 1, t2;
  }
  function Ot(t2) {
    return "mat3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ")";
  }
  function Qt(t2) {
    return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6], t2[7], t2[8]);
  }
  function Yt(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2[4] = n2[4] + a2[4], t2[5] = n2[5] + a2[5], t2[6] = n2[6] + a2[6], t2[7] = n2[7] + a2[7], t2[8] = n2[8] + a2[8], t2;
  }
  function Xt(t2, n2, a2) {
    return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2[3] = n2[3] - a2[3], t2[4] = n2[4] - a2[4], t2[5] = n2[5] - a2[5], t2[6] = n2[6] - a2[6], t2[7] = n2[7] - a2[7], t2[8] = n2[8] - a2[8], t2;
  }
  function Zt(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2[4] = n2[4] * a2, t2[5] = n2[5] * a2, t2[6] = n2[6] * a2, t2[7] = n2[7] * a2, t2[8] = n2[8] * a2, t2;
  }
  function _t(t2, n2, a2, r2) {
    return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2[3] = n2[3] + a2[3] * r2, t2[4] = n2[4] + a2[4] * r2, t2[5] = n2[5] + a2[5] * r2, t2[6] = n2[6] + a2[6] * r2, t2[7] = n2[7] + a2[7] * r2, t2[8] = n2[8] + a2[8] * r2, t2;
  }
  function Bt(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5] && t2[6] === n2[6] && t2[7] === n2[7] && t2[8] === n2[8];
  }
  function Nt(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = t2[2], e2 = t2[3], o2 = t2[4], i2 = t2[5], h2 = t2[6], c2 = t2[7], s2 = t2[8], f2 = n2[0], l2 = n2[1], v2 = n2[2], b2 = n2[3], m2 = n2[4], d2 = n2[5], x2 = n2[6], y2 = n2[7], p2 = n2[8];
    return Math.abs(a2 - f2) <= M * Math.max(1, Math.abs(a2), Math.abs(f2)) && Math.abs(r2 - l2) <= M * Math.max(1, Math.abs(r2), Math.abs(l2)) && Math.abs(u2 - v2) <= M * Math.max(1, Math.abs(u2), Math.abs(v2)) && Math.abs(e2 - b2) <= M * Math.max(1, Math.abs(e2), Math.abs(b2)) && Math.abs(o2 - m2) <= M * Math.max(1, Math.abs(o2), Math.abs(m2)) && Math.abs(i2 - d2) <= M * Math.max(1, Math.abs(i2), Math.abs(d2)) && Math.abs(h2 - x2) <= M * Math.max(1, Math.abs(h2), Math.abs(x2)) && Math.abs(c2 - y2) <= M * Math.max(1, Math.abs(c2), Math.abs(y2)) && Math.abs(s2 - p2) <= M * Math.max(1, Math.abs(s2), Math.abs(p2));
  }
  var kt = St, Ut = Xt;
  function Wt() {
    var t2 = new f(16);
    return f != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
  }
  function Ct(t2) {
    var n2 = new f(16);
    return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2[6] = t2[6], n2[7] = t2[7], n2[8] = t2[8], n2[9] = t2[9], n2[10] = t2[10], n2[11] = t2[11], n2[12] = t2[12], n2[13] = t2[13], n2[14] = t2[14], n2[15] = t2[15], n2;
  }
  function Gt(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2[9] = n2[9], t2[10] = n2[10], t2[11] = n2[11], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15], t2;
  }
  function Ht(t2, n2, a2, r2, u2, e2, o2, i2, h2, c2, s2, M2, l2, v2, b2, m2) {
    var d2 = new f(16);
    return d2[0] = t2, d2[1] = n2, d2[2] = a2, d2[3] = r2, d2[4] = u2, d2[5] = e2, d2[6] = o2, d2[7] = i2, d2[8] = h2, d2[9] = c2, d2[10] = s2, d2[11] = M2, d2[12] = l2, d2[13] = v2, d2[14] = b2, d2[15] = m2, d2;
  }
  function Jt(t2, n2, a2, r2, u2, e2, o2, i2, h2, c2, s2, M2, f2, l2, v2, b2, m2) {
    return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = u2, t2[4] = e2, t2[5] = o2, t2[6] = i2, t2[7] = h2, t2[8] = c2, t2[9] = s2, t2[10] = M2, t2[11] = f2, t2[12] = l2, t2[13] = v2, t2[14] = b2, t2[15] = m2, t2;
  }
  function Kt(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }
  function $t(t2, n2) {
    if (t2 === n2) {
      var a2 = n2[1], r2 = n2[2], u2 = n2[3], e2 = n2[6], o2 = n2[7], i2 = n2[11];
      t2[1] = n2[4], t2[2] = n2[8], t2[3] = n2[12], t2[4] = a2, t2[6] = n2[9], t2[7] = n2[13], t2[8] = r2, t2[9] = e2, t2[11] = n2[14], t2[12] = u2, t2[13] = o2, t2[14] = i2;
    } else
      t2[0] = n2[0], t2[1] = n2[4], t2[2] = n2[8], t2[3] = n2[12], t2[4] = n2[1], t2[5] = n2[5], t2[6] = n2[9], t2[7] = n2[13], t2[8] = n2[2], t2[9] = n2[6], t2[10] = n2[10], t2[11] = n2[14], t2[12] = n2[3], t2[13] = n2[7], t2[14] = n2[11], t2[15] = n2[15];
    return t2;
  }
  function tn(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = n2[4], i2 = n2[5], h2 = n2[6], c2 = n2[7], s2 = n2[8], M2 = n2[9], f2 = n2[10], l2 = n2[11], v2 = n2[12], b2 = n2[13], m2 = n2[14], d2 = n2[15], x2 = a2 * i2 - r2 * o2, y2 = a2 * h2 - u2 * o2, p2 = a2 * c2 - e2 * o2, q2 = r2 * h2 - u2 * i2, w2 = r2 * c2 - e2 * i2, g2 = u2 * c2 - e2 * h2, A2 = s2 * b2 - M2 * v2, P2 = s2 * m2 - f2 * v2, S2 = s2 * d2 - l2 * v2, R2 = M2 * m2 - f2 * b2, T2 = M2 * d2 - l2 * b2, I2 = f2 * d2 - l2 * m2, E2 = x2 * I2 - y2 * T2 + p2 * R2 + q2 * S2 - w2 * P2 + g2 * A2;
    return E2 ? (E2 = 1 / E2, t2[0] = (i2 * I2 - h2 * T2 + c2 * R2) * E2, t2[1] = (u2 * T2 - r2 * I2 - e2 * R2) * E2, t2[2] = (b2 * g2 - m2 * w2 + d2 * q2) * E2, t2[3] = (f2 * w2 - M2 * g2 - l2 * q2) * E2, t2[4] = (h2 * S2 - o2 * I2 - c2 * P2) * E2, t2[5] = (a2 * I2 - u2 * S2 + e2 * P2) * E2, t2[6] = (m2 * p2 - v2 * g2 - d2 * y2) * E2, t2[7] = (s2 * g2 - f2 * p2 + l2 * y2) * E2, t2[8] = (o2 * T2 - i2 * S2 + c2 * A2) * E2, t2[9] = (r2 * S2 - a2 * T2 - e2 * A2) * E2, t2[10] = (v2 * w2 - b2 * p2 + d2 * x2) * E2, t2[11] = (M2 * p2 - s2 * w2 - l2 * x2) * E2, t2[12] = (i2 * P2 - o2 * R2 - h2 * A2) * E2, t2[13] = (a2 * R2 - r2 * P2 + u2 * A2) * E2, t2[14] = (b2 * y2 - v2 * q2 - m2 * x2) * E2, t2[15] = (s2 * q2 - M2 * y2 + f2 * x2) * E2, t2) : null;
  }
  function nn(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = n2[4], i2 = n2[5], h2 = n2[6], c2 = n2[7], s2 = n2[8], M2 = n2[9], f2 = n2[10], l2 = n2[11], v2 = n2[12], b2 = n2[13], m2 = n2[14], d2 = n2[15];
    return t2[0] = i2 * (f2 * d2 - l2 * m2) - M2 * (h2 * d2 - c2 * m2) + b2 * (h2 * l2 - c2 * f2), t2[1] = -(r2 * (f2 * d2 - l2 * m2) - M2 * (u2 * d2 - e2 * m2) + b2 * (u2 * l2 - e2 * f2)), t2[2] = r2 * (h2 * d2 - c2 * m2) - i2 * (u2 * d2 - e2 * m2) + b2 * (u2 * c2 - e2 * h2), t2[3] = -(r2 * (h2 * l2 - c2 * f2) - i2 * (u2 * l2 - e2 * f2) + M2 * (u2 * c2 - e2 * h2)), t2[4] = -(o2 * (f2 * d2 - l2 * m2) - s2 * (h2 * d2 - c2 * m2) + v2 * (h2 * l2 - c2 * f2)), t2[5] = a2 * (f2 * d2 - l2 * m2) - s2 * (u2 * d2 - e2 * m2) + v2 * (u2 * l2 - e2 * f2), t2[6] = -(a2 * (h2 * d2 - c2 * m2) - o2 * (u2 * d2 - e2 * m2) + v2 * (u2 * c2 - e2 * h2)), t2[7] = a2 * (h2 * l2 - c2 * f2) - o2 * (u2 * l2 - e2 * f2) + s2 * (u2 * c2 - e2 * h2), t2[8] = o2 * (M2 * d2 - l2 * b2) - s2 * (i2 * d2 - c2 * b2) + v2 * (i2 * l2 - c2 * M2), t2[9] = -(a2 * (M2 * d2 - l2 * b2) - s2 * (r2 * d2 - e2 * b2) + v2 * (r2 * l2 - e2 * M2)), t2[10] = a2 * (i2 * d2 - c2 * b2) - o2 * (r2 * d2 - e2 * b2) + v2 * (r2 * c2 - e2 * i2), t2[11] = -(a2 * (i2 * l2 - c2 * M2) - o2 * (r2 * l2 - e2 * M2) + s2 * (r2 * c2 - e2 * i2)), t2[12] = -(o2 * (M2 * m2 - f2 * b2) - s2 * (i2 * m2 - h2 * b2) + v2 * (i2 * f2 - h2 * M2)), t2[13] = a2 * (M2 * m2 - f2 * b2) - s2 * (r2 * m2 - u2 * b2) + v2 * (r2 * f2 - u2 * M2), t2[14] = -(a2 * (i2 * m2 - h2 * b2) - o2 * (r2 * m2 - u2 * b2) + v2 * (r2 * h2 - u2 * i2)), t2[15] = a2 * (i2 * f2 - h2 * M2) - o2 * (r2 * f2 - u2 * M2) + s2 * (r2 * h2 - u2 * i2), t2;
  }
  function an(t2) {
    var n2 = t2[0], a2 = t2[1], r2 = t2[2], u2 = t2[3], e2 = t2[4], o2 = t2[5], i2 = t2[6], h2 = t2[7], c2 = t2[8], s2 = t2[9], M2 = t2[10], f2 = t2[11], l2 = t2[12], v2 = t2[13], b2 = t2[14], m2 = t2[15];
    return (n2 * o2 - a2 * e2) * (M2 * m2 - f2 * b2) - (n2 * i2 - r2 * e2) * (s2 * m2 - f2 * v2) + (n2 * h2 - u2 * e2) * (s2 * b2 - M2 * v2) + (a2 * i2 - r2 * o2) * (c2 * m2 - f2 * l2) - (a2 * h2 - u2 * o2) * (c2 * b2 - M2 * l2) + (r2 * h2 - u2 * i2) * (c2 * v2 - s2 * l2);
  }
  function rn(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = n2[8], f2 = n2[9], l2 = n2[10], v2 = n2[11], b2 = n2[12], m2 = n2[13], d2 = n2[14], x2 = n2[15], y2 = a2[0], p2 = a2[1], q2 = a2[2], w2 = a2[3];
    return t2[0] = y2 * r2 + p2 * i2 + q2 * M2 + w2 * b2, t2[1] = y2 * u2 + p2 * h2 + q2 * f2 + w2 * m2, t2[2] = y2 * e2 + p2 * c2 + q2 * l2 + w2 * d2, t2[3] = y2 * o2 + p2 * s2 + q2 * v2 + w2 * x2, y2 = a2[4], p2 = a2[5], q2 = a2[6], w2 = a2[7], t2[4] = y2 * r2 + p2 * i2 + q2 * M2 + w2 * b2, t2[5] = y2 * u2 + p2 * h2 + q2 * f2 + w2 * m2, t2[6] = y2 * e2 + p2 * c2 + q2 * l2 + w2 * d2, t2[7] = y2 * o2 + p2 * s2 + q2 * v2 + w2 * x2, y2 = a2[8], p2 = a2[9], q2 = a2[10], w2 = a2[11], t2[8] = y2 * r2 + p2 * i2 + q2 * M2 + w2 * b2, t2[9] = y2 * u2 + p2 * h2 + q2 * f2 + w2 * m2, t2[10] = y2 * e2 + p2 * c2 + q2 * l2 + w2 * d2, t2[11] = y2 * o2 + p2 * s2 + q2 * v2 + w2 * x2, y2 = a2[12], p2 = a2[13], q2 = a2[14], w2 = a2[15], t2[12] = y2 * r2 + p2 * i2 + q2 * M2 + w2 * b2, t2[13] = y2 * u2 + p2 * h2 + q2 * f2 + w2 * m2, t2[14] = y2 * e2 + p2 * c2 + q2 * l2 + w2 * d2, t2[15] = y2 * o2 + p2 * s2 + q2 * v2 + w2 * x2, t2;
  }
  function un(t2, n2, a2) {
    var r2, u2, e2, o2, i2, h2, c2, s2, M2, f2, l2, v2, b2 = a2[0], m2 = a2[1], d2 = a2[2];
    return n2 === t2 ? (t2[12] = n2[0] * b2 + n2[4] * m2 + n2[8] * d2 + n2[12], t2[13] = n2[1] * b2 + n2[5] * m2 + n2[9] * d2 + n2[13], t2[14] = n2[2] * b2 + n2[6] * m2 + n2[10] * d2 + n2[14], t2[15] = n2[3] * b2 + n2[7] * m2 + n2[11] * d2 + n2[15]) : (r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = n2[8], f2 = n2[9], l2 = n2[10], v2 = n2[11], t2[0] = r2, t2[1] = u2, t2[2] = e2, t2[3] = o2, t2[4] = i2, t2[5] = h2, t2[6] = c2, t2[7] = s2, t2[8] = M2, t2[9] = f2, t2[10] = l2, t2[11] = v2, t2[12] = r2 * b2 + i2 * m2 + M2 * d2 + n2[12], t2[13] = u2 * b2 + h2 * m2 + f2 * d2 + n2[13], t2[14] = e2 * b2 + c2 * m2 + l2 * d2 + n2[14], t2[15] = o2 * b2 + s2 * m2 + v2 * d2 + n2[15]), t2;
  }
  function en(t2, n2, a2) {
    var r2 = a2[0], u2 = a2[1], e2 = a2[2];
    return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = n2[3] * r2, t2[4] = n2[4] * u2, t2[5] = n2[5] * u2, t2[6] = n2[6] * u2, t2[7] = n2[7] * u2, t2[8] = n2[8] * e2, t2[9] = n2[9] * e2, t2[10] = n2[10] * e2, t2[11] = n2[11] * e2, t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15], t2;
  }
  function on(t2, n2, a2, r2) {
    var u2, e2, o2, i2, h2, c2, s2, f2, l2, v2, b2, m2, d2, x2, y2, p2, q2, w2, g2, A2, P2, S2, R2, T2, I2 = r2[0], E2 = r2[1], D2 = r2[2], F2 = Math.hypot(I2, E2, D2);
    return F2 < M ? null : (I2 *= F2 = 1 / F2, E2 *= F2, D2 *= F2, u2 = Math.sin(a2), o2 = 1 - (e2 = Math.cos(a2)), i2 = n2[0], h2 = n2[1], c2 = n2[2], s2 = n2[3], f2 = n2[4], l2 = n2[5], v2 = n2[6], b2 = n2[7], m2 = n2[8], d2 = n2[9], x2 = n2[10], y2 = n2[11], p2 = I2 * I2 * o2 + e2, q2 = E2 * I2 * o2 + D2 * u2, w2 = D2 * I2 * o2 - E2 * u2, g2 = I2 * E2 * o2 - D2 * u2, A2 = E2 * E2 * o2 + e2, P2 = D2 * E2 * o2 + I2 * u2, S2 = I2 * D2 * o2 + E2 * u2, R2 = E2 * D2 * o2 - I2 * u2, T2 = D2 * D2 * o2 + e2, t2[0] = i2 * p2 + f2 * q2 + m2 * w2, t2[1] = h2 * p2 + l2 * q2 + d2 * w2, t2[2] = c2 * p2 + v2 * q2 + x2 * w2, t2[3] = s2 * p2 + b2 * q2 + y2 * w2, t2[4] = i2 * g2 + f2 * A2 + m2 * P2, t2[5] = h2 * g2 + l2 * A2 + d2 * P2, t2[6] = c2 * g2 + v2 * A2 + x2 * P2, t2[7] = s2 * g2 + b2 * A2 + y2 * P2, t2[8] = i2 * S2 + f2 * R2 + m2 * T2, t2[9] = h2 * S2 + l2 * R2 + d2 * T2, t2[10] = c2 * S2 + v2 * R2 + x2 * T2, t2[11] = s2 * S2 + b2 * R2 + y2 * T2, n2 !== t2 && (t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]), t2);
  }
  function hn(t2, n2, a2) {
    var r2 = Math.sin(a2), u2 = Math.cos(a2), e2 = n2[4], o2 = n2[5], i2 = n2[6], h2 = n2[7], c2 = n2[8], s2 = n2[9], M2 = n2[10], f2 = n2[11];
    return n2 !== t2 && (t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]), t2[4] = e2 * u2 + c2 * r2, t2[5] = o2 * u2 + s2 * r2, t2[6] = i2 * u2 + M2 * r2, t2[7] = h2 * u2 + f2 * r2, t2[8] = c2 * u2 - e2 * r2, t2[9] = s2 * u2 - o2 * r2, t2[10] = M2 * u2 - i2 * r2, t2[11] = f2 * u2 - h2 * r2, t2;
  }
  function cn(t2, n2, a2) {
    var r2 = Math.sin(a2), u2 = Math.cos(a2), e2 = n2[0], o2 = n2[1], i2 = n2[2], h2 = n2[3], c2 = n2[8], s2 = n2[9], M2 = n2[10], f2 = n2[11];
    return n2 !== t2 && (t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]), t2[0] = e2 * u2 - c2 * r2, t2[1] = o2 * u2 - s2 * r2, t2[2] = i2 * u2 - M2 * r2, t2[3] = h2 * u2 - f2 * r2, t2[8] = e2 * r2 + c2 * u2, t2[9] = o2 * r2 + s2 * u2, t2[10] = i2 * r2 + M2 * u2, t2[11] = h2 * r2 + f2 * u2, t2;
  }
  function sn(t2, n2, a2) {
    var r2 = Math.sin(a2), u2 = Math.cos(a2), e2 = n2[0], o2 = n2[1], i2 = n2[2], h2 = n2[3], c2 = n2[4], s2 = n2[5], M2 = n2[6], f2 = n2[7];
    return n2 !== t2 && (t2[8] = n2[8], t2[9] = n2[9], t2[10] = n2[10], t2[11] = n2[11], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]), t2[0] = e2 * u2 + c2 * r2, t2[1] = o2 * u2 + s2 * r2, t2[2] = i2 * u2 + M2 * r2, t2[3] = h2 * u2 + f2 * r2, t2[4] = c2 * u2 - e2 * r2, t2[5] = s2 * u2 - o2 * r2, t2[6] = M2 * u2 - i2 * r2, t2[7] = f2 * u2 - h2 * r2, t2;
  }
  function Mn(t2, n2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = n2[0], t2[13] = n2[1], t2[14] = n2[2], t2[15] = 1, t2;
  }
  function fn(t2, n2) {
    return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = n2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = n2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }
  function ln(t2, n2, a2) {
    var r2, u2, e2, o2 = a2[0], i2 = a2[1], h2 = a2[2], c2 = Math.hypot(o2, i2, h2);
    return c2 < M ? null : (o2 *= c2 = 1 / c2, i2 *= c2, h2 *= c2, r2 = Math.sin(n2), e2 = 1 - (u2 = Math.cos(n2)), t2[0] = o2 * o2 * e2 + u2, t2[1] = i2 * o2 * e2 + h2 * r2, t2[2] = h2 * o2 * e2 - i2 * r2, t2[3] = 0, t2[4] = o2 * i2 * e2 - h2 * r2, t2[5] = i2 * i2 * e2 + u2, t2[6] = h2 * i2 * e2 + o2 * r2, t2[7] = 0, t2[8] = o2 * h2 * e2 + i2 * r2, t2[9] = i2 * h2 * e2 - o2 * r2, t2[10] = h2 * h2 * e2 + u2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
  }
  function vn(t2, n2) {
    var a2 = Math.sin(n2), r2 = Math.cos(n2);
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = r2, t2[6] = a2, t2[7] = 0, t2[8] = 0, t2[9] = -a2, t2[10] = r2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }
  function bn(t2, n2) {
    var a2 = Math.sin(n2), r2 = Math.cos(n2);
    return t2[0] = r2, t2[1] = 0, t2[2] = -a2, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = a2, t2[9] = 0, t2[10] = r2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }
  function mn(t2, n2) {
    var a2 = Math.sin(n2), r2 = Math.cos(n2);
    return t2[0] = r2, t2[1] = a2, t2[2] = 0, t2[3] = 0, t2[4] = -a2, t2[5] = r2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }
  function dn(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = r2 + r2, h2 = u2 + u2, c2 = e2 + e2, s2 = r2 * i2, M2 = r2 * h2, f2 = r2 * c2, l2 = u2 * h2, v2 = u2 * c2, b2 = e2 * c2, m2 = o2 * i2, d2 = o2 * h2, x2 = o2 * c2;
    return t2[0] = 1 - (l2 + b2), t2[1] = M2 + x2, t2[2] = f2 - d2, t2[3] = 0, t2[4] = M2 - x2, t2[5] = 1 - (s2 + b2), t2[6] = v2 + m2, t2[7] = 0, t2[8] = f2 + d2, t2[9] = v2 - m2, t2[10] = 1 - (s2 + l2), t2[11] = 0, t2[12] = a2[0], t2[13] = a2[1], t2[14] = a2[2], t2[15] = 1, t2;
  }
  function xn(t2, n2) {
    var a2 = new f(3), r2 = -n2[0], u2 = -n2[1], e2 = -n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = r2 * r2 + u2 * u2 + e2 * e2 + o2 * o2;
    return M2 > 0 ? (a2[0] = 2 * (i2 * o2 + s2 * r2 + h2 * e2 - c2 * u2) / M2, a2[1] = 2 * (h2 * o2 + s2 * u2 + c2 * r2 - i2 * e2) / M2, a2[2] = 2 * (c2 * o2 + s2 * e2 + i2 * u2 - h2 * r2) / M2) : (a2[0] = 2 * (i2 * o2 + s2 * r2 + h2 * e2 - c2 * u2), a2[1] = 2 * (h2 * o2 + s2 * u2 + c2 * r2 - i2 * e2), a2[2] = 2 * (c2 * o2 + s2 * e2 + i2 * u2 - h2 * r2)), dn(t2, n2, a2), t2;
  }
  function yn(t2, n2) {
    return t2[0] = n2[12], t2[1] = n2[13], t2[2] = n2[14], t2;
  }
  function pn(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[4], o2 = n2[5], i2 = n2[6], h2 = n2[8], c2 = n2[9], s2 = n2[10];
    return t2[0] = Math.hypot(a2, r2, u2), t2[1] = Math.hypot(e2, o2, i2), t2[2] = Math.hypot(h2, c2, s2), t2;
  }
  function qn(t2, n2) {
    var a2 = new f(3);
    pn(a2, n2);
    var r2 = 1 / a2[0], u2 = 1 / a2[1], e2 = 1 / a2[2], o2 = n2[0] * r2, i2 = n2[1] * u2, h2 = n2[2] * e2, c2 = n2[4] * r2, s2 = n2[5] * u2, M2 = n2[6] * e2, l2 = n2[8] * r2, v2 = n2[9] * u2, b2 = n2[10] * e2, m2 = o2 + s2 + b2, d2 = 0;
    return m2 > 0 ? (d2 = 2 * Math.sqrt(m2 + 1), t2[3] = 0.25 * d2, t2[0] = (M2 - v2) / d2, t2[1] = (l2 - h2) / d2, t2[2] = (i2 - c2) / d2) : o2 > s2 && o2 > b2 ? (d2 = 2 * Math.sqrt(1 + o2 - s2 - b2), t2[3] = (M2 - v2) / d2, t2[0] = 0.25 * d2, t2[1] = (i2 + c2) / d2, t2[2] = (l2 + h2) / d2) : s2 > b2 ? (d2 = 2 * Math.sqrt(1 + s2 - o2 - b2), t2[3] = (l2 - h2) / d2, t2[0] = (i2 + c2) / d2, t2[1] = 0.25 * d2, t2[2] = (M2 + v2) / d2) : (d2 = 2 * Math.sqrt(1 + b2 - o2 - s2), t2[3] = (i2 - c2) / d2, t2[0] = (l2 + h2) / d2, t2[1] = (M2 + v2) / d2, t2[2] = 0.25 * d2), t2;
  }
  function wn(t2, n2, a2, r2) {
    var u2 = n2[0], e2 = n2[1], o2 = n2[2], i2 = n2[3], h2 = u2 + u2, c2 = e2 + e2, s2 = o2 + o2, M2 = u2 * h2, f2 = u2 * c2, l2 = u2 * s2, v2 = e2 * c2, b2 = e2 * s2, m2 = o2 * s2, d2 = i2 * h2, x2 = i2 * c2, y2 = i2 * s2, p2 = r2[0], q2 = r2[1], w2 = r2[2];
    return t2[0] = (1 - (v2 + m2)) * p2, t2[1] = (f2 + y2) * p2, t2[2] = (l2 - x2) * p2, t2[3] = 0, t2[4] = (f2 - y2) * q2, t2[5] = (1 - (M2 + m2)) * q2, t2[6] = (b2 + d2) * q2, t2[7] = 0, t2[8] = (l2 + x2) * w2, t2[9] = (b2 - d2) * w2, t2[10] = (1 - (M2 + v2)) * w2, t2[11] = 0, t2[12] = a2[0], t2[13] = a2[1], t2[14] = a2[2], t2[15] = 1, t2;
  }
  function gn(t2, n2, a2, r2, u2) {
    var e2 = n2[0], o2 = n2[1], i2 = n2[2], h2 = n2[3], c2 = e2 + e2, s2 = o2 + o2, M2 = i2 + i2, f2 = e2 * c2, l2 = e2 * s2, v2 = e2 * M2, b2 = o2 * s2, m2 = o2 * M2, d2 = i2 * M2, x2 = h2 * c2, y2 = h2 * s2, p2 = h2 * M2, q2 = r2[0], w2 = r2[1], g2 = r2[2], A2 = u2[0], P2 = u2[1], S2 = u2[2], R2 = (1 - (b2 + d2)) * q2, T2 = (l2 + p2) * q2, I2 = (v2 - y2) * q2, E2 = (l2 - p2) * w2, D2 = (1 - (f2 + d2)) * w2, F2 = (m2 + x2) * w2, L2 = (v2 + y2) * g2, V2 = (m2 - x2) * g2, j2 = (1 - (f2 + b2)) * g2;
    return t2[0] = R2, t2[1] = T2, t2[2] = I2, t2[3] = 0, t2[4] = E2, t2[5] = D2, t2[6] = F2, t2[7] = 0, t2[8] = L2, t2[9] = V2, t2[10] = j2, t2[11] = 0, t2[12] = a2[0] + A2 - (R2 * A2 + E2 * P2 + L2 * S2), t2[13] = a2[1] + P2 - (T2 * A2 + D2 * P2 + V2 * S2), t2[14] = a2[2] + S2 - (I2 * A2 + F2 * P2 + j2 * S2), t2[15] = 1, t2;
  }
  function An(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = a2 + a2, i2 = r2 + r2, h2 = u2 + u2, c2 = a2 * o2, s2 = r2 * o2, M2 = r2 * i2, f2 = u2 * o2, l2 = u2 * i2, v2 = u2 * h2, b2 = e2 * o2, m2 = e2 * i2, d2 = e2 * h2;
    return t2[0] = 1 - M2 - v2, t2[1] = s2 + d2, t2[2] = f2 - m2, t2[3] = 0, t2[4] = s2 - d2, t2[5] = 1 - c2 - v2, t2[6] = l2 + b2, t2[7] = 0, t2[8] = f2 + m2, t2[9] = l2 - b2, t2[10] = 1 - c2 - M2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }
  function Pn(t2, n2, a2, r2, u2, e2, o2) {
    var i2 = 1 / (a2 - n2), h2 = 1 / (u2 - r2), c2 = 1 / (e2 - o2);
    return t2[0] = 2 * e2 * i2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 2 * e2 * h2, t2[6] = 0, t2[7] = 0, t2[8] = (a2 + n2) * i2, t2[9] = (u2 + r2) * h2, t2[10] = (o2 + e2) * c2, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = o2 * e2 * 2 * c2, t2[15] = 0, t2;
  }
  function Sn(t2, n2, a2, r2, u2) {
    var e2, o2 = 1 / Math.tan(n2 / 2);
    return t2[0] = o2 / a2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != u2 && u2 !== 1 / 0 ? (e2 = 1 / (r2 - u2), t2[10] = (u2 + r2) * e2, t2[14] = 2 * u2 * r2 * e2) : (t2[10] = -1, t2[14] = -2 * r2), t2;
  }
  function Rn(t2, n2, a2, r2) {
    var u2 = Math.tan(n2.upDegrees * Math.PI / 180), e2 = Math.tan(n2.downDegrees * Math.PI / 180), o2 = Math.tan(n2.leftDegrees * Math.PI / 180), i2 = Math.tan(n2.rightDegrees * Math.PI / 180), h2 = 2 / (o2 + i2), c2 = 2 / (u2 + e2);
    return t2[0] = h2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = c2, t2[6] = 0, t2[7] = 0, t2[8] = -(o2 - i2) * h2 * 0.5, t2[9] = (u2 - e2) * c2 * 0.5, t2[10] = r2 / (a2 - r2), t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = r2 * a2 / (a2 - r2), t2[15] = 0, t2;
  }
  function Tn(t2, n2, a2, r2, u2, e2, o2) {
    var i2 = 1 / (n2 - a2), h2 = 1 / (r2 - u2), c2 = 1 / (e2 - o2);
    return t2[0] = -2 * i2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * h2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * c2, t2[11] = 0, t2[12] = (n2 + a2) * i2, t2[13] = (u2 + r2) * h2, t2[14] = (o2 + e2) * c2, t2[15] = 1, t2;
  }
  function In(t2, n2, a2, r2) {
    var u2, e2, o2, i2, h2, c2, s2, f2, l2, v2, b2 = n2[0], m2 = n2[1], d2 = n2[2], x2 = r2[0], y2 = r2[1], p2 = r2[2], q2 = a2[0], w2 = a2[1], g2 = a2[2];
    return Math.abs(b2 - q2) < M && Math.abs(m2 - w2) < M && Math.abs(d2 - g2) < M ? Kt(t2) : (s2 = b2 - q2, f2 = m2 - w2, l2 = d2 - g2, u2 = y2 * (l2 *= v2 = 1 / Math.hypot(s2, f2, l2)) - p2 * (f2 *= v2), e2 = p2 * (s2 *= v2) - x2 * l2, o2 = x2 * f2 - y2 * s2, (v2 = Math.hypot(u2, e2, o2)) ? (u2 *= v2 = 1 / v2, e2 *= v2, o2 *= v2) : (u2 = 0, e2 = 0, o2 = 0), i2 = f2 * o2 - l2 * e2, h2 = l2 * u2 - s2 * o2, c2 = s2 * e2 - f2 * u2, (v2 = Math.hypot(i2, h2, c2)) ? (i2 *= v2 = 1 / v2, h2 *= v2, c2 *= v2) : (i2 = 0, h2 = 0, c2 = 0), t2[0] = u2, t2[1] = i2, t2[2] = s2, t2[3] = 0, t2[4] = e2, t2[5] = h2, t2[6] = f2, t2[7] = 0, t2[8] = o2, t2[9] = c2, t2[10] = l2, t2[11] = 0, t2[12] = -(u2 * b2 + e2 * m2 + o2 * d2), t2[13] = -(i2 * b2 + h2 * m2 + c2 * d2), t2[14] = -(s2 * b2 + f2 * m2 + l2 * d2), t2[15] = 1, t2);
  }
  function En(t2, n2, a2, r2) {
    var u2 = n2[0], e2 = n2[1], o2 = n2[2], i2 = r2[0], h2 = r2[1], c2 = r2[2], s2 = u2 - a2[0], M2 = e2 - a2[1], f2 = o2 - a2[2], l2 = s2 * s2 + M2 * M2 + f2 * f2;
    l2 > 0 && (s2 *= l2 = 1 / Math.sqrt(l2), M2 *= l2, f2 *= l2);
    var v2 = h2 * f2 - c2 * M2, b2 = c2 * s2 - i2 * f2, m2 = i2 * M2 - h2 * s2;
    return (l2 = v2 * v2 + b2 * b2 + m2 * m2) > 0 && (v2 *= l2 = 1 / Math.sqrt(l2), b2 *= l2, m2 *= l2), t2[0] = v2, t2[1] = b2, t2[2] = m2, t2[3] = 0, t2[4] = M2 * m2 - f2 * b2, t2[5] = f2 * v2 - s2 * m2, t2[6] = s2 * b2 - M2 * v2, t2[7] = 0, t2[8] = s2, t2[9] = M2, t2[10] = f2, t2[11] = 0, t2[12] = u2, t2[13] = e2, t2[14] = o2, t2[15] = 1, t2;
  }
  function Dn(t2) {
    return "mat4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ", " + t2[9] + ", " + t2[10] + ", " + t2[11] + ", " + t2[12] + ", " + t2[13] + ", " + t2[14] + ", " + t2[15] + ")";
  }
  function Fn(t2) {
    return Math.hypot(t2[0], t2[1], t2[3], t2[4], t2[5], t2[6], t2[7], t2[8], t2[9], t2[10], t2[11], t2[12], t2[13], t2[14], t2[15]);
  }
  function Ln(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2[4] = n2[4] + a2[4], t2[5] = n2[5] + a2[5], t2[6] = n2[6] + a2[6], t2[7] = n2[7] + a2[7], t2[8] = n2[8] + a2[8], t2[9] = n2[9] + a2[9], t2[10] = n2[10] + a2[10], t2[11] = n2[11] + a2[11], t2[12] = n2[12] + a2[12], t2[13] = n2[13] + a2[13], t2[14] = n2[14] + a2[14], t2[15] = n2[15] + a2[15], t2;
  }
  function Vn(t2, n2, a2) {
    return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2[3] = n2[3] - a2[3], t2[4] = n2[4] - a2[4], t2[5] = n2[5] - a2[5], t2[6] = n2[6] - a2[6], t2[7] = n2[7] - a2[7], t2[8] = n2[8] - a2[8], t2[9] = n2[9] - a2[9], t2[10] = n2[10] - a2[10], t2[11] = n2[11] - a2[11], t2[12] = n2[12] - a2[12], t2[13] = n2[13] - a2[13], t2[14] = n2[14] - a2[14], t2[15] = n2[15] - a2[15], t2;
  }
  function jn(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2[4] = n2[4] * a2, t2[5] = n2[5] * a2, t2[6] = n2[6] * a2, t2[7] = n2[7] * a2, t2[8] = n2[8] * a2, t2[9] = n2[9] * a2, t2[10] = n2[10] * a2, t2[11] = n2[11] * a2, t2[12] = n2[12] * a2, t2[13] = n2[13] * a2, t2[14] = n2[14] * a2, t2[15] = n2[15] * a2, t2;
  }
  function zn(t2, n2, a2, r2) {
    return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2[3] = n2[3] + a2[3] * r2, t2[4] = n2[4] + a2[4] * r2, t2[5] = n2[5] + a2[5] * r2, t2[6] = n2[6] + a2[6] * r2, t2[7] = n2[7] + a2[7] * r2, t2[8] = n2[8] + a2[8] * r2, t2[9] = n2[9] + a2[9] * r2, t2[10] = n2[10] + a2[10] * r2, t2[11] = n2[11] + a2[11] * r2, t2[12] = n2[12] + a2[12] * r2, t2[13] = n2[13] + a2[13] * r2, t2[14] = n2[14] + a2[14] * r2, t2[15] = n2[15] + a2[15] * r2, t2;
  }
  function On(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5] && t2[6] === n2[6] && t2[7] === n2[7] && t2[8] === n2[8] && t2[9] === n2[9] && t2[10] === n2[10] && t2[11] === n2[11] && t2[12] === n2[12] && t2[13] === n2[13] && t2[14] === n2[14] && t2[15] === n2[15];
  }
  function Qn(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = t2[2], e2 = t2[3], o2 = t2[4], i2 = t2[5], h2 = t2[6], c2 = t2[7], s2 = t2[8], f2 = t2[9], l2 = t2[10], v2 = t2[11], b2 = t2[12], m2 = t2[13], d2 = t2[14], x2 = t2[15], y2 = n2[0], p2 = n2[1], q2 = n2[2], w2 = n2[3], g2 = n2[4], A2 = n2[5], P2 = n2[6], S2 = n2[7], R2 = n2[8], T2 = n2[9], I2 = n2[10], E2 = n2[11], D2 = n2[12], F2 = n2[13], L2 = n2[14], V2 = n2[15];
    return Math.abs(a2 - y2) <= M * Math.max(1, Math.abs(a2), Math.abs(y2)) && Math.abs(r2 - p2) <= M * Math.max(1, Math.abs(r2), Math.abs(p2)) && Math.abs(u2 - q2) <= M * Math.max(1, Math.abs(u2), Math.abs(q2)) && Math.abs(e2 - w2) <= M * Math.max(1, Math.abs(e2), Math.abs(w2)) && Math.abs(o2 - g2) <= M * Math.max(1, Math.abs(o2), Math.abs(g2)) && Math.abs(i2 - A2) <= M * Math.max(1, Math.abs(i2), Math.abs(A2)) && Math.abs(h2 - P2) <= M * Math.max(1, Math.abs(h2), Math.abs(P2)) && Math.abs(c2 - S2) <= M * Math.max(1, Math.abs(c2), Math.abs(S2)) && Math.abs(s2 - R2) <= M * Math.max(1, Math.abs(s2), Math.abs(R2)) && Math.abs(f2 - T2) <= M * Math.max(1, Math.abs(f2), Math.abs(T2)) && Math.abs(l2 - I2) <= M * Math.max(1, Math.abs(l2), Math.abs(I2)) && Math.abs(v2 - E2) <= M * Math.max(1, Math.abs(v2), Math.abs(E2)) && Math.abs(b2 - D2) <= M * Math.max(1, Math.abs(b2), Math.abs(D2)) && Math.abs(m2 - F2) <= M * Math.max(1, Math.abs(m2), Math.abs(F2)) && Math.abs(d2 - L2) <= M * Math.max(1, Math.abs(d2), Math.abs(L2)) && Math.abs(x2 - V2) <= M * Math.max(1, Math.abs(x2), Math.abs(V2));
  }
  var Yn = rn, Xn = Vn;
  function Zn() {
    var t2 = new f(3);
    return f != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
  }
  function _n(t2) {
    var n2 = new f(3);
    return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2;
  }
  function Bn(t2) {
    var n2 = t2[0], a2 = t2[1], r2 = t2[2];
    return Math.hypot(n2, a2, r2);
  }
  function Nn(t2, n2, a2) {
    var r2 = new f(3);
    return r2[0] = t2, r2[1] = n2, r2[2] = a2, r2;
  }
  function kn(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2;
  }
  function Un(t2, n2, a2, r2) {
    return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2;
  }
  function Wn(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2;
  }
  function Cn(t2, n2, a2) {
    return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2;
  }
  function Gn(t2, n2, a2) {
    return t2[0] = n2[0] * a2[0], t2[1] = n2[1] * a2[1], t2[2] = n2[2] * a2[2], t2;
  }
  function Hn(t2, n2, a2) {
    return t2[0] = n2[0] / a2[0], t2[1] = n2[1] / a2[1], t2[2] = n2[2] / a2[2], t2;
  }
  function Jn(t2, n2) {
    return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2[2] = Math.ceil(n2[2]), t2;
  }
  function Kn(t2, n2) {
    return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2[2] = Math.floor(n2[2]), t2;
  }
  function $n(t2, n2, a2) {
    return t2[0] = Math.min(n2[0], a2[0]), t2[1] = Math.min(n2[1], a2[1]), t2[2] = Math.min(n2[2], a2[2]), t2;
  }
  function ta(t2, n2, a2) {
    return t2[0] = Math.max(n2[0], a2[0]), t2[1] = Math.max(n2[1], a2[1]), t2[2] = Math.max(n2[2], a2[2]), t2;
  }
  function na(t2, n2) {
    return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2[2] = Math.round(n2[2]), t2;
  }
  function aa(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2;
  }
  function ra(t2, n2, a2, r2) {
    return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2;
  }
  function ua(t2, n2) {
    var a2 = n2[0] - t2[0], r2 = n2[1] - t2[1], u2 = n2[2] - t2[2];
    return Math.hypot(a2, r2, u2);
  }
  function ea(t2, n2) {
    var a2 = n2[0] - t2[0], r2 = n2[1] - t2[1], u2 = n2[2] - t2[2];
    return a2 * a2 + r2 * r2 + u2 * u2;
  }
  function oa(t2) {
    var n2 = t2[0], a2 = t2[1], r2 = t2[2];
    return n2 * n2 + a2 * a2 + r2 * r2;
  }
  function ia(t2, n2) {
    return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2;
  }
  function ha(t2, n2) {
    return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2[2] = 1 / n2[2], t2;
  }
  function ca(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = a2 * a2 + r2 * r2 + u2 * u2;
    return e2 > 0 && (e2 = 1 / Math.sqrt(e2)), t2[0] = n2[0] * e2, t2[1] = n2[1] * e2, t2[2] = n2[2] * e2, t2;
  }
  function sa(t2, n2) {
    return t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2];
  }
  function Ma(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = a2[0], i2 = a2[1], h2 = a2[2];
    return t2[0] = u2 * h2 - e2 * i2, t2[1] = e2 * o2 - r2 * h2, t2[2] = r2 * i2 - u2 * o2, t2;
  }
  function fa(t2, n2, a2, r2) {
    var u2 = n2[0], e2 = n2[1], o2 = n2[2];
    return t2[0] = u2 + r2 * (a2[0] - u2), t2[1] = e2 + r2 * (a2[1] - e2), t2[2] = o2 + r2 * (a2[2] - o2), t2;
  }
  function la(t2, n2, a2, r2, u2, e2) {
    var o2 = e2 * e2, i2 = o2 * (2 * e2 - 3) + 1, h2 = o2 * (e2 - 2) + e2, c2 = o2 * (e2 - 1), s2 = o2 * (3 - 2 * e2);
    return t2[0] = n2[0] * i2 + a2[0] * h2 + r2[0] * c2 + u2[0] * s2, t2[1] = n2[1] * i2 + a2[1] * h2 + r2[1] * c2 + u2[1] * s2, t2[2] = n2[2] * i2 + a2[2] * h2 + r2[2] * c2 + u2[2] * s2, t2;
  }
  function va(t2, n2, a2, r2, u2, e2) {
    var o2 = 1 - e2, i2 = o2 * o2, h2 = e2 * e2, c2 = i2 * o2, s2 = 3 * e2 * i2, M2 = 3 * h2 * o2, f2 = h2 * e2;
    return t2[0] = n2[0] * c2 + a2[0] * s2 + r2[0] * M2 + u2[0] * f2, t2[1] = n2[1] * c2 + a2[1] * s2 + r2[1] * M2 + u2[1] * f2, t2[2] = n2[2] * c2 + a2[2] * s2 + r2[2] * M2 + u2[2] * f2, t2;
  }
  function ba(t2, n2) {
    n2 = n2 || 1;
    var a2 = 2 * l() * Math.PI, r2 = 2 * l() - 1, u2 = Math.sqrt(1 - r2 * r2) * n2;
    return t2[0] = Math.cos(a2) * u2, t2[1] = Math.sin(a2) * u2, t2[2] = r2 * n2, t2;
  }
  function ma(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = a2[3] * r2 + a2[7] * u2 + a2[11] * e2 + a2[15];
    return o2 = o2 || 1, t2[0] = (a2[0] * r2 + a2[4] * u2 + a2[8] * e2 + a2[12]) / o2, t2[1] = (a2[1] * r2 + a2[5] * u2 + a2[9] * e2 + a2[13]) / o2, t2[2] = (a2[2] * r2 + a2[6] * u2 + a2[10] * e2 + a2[14]) / o2, t2;
  }
  function da(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2];
    return t2[0] = r2 * a2[0] + u2 * a2[3] + e2 * a2[6], t2[1] = r2 * a2[1] + u2 * a2[4] + e2 * a2[7], t2[2] = r2 * a2[2] + u2 * a2[5] + e2 * a2[8], t2;
  }
  function xa(t2, n2, a2) {
    var r2 = a2[0], u2 = a2[1], e2 = a2[2], o2 = a2[3], i2 = n2[0], h2 = n2[1], c2 = n2[2], s2 = u2 * c2 - e2 * h2, M2 = e2 * i2 - r2 * c2, f2 = r2 * h2 - u2 * i2, l2 = u2 * f2 - e2 * M2, v2 = e2 * s2 - r2 * f2, b2 = r2 * M2 - u2 * s2, m2 = 2 * o2;
    return s2 *= m2, M2 *= m2, f2 *= m2, l2 *= 2, v2 *= 2, b2 *= 2, t2[0] = i2 + s2 + l2, t2[1] = h2 + M2 + v2, t2[2] = c2 + f2 + b2, t2;
  }
  function ya(t2, n2, a2, r2) {
    var u2 = [], e2 = [];
    return u2[0] = n2[0] - a2[0], u2[1] = n2[1] - a2[1], u2[2] = n2[2] - a2[2], e2[0] = u2[0], e2[1] = u2[1] * Math.cos(r2) - u2[2] * Math.sin(r2), e2[2] = u2[1] * Math.sin(r2) + u2[2] * Math.cos(r2), t2[0] = e2[0] + a2[0], t2[1] = e2[1] + a2[1], t2[2] = e2[2] + a2[2], t2;
  }
  function pa(t2, n2, a2, r2) {
    var u2 = [], e2 = [];
    return u2[0] = n2[0] - a2[0], u2[1] = n2[1] - a2[1], u2[2] = n2[2] - a2[2], e2[0] = u2[2] * Math.sin(r2) + u2[0] * Math.cos(r2), e2[1] = u2[1], e2[2] = u2[2] * Math.cos(r2) - u2[0] * Math.sin(r2), t2[0] = e2[0] + a2[0], t2[1] = e2[1] + a2[1], t2[2] = e2[2] + a2[2], t2;
  }
  function qa(t2, n2, a2, r2) {
    var u2 = [], e2 = [];
    return u2[0] = n2[0] - a2[0], u2[1] = n2[1] - a2[1], u2[2] = n2[2] - a2[2], e2[0] = u2[0] * Math.cos(r2) - u2[1] * Math.sin(r2), e2[1] = u2[0] * Math.sin(r2) + u2[1] * Math.cos(r2), e2[2] = u2[2], t2[0] = e2[0] + a2[0], t2[1] = e2[1] + a2[1], t2[2] = e2[2] + a2[2], t2;
  }
  function wa(t2, n2) {
    var a2 = Nn(t2[0], t2[1], t2[2]), r2 = Nn(n2[0], n2[1], n2[2]);
    ca(a2, a2), ca(r2, r2);
    var u2 = sa(a2, r2);
    return u2 > 1 ? 0 : u2 < -1 ? Math.PI : Math.acos(u2);
  }
  function ga(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
  }
  function Aa(t2) {
    return "vec3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ")";
  }
  function Pa(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2];
  }
  function Sa(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = t2[2], e2 = n2[0], o2 = n2[1], i2 = n2[2];
    return Math.abs(a2 - e2) <= M * Math.max(1, Math.abs(a2), Math.abs(e2)) && Math.abs(r2 - o2) <= M * Math.max(1, Math.abs(r2), Math.abs(o2)) && Math.abs(u2 - i2) <= M * Math.max(1, Math.abs(u2), Math.abs(i2));
  }
  var Ra, Ta = Cn, Ia = Gn, Ea = Hn, Da = ua, Fa = ea, La = Bn, Va = oa, ja = (Ra = Zn(), function(t2, n2, a2, r2, u2, e2) {
    var o2, i2;
    for (n2 || (n2 = 3), a2 || (a2 = 0), i2 = r2 ? Math.min(r2 * n2 + a2, t2.length) : t2.length, o2 = a2; o2 < i2; o2 += n2)
      Ra[0] = t2[o2], Ra[1] = t2[o2 + 1], Ra[2] = t2[o2 + 2], u2(Ra, Ra, e2), t2[o2] = Ra[0], t2[o2 + 1] = Ra[1], t2[o2 + 2] = Ra[2];
    return t2;
  });
  function za() {
    var t2 = new f(4);
    return f != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0), t2;
  }
  function Oa(t2) {
    var n2 = new f(4);
    return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2;
  }
  function Qa(t2, n2, a2, r2) {
    var u2 = new f(4);
    return u2[0] = t2, u2[1] = n2, u2[2] = a2, u2[3] = r2, u2;
  }
  function Ya(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2;
  }
  function Xa(t2, n2, a2, r2, u2) {
    return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = u2, t2;
  }
  function Za(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2;
  }
  function _a(t2, n2, a2) {
    return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2[3] = n2[3] - a2[3], t2;
  }
  function Ba(t2, n2, a2) {
    return t2[0] = n2[0] * a2[0], t2[1] = n2[1] * a2[1], t2[2] = n2[2] * a2[2], t2[3] = n2[3] * a2[3], t2;
  }
  function Na(t2, n2, a2) {
    return t2[0] = n2[0] / a2[0], t2[1] = n2[1] / a2[1], t2[2] = n2[2] / a2[2], t2[3] = n2[3] / a2[3], t2;
  }
  function ka(t2, n2) {
    return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2[2] = Math.ceil(n2[2]), t2[3] = Math.ceil(n2[3]), t2;
  }
  function Ua(t2, n2) {
    return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2[2] = Math.floor(n2[2]), t2[3] = Math.floor(n2[3]), t2;
  }
  function Wa(t2, n2, a2) {
    return t2[0] = Math.min(n2[0], a2[0]), t2[1] = Math.min(n2[1], a2[1]), t2[2] = Math.min(n2[2], a2[2]), t2[3] = Math.min(n2[3], a2[3]), t2;
  }
  function Ca(t2, n2, a2) {
    return t2[0] = Math.max(n2[0], a2[0]), t2[1] = Math.max(n2[1], a2[1]), t2[2] = Math.max(n2[2], a2[2]), t2[3] = Math.max(n2[3], a2[3]), t2;
  }
  function Ga(t2, n2) {
    return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2[2] = Math.round(n2[2]), t2[3] = Math.round(n2[3]), t2;
  }
  function Ha(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2;
  }
  function Ja(t2, n2, a2, r2) {
    return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2[3] = n2[3] + a2[3] * r2, t2;
  }
  function Ka(t2, n2) {
    var a2 = n2[0] - t2[0], r2 = n2[1] - t2[1], u2 = n2[2] - t2[2], e2 = n2[3] - t2[3];
    return Math.hypot(a2, r2, u2, e2);
  }
  function $a(t2, n2) {
    var a2 = n2[0] - t2[0], r2 = n2[1] - t2[1], u2 = n2[2] - t2[2], e2 = n2[3] - t2[3];
    return a2 * a2 + r2 * r2 + u2 * u2 + e2 * e2;
  }
  function tr(t2) {
    var n2 = t2[0], a2 = t2[1], r2 = t2[2], u2 = t2[3];
    return Math.hypot(n2, a2, r2, u2);
  }
  function nr(t2) {
    var n2 = t2[0], a2 = t2[1], r2 = t2[2], u2 = t2[3];
    return n2 * n2 + a2 * a2 + r2 * r2 + u2 * u2;
  }
  function ar(t2, n2) {
    return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = -n2[3], t2;
  }
  function rr(t2, n2) {
    return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2[2] = 1 / n2[2], t2[3] = 1 / n2[3], t2;
  }
  function ur(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = a2 * a2 + r2 * r2 + u2 * u2 + e2 * e2;
    return o2 > 0 && (o2 = 1 / Math.sqrt(o2)), t2[0] = a2 * o2, t2[1] = r2 * o2, t2[2] = u2 * o2, t2[3] = e2 * o2, t2;
  }
  function er(t2, n2) {
    return t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2] + t2[3] * n2[3];
  }
  function or(t2, n2, a2, r2) {
    var u2 = a2[0] * r2[1] - a2[1] * r2[0], e2 = a2[0] * r2[2] - a2[2] * r2[0], o2 = a2[0] * r2[3] - a2[3] * r2[0], i2 = a2[1] * r2[2] - a2[2] * r2[1], h2 = a2[1] * r2[3] - a2[3] * r2[1], c2 = a2[2] * r2[3] - a2[3] * r2[2], s2 = n2[0], M2 = n2[1], f2 = n2[2], l2 = n2[3];
    return t2[0] = M2 * c2 - f2 * h2 + l2 * i2, t2[1] = -s2 * c2 + f2 * o2 - l2 * e2, t2[2] = s2 * h2 - M2 * o2 + l2 * u2, t2[3] = -s2 * i2 + M2 * e2 - f2 * u2, t2;
  }
  function ir(t2, n2, a2, r2) {
    var u2 = n2[0], e2 = n2[1], o2 = n2[2], i2 = n2[3];
    return t2[0] = u2 + r2 * (a2[0] - u2), t2[1] = e2 + r2 * (a2[1] - e2), t2[2] = o2 + r2 * (a2[2] - o2), t2[3] = i2 + r2 * (a2[3] - i2), t2;
  }
  function hr(t2, n2) {
    var a2, r2, u2, e2, o2, i2;
    n2 = n2 || 1;
    do {
      o2 = (a2 = 2 * l() - 1) * a2 + (r2 = 2 * l() - 1) * r2;
    } while (o2 >= 1);
    do {
      i2 = (u2 = 2 * l() - 1) * u2 + (e2 = 2 * l() - 1) * e2;
    } while (i2 >= 1);
    var h2 = Math.sqrt((1 - o2) / i2);
    return t2[0] = n2 * a2, t2[1] = n2 * r2, t2[2] = n2 * u2 * h2, t2[3] = n2 * e2 * h2, t2;
  }
  function cr(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3];
    return t2[0] = a2[0] * r2 + a2[4] * u2 + a2[8] * e2 + a2[12] * o2, t2[1] = a2[1] * r2 + a2[5] * u2 + a2[9] * e2 + a2[13] * o2, t2[2] = a2[2] * r2 + a2[6] * u2 + a2[10] * e2 + a2[14] * o2, t2[3] = a2[3] * r2 + a2[7] * u2 + a2[11] * e2 + a2[15] * o2, t2;
  }
  function sr(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = a2[0], i2 = a2[1], h2 = a2[2], c2 = a2[3], s2 = c2 * r2 + i2 * e2 - h2 * u2, M2 = c2 * u2 + h2 * r2 - o2 * e2, f2 = c2 * e2 + o2 * u2 - i2 * r2, l2 = -o2 * r2 - i2 * u2 - h2 * e2;
    return t2[0] = s2 * c2 + l2 * -o2 + M2 * -h2 - f2 * -i2, t2[1] = M2 * c2 + l2 * -i2 + f2 * -o2 - s2 * -h2, t2[2] = f2 * c2 + l2 * -h2 + s2 * -i2 - M2 * -o2, t2[3] = n2[3], t2;
  }
  function Mr(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2;
  }
  function fr(t2) {
    return "vec4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
  }
  function lr(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3];
  }
  function vr(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = t2[2], e2 = t2[3], o2 = n2[0], i2 = n2[1], h2 = n2[2], c2 = n2[3];
    return Math.abs(a2 - o2) <= M * Math.max(1, Math.abs(a2), Math.abs(o2)) && Math.abs(r2 - i2) <= M * Math.max(1, Math.abs(r2), Math.abs(i2)) && Math.abs(u2 - h2) <= M * Math.max(1, Math.abs(u2), Math.abs(h2)) && Math.abs(e2 - c2) <= M * Math.max(1, Math.abs(e2), Math.abs(c2));
  }
  var br = _a, mr = Ba, dr = Na, xr = Ka, yr = $a, pr = tr, qr = nr, wr = function() {
    var t2 = za();
    return function(n2, a2, r2, u2, e2, o2) {
      var i2, h2;
      for (a2 || (a2 = 4), r2 || (r2 = 0), h2 = u2 ? Math.min(u2 * a2 + r2, n2.length) : n2.length, i2 = r2; i2 < h2; i2 += a2)
        t2[0] = n2[i2], t2[1] = n2[i2 + 1], t2[2] = n2[i2 + 2], t2[3] = n2[i2 + 3], e2(t2, t2, o2), n2[i2] = t2[0], n2[i2 + 1] = t2[1], n2[i2 + 2] = t2[2], n2[i2 + 3] = t2[3];
      return n2;
    };
  }();
  function gr() {
    var t2 = new f(4);
    return f != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
  }
  function Ar(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
  }
  function Pr(t2, n2, a2) {
    a2 *= 0.5;
    var r2 = Math.sin(a2);
    return t2[0] = r2 * n2[0], t2[1] = r2 * n2[1], t2[2] = r2 * n2[2], t2[3] = Math.cos(a2), t2;
  }
  function Sr(t2, n2) {
    var a2 = 2 * Math.acos(n2[3]), r2 = Math.sin(a2 / 2);
    return r2 > M ? (t2[0] = n2[0] / r2, t2[1] = n2[1] / r2, t2[2] = n2[2] / r2) : (t2[0] = 1, t2[1] = 0, t2[2] = 0), a2;
  }
  function Rr(t2, n2) {
    var a2 = au(t2, n2);
    return Math.acos(2 * a2 * a2 - 1);
  }
  function Tr(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = a2[0], h2 = a2[1], c2 = a2[2], s2 = a2[3];
    return t2[0] = r2 * s2 + o2 * i2 + u2 * c2 - e2 * h2, t2[1] = u2 * s2 + o2 * h2 + e2 * i2 - r2 * c2, t2[2] = e2 * s2 + o2 * c2 + r2 * h2 - u2 * i2, t2[3] = o2 * s2 - r2 * i2 - u2 * h2 - e2 * c2, t2;
  }
  function Ir(t2, n2, a2) {
    a2 *= 0.5;
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = Math.sin(a2), h2 = Math.cos(a2);
    return t2[0] = r2 * h2 + o2 * i2, t2[1] = u2 * h2 + e2 * i2, t2[2] = e2 * h2 - u2 * i2, t2[3] = o2 * h2 - r2 * i2, t2;
  }
  function Er(t2, n2, a2) {
    a2 *= 0.5;
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = Math.sin(a2), h2 = Math.cos(a2);
    return t2[0] = r2 * h2 - e2 * i2, t2[1] = u2 * h2 + o2 * i2, t2[2] = e2 * h2 + r2 * i2, t2[3] = o2 * h2 - u2 * i2, t2;
  }
  function Dr(t2, n2, a2) {
    a2 *= 0.5;
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = Math.sin(a2), h2 = Math.cos(a2);
    return t2[0] = r2 * h2 + u2 * i2, t2[1] = u2 * h2 - r2 * i2, t2[2] = e2 * h2 + o2 * i2, t2[3] = o2 * h2 - e2 * i2, t2;
  }
  function Fr(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2];
    return t2[0] = a2, t2[1] = r2, t2[2] = u2, t2[3] = Math.sqrt(Math.abs(1 - a2 * a2 - r2 * r2 - u2 * u2)), t2;
  }
  function Lr(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = Math.sqrt(a2 * a2 + r2 * r2 + u2 * u2), i2 = Math.exp(e2), h2 = o2 > 0 ? i2 * Math.sin(o2) / o2 : 0;
    return t2[0] = a2 * h2, t2[1] = r2 * h2, t2[2] = u2 * h2, t2[3] = i2 * Math.cos(o2), t2;
  }
  function Vr(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = Math.sqrt(a2 * a2 + r2 * r2 + u2 * u2), i2 = o2 > 0 ? Math.atan2(o2, e2) / o2 : 0;
    return t2[0] = a2 * i2, t2[1] = r2 * i2, t2[2] = u2 * i2, t2[3] = 0.5 * Math.log(a2 * a2 + r2 * r2 + u2 * u2 + e2 * e2), t2;
  }
  function jr(t2, n2, a2) {
    return Vr(t2, n2), nu(t2, t2, a2), Lr(t2, t2), t2;
  }
  function zr(t2, n2, a2, r2) {
    var u2, e2, o2, i2, h2, c2 = n2[0], s2 = n2[1], f2 = n2[2], l2 = n2[3], v2 = a2[0], b2 = a2[1], m2 = a2[2], d2 = a2[3];
    return (e2 = c2 * v2 + s2 * b2 + f2 * m2 + l2 * d2) < 0 && (e2 = -e2, v2 = -v2, b2 = -b2, m2 = -m2, d2 = -d2), 1 - e2 > M ? (u2 = Math.acos(e2), o2 = Math.sin(u2), i2 = Math.sin((1 - r2) * u2) / o2, h2 = Math.sin(r2 * u2) / o2) : (i2 = 1 - r2, h2 = r2), t2[0] = i2 * c2 + h2 * v2, t2[1] = i2 * s2 + h2 * b2, t2[2] = i2 * f2 + h2 * m2, t2[3] = i2 * l2 + h2 * d2, t2;
  }
  function Or(t2) {
    var n2 = l(), a2 = l(), r2 = l(), u2 = Math.sqrt(1 - n2), e2 = Math.sqrt(n2);
    return t2[0] = u2 * Math.sin(2 * Math.PI * a2), t2[1] = u2 * Math.cos(2 * Math.PI * a2), t2[2] = e2 * Math.sin(2 * Math.PI * r2), t2[3] = e2 * Math.cos(2 * Math.PI * r2), t2;
  }
  function Qr(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = n2[2], e2 = n2[3], o2 = a2 * a2 + r2 * r2 + u2 * u2 + e2 * e2, i2 = o2 ? 1 / o2 : 0;
    return t2[0] = -a2 * i2, t2[1] = -r2 * i2, t2[2] = -u2 * i2, t2[3] = e2 * i2, t2;
  }
  function Yr(t2, n2) {
    return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = n2[3], t2;
  }
  function Xr(t2, n2) {
    var a2, r2 = n2[0] + n2[4] + n2[8];
    if (r2 > 0)
      a2 = Math.sqrt(r2 + 1), t2[3] = 0.5 * a2, a2 = 0.5 / a2, t2[0] = (n2[5] - n2[7]) * a2, t2[1] = (n2[6] - n2[2]) * a2, t2[2] = (n2[1] - n2[3]) * a2;
    else {
      var u2 = 0;
      n2[4] > n2[0] && (u2 = 1), n2[8] > n2[3 * u2 + u2] && (u2 = 2);
      var e2 = (u2 + 1) % 3, o2 = (u2 + 2) % 3;
      a2 = Math.sqrt(n2[3 * u2 + u2] - n2[3 * e2 + e2] - n2[3 * o2 + o2] + 1), t2[u2] = 0.5 * a2, a2 = 0.5 / a2, t2[3] = (n2[3 * e2 + o2] - n2[3 * o2 + e2]) * a2, t2[e2] = (n2[3 * e2 + u2] + n2[3 * u2 + e2]) * a2, t2[o2] = (n2[3 * o2 + u2] + n2[3 * u2 + o2]) * a2;
    }
    return t2;
  }
  function Zr(t2, n2, a2, r2) {
    var u2 = 0.5 * Math.PI / 180;
    n2 *= u2, a2 *= u2, r2 *= u2;
    var e2 = Math.sin(n2), o2 = Math.cos(n2), i2 = Math.sin(a2), h2 = Math.cos(a2), c2 = Math.sin(r2), s2 = Math.cos(r2);
    return t2[0] = e2 * h2 * s2 - o2 * i2 * c2, t2[1] = o2 * i2 * s2 + e2 * h2 * c2, t2[2] = o2 * h2 * c2 - e2 * i2 * s2, t2[3] = o2 * h2 * s2 + e2 * i2 * c2, t2;
  }
  function _r(t2) {
    return "quat(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
  }
  var Br, Nr, kr, Ur, Wr, Cr, Gr = Oa, Hr = Qa, Jr = Ya, Kr = Xa, $r = Za, tu = Tr, nu = Ha, au = er, ru = ir, uu = tr, eu = uu, ou = nr, iu = ou, hu = ur, cu = lr, su = vr, Mu = (Br = Zn(), Nr = Nn(1, 0, 0), kr = Nn(0, 1, 0), function(t2, n2, a2) {
    var r2 = sa(n2, a2);
    return r2 < -0.999999 ? (Ma(Br, Nr, n2), La(Br) < 1e-6 && Ma(Br, kr, n2), ca(Br, Br), Pr(t2, Br, Math.PI), t2) : r2 > 0.999999 ? (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2) : (Ma(Br, n2, a2), t2[0] = Br[0], t2[1] = Br[1], t2[2] = Br[2], t2[3] = 1 + r2, hu(t2, t2));
  }), fu = (Ur = gr(), Wr = gr(), function(t2, n2, a2, r2, u2, e2) {
    return zr(Ur, n2, u2, e2), zr(Wr, a2, r2, e2), zr(t2, Ur, Wr, 2 * e2 * (1 - e2)), t2;
  }), lu = (Cr = bt(), function(t2, n2, a2, r2) {
    return Cr[0] = a2[0], Cr[3] = a2[1], Cr[6] = a2[2], Cr[1] = r2[0], Cr[4] = r2[1], Cr[7] = r2[2], Cr[2] = -n2[0], Cr[5] = -n2[1], Cr[8] = -n2[2], hu(t2, Xr(t2, Cr));
  });
  function vu() {
    var t2 = new f(8);
    return f != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[3] = 1, t2;
  }
  function bu(t2) {
    var n2 = new f(8);
    return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2[6] = t2[6], n2[7] = t2[7], n2;
  }
  function mu(t2, n2, a2, r2, u2, e2, o2, i2) {
    var h2 = new f(8);
    return h2[0] = t2, h2[1] = n2, h2[2] = a2, h2[3] = r2, h2[4] = u2, h2[5] = e2, h2[6] = o2, h2[7] = i2, h2;
  }
  function du(t2, n2, a2, r2, u2, e2, o2) {
    var i2 = new f(8);
    i2[0] = t2, i2[1] = n2, i2[2] = a2, i2[3] = r2;
    var h2 = 0.5 * u2, c2 = 0.5 * e2, s2 = 0.5 * o2;
    return i2[4] = h2 * r2 + c2 * a2 - s2 * n2, i2[5] = c2 * r2 + s2 * t2 - h2 * a2, i2[6] = s2 * r2 + h2 * n2 - c2 * t2, i2[7] = -h2 * t2 - c2 * n2 - s2 * a2, i2;
  }
  function xu(t2, n2, a2) {
    var r2 = 0.5 * a2[0], u2 = 0.5 * a2[1], e2 = 0.5 * a2[2], o2 = n2[0], i2 = n2[1], h2 = n2[2], c2 = n2[3];
    return t2[0] = o2, t2[1] = i2, t2[2] = h2, t2[3] = c2, t2[4] = r2 * c2 + u2 * h2 - e2 * i2, t2[5] = u2 * c2 + e2 * o2 - r2 * h2, t2[6] = e2 * c2 + r2 * i2 - u2 * o2, t2[7] = -r2 * o2 - u2 * i2 - e2 * h2, t2;
  }
  function yu(t2, n2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0.5 * n2[0], t2[5] = 0.5 * n2[1], t2[6] = 0.5 * n2[2], t2[7] = 0, t2;
  }
  function pu(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
  }
  function qu(t2, n2) {
    var a2 = gr();
    qn(a2, n2);
    var r2 = new f(3);
    return yn(r2, n2), xu(t2, a2, r2), t2;
  }
  function wu(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2;
  }
  function gu(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
  }
  function Au(t2, n2, a2, r2, u2, e2, o2, i2, h2) {
    return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = u2, t2[4] = e2, t2[5] = o2, t2[6] = i2, t2[7] = h2, t2;
  }
  var Pu = Jr;
  function Su(t2, n2) {
    return t2[0] = n2[4], t2[1] = n2[5], t2[2] = n2[6], t2[3] = n2[7], t2;
  }
  var Ru = Jr;
  function Tu(t2, n2) {
    return t2[4] = n2[0], t2[5] = n2[1], t2[6] = n2[2], t2[7] = n2[3], t2;
  }
  function Iu(t2, n2) {
    var a2 = n2[4], r2 = n2[5], u2 = n2[6], e2 = n2[7], o2 = -n2[0], i2 = -n2[1], h2 = -n2[2], c2 = n2[3];
    return t2[0] = 2 * (a2 * c2 + e2 * o2 + r2 * h2 - u2 * i2), t2[1] = 2 * (r2 * c2 + e2 * i2 + u2 * o2 - a2 * h2), t2[2] = 2 * (u2 * c2 + e2 * h2 + a2 * i2 - r2 * o2), t2;
  }
  function Eu(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = 0.5 * a2[0], h2 = 0.5 * a2[1], c2 = 0.5 * a2[2], s2 = n2[4], M2 = n2[5], f2 = n2[6], l2 = n2[7];
    return t2[0] = r2, t2[1] = u2, t2[2] = e2, t2[3] = o2, t2[4] = o2 * i2 + u2 * c2 - e2 * h2 + s2, t2[5] = o2 * h2 + e2 * i2 - r2 * c2 + M2, t2[6] = o2 * c2 + r2 * h2 - u2 * i2 + f2, t2[7] = -r2 * i2 - u2 * h2 - e2 * c2 + l2, t2;
  }
  function Du(t2, n2, a2) {
    var r2 = -n2[0], u2 = -n2[1], e2 = -n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = i2 * o2 + s2 * r2 + h2 * e2 - c2 * u2, f2 = h2 * o2 + s2 * u2 + c2 * r2 - i2 * e2, l2 = c2 * o2 + s2 * e2 + i2 * u2 - h2 * r2, v2 = s2 * o2 - i2 * r2 - h2 * u2 - c2 * e2;
    return Ir(t2, n2, a2), r2 = t2[0], u2 = t2[1], e2 = t2[2], o2 = t2[3], t2[4] = M2 * o2 + v2 * r2 + f2 * e2 - l2 * u2, t2[5] = f2 * o2 + v2 * u2 + l2 * r2 - M2 * e2, t2[6] = l2 * o2 + v2 * e2 + M2 * u2 - f2 * r2, t2[7] = v2 * o2 - M2 * r2 - f2 * u2 - l2 * e2, t2;
  }
  function Fu(t2, n2, a2) {
    var r2 = -n2[0], u2 = -n2[1], e2 = -n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = i2 * o2 + s2 * r2 + h2 * e2 - c2 * u2, f2 = h2 * o2 + s2 * u2 + c2 * r2 - i2 * e2, l2 = c2 * o2 + s2 * e2 + i2 * u2 - h2 * r2, v2 = s2 * o2 - i2 * r2 - h2 * u2 - c2 * e2;
    return Er(t2, n2, a2), r2 = t2[0], u2 = t2[1], e2 = t2[2], o2 = t2[3], t2[4] = M2 * o2 + v2 * r2 + f2 * e2 - l2 * u2, t2[5] = f2 * o2 + v2 * u2 + l2 * r2 - M2 * e2, t2[6] = l2 * o2 + v2 * e2 + M2 * u2 - f2 * r2, t2[7] = v2 * o2 - M2 * r2 - f2 * u2 - l2 * e2, t2;
  }
  function Lu(t2, n2, a2) {
    var r2 = -n2[0], u2 = -n2[1], e2 = -n2[2], o2 = n2[3], i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = i2 * o2 + s2 * r2 + h2 * e2 - c2 * u2, f2 = h2 * o2 + s2 * u2 + c2 * r2 - i2 * e2, l2 = c2 * o2 + s2 * e2 + i2 * u2 - h2 * r2, v2 = s2 * o2 - i2 * r2 - h2 * u2 - c2 * e2;
    return Dr(t2, n2, a2), r2 = t2[0], u2 = t2[1], e2 = t2[2], o2 = t2[3], t2[4] = M2 * o2 + v2 * r2 + f2 * e2 - l2 * u2, t2[5] = f2 * o2 + v2 * u2 + l2 * r2 - M2 * e2, t2[6] = l2 * o2 + v2 * e2 + M2 * u2 - f2 * r2, t2[7] = v2 * o2 - M2 * r2 - f2 * u2 - l2 * e2, t2;
  }
  function Vu(t2, n2, a2) {
    var r2 = a2[0], u2 = a2[1], e2 = a2[2], o2 = a2[3], i2 = n2[0], h2 = n2[1], c2 = n2[2], s2 = n2[3];
    return t2[0] = i2 * o2 + s2 * r2 + h2 * e2 - c2 * u2, t2[1] = h2 * o2 + s2 * u2 + c2 * r2 - i2 * e2, t2[2] = c2 * o2 + s2 * e2 + i2 * u2 - h2 * r2, t2[3] = s2 * o2 - i2 * r2 - h2 * u2 - c2 * e2, i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], t2[4] = i2 * o2 + s2 * r2 + h2 * e2 - c2 * u2, t2[5] = h2 * o2 + s2 * u2 + c2 * r2 - i2 * e2, t2[6] = c2 * o2 + s2 * e2 + i2 * u2 - h2 * r2, t2[7] = s2 * o2 - i2 * r2 - h2 * u2 - c2 * e2, t2;
  }
  function ju(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = a2[0], h2 = a2[1], c2 = a2[2], s2 = a2[3];
    return t2[0] = r2 * s2 + o2 * i2 + u2 * c2 - e2 * h2, t2[1] = u2 * s2 + o2 * h2 + e2 * i2 - r2 * c2, t2[2] = e2 * s2 + o2 * c2 + r2 * h2 - u2 * i2, t2[3] = o2 * s2 - r2 * i2 - u2 * h2 - e2 * c2, i2 = a2[4], h2 = a2[5], c2 = a2[6], s2 = a2[7], t2[4] = r2 * s2 + o2 * i2 + u2 * c2 - e2 * h2, t2[5] = u2 * s2 + o2 * h2 + e2 * i2 - r2 * c2, t2[6] = e2 * s2 + o2 * c2 + r2 * h2 - u2 * i2, t2[7] = o2 * s2 - r2 * i2 - u2 * h2 - e2 * c2, t2;
  }
  function zu(t2, n2, a2, r2) {
    if (Math.abs(r2) < M)
      return wu(t2, n2);
    var u2 = Math.hypot(a2[0], a2[1], a2[2]);
    r2 *= 0.5;
    var e2 = Math.sin(r2), o2 = e2 * a2[0] / u2, i2 = e2 * a2[1] / u2, h2 = e2 * a2[2] / u2, c2 = Math.cos(r2), s2 = n2[0], f2 = n2[1], l2 = n2[2], v2 = n2[3];
    t2[0] = s2 * c2 + v2 * o2 + f2 * h2 - l2 * i2, t2[1] = f2 * c2 + v2 * i2 + l2 * o2 - s2 * h2, t2[2] = l2 * c2 + v2 * h2 + s2 * i2 - f2 * o2, t2[3] = v2 * c2 - s2 * o2 - f2 * i2 - l2 * h2;
    var b2 = n2[4], m2 = n2[5], d2 = n2[6], x2 = n2[7];
    return t2[4] = b2 * c2 + x2 * o2 + m2 * h2 - d2 * i2, t2[5] = m2 * c2 + x2 * i2 + d2 * o2 - b2 * h2, t2[6] = d2 * c2 + x2 * h2 + b2 * i2 - m2 * o2, t2[7] = x2 * c2 - b2 * o2 - m2 * i2 - d2 * h2, t2;
  }
  function Ou(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2[4] = n2[4] + a2[4], t2[5] = n2[5] + a2[5], t2[6] = n2[6] + a2[6], t2[7] = n2[7] + a2[7], t2;
  }
  function Qu(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1], e2 = n2[2], o2 = n2[3], i2 = a2[4], h2 = a2[5], c2 = a2[6], s2 = a2[7], M2 = n2[4], f2 = n2[5], l2 = n2[6], v2 = n2[7], b2 = a2[0], m2 = a2[1], d2 = a2[2], x2 = a2[3];
    return t2[0] = r2 * x2 + o2 * b2 + u2 * d2 - e2 * m2, t2[1] = u2 * x2 + o2 * m2 + e2 * b2 - r2 * d2, t2[2] = e2 * x2 + o2 * d2 + r2 * m2 - u2 * b2, t2[3] = o2 * x2 - r2 * b2 - u2 * m2 - e2 * d2, t2[4] = r2 * s2 + o2 * i2 + u2 * c2 - e2 * h2 + M2 * x2 + v2 * b2 + f2 * d2 - l2 * m2, t2[5] = u2 * s2 + o2 * h2 + e2 * i2 - r2 * c2 + f2 * x2 + v2 * m2 + l2 * b2 - M2 * d2, t2[6] = e2 * s2 + o2 * c2 + r2 * h2 - u2 * i2 + l2 * x2 + v2 * d2 + M2 * m2 - f2 * b2, t2[7] = o2 * s2 - r2 * i2 - u2 * h2 - e2 * c2 + v2 * x2 - M2 * b2 - f2 * m2 - l2 * d2, t2;
  }
  var Yu = Qu;
  function Xu(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2[4] = n2[4] * a2, t2[5] = n2[5] * a2, t2[6] = n2[6] * a2, t2[7] = n2[7] * a2, t2;
  }
  var Zu = au;
  function _u(t2, n2, a2, r2) {
    var u2 = 1 - r2;
    return Zu(n2, a2) < 0 && (r2 = -r2), t2[0] = n2[0] * u2 + a2[0] * r2, t2[1] = n2[1] * u2 + a2[1] * r2, t2[2] = n2[2] * u2 + a2[2] * r2, t2[3] = n2[3] * u2 + a2[3] * r2, t2[4] = n2[4] * u2 + a2[4] * r2, t2[5] = n2[5] * u2 + a2[5] * r2, t2[6] = n2[6] * u2 + a2[6] * r2, t2[7] = n2[7] * u2 + a2[7] * r2, t2;
  }
  function Bu(t2, n2) {
    var a2 = Wu(n2);
    return t2[0] = -n2[0] / a2, t2[1] = -n2[1] / a2, t2[2] = -n2[2] / a2, t2[3] = n2[3] / a2, t2[4] = -n2[4] / a2, t2[5] = -n2[5] / a2, t2[6] = -n2[6] / a2, t2[7] = n2[7] / a2, t2;
  }
  function Nu(t2, n2) {
    return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = n2[3], t2[4] = -n2[4], t2[5] = -n2[5], t2[6] = -n2[6], t2[7] = n2[7], t2;
  }
  var ku = uu, Uu = ku, Wu = ou, Cu = Wu;
  function Gu(t2, n2) {
    var a2 = Wu(n2);
    if (a2 > 0) {
      a2 = Math.sqrt(a2);
      var r2 = n2[0] / a2, u2 = n2[1] / a2, e2 = n2[2] / a2, o2 = n2[3] / a2, i2 = n2[4], h2 = n2[5], c2 = n2[6], s2 = n2[7], M2 = r2 * i2 + u2 * h2 + e2 * c2 + o2 * s2;
      t2[0] = r2, t2[1] = u2, t2[2] = e2, t2[3] = o2, t2[4] = (i2 - r2 * M2) / a2, t2[5] = (h2 - u2 * M2) / a2, t2[6] = (c2 - e2 * M2) / a2, t2[7] = (s2 - o2 * M2) / a2;
    }
    return t2;
  }
  function Hu(t2) {
    return "quat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ")";
  }
  function Ju(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5] && t2[6] === n2[6] && t2[7] === n2[7];
  }
  function Ku(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = t2[2], e2 = t2[3], o2 = t2[4], i2 = t2[5], h2 = t2[6], c2 = t2[7], s2 = n2[0], f2 = n2[1], l2 = n2[2], v2 = n2[3], b2 = n2[4], m2 = n2[5], d2 = n2[6], x2 = n2[7];
    return Math.abs(a2 - s2) <= M * Math.max(1, Math.abs(a2), Math.abs(s2)) && Math.abs(r2 - f2) <= M * Math.max(1, Math.abs(r2), Math.abs(f2)) && Math.abs(u2 - l2) <= M * Math.max(1, Math.abs(u2), Math.abs(l2)) && Math.abs(e2 - v2) <= M * Math.max(1, Math.abs(e2), Math.abs(v2)) && Math.abs(o2 - b2) <= M * Math.max(1, Math.abs(o2), Math.abs(b2)) && Math.abs(i2 - m2) <= M * Math.max(1, Math.abs(i2), Math.abs(m2)) && Math.abs(h2 - d2) <= M * Math.max(1, Math.abs(h2), Math.abs(d2)) && Math.abs(c2 - x2) <= M * Math.max(1, Math.abs(c2), Math.abs(x2));
  }
  function $u() {
    var t2 = new f(2);
    return f != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
  }
  function te(t2) {
    var n2 = new f(2);
    return n2[0] = t2[0], n2[1] = t2[1], n2;
  }
  function ne(t2, n2) {
    var a2 = new f(2);
    return a2[0] = t2, a2[1] = n2, a2;
  }
  function ae(t2, n2) {
    return t2[0] = n2[0], t2[1] = n2[1], t2;
  }
  function re(t2, n2, a2) {
    return t2[0] = n2, t2[1] = a2, t2;
  }
  function ue(t2, n2, a2) {
    return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2;
  }
  function ee(t2, n2, a2) {
    return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2;
  }
  function oe(t2, n2, a2) {
    return t2[0] = n2[0] * a2[0], t2[1] = n2[1] * a2[1], t2;
  }
  function ie(t2, n2, a2) {
    return t2[0] = n2[0] / a2[0], t2[1] = n2[1] / a2[1], t2;
  }
  function he(t2, n2) {
    return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2;
  }
  function ce(t2, n2) {
    return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2;
  }
  function se(t2, n2, a2) {
    return t2[0] = Math.min(n2[0], a2[0]), t2[1] = Math.min(n2[1], a2[1]), t2;
  }
  function Me(t2, n2, a2) {
    return t2[0] = Math.max(n2[0], a2[0]), t2[1] = Math.max(n2[1], a2[1]), t2;
  }
  function fe(t2, n2) {
    return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2;
  }
  function le(t2, n2, a2) {
    return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2;
  }
  function ve(t2, n2, a2, r2) {
    return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2;
  }
  function be(t2, n2) {
    var a2 = n2[0] - t2[0], r2 = n2[1] - t2[1];
    return Math.hypot(a2, r2);
  }
  function me(t2, n2) {
    var a2 = n2[0] - t2[0], r2 = n2[1] - t2[1];
    return a2 * a2 + r2 * r2;
  }
  function de(t2) {
    var n2 = t2[0], a2 = t2[1];
    return Math.hypot(n2, a2);
  }
  function xe(t2) {
    var n2 = t2[0], a2 = t2[1];
    return n2 * n2 + a2 * a2;
  }
  function ye(t2, n2) {
    return t2[0] = -n2[0], t2[1] = -n2[1], t2;
  }
  function pe(t2, n2) {
    return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2;
  }
  function qe(t2, n2) {
    var a2 = n2[0], r2 = n2[1], u2 = a2 * a2 + r2 * r2;
    return u2 > 0 && (u2 = 1 / Math.sqrt(u2)), t2[0] = n2[0] * u2, t2[1] = n2[1] * u2, t2;
  }
  function we(t2, n2) {
    return t2[0] * n2[0] + t2[1] * n2[1];
  }
  function ge(t2, n2, a2) {
    var r2 = n2[0] * a2[1] - n2[1] * a2[0];
    return t2[0] = t2[1] = 0, t2[2] = r2, t2;
  }
  function Ae(t2, n2, a2, r2) {
    var u2 = n2[0], e2 = n2[1];
    return t2[0] = u2 + r2 * (a2[0] - u2), t2[1] = e2 + r2 * (a2[1] - e2), t2;
  }
  function Pe(t2, n2) {
    n2 = n2 || 1;
    var a2 = 2 * l() * Math.PI;
    return t2[0] = Math.cos(a2) * n2, t2[1] = Math.sin(a2) * n2, t2;
  }
  function Se(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1];
    return t2[0] = a2[0] * r2 + a2[2] * u2, t2[1] = a2[1] * r2 + a2[3] * u2, t2;
  }
  function Re(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1];
    return t2[0] = a2[0] * r2 + a2[2] * u2 + a2[4], t2[1] = a2[1] * r2 + a2[3] * u2 + a2[5], t2;
  }
  function Te(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1];
    return t2[0] = a2[0] * r2 + a2[3] * u2 + a2[6], t2[1] = a2[1] * r2 + a2[4] * u2 + a2[7], t2;
  }
  function Ie(t2, n2, a2) {
    var r2 = n2[0], u2 = n2[1];
    return t2[0] = a2[0] * r2 + a2[4] * u2 + a2[12], t2[1] = a2[1] * r2 + a2[5] * u2 + a2[13], t2;
  }
  function Ee(t2, n2, a2, r2) {
    var u2 = n2[0] - a2[0], e2 = n2[1] - a2[1], o2 = Math.sin(r2), i2 = Math.cos(r2);
    return t2[0] = u2 * i2 - e2 * o2 + a2[0], t2[1] = u2 * o2 + e2 * i2 + a2[1], t2;
  }
  function De(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = n2[0], e2 = n2[1], o2 = a2 * a2 + r2 * r2;
    o2 > 0 && (o2 = 1 / Math.sqrt(o2));
    var i2 = u2 * u2 + e2 * e2;
    i2 > 0 && (i2 = 1 / Math.sqrt(i2));
    var h2 = (a2 * u2 + r2 * e2) * o2 * i2;
    return h2 > 1 ? 0 : h2 < -1 ? Math.PI : Math.acos(h2);
  }
  function Fe(t2) {
    return t2[0] = 0, t2[1] = 0, t2;
  }
  function Le(t2) {
    return "vec2(" + t2[0] + ", " + t2[1] + ")";
  }
  function Ve(t2, n2) {
    return t2[0] === n2[0] && t2[1] === n2[1];
  }
  function je(t2, n2) {
    var a2 = t2[0], r2 = t2[1], u2 = n2[0], e2 = n2[1];
    return Math.abs(a2 - u2) <= M * Math.max(1, Math.abs(a2), Math.abs(u2)) && Math.abs(r2 - e2) <= M * Math.max(1, Math.abs(r2), Math.abs(e2));
  }
  var ze = de, Oe = ee, Qe = oe, Ye = ie, Xe = be, Ze = me, _e = xe, Be = function() {
    var t2 = $u();
    return function(n2, a2, r2, u2, e2, o2) {
      var i2, h2;
      for (a2 || (a2 = 2), r2 || (r2 = 0), h2 = u2 ? Math.min(u2 * a2 + r2, n2.length) : n2.length, i2 = r2; i2 < h2; i2 += a2)
        t2[0] = n2[i2], t2[1] = n2[i2 + 1], e2(t2, t2, o2), n2[i2] = t2[0], n2[i2 + 1] = t2[1];
      return n2;
    };
  }();
  window.glMatrix = n, window.mat2 = a, window.mat2d = r, window.mat3 = u, window.mat4 = e, window.quat = h, window.quat2 = c, window.vec2 = s, window.vec3 = o, window.vec4 = i;
})();
if (!CABLES.exportedPatches)
  CABLES.exportedPatches = {};
CABLES.exportedPatches["mhkN4m"] = { _id: "66c5b49342d25de9e6d7bb54", ops: [{ id: "zdo60lxbk", uiAttribs: {}, portsIn: [{ name: "Reduce FPS not focussed", value: 1 }, { name: "Reduce FPS loading", value: 1 }, { name: "Clear", value: 1 }, { name: "ClearAlpha", value: 0 }, { name: "Fullscreen Button", value: 0 }, { name: "Active", value: 1 }, { name: "Hires Displays", value: 1 }, { name: "Pixel Unit index", value: 0 }, { name: "Pixel Unit", value: "Display" }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "e0268dfa-e089-4f1f-966c-c30218792023", objOut: "zdo60lxbk" }] }, { name: "width", value: 1558 }, { name: "height", value: 850 }], objName: "Ops.Gl.MainLoop" }, { id: "141502b6-2964-42b8-b273-c6d7f5bcf303", uiAttribs: {}, portsOut: [{ name: "trigger 0", links: [{ portIn: "Trigger", portOut: "trigger 0", objIn: "e0698285-4e6a-4339-a9ba-d9b3e441372c", objOut: "141502b6-2964-42b8-b273-c6d7f5bcf303" }, { portIn: "Increment", portOut: "trigger 0", objIn: "6hojoyomj", objOut: "141502b6-2964-42b8-b273-c6d7f5bcf303" }] }, { name: "trigger 5", links: [{ portIn: "in0 Cursor Update", portOut: "trigger 5", objIn: "cd9136e7-4c7b-4555-bf01-18381685410b", objOut: "141502b6-2964-42b8-b273-c6d7f5bcf303" }] }, { name: "trigger 8", links: [{ portIn: "Trigger", portOut: "trigger 8", objIn: "ch5u1xz0l", objOut: "141502b6-2964-42b8-b273-c6d7f5bcf303" }] }, { name: "trigger 9", links: [{ portIn: "exe", portOut: "trigger 9", objIn: "124910bf-e88f-4da5-847e-888a7ac73020", objOut: "141502b6-2964-42b8-b273-c6d7f5bcf303" }] }, { name: "trigger 13", links: [{ portIn: "Trigger", portOut: "trigger 13", objIn: "afa40c7e-19f5-4546-911c-1e34c62f310b", objOut: "141502b6-2964-42b8-b273-c6d7f5bcf303" }] }], objName: "Ops.Trigger.Sequence" }, { id: "4950e7c1-dcaf-47ac-9ca9-512013c4e9c9", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Coordinates index", value: 0 }, { name: "Coordinates", value: "-1 to 1" }, { name: "Area index", value: 3 }, { name: "Area", value: "Canvas Area" }, { name: "flip y", value: 0 }, { name: "right click prevent default", value: 1 }, { name: "Touch support", value: 1 }, { name: "Passive Events", value: 0 }, { name: "Active", value: 1 }], portsOut: [{ name: "x", value: -1 }, { name: "y", value: 0.4682352941176471 }, { name: "click", links: [{ portIn: "Trigger", portOut: "click", objIn: "xz7qgpta6", objOut: "4950e7c1-dcaf-47ac-9ca9-512013c4e9c9" }] }, { name: "Button is down", value: 0 }, { name: "Mouse is hovering", links: [{ portIn: "Value", portOut: "Mouse is hovering", objIn: "d155f04b-ae78-473c-994b-81138389d0f0", objOut: "4950e7c1-dcaf-47ac-9ca9-512013c4e9c9" }] }, { name: "Movement X", value: 0 }, { name: "Movement Y", value: 0.5 }], objName: "Ops.Devices.Mouse.Mouse_v3" }, { id: "d155f04b-ae78-473c-994b-81138389d0f0", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_mouseOver" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "dq71li66q", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Limit", value: 1 }, { name: "Min", value: 0 }, { name: "Max", value: 1 }, { name: "Rubberband", value: 0 }], portsOut: [{ name: "Absolute Value", links: [{ portIn: "Value In", portOut: "Absolute Value", objIn: "csl3j7cy1", objOut: "dq71li66q" }] }], objName: "Ops.Math.DeltaSum" }, { id: "9d85ffdc-685a-42ef-bd41-b501521a114c", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsOut: [{ name: "create port", value: 0 }], objName: "Ops.Ui.PatchInput" }, { id: "7bebb5f0-9d69-43ee-98be-27a13edd98db", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "create port", value: 0 }, { name: "out1 Ops.Devices.Mouse.Mouse_v3 x", value: 0 }, { name: "out2 Ops.Devices.Mouse.Mouse_v3 y", value: 0 }, { name: "out3 DeltaSum Absolute Value", value: 0, title: "DeltaX" }], objName: "Ops.Ui.PatchOutput" }, { id: "cd9136e7-4c7b-4555-bf01-18381685410b", uiAttribs: {}, storage: { subPatchVer: 1 }, portsIn: [{ name: "create port", value: 0 }, { name: "dataStr", value: '{"ports":[{"name":"in0 Cursor Update","type":1}],"portsOut":[{"name":"out0 DeltaSum Absolute Value","type":0},{"name":"out1 Ops.Devices.Mouse.Mouse_v3 x","type":0},{"name":"out2 Ops.Devices.Mouse.Mouse_v3 y","type":0},{"name":"out3 DeltaSum Absolute Value","type":0,"title":"DeltaX"}]}' }, { name: "patchId", value: "66dae55a-8297-4120-81e2-d946cc6b2b60" }], portsOut: [{ name: "create port out", value: 0 }, { name: "out0 DeltaSum Absolute Value", links: [{ portIn: "Value", portOut: "out0 DeltaSum Absolute Value", objIn: "9fsk0rgx7", objOut: "cd9136e7-4c7b-4555-bf01-18381685410b" }] }, { name: "out3 DeltaSum Absolute Value", title: "DeltaX" }], objName: "Ops.Ui.SubPatch" }, { id: "c2a85325-d75f-4f01-9b5c-83a2edd8d35d", uiAttribs: {}, portsIn: [{ name: "posY", value: -0.21 }, { name: "posZ", value: 0 }, { name: "scale", value: 0.25 }, { name: "rotX", value: 0 }, { name: "rotY", value: 180 }, { name: "rotZ", value: 315.48 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "li365texv", objOut: "c2a85325-d75f-4f01-9b5c-83a2edd8d35d" }, { portIn: "render", portOut: "trigger", objIn: "uc9r4wu0r", objOut: "c2a85325-d75f-4f01-9b5c-83a2edd8d35d" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "e0268dfa-e089-4f1f-966c-c30218792023", uiAttribs: {}, portsIn: [{ name: "r", value: 0 }, { name: "g", value: 0 }, { name: "b", value: 0 }, { name: "a", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "te11ob7nw", objOut: "e0268dfa-e089-4f1f-966c-c30218792023" }, { portIn: "Trigger", portOut: "trigger", objIn: "zcc6zzw4d", objOut: "e0268dfa-e089-4f1f-966c-c30218792023" }] }], objName: "Ops.Gl.ClearColor" }, { id: "b65ca0b8-40c9-4d0a-9e22-aba7d89f3abf", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Active", value: 1 }, { name: "Input Type index", value: 0 }, { name: "Input Type", value: "All" }, { name: "Area index", value: 0 }, { name: "Area", value: "Canvas Area" }], portsOut: [{ name: "Delta X", value: 0 }, { name: "Delta Y", links: [{ portIn: "Delta Value", portOut: "Delta Y", objIn: "dq71li66q", objOut: "b65ca0b8-40c9-4d0a-9e22-aba7d89f3abf" }] }, { name: "Is Dragging", links: [{ portIn: "Value", portOut: "Is Dragging", objIn: "ls3p3eowk", objOut: "b65ca0b8-40c9-4d0a-9e22-aba7d89f3abf" }, { portIn: "Value", portOut: "Is Dragging", objIn: "t1ryttgy8", objOut: "b65ca0b8-40c9-4d0a-9e22-aba7d89f3abf" }] }], objName: "Ops.Patch.PmhkN4m.MouseDrag" }, { id: "e0698285-4e6a-4339-a9ba-d9b3e441372c", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "mainExe" }], objName: "Ops.Trigger.TriggerSend" }, { id: "babe81ef-3ee9-4ed3-ba28-8b648c21dd11", uiAttribs: {}, portsIn: [{ name: "Title", value: "LOOP: Main 4" }], objName: "Ops.Ui.Area" }, { id: "a82e74aa-f66f-47c9-a07a-2f1b0376925b", uiAttribs: {}, portsIn: [{ name: "Title", value: "Data" }], objName: "Ops.Ui.Area" }, { id: "afa40c7e-19f5-4546-911c-1e34c62f310b", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "finalExe" }], objName: "Ops.Trigger.TriggerSend" }, { id: "1aaf40f7-386a-40d0-80de-4857b3f558f4", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_NormValue" }], portsOut: [{ name: "Value", links: [{ portIn: "Number", portOut: "Value", objIn: "2cbchlduf", objOut: "1aaf40f7-386a-40d0-80de-4857b3f558f4" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "7dq6j5p5k", uiAttribs: {}, portsIn: [{ name: "Check Body Collisions", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Trigger", portOut: "Next", objIn: "9sm9dp98r", objOut: "7dq6j5p5k" }] }, { name: "Total Bodies", value: 4 }], objName: "Ops.Graphics.Intersection.IntersectWorld" }, { id: "9sm9dp98r", uiAttribs: {}, portsIn: [{ name: "Coordinate Format index", value: 0 }, { name: "Coordinate Format", value: "-1 to 1" }, { name: "Z", value: 0 }, { name: "To X", value: 0 }, { name: "To Y", value: 0 }, { name: "To Z", value: 0 }, { name: "Active", value: 1 }, { name: "Change Cursor", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "mbk4m8pcr", objOut: "9sm9dp98r" }, { portIn: "render", portOut: "Next", objIn: "7qikt1vaf", objOut: "9sm9dp98r" }, { portIn: "render", portOut: "Next", objIn: "aupoduf7d", objOut: "9sm9dp98r" }, { portIn: "render", portOut: "Next", objIn: "ge3zj70cy", objOut: "9sm9dp98r" }] }, { name: "Has Hit", value: 0 }, { name: "Hit Body Name", links: [{ portIn: "Value", portOut: "Hit Body Name", objIn: "tg35ehmtt", objOut: "9sm9dp98r" }] }, { name: "Hit X", value: 0 }, { name: "Hit Y", value: 0 }, { name: "Hit Z", value: 0 }], objName: "Ops.Graphics.Intersection.IntersectTestRaycast" }, { id: "bs0d2bloj", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "mainExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "Trigger", portOut: "Triggered", objIn: "7dq6j5p5k", objOut: "bs0d2bloj" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "5me0htliz", uiAttribs: {}, portsIn: [{ name: "Shape index", value: 1 }, { name: "Shape", value: "BoxAA" }, { name: "Name", value: "dial.2" }, { name: "Radius", value: 0.22 }, { name: "Size X", value: 0.55 }, { name: "Size Y", value: 1 }, { name: "Size Z", value: 0 }, { name: "Positions" }, { name: "Append Index to name", value: 1 }], objName: "Ops.Graphics.Intersection.IntersectBody" }, { id: "mbk4m8pcr", uiAttribs: {}, portsIn: [{ name: "x", value: -0.28 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Trigger", portOut: "trigger", objIn: "5me0htliz", objOut: "mbk4m8pcr" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "adh054ku6", uiAttribs: {}, portsIn: [{ name: "Shape index", value: 1 }, { name: "Shape", value: "BoxAA" }, { name: "Name", value: "dial.3" }, { name: "Radius", value: 0.23 }, { name: "Size X", value: 0.55 }, { name: "Size Y", value: 1 }, { name: "Size Z", value: 0 }, { name: "Positions" }, { name: "Append Index to name", value: 1 }], objName: "Ops.Graphics.Intersection.IntersectBody" }, { id: "yjtjh6kai", uiAttribs: {}, portsIn: [{ name: "Shape index", value: 1 }, { name: "Shape", value: "BoxAA" }, { name: "Name", value: "dial.4" }, { name: "Radius", value: 0.23 }, { name: "Size X", value: 0.56 }, { name: "Size Y", value: 1 }, { name: "Size Z", value: 0 }, { name: "Positions" }, { name: "Append Index to name", value: 1 }], objName: "Ops.Graphics.Intersection.IntersectBody" }, { id: "sfqxroo9q", uiAttribs: {}, portsIn: [{ name: "Coordinates index", value: 0 }, { name: "Coordinates", value: "-1 to 1" }, { name: "Area index", value: 0 }, { name: "Area", value: "Canvas" }, { name: "flip y", value: 1 }, { name: "right click prevent default", value: 1 }, { name: "Touch support", value: 1 }, { name: "Passive Events", value: 0 }, { name: "Active", value: 1 }], portsOut: [{ name: "x", links: [{ portIn: "X", portOut: "x", objIn: "9sm9dp98r", objOut: "sfqxroo9q" }] }, { name: "y", links: [{ portIn: "Y", portOut: "y", objIn: "9sm9dp98r", objOut: "sfqxroo9q" }] }, { name: "Button is down", links: [{ portIn: "Value", portOut: "Button is down", objIn: "er6016ry9", objOut: "sfqxroo9q" }] }, { name: "Mouse is hovering", value: 0 }, { name: "Movement X", value: -14.5 }, { name: "Movement Y", value: 1 }], objName: "Ops.Devices.Mouse.Mouse_v3" }, { id: "124910bf-e88f-4da5-847e-888a7ac73020", uiAttribs: {}, portsIn: [{ name: "num x", value: 4 }, { name: "num y", value: 1 }, { name: "center", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "zlpf1p0f5", objOut: "124910bf-e88f-4da5-847e-888a7ac73020" }, { portIn: "render", portOut: "trigger", objIn: "c2a85325-d75f-4f01-9b5c-83a2edd8d35d", objOut: "124910bf-e88f-4da5-847e-888a7ac73020" }] }, { name: "x", links: [{ portIn: "posX", portOut: "x", objIn: "c2a85325-d75f-4f01-9b5c-83a2edd8d35d", objOut: "124910bf-e88f-4da5-847e-888a7ac73020" }, { portIn: "posX", portOut: "x", objIn: "zlpf1p0f5", objOut: "124910bf-e88f-4da5-847e-888a7ac73020" }, { portIn: "Value", portOut: "x", objIn: "6v0s7i2sf", objOut: "124910bf-e88f-4da5-847e-888a7ac73020" }] }, { name: "y", value: 0 }, { name: "index", links: [{ portIn: "Value", portOut: "index", objIn: "euqza6b25", objOut: "124910bf-e88f-4da5-847e-888a7ac73020" }] }, { name: "total iterations", value: 4 }], objName: "Ops.Trigger.Repeat2d" }, { id: "7qikt1vaf", uiAttribs: {}, portsIn: [{ name: "x", value: 0.27 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Trigger", portOut: "trigger", objIn: "adh054ku6", objOut: "7qikt1vaf" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "aupoduf7d", uiAttribs: {}, portsIn: [{ name: "x", value: 0.84 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Trigger", portOut: "trigger", objIn: "yjtjh6kai", objOut: "aupoduf7d" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "32lmfrmux", uiAttribs: {}, portsIn: [{ name: "Title", value: "Intersect" }], objName: "Ops.Ui.Area" }, { id: "tg35ehmtt", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_hitBodyName" }], objName: "Ops.Vars.VarSetString_v2" }, { id: "gb0lraco2", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_activeDial_ID" }], portsOut: [{ name: "Value", links: [{ portIn: "number1", portOut: "Value", objIn: "kcwn0w2tu", objOut: "gb0lraco2" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "qyara3wac", uiAttribs: {}, portsOut: [{ name: "result", links: [{ portIn: "Value", portOut: "result", objIn: "hb06uwqts", objOut: "qyara3wac" }] }], objName: "Ops.Math.Compare.Equals" }, { id: "xz7qgpta6", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Named Trigger", value: "mouseDown" }], objName: "Ops.Trigger.TriggerSend" }, { id: "53603a6e-a331-41a7-9822-120aba8de4f8", uiAttribs: {}, portsIn: [{ name: "number2", value: 270 }], portsOut: [{ name: "result", links: [{ portIn: "rotY", portOut: "result", objIn: "li365texv", objOut: "53603a6e-a331-41a7-9822-120aba8de4f8" }] }], objName: "Ops.Math.Multiply" }, { id: "9fsk0rgx7", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_NormValue" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "aqjh1act1", uiAttribs: {}, portsIn: [{ name: "Value Invalid Index", value: 0 }], portsOut: [{ name: "value", links: [{ portIn: "Value", portOut: "value", objIn: "j3kd0q09w", objOut: "aqjh1act1" }, { portIn: "Value", portOut: "value", objIn: "1rc15x0gs", objOut: "aqjh1act1" }, { portIn: "number1", portOut: "value", objIn: "53603a6e-a331-41a7-9822-120aba8de4f8", objOut: "aqjh1act1" }, { portIn: "A", portOut: "value", objIn: "v11enlha4", objOut: "aqjh1act1" }] }, { name: "Valid Index", value: 1 }], objName: "Ops.Array.ArrayGetNumber" }, { id: "x6efudpvd", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_dialValues_array" }], objName: "Ops.Vars.VarSetArray_v2" }, { id: "i0rjtphmz", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_dialValues_array" }], portsOut: [{ name: "Value", links: [{ portIn: "array", portOut: "Value", objIn: "aqjh1act1", objOut: "i0rjtphmz" }] }], objName: "Ops.Vars.VarGetArray_v2" }, { id: "er6016ry9", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_buttonIsDown" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "ls3p3eowk", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_mouseIsDragging" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "kcwn0w2tu", uiAttribs: {}, portsIn: [{ name: "number2", value: 1 }], portsOut: [{ name: "result", links: [{ portIn: "number1", portOut: "result", objIn: "qyara3wac", objOut: "kcwn0w2tu" }] }], objName: "Ops.Math.Subtract" }, { id: "pd9s43czm", uiAttribs: {}, storage: { blueprintVer: 2, subPatchVer: 2 }, portsIn: [{ name: "patchId", value: "bp2sub_pd9s43czm" }], objName: "Ops.Patch.PmhkN4m.SubPatch2" }, { id: "te11ob7nw", uiAttribs: {}, portsIn: [{ name: "projection mode index", value: 0 }, { name: "projection mode", value: "prespective" }, { name: "frustum near", value: 0.01 }, { name: "frustum far", value: 5e3 }, { name: "fov", value: 30 }, { name: "Auto Aspect Ratio", value: 1 }, { name: "Aspect Ratio", value: 1 }, { name: "eye X", value: 0 }, { name: "eye Y", value: -0.03 }, { name: "eye Z", value: 0.73 }, { name: "center X", value: 0 }, { name: "center Y", value: 0 }, { name: "center Z", value: 0 }, { name: "truck", value: 0 }, { name: "boom", value: 0.23 }, { name: "dolly", value: 0 }, { name: "tilt", value: 0 }, { name: "pan", value: 0 }, { name: "roll", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "exe", portOut: "trigger", objIn: "141502b6-2964-42b8-b273-c6d7f5bcf303", objOut: "te11ob7nw" }, { portIn: "Trigger", portOut: "trigger", objIn: "4pu8mr0y2", objOut: "te11ob7nw" }] }, { name: "Aspect", value: 1.8329411764705883 }], objName: "Ops.Gl.Matrix.Camera" }, { id: "uc9r4wu0r", uiAttribs: {}, portsIn: [{ name: "r", value: 0.885 }, { name: "g", value: 0.8560132010421952 }, { name: "b", value: 0.856 }, { name: "colorizeTexture", value: 1 }, { name: "Vertex Colors", value: 0 }, { name: "Alpha Mask Source index", value: 4 }, { name: "Alpha Mask Source", value: "A" }, { name: "Opacity TexCoords Transform", value: 0 }, { name: "Discard Transparent Pixels", value: 0 }, { name: "diffuseRepeatX", value: 1 }, { name: "diffuseRepeatY", value: 0 }, { name: "Tex Offset X", value: 0 }, { name: "Tex Offset Y", value: 0 }, { name: "Crop TexCoords", value: 0 }, { name: "billboard", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "3g7cbchrs", objOut: "uc9r4wu0r" }] }], objName: "Ops.Gl.Shader.BasicMaterial_v3" }, { id: "j3kd0q09w", uiAttribs: {}, portsIn: [{ name: "Min", value: 0 }, { name: "Max", value: 0.9 }, { name: "Easing index", value: 4 }, { name: "Easing", value: "Cubic In" }], portsOut: [{ name: "Result", links: [{ portIn: "Value", portOut: "Result", objIn: "conrnxfgk", objOut: "j3kd0q09w" }, { portIn: "Value", portOut: "Result", objIn: "s0o3lhs2y", objOut: "j3kd0q09w" }] }], objName: "Ops.Math.Ease" }, { id: "conrnxfgk", uiAttribs: {}, portsIn: [{ name: "Min", value: 0 }, { name: "Max", value: 0.27 }, { name: "Easing index", value: 5 }, { name: "Easing", value: "Cubic Out" }], portsOut: [{ name: "Result", links: [{ portIn: "Value", portOut: "Result", objIn: "z5bv7gal9", objOut: "conrnxfgk" }] }], objName: "Ops.Math.Ease" }, { id: "chztenqi0", uiAttribs: {}, portsIn: [{ name: "r", value: 1 }, { name: "b", value: 0.645 }, { name: "Opacity", value: 0.956 }, { name: "AO Intensity", value: 0.747 }, { name: "Normal Map Intensity", value: 0.66 }, { name: "Repeat X", value: 6 }, { name: "Repeat Y", value: 0 }, { name: "Offset X", value: 0 }, { name: "Offset Y", value: 1.6 }, { name: "Screen Space Normals", value: 0 }, { name: "Calc normal tangents", value: 0 }, { name: "Opacity TexCoords Transform", value: 0 }, { name: "Discard Transparent Pixels", value: 1 }, { name: "Alpha Mask Source index", value: 0 }, { name: "Alpha Mask Source", value: "Luminance" }], portsOut: [{ name: "Next", links: [{ portIn: "Execute", portOut: "Next", objIn: "leqa7h4pd", objOut: "chztenqi0" }] }, { name: "Shader", links: [{ portIn: "Value", portOut: "Shader", objIn: "nnu0oo0gu", objOut: "chztenqi0" }] }], objName: "Ops.Gl.Shader.MatCapMaterial_v3" }, { id: "0oya8etuv", uiAttribs: {}, portsIn: [{ name: "File", value: "assets/6697c3b245eb5d333bae2007_NEL_SRVB.webp", display: "file" }, { name: "Filter index", value: 1 }, { name: "Filter", value: "linear" }, { name: "Wrap index", value: 0 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Data Format index", value: 3 }, { name: "Data Format", value: "RGBA" }, { name: "Flip", value: 0 }, { name: "Pre Multiplied Alpha", value: 0 }, { name: "Active", value: 1 }, { name: "Save Memory", value: 1 }, { name: "Add Cachebuster", value: 1 }], portsOut: [{ name: "Texture", links: [{ portIn: "MatCap", portOut: "Texture", objIn: "chztenqi0", objOut: "0oya8etuv" }] }, { name: "Width", value: 256 }, { name: "Height", value: 256 }, { name: "Aspect Ratio", value: 1 }, { name: "Loaded", value: 1 }, { name: "Loading", value: 0 }], objName: "Ops.Gl.Texture_v2" }, { id: "li365texv", uiAttribs: {}, portsIn: [{ name: "posX", value: 0 }, { name: "posY", value: 0 }, { name: "posZ", value: 0 }, { name: "scale", value: 1 }, { name: "rotZ", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "ts03zao35", objOut: "li365texv" }, { portIn: "Render", portOut: "trigger", objIn: "chztenqi0", objOut: "li365texv" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "bd0mu1qkj", uiAttribs: {}, portsIn: [{ name: "Title", value: "Main" }], objName: "Ops.Ui.Area" }, { id: "6a24jo2e0", uiAttribs: {}, portsIn: [{ name: "Title", value: "Scape" }], objName: "Ops.Ui.Area" }, { id: "kgtq6kbqp", uiAttribs: {}, portsIn: [{ name: "Font", value: "chivo" }, { name: "Scale", value: 0.8 }, { name: "Letter Spacing", value: -0.02 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 1 }, { name: "Align", value: "Center" }, { name: "Vertical Align index", value: 2 }, { name: "Vertical Align", value: "Middle" }, { name: "r", value: 0.949 }, { name: "g", value: 0.933 }, { name: "b", value: 0.899 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.126 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.222 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 0 }, { name: "Border g", value: 0 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 0 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Rotations", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Num Lines", value: 1 }, { name: "Width", value: 1.3237500000000002 }, { name: "Height", value: 0.4727234848484848 }, { name: "Start Y", value: 0.24641098484848484 }, { name: "Num Chars", value: 7 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "1rc15x0gs", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentDialValueInsideRepeat2D" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "o8zk12f1r", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentDialValueInsideRepeat2D" }], portsOut: [{ name: "Value", links: [{ portIn: "number", portOut: "Value", objIn: "2lpsqzgrb", objOut: "o8zk12f1r" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "2lpsqzgrb", uiAttribs: {}, portsIn: [{ name: "Decimal Places", value: 4 }], portsOut: [{ name: "result", links: [{ portIn: "Number", portOut: "result", objIn: "vib72zx3n", objOut: "2lpsqzgrb" }] }], objName: "Ops.Math.Round" }, { id: "vib72zx3n", uiAttribs: {}, portsIn: [{ name: "Decimal Places", value: 4 }], portsOut: [{ name: "Result", links: [{ portIn: "String B", portOut: "Result", objIn: "hhpgrbf2g", objOut: "vib72zx3n" }] }], objName: "Ops.String.NumberToString_v2" }, { id: "zlpf1p0f5", uiAttribs: {}, portsIn: [{ name: "posY", value: -0.59 }, { name: "posZ", value: 0.22 }, { name: "scale", value: 0.15 }, { name: "rotX", value: 0 }, { name: "rotY", value: 0 }, { name: "rotZ", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "kgtq6kbqp", objOut: "zlpf1p0f5" }] }], objName: "Ops.Gl.Matrix.TransformView" }, { id: "f67se0kft", uiAttribs: {}, portsIn: [{ name: "Title", value: "Text" }], objName: "Ops.Ui.Area" }, { id: "6hojoyomj", uiAttribs: {}, portsIn: [{ name: "Limit", value: 1 }, { name: "Length", value: 10 }, { name: "Mode index", value: 1 }, { name: "Mode", value: "Stop at Max" }, { name: "Default", value: 0 }], portsOut: [{ name: "Value", links: [{ portIn: "val", portOut: "Value", objIn: "1b7ls5v00", objOut: "6hojoyomj" }] }], objName: "Ops.Math.Incrementor" }, { id: "m4wpz0q5c", uiAttribs: {}, portsIn: [{ name: "number2", value: 0.06 }], portsOut: [{ name: "result", links: [{ portIn: "mul", portOut: "result", objIn: "124910bf-e88f-4da5-847e-888a7ac73020", objOut: "m4wpz0q5c" }] }], objName: "Ops.Math.Multiply" }, { id: "1b7ls5v00", uiAttribs: {}, portsIn: [{ name: "min", value: 0 }, { name: "max", value: 9 }], portsOut: [{ name: "result", links: [{ portIn: "number1", portOut: "result", objIn: "m4wpz0q5c", objOut: "1b7ls5v00" }] }], objName: "Ops.Math.SmootherStep" }, { id: "hhpgrbf2g", uiAttribs: {}, portsIn: [{ name: "Format", value: "*$a $b" }, { name: "String C", value: 2 }, { name: "String D", value: 3 }, { name: "String E", value: "" }, { name: "String F", value: "" }], portsOut: [{ name: "Result", links: [{ portIn: "Text", portOut: "Result", objIn: "kgtq6kbqp", objOut: "hhpgrbf2g" }] }], objName: "Ops.String.StringCompose_v3" }, { id: "euqza6b25", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentIndexInsideRepeat2D" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "34zd4vl4f", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentIndexInsideRepeat2D" }], portsOut: [{ name: "Value", links: [{ portIn: "number2", portOut: "Value", objIn: "qyara3wac", objOut: "34zd4vl4f" }, { portIn: "number1", portOut: "Value", objIn: "ai5mgf397", objOut: "34zd4vl4f" }, { portIn: "index", portOut: "Value", objIn: "aqjh1act1", objOut: "34zd4vl4f" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "mtxdae1jj", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentIndexInsideRepeat2D" }], portsOut: [{ name: "Value", links: [{ portIn: "index", portOut: "Value", objIn: "fxd9qy0nv", objOut: "mtxdae1jj" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "ejryfn62d", uiAttribs: {}, portsIn: [{ name: "Title", value: "*" }], objName: "Ops.Ui.Area" }, { id: "yvvnsby8j", uiAttribs: {}, portsIn: [{ name: "text", value: "mix, diffuse, tone, size" }, { name: "separator", value: "," }, { name: "Numbers", value: 0 }, { name: "Trim", value: 1 }, { name: "Split Lines", value: 0 }], portsOut: [{ name: "array", links: [{ portIn: "array", portOut: "array", objIn: "fxd9qy0nv", objOut: "yvvnsby8j" }] }, { name: "length", value: 4 }], objName: "Ops.Array.StringToArray_v2" }, { id: "fxd9qy0nv", uiAttribs: {}, portsOut: [{ name: "result", links: [{ portIn: "String A", portOut: "result", objIn: "hhpgrbf2g", objOut: "fxd9qy0nv" }] }], objName: "Ops.Array.ArrayGetString" }, { id: "xqowbomkj", uiAttribs: {}, portsIn: [{ name: "Title", value: "*" }], objName: "Ops.Ui.Area" }, { id: "ch5u1xz0l", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "midExe" }], objName: "Ops.Trigger.TriggerSend" }, { id: "faiior48h", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "midExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "Render", portOut: "Triggered", objIn: "48vrkn65x", objOut: "faiior48h" }, { portIn: "render", portOut: "Triggered", objIn: "33hdtkr51", objOut: "faiior48h" }, { portIn: "render", portOut: "Triggered", objIn: "fvg1zz75v", objOut: "faiior48h" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "smns78b6k", uiAttribs: {}, portsIn: [{ name: "Title", value: "*" }], objName: "Ops.Ui.Area" }, { id: "piq1e64rw", uiAttribs: {}, portsIn: [{ name: "Title", value: "*" }], objName: "Ops.Ui.Area" }, { id: "t83msa078", uiAttribs: {}, portsIn: [{ name: "Title", value: "*" }], objName: "Ops.Ui.Area" }, { id: "4pu8mr0y2", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "preSequenceFlow" }], objName: "Ops.Trigger.TriggerSend" }, { id: "of6q9dm1m", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "midExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "v2qv1ozh2", objOut: "of6q9dm1m" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "zcc6zzw4d", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "exeNoCamera" }], objName: "Ops.Trigger.TriggerSend" }, { id: "zi3u8x4zd", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_activeDial_ID" }], portsOut: [{ name: "Value", links: [{ portIn: "number1", portOut: "Value", objIn: "zhjkbd61e", objOut: "zi3u8x4zd" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "0txm5qrgs", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_dialValues_array" }], portsOut: [{ name: "Value", links: [{ portIn: "array", portOut: "Value", objIn: "ccotjup9t", objOut: "0txm5qrgs" }] }], objName: "Ops.Vars.VarGetArray_v2" }, { id: "ccotjup9t", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Value Invalid Index", value: 0 }], portsOut: [{ name: "value", links: [{ portIn: "Default Value", portOut: "value", objIn: "dq71li66q", objOut: "ccotjup9t" }] }, { name: "Valid Index", value: 1 }], objName: "Ops.Array.ArrayGetNumber" }, { id: "zhjkbd61e", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "number2", value: 1 }], portsOut: [{ name: "result", links: [{ portIn: "index", portOut: "result", objIn: "ccotjup9t", objOut: "zhjkbd61e" }] }], objName: "Ops.Math.Subtract" }, { id: "v2qv1ozh2", uiAttribs: {}, portsIn: [{ name: "Size index", value: 1 }, { name: "Size", value: "Manual" }, { name: "texture height", value: 512 }, { name: "Auto Aspect", value: 1 }, { name: "filter index", value: 1 }, { name: "filter", value: "linear" }, { name: "Wrap index", value: 1 }, { name: "Wrap", value: "Repeat" }, { name: "MSAA index", value: 1 }, { name: "MSAA", value: "2x" }, { name: "Pixel Format index", value: 4 }, { name: "Pixel Format", value: "RGBA 8bit ubyte" }, { name: "Depth", value: 0 }, { name: "Clear", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "Execute", portOut: "trigger", objIn: "3so3f33cf", objOut: "v2qv1ozh2" }] }, { name: "texture", links: [{ portIn: "Texture In", portOut: "texture", objIn: "ldg250fag", objOut: "v2qv1ozh2" }, { portIn: "Base Texture", portOut: "texture", objIn: "eerqtlpnp", objOut: "v2qv1ozh2" }] }], objName: "Ops.Gl.RenderToTexture_v3" }, { id: "o4q65sx2h", uiAttribs: {}, portsIn: [{ name: "x", value: -1.4 }, { name: "y", value: -1.79 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "eb7wv37c6", objOut: "o4q65sx2h" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "qeilqpgn3", uiAttribs: {}, portsIn: [{ name: "Area index", value: 0 }, { name: "Area", value: "Canvas" }, { name: "Active", value: 1 }], portsOut: [{ name: "Button pressed Left", links: [{ portIn: "bool 1", portOut: "Button pressed Left", objIn: "eqbxs1gra", objOut: "qeilqpgn3" }] }, { name: "Button pressed Middle", links: [{ portIn: "bool 2", portOut: "Button pressed Middle", objIn: "eqbxs1gra", objOut: "qeilqpgn3" }] }, { name: "Button pressed Right", links: [{ portIn: "bool 3", portOut: "Button pressed Right", objIn: "eqbxs1gra", objOut: "qeilqpgn3" }] }], objName: "Ops.Devices.Mouse.MouseButtons" }, { id: "7cmaok29c", uiAttribs: {}, portsIn: [{ name: "Value 0", value: 30 }, { name: "Value 1", value: 60 }], portsOut: [{ name: "Out Value", links: [{ portIn: "FPS Limit", portOut: "Out Value", objIn: "zdo60lxbk", objOut: "7cmaok29c" }] }], objName: "Ops.Boolean.BoolToNumber_v2" }, { id: "eqbxs1gra", uiAttribs: {}, portsIn: [{ name: "bool 4", value: 0 }, { name: "bool 5", value: 0 }, { name: "bool 6", value: 0 }, { name: "bool 7", value: 0 }, { name: "bool 8", value: 0 }, { name: "bool 9", value: 0 }, { name: "bool 10", value: 0 }], portsOut: [{ name: "result", links: [{ portIn: "Use Value 1", portOut: "result", objIn: "7cmaok29c", objOut: "eqbxs1gra" }] }], objName: "Ops.Boolean.Or" }, { id: "gv2xr0zt3", uiAttribs: {}, portsIn: [{ name: "Font Name", value: "chivo" }, { name: "Font Data", value: "assets/6697c3b245eb5d333bae2007_ChivoMono-Medium-msdf.json", display: "file" }, { name: "Font Image", value: "assets/6697c3b245eb5d333bae2007_ChivoMono-Medium.png", display: "file" }, { name: "Font Image 1", value: 0, display: "file" }, { name: "Font Image 2", value: 0, display: "file" }, { name: "Font Image 3", value: 0, display: "file" }], portsOut: [{ name: "Loaded", value: true }, { name: "Total Chars", value: 66 }, { name: "Chars", value: "jQgbdf03689CGOShikl12457ABDEFHIJKLMNPRTUVWXYZpqtyw+acemnorsuvxz*-." }], objName: "Ops.Gl.FontMSDF_v2" }, { id: "kmdf8veed", uiAttribs: {}, portsIn: [{ name: "File", value: "assets/lib_matcaps_Chrome_Blue_Tint-White.png", display: "file" }, { name: "Filter index", value: 2 }, { name: "Filter", value: "mipmap" }, { name: "Wrap index", value: 0 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Data Format index", value: 3 }, { name: "Data Format", value: "RGBA" }, { name: "Flip", value: 0 }, { name: "Pre Multiplied Alpha", value: 0 }, { name: "Active", value: 1 }, { name: "Save Memory", value: 1 }, { name: "Add Cachebuster", value: 0 }], portsOut: [{ name: "Texture", links: [{ portIn: "Specular MatCap", portOut: "Texture", objIn: "chztenqi0", objOut: "kmdf8veed" }] }, { name: "Width", value: 256 }, { name: "Height", value: 256 }, { name: "Aspect Ratio", value: 1 }, { name: "Loaded", value: 1 }, { name: "Loading", value: 0 }], objName: "Ops.Gl.Texture_v2" }, { id: "flv1jlkal", uiAttribs: {}, portsIn: [{ name: "File", value: "assets/6697c3b245eb5d333bae2007_Sterungs.webp", display: "file" }, { name: "Filter index", value: 2 }, { name: "Filter", value: "mipmap" }, { name: "Wrap index", value: 0 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Data Format index", value: 3 }, { name: "Data Format", value: "RGBA" }, { name: "Flip", value: 0 }, { name: "Pre Multiplied Alpha", value: 0 }, { name: "Active", value: 1 }, { name: "Save Memory", value: 1 }, { name: "Add Cachebuster", value: 0 }], portsOut: [{ name: "Texture", links: [{ portIn: "Specular Mask", portOut: "Texture", objIn: "chztenqi0", objOut: "flv1jlkal" }] }, { name: "Width", value: 256 }, { name: "Height", value: 256 }, { name: "Aspect Ratio", value: 1 }, { name: "Loaded", value: 1 }, { name: "Loading", value: 0 }], objName: "Ops.Gl.Texture_v2" }, { id: "40fnzsucx", uiAttribs: {}, portsIn: [{ name: "Play", value: 1 }, { name: "Sync to timeline", value: 0 }], portsOut: [{ name: "Time", links: [{ portIn: "Time", portOut: "Time", objIn: "lv0f0jbcs", objOut: "40fnzsucx" }] }], objName: "Ops.Anim.Timer_v2" }, { id: "lv0f0jbcs", uiAttribs: {}, portsIn: [{ name: "Type index", value: 2 }, { name: "Type", value: "ramp up" }, { name: "Phase", value: 0 }, { name: "Range Min", value: -360 }, { name: "Range Max", value: 360 }], portsOut: [{ name: "Result", links: [{ portIn: "rotX", portOut: "Result", objIn: "li365texv", objOut: "lv0f0jbcs" }] }], objName: "Ops.Anim.LFO_v2" }, { id: "ai5mgf397", uiAttribs: {}, portsIn: [{ name: "number2", value: 0.01 }], portsOut: [{ name: "result", links: [{ portIn: "Frequency", portOut: "result", objIn: "lv0f0jbcs", objOut: "ai5mgf397" }] }], objName: "Ops.Math.Multiply" }, { id: "dsy5j4yzl", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsOut: [{ name: "result", links: [{ portIn: "Value", portOut: "result", objIn: "s9n3wwypa", objOut: "dsy5j4yzl" }, { portIn: "Pass Through", portOut: "result", objIn: "8lyuqd6tn", objOut: "dsy5j4yzl" }, { portIn: "Pass Through", portOut: "result", objIn: "csl3j7cy1", objOut: "dsy5j4yzl" }] }], objName: "Ops.Boolean.And" }, { id: "hd8nl2ugk", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_buttonIsDown" }], portsOut: [{ name: "Value", links: [{ portIn: "bool 2", portOut: "Value", objIn: "dsy5j4yzl", objOut: "hd8nl2ugk" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "yi13493pq", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_hitBodyName" }], portsOut: [{ name: "Value", links: [{ portIn: "String", portOut: "Value", objIn: "i77gb1h2c", objOut: "yi13493pq" }, { portIn: "String In", portOut: "Value", objIn: "8lyuqd6tn", objOut: "yi13493pq" }] }], objName: "Ops.Vars.VarGetString" }, { id: "i77gb1h2c", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "SearchValue", value: "dial" }], portsOut: [{ name: "Found", links: [{ portIn: "bool 1", portOut: "Found", objIn: "dsy5j4yzl", objOut: "i77gb1h2c" }] }, { name: "Index", value: -1 }], objName: "Ops.String.StringContains_v2" }, { id: "ozs800vz3", uiAttribs: {}, objName: "Ops.Gl.GLTF.GltfDracoCompression" }, { id: "bmau99lwf", uiAttribs: {}, portsIn: [{ name: "data", value: '{"hiddenNodes":{}}' }, { name: "glb File", value: "assets/66a8cc11ac4e6d02513b1fae_spherical_animation.draco.glb", display: "file" }, { name: "Draw", value: 1 }, { name: "Camera index", value: 0 }, { name: "Camera", value: "None" }, { name: "Animation", value: "Anim " }, { name: "Center index", value: 0 }, { name: "Center", value: "None" }, { name: "Rescale", value: 1 }, { name: "Rescale Size", value: 1 }, { name: "Sync to timeline", value: 0 }, { name: "Loop", value: 1 }, { name: "Normals Format index", value: 0 }, { name: "Normals Format", value: "XYZ" }, { name: "Vertices Format index", value: 0 }, { name: "Vertices Format", value: "XYZ" }, { name: "Calc Normals index", value: 0 }, { name: "Calc Normals", value: "Auto" }, { name: "Hide Nodes", value: 0 }, { name: "Use Material Properties", value: 0 }, { name: "Active", value: 1 }], portsOut: [{ name: "Next", links: [{ portIn: "Render", portOut: "Next", objIn: "38w7tj78u", objOut: "bmau99lwf" }] }, { name: "Generator", value: "Sketchfab-16.17.0" }, { name: "GLTF Version", value: 2 }, { name: "Anim Length", value: 8.333333015441895 }, { name: "Anim Time", value: 0.8198127765691052 }, { name: "Loading", value: false }], objName: "Ops.Gl.GLTF.GltfScene_v4" }, { id: "lb1qzrcoj", uiAttribs: {}, portsIn: [{ name: "Material Name", value: "FORGED_METAL" }], portsOut: [{ name: "Material", links: [{ portIn: "Materials", portOut: "Material", objIn: "bmau99lwf", objOut: "lb1qzrcoj" }] }], objName: "Ops.Gl.GLTF.GltfSetMaterial" }, { id: "fs2uw3jmy", uiAttribs: {}, portsIn: [{ name: "Material Name", value: "Side" }], portsOut: [{ name: "Material", links: [{ portIn: "Materials", portOut: "Material", objIn: "bmau99lwf", objOut: "fs2uw3jmy" }] }], objName: "Ops.Gl.GLTF.GltfSetMaterial" }, { id: "nnu0oo0gu", uiAttribs: {}, portsIn: [{ name: "Variable", value: "NEL_SRVB_Metals" }], objName: "Ops.Vars.VarSetObject_v2" }, { id: "u5bcyfii0", uiAttribs: {}, portsIn: [{ name: "Variable", value: "NEL_SRVB_Metals" }], portsOut: [{ name: "Value", links: [{ portIn: "Shader", portOut: "Value", objIn: "lb1qzrcoj", objOut: "u5bcyfii0" }] }], objName: "Ops.Vars.VarGetObject_v2" }, { id: "leqa7h4pd", uiAttribs: {}, portsIn: [{ name: "Diffuse A", value: 1 }, { name: "Double Sided", value: 0 }, { name: "Colorize Texture", value: 0 }], portsOut: [{ name: "next", links: [{ portIn: "Execute", portOut: "next", objIn: "0rcbij4av", objOut: "leqa7h4pd" }] }, { name: "Shader", links: [{ portIn: "Shader", portOut: "Shader", objIn: "fs2uw3jmy", objOut: "leqa7h4pd" }] }], objName: "Ops.Gl.Phong.LambertMaterial_v2" }, { id: "s0o3lhs2y", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ringR" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "z5bv7gal9", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ringG" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "oa1101yyu", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ringR" }], portsOut: [{ name: "Value", links: [{ portIn: "Value", portOut: "Value", objIn: "y7uobh49q", objOut: "oa1101yyu" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "tnds1iu5y", uiAttribs: {}, portsIn: [{ name: "Material Name", value: "POINTS" }], portsOut: [{ name: "Material", links: [{ portIn: "Materials", portOut: "Material", objIn: "bmau99lwf", objOut: "tnds1iu5y" }] }], objName: "Ops.Gl.GLTF.GltfSetMaterial" }, { id: "0rcbij4av", uiAttribs: {}, portsIn: [{ name: "Diffuse R", value: 0.919 }, { name: "Diffuse G", value: 0.97 }, { name: "Diffuse B", value: 1 }, { name: "Diffuse A", value: 1 }, { name: "Double Sided", value: 0 }, { name: "Colorize Texture", value: 0 }], portsOut: [{ name: "Shader", links: [{ portIn: "Shader", portOut: "Shader", objIn: "tnds1iu5y", objOut: "0rcbij4av" }] }], objName: "Ops.Gl.Phong.LambertMaterial_v2" }, { id: "y7uobh49q", uiAttribs: {}, portsOut: [{ name: "Result", links: [{ portIn: "g", portOut: "Result", objIn: "chztenqi0", objOut: "y7uobh49q" }] }], objName: "Ops.Math.OneMinus" }, { id: "ts03zao35", uiAttribs: {}, portsIn: [{ name: "r", value: 1 }, { name: "g", value: 1 }, { name: "b", value: 1 }, { name: "Opacity", value: 1 }, { name: "AO Intensity", value: 1 }, { name: "Normal Map Intensity", value: 1 }, { name: "Repeat X", value: 1 }, { name: "Repeat Y", value: 1 }, { name: "Offset X", value: 0 }, { name: "Offset Y", value: 0 }, { name: "Screen Space Normals", value: 0 }, { name: "Calc normal tangents", value: 1 }, { name: "Opacity TexCoords Transform", value: 0 }, { name: "Discard Transparent Pixels", value: 0 }, { name: "Alpha Mask Source index", value: 0 }, { name: "Alpha Mask Source", value: "Luminance" }], portsOut: [{ name: "Next", links: [{ portIn: "Execute", portOut: "Next", objIn: "l7fhi163a", objOut: "ts03zao35" }, { portIn: "render", portOut: "Next", objIn: "orseg18lf", objOut: "ts03zao35" }] }], objName: "Ops.Gl.Shader.MatCapMaterial_v3" }, { id: "38w7tj78u", uiAttribs: {}, portsIn: [{ name: "Node Name", value: "c001_1" }, { name: "Translate Y", value: 0 }, { name: "Translate Z", value: 0 }, { name: "Rotation X", value: 0 }, { name: "Rotation Y", value: 0 }, { name: "Rotation Z", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Render", portOut: "Next", objIn: "bq7dcj36g", objOut: "38w7tj78u" }] }, { name: "Found", value: true }], objName: "Ops.Gl.GLTF.GltfTransformNode" }, { id: "5g6m8w0kd", uiAttribs: {}, portsIn: [{ name: "Node Name", value: "c003_3" }, { name: "Translate Y", value: 0 }, { name: "Translate Z", value: 0 }, { name: "Rotation X", value: 0 }, { name: "Rotation Y", value: 0 }, { name: "Rotation Z", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Render", portOut: "Next", objIn: "br7cvag8u", objOut: "5g6m8w0kd" }] }, { name: "Found", value: true }], objName: "Ops.Gl.GLTF.GltfTransformNode" }, { id: "bq7dcj36g", uiAttribs: {}, portsIn: [{ name: "Node Name", value: "c002_2" }, { name: "Translate Y", value: 0 }, { name: "Translate Z", value: 0 }, { name: "Rotation X", value: 0 }, { name: "Rotation Y", value: 0 }, { name: "Rotation Z", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Render", portOut: "Next", objIn: "5g6m8w0kd", objOut: "bq7dcj36g" }] }, { name: "Found", value: true }], objName: "Ops.Gl.GLTF.GltfTransformNode" }, { id: "br7cvag8u", uiAttribs: {}, portsIn: [{ name: "Node Name", value: "c004_4" }, { name: "Translate Y", value: 0 }, { name: "Translate Z", value: 0 }, { name: "Rotation X", value: 0 }, { name: "Rotation Y", value: 0 }, { name: "Rotation Z", value: 0 }], portsOut: [{ name: "Found", value: true }], objName: "Ops.Gl.GLTF.GltfTransformNode" }, { id: "hf23rbdfn", uiAttribs: {}, portsIn: [{ name: "number2", value: 20 }], portsOut: [{ name: "result", links: [{ portIn: "Translate X", portOut: "result", objIn: "38w7tj78u", objOut: "hf23rbdfn" }, { portIn: "Translate X", portOut: "result", objIn: "bq7dcj36g", objOut: "hf23rbdfn" }, { portIn: "Translate X", portOut: "result", objIn: "5g6m8w0kd", objOut: "hf23rbdfn" }, { portIn: "Translate X", portOut: "result", objIn: "br7cvag8u", objOut: "hf23rbdfn" }] }], objName: "Ops.Math.Multiply" }, { id: "w1vt61ydw", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_dialValues_array" }], portsOut: [{ name: "Value", links: [{ portIn: "Array in", portOut: "Value", objIn: "z1obzd6uz", objOut: "w1vt61ydw" }] }], objName: "Ops.Vars.VarGetArray_v2" }, { id: "9044xju7n", uiAttribs: {}, portsIn: [{ name: "Value Invalid Index", value: 0 }], portsOut: [{ name: "value", links: [{ portIn: "number1", portOut: "value", objIn: "hf23rbdfn", objOut: "9044xju7n" }] }, { name: "Valid Index", value: 1 }], objName: "Ops.Array.ArrayGetNumber" }, { id: "z1obzd6uz", uiAttribs: {}, portsIn: [{ name: "When False index", value: 0 }, { name: "When False", value: "keep last array" }], portsOut: [{ name: "Array Out", links: [{ portIn: "array", portOut: "Array Out", objIn: "9044xju7n", objOut: "z1obzd6uz" }] }], objName: "Ops.Array.GateArray_v2" }, { id: "0lxocfgel", uiAttribs: {}, portsIn: [{ name: "Title", value: "Spatial GLTF" }], objName: "Ops.Ui.Area" }, { id: "hb06uwqts", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentInstanceIsActive" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "9hyokghvg", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentInstanceIsActive" }], portsOut: [{ name: "Value", links: [{ portIn: "Pass Through", portOut: "Value", objIn: "z1obzd6uz", objOut: "9hyokghvg" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "6dc9673bl", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentIndexInsideRepeat2D" }], portsOut: [{ name: "Value", links: [{ portIn: "A", portOut: "Value", objIn: "88c0pg2n0", objOut: "6dc9673bl" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "88c0pg2n0", uiAttribs: {}, portsIn: [{ name: "B", value: 1 }, { name: "C", value: 2 }, { name: "D", value: 3 }, { name: "Expression", value: "(a + 1) % 4" }], portsOut: [{ name: "Result", links: [{ portIn: "index", portOut: "Result", objIn: "9044xju7n", objOut: "88c0pg2n0" }] }, { name: "Expression Valid", value: true }], objName: "Ops.Math.MathExpression" }, { id: "6v0s7i2sf", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_rep2d_x" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "q3siwjs06", uiAttribs: {}, portsIn: [{ name: "Frequency", value: 2002e-6 }, { name: "Type index", value: 0 }, { name: "Type", value: "sine" }, { name: "Range Min", value: 0 }, { name: "Range Max", value: 8 }], portsOut: [{ name: "Result", links: [{ portIn: "Time", portOut: "Result", objIn: "bmau99lwf", objOut: "q3siwjs06" }] }], objName: "Ops.Anim.LFO_v2" }, { id: "l3284qrsh", uiAttribs: {}, portsOut: [{ name: "timesTriggered", links: [{ portIn: "A", portOut: "timesTriggered", objIn: "hd355ern0", objOut: "l3284qrsh" }] }], objName: "Ops.Trigger.TriggerCounter" }, { id: "xja9p9adg", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentIndexInsideRepeat2D" }], portsOut: [{ name: "Value", links: [{ portIn: "B", portOut: "Value", objIn: "hd355ern0", objOut: "xja9p9adg" }, { portIn: "Phase", portOut: "Value", objIn: "q3siwjs06", objOut: "xja9p9adg" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "orseg18lf", uiAttribs: {}, portsIn: [{ name: "scale", value: 1.28 }, { name: "x", value: 1 }, { name: "y", value: 1 }, { name: "z", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "bmau99lwf", objOut: "orseg18lf" }] }], objName: "Ops.Gl.Matrix.Scale" }, { id: "hd355ern0", uiAttribs: {}, portsIn: [{ name: "C", value: -1 }, { name: "D", value: 0 }, { name: "Expression", value: "a*(b * 0.01)" }], portsOut: [{ name: "Result", links: [{ portIn: "Time", portOut: "Result", objIn: "q3siwjs06", objOut: "hd355ern0" }] }, { name: "Expression Valid", value: true }], objName: "Ops.Math.MathExpression" }, { id: "2p7s5nsc9", uiAttribs: {}, portsIn: [{ name: "render", title: "Trigger" }, { name: "Render Mesh", value: 1, title: "Render" }, { name: "width", value: 5e-3 }, { name: "pivot x index", value: 1 }, { name: "pivot x", value: "center" }, { name: "pivot y index", value: 2 }, { name: "pivot y", value: "bottom" }, { name: "axis index", value: 0 }, { name: "axis", value: "xy" }, { name: "Flip TexCoord X", value: 0 }, { name: "Flip TexCoord Y", value: 1 }, { name: "num columns", value: 1 }, { name: "num rows", value: 1 }], objName: "Ops.Gl.Meshes.Rectangle_v4" }, { id: "cplq646td", uiAttribs: {}, portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "j447574nb", objOut: "cplq646td" }] }], objName: "Ops.Gl.Matrix.Billboard" }, { id: "j447574nb", uiAttribs: {}, portsIn: [{ name: "y", value: 1.45 }, { name: "z", value: 6.66 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "lb4ss1de9", objOut: "j447574nb" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "l53eehg6x", uiAttribs: {}, portsIn: [{ name: "Text", value: "ScapeRVB" }, { name: "Font", value: "chivo" }, { name: "Scale", value: 1.54 }, { name: "Letter Spacing", value: 0.02 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 1 }, { name: "Align", value: "Center" }, { name: "Vertical Align index", value: 1 }, { name: "Vertical Align", value: "Top" }, { name: "r", value: 0.179 }, { name: "g", value: 1 }, { name: "b", value: 0.692 }, { name: "a", value: 0.91 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.126 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.222 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 0 }, { name: "Border g", value: 0 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 0 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Rotations", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Num Lines", value: 1 }, { name: "Width", value: 3.4483968750000003 }, { name: "Height", value: 0.9838645833333333 }, { name: "Start Y", value: 0.4781656249999999 }, { name: "Num Chars", value: 8 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "fevah6hns", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "finalExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "bav6ydpr2", objOut: "fevah6hns" }, { portIn: "exe", portOut: "Triggered", objIn: "rw14ave8u", objOut: "fevah6hns" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "bav6ydpr2", uiAttribs: {}, portsIn: [{ name: "posX", value: 0.89 }, { name: "posY", value: 0.435 }, { name: "posZ", value: 0 }, { name: "scale", value: 0.125 }, { name: "rotX", value: 0 }, { name: "rotY", value: 0 }, { name: "rotZ", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "l53eehg6x", objOut: "bav6ydpr2" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "3g7cbchrs", uiAttribs: {}, portsIn: [{ name: "x", value: -0.6 }, { name: "y", value: -0.84 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Exec", portOut: "trigger", objIn: "cplq646td", objOut: "3g7cbchrs" }] }], objName: "Ops.Gl.Matrix.TranslateView" }, { id: "s9n3wwypa", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_mouseIsChangingDialValue" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "1a68gpjeh", uiAttribs: {}, portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "2iozqy3i6", objOut: "1a68gpjeh" }] }, { name: "Result", links: [{ portIn: "Object", portOut: "Result", objIn: "2cbchlduf", objOut: "1a68gpjeh" }] }], objName: "Ops.Data.Compose.Object.CompObject" }, { id: "2iozqy3i6", uiAttribs: {}, portsIn: [{ name: "Key", value: "mix" }, { name: "Number", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "42ukcss4d", objOut: "2iozqy3i6" }] }], objName: "Ops.Data.Compose.Object.CompObjectSetNumber" }, { id: "42ukcss4d", uiAttribs: {}, portsIn: [{ name: "Key", value: "diffuse" }, { name: "Number", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "ebt09vc90", objOut: "42ukcss4d" }] }], objName: "Ops.Data.Compose.Object.CompObjectSetNumber" }, { id: "ebt09vc90", uiAttribs: {}, portsIn: [{ name: "Key", value: "tone" }, { name: "Number", value: 0.5 }], portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "fdu5vba76", objOut: "ebt09vc90" }] }], objName: "Ops.Data.Compose.Object.CompObjectSetNumber" }, { id: "fdu5vba76", uiAttribs: {}, portsIn: [{ name: "Key", value: "size" }, { name: "Number", value: 0 }], objName: "Ops.Data.Compose.Object.CompObjectSetNumber" }, { id: "28d5nmh91", uiAttribs: {}, portsIn: [{ name: "ZoomText", value: 0 }, { name: "Line Numbers", value: 1 }, { name: "Font Size", value: 10 }, { name: "Scroll", value: 0 }], objName: "Ops.Ui.VizObject" }, { id: "ueht75nuq", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "finalExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "Exec", portOut: "Triggered", objIn: "x7p8k6vel", objOut: "ueht75nuq" }, { portIn: "Trigger", portOut: "Triggered", objIn: "2cbchlduf", objOut: "ueht75nuq" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "2k40p1ixu", uiAttribs: {}, portsOut: [{ name: "Values", links: [{ portIn: "Array", portOut: "Values", objIn: "o5k93vq6e", objOut: "2k40p1ixu" }, { portIn: "Value", portOut: "Values", objIn: "x6efudpvd", objOut: "2k40p1ixu" }] }, { name: "Num values", value: 4 }], objName: "Ops.Json.ObjectValuesAsArray" }, { id: "o5k93vq6e", uiAttribs: {}, portsIn: [{ name: "Start Row", value: 0 }], objName: "Ops.Ui.VizArrayTable" }, { id: "lgfxem7we", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Variable", value: "ui_mouseIsChangingParamID" }], objName: "Ops.Vars.VarSetString_v2" }, { id: "8lyuqd6tn", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "When False index", value: 0 }, { name: "When False", value: "keep last string" }, { name: "Custom Value", value: "" }], portsOut: [{ name: "String Out", links: [{ portIn: "Key", portOut: "String Out", objIn: "q2imefo72", objOut: "8lyuqd6tn" }] }], objName: "Ops.String.GateString" }, { id: "8vvl2gwwz", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "el0us87h5", objOut: "8vvl2gwwz" }] }, { name: "Result", links: [{ portIn: "data", portOut: "Result", objIn: "q2imefo72", objOut: "8vvl2gwwz" }] }], objName: "Ops.Data.Compose.Object.CompObject" }, { id: "madc5uih6", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Named Trigger", value: "mainExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "Update", portOut: "Triggered", objIn: "8vvl2gwwz", objOut: "madc5uih6" }, { portIn: "Exec", portOut: "Triggered", objIn: "hf3ib8jqh", objOut: "madc5uih6" }, { portIn: "Update", portOut: "Triggered", objIn: "na2pda15t", objOut: "madc5uih6" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "el0us87h5", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Key", value: "dial.1" }, { name: "String", value: "mix" }], portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "lq1vvjm70", objOut: "el0us87h5" }] }], objName: "Ops.Data.Compose.Object.CompObjectSetString" }, { id: "lq1vvjm70", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Key", value: "dial.2" }, { name: "String", value: "diffuse" }], portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "zuuutor70", objOut: "lq1vvjm70" }] }], objName: "Ops.Data.Compose.Object.CompObjectSetString" }, { id: "zuuutor70", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Key", value: "dial.3" }, { name: "String", value: "tone" }], portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "fvxs3gsfk", objOut: "zuuutor70" }] }], objName: "Ops.Data.Compose.Object.CompObjectSetString" }, { id: "fvxs3gsfk", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Key", value: "dial.4" }, { name: "String", value: "size" }], objName: "Ops.Data.Compose.Object.CompObjectSetString" }, { id: "q2imefo72", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsOut: [{ name: "Result", links: [{ portIn: "Value", portOut: "Result", objIn: "lgfxem7we", objOut: "q2imefo72" }] }], objName: "Ops.Json.ObjectGetString" }, { id: "5h3v4dsa0", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_mouseIsChangingParamID" }], portsOut: [{ name: "Value", links: [{ portIn: "Key", portOut: "Value", objIn: "2cbchlduf", objOut: "5h3v4dsa0" }] }], objName: "Ops.Vars.VarGetString" }, { id: "2cbchlduf", uiAttribs: {}, portsOut: [{ name: "Result", links: [{ portIn: "Object In", portOut: "Result", objIn: "1qxuxacu8", objOut: "2cbchlduf" }] }], objName: "Ops.Json.TriggerObjectSetNumber" }, { id: "x7p8k6vel", uiAttribs: {}, portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "1a68gpjeh", objOut: "x7p8k6vel" }, { portIn: "Trigger", portOut: "Next", objIn: "z2nzidnng", objOut: "x7p8k6vel" }] }, { name: "Was Triggered", value: 1 }], objName: "Ops.Trigger.TriggerOnce" }, { id: "bp5rcdeha", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "preSequenceFlow" }], objName: "Ops.Trigger.TriggerReceive" }, { id: "cconk53k8", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_dialValues_object" }], objName: "Ops.Vars.VarSetObject_v2" }, { id: "eko3x9yfz", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_buttonIsDown" }], portsOut: [{ name: "Value", links: [{ portIn: "bool 1", portOut: "Value", objIn: "uesg11629", objOut: "eko3x9yfz" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "h6fm96idh", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_dialValues_object" }], portsOut: [{ name: "Value", links: [{ portIn: "Object2", portOut: "Value", objIn: "cx3uanmz2", objOut: "h6fm96idh" }] }], objName: "Ops.Vars.VarGetObject_v2" }, { id: "1qxuxacu8", uiAttribs: {}, portsIn: [{ name: "When False index", value: 0 }, { name: "When False", value: "keep last object" }, { name: "Only Valid Objects", value: 1 }], portsOut: [{ name: "Object Out", links: [{ portIn: "Object", portOut: "Object Out", objIn: "28d5nmh91", objOut: "1qxuxacu8" }, { portIn: "Value", portOut: "Object Out", objIn: "cconk53k8", objOut: "1qxuxacu8" }, { portIn: "Object1", portOut: "Object Out", objIn: "cx3uanmz2", objOut: "1qxuxacu8" }] }], objName: "Ops.Json.GateObject" }, { id: "uesg11629", uiAttribs: {}, portsIn: [{ name: "bool 3", value: 0 }, { name: "bool 4", value: 0 }, { name: "bool 5", value: 0 }, { name: "bool 6", value: 0 }, { name: "bool 7", value: 0 }, { name: "bool 8", value: 0 }, { name: "bool 9", value: 0 }, { name: "bool 10", value: 0 }], portsOut: [{ name: "result", links: [{ portIn: "Pass Through", portOut: "result", objIn: "1qxuxacu8", objOut: "uesg11629" }] }], objName: "Ops.Boolean.Or" }, { id: "z2nzidnng", uiAttribs: {}, portsIn: [{ name: "Duration", value: 0.1 }, { name: "Value True", value: 1 }, { name: "Value False", value: 0 }], portsOut: [{ name: "Result", links: [{ portIn: "bool 2", portOut: "Result", objIn: "uesg11629", objOut: "z2nzidnng" }] }], objName: "Ops.Boolean.MonoFlop" }, { id: "tvhdy0oy7", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "key code", value: 16 }, { name: "canvas only", value: 1 }, { name: "Mod Key index", value: 0 }, { name: "Mod Key", value: "none" }, { name: "Enabled", value: 1 }, { name: "Prevent Default", value: 0 }], portsOut: [{ name: "on press", links: [{ portIn: "Trigger 0", portOut: "on press", objIn: "9xrx1aiud", objOut: "tvhdy0oy7" }] }, { name: "on release", links: [{ portIn: "Trigger 1", portOut: "on release", objIn: "9xrx1aiud", objOut: "tvhdy0oy7" }] }, { name: "Pressed", value: 1 }, { name: "Key", value: "Shift" }], objName: "Ops.Devices.Keyboard.KeyPressLearn" }, { id: "9xrx1aiud", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Value 0", value: 0.05 }, { name: "Value 1", value: 0.5 }, { name: "Value 2", value: 0.5 }, { name: "Value 3", value: 0 }, { name: "Value 4", value: 0 }, { name: "Value 5", value: 0 }, { name: "Value 6", value: 0 }, { name: "Value 7", value: 0 }, { name: "Default Value", value: "" }], portsOut: [{ name: "Value", links: [{ portIn: "Multiply", portOut: "Value", objIn: "dq71li66q", objOut: "9xrx1aiud" }] }, { name: "Last Value", value: "" }], objName: "Ops.Number.SwitchNumberOnTrigger" }, { id: "hf3ib8jqh", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsOut: [{ name: "Next", links: [{ portIn: "Trigger 2", portOut: "Next", objIn: "9xrx1aiud", objOut: "hf3ib8jqh" }] }, { name: "Was Triggered", value: 1 }], objName: "Ops.Trigger.TriggerOnce" }, { id: "48vrkn65x", uiAttribs: {}, portsIn: [{ name: "Size index", value: 0 }, { name: "Size", value: "Auto" }, { name: "Width", value: 640 }, { name: "Height", value: 480 }, { name: "Filter index", value: 1 }, { name: "Filter", value: "linear" }, { name: "Wrap index", value: 1 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Pixel Format index", value: 5 }, { name: "Pixel Format", value: "SRGBA 8bit ubyte" }, { name: "R", value: 0 }, { name: "G", value: 0 }, { name: "B", value: 0 }, { name: "A", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "6fb2f0244", objOut: "48vrkn65x" }] }, { name: "texture_out", links: [{ portIn: "Diffuse", portOut: "texture_out", objIn: "flor1ge09", objOut: "48vrkn65x" }] }, { name: "Aspect Ratio", value: 1.8329411764705883 }, { name: "Texture Width", value: 1558 }, { name: "Texture Height", value: 850 }], objName: "Ops.Gl.ImageCompose.ImageCompose_v4" }, { id: "wcm52u6xo", uiAttribs: {}, portsIn: [{ name: "x", value: -1 }, { name: "y", value: 0.4 }, { name: "z", value: -1 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "62jtojeuu", objOut: "wcm52u6xo" }] }], objName: "Ops.Gl.Matrix.ScaleXYZViewMatrix" }, { id: "flor1ge09", uiAttribs: {}, portsIn: [{ name: "r", value: 0.07 }, { name: "g", value: 0.06 }, { name: "b", value: 0.51 }, { name: "AO Intensity", value: 1 }, { name: "Normal Map Intensity", value: 1 }, { name: "Repeat X", value: 1 }, { name: "Repeat Y", value: 1 }, { name: "Offset X", value: 0.93 }, { name: "Offset Y", value: -0.89 }, { name: "Screen Space Normals", value: 0 }, { name: "Calc normal tangents", value: 1 }, { name: "Opacity TexCoords Transform", value: 0 }, { name: "Discard Transparent Pixels", value: 1 }, { name: "Alpha Mask Source index", value: 0 }, { name: "Alpha Mask Source", value: "Luminance" }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "wcm52u6xo", objOut: "flor1ge09" }] }], objName: "Ops.Gl.Shader.MatCapMaterial_v3" }, { id: "9dqwuc8l6", uiAttribs: {}, portsIn: [{ name: "render", title: "Trigger" }, { name: "Render Mesh", value: 1, title: "Render" }, { name: "width", value: 1 }, { name: "height", value: 1.8 }, { name: "pivot x index", value: 1 }, { name: "pivot x", value: "center" }, { name: "pivot y index", value: 1 }, { name: "pivot y", value: "center" }, { name: "axis index", value: 0 }, { name: "axis", value: "xy" }, { name: "Flip TexCoord X", value: 0 }, { name: "Flip TexCoord Y", value: 1 }, { name: "num columns", value: 1 }, { name: "num rows", value: 1 }], objName: "Ops.Gl.Meshes.Rectangle_v4" }, { id: "2zbdnj6oz", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_size" }], portsOut: [{ name: "Value", links: [{ portIn: "Value", portOut: "Value", objIn: "zpf6nadj7", objOut: "2zbdnj6oz" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "eb7wv37c6", uiAttribs: {}, portsIn: [{ name: "file", value: "assets/6697c3b245eb5d333bae2007_NEL_SRVB.webp", display: "file" }, { name: "extrude", value: 4.42 }, { name: "width", value: 3 }, { name: "height", value: 3 }, { name: "columns", value: 21 }, { name: "texCoords slice", value: 1 }, { name: "flat", value: 1 }], portsOut: [{ name: "geometry", links: [{ portIn: "Value", portOut: "geometry", objIn: "hr05yjyy0", objOut: "eb7wv37c6" }] }], objName: "Ops.Gl.Meshes.HeightMap" }, { id: "ldg250fag", uiAttribs: {}, portsIn: [{ name: "Show Info", value: 0 }, { name: "Visualize outside 0-1 index", value: 0 }, { name: "Visualize outside 0-1", value: "Off" }, { name: "Alpha index", value: 1 }, { name: "Alpha", value: "1" }, { name: "Show Color", value: 0 }, { name: "X", value: 0.5 }, { name: "Y", value: 0.5 }], portsOut: [{ name: "Info", value: "" }], objName: "Ops.Ui.VizTexture" }, { id: "u8jt2zskv", uiAttribs: {}, portsIn: [{ name: "Value", value: 0 }, { name: "Variable", value: "rcv_structure" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "omwm1ixga", uiAttribs: {}, portsIn: [{ name: "Title", value: "RCV" }], objName: "Ops.Ui.Area" }, { id: "wku86fxpi", uiAttribs: {}, portsIn: [{ name: "Value", value: 0 }, { name: "Variable", value: "rcv_structureArray" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "cx3uanmz2", uiAttribs: {}, portsOut: [{ name: "Out Object", links: [{ portIn: "Object", portOut: "Out Object", objIn: "2k40p1ixu", objOut: "cx3uanmz2" }] }], objName: "Ops.Json.ObjectFunnel" }, { id: "j4exj9jwp", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_tone" }], portsOut: [{ name: "Value", links: [{ portIn: "Diffuse R", portOut: "Value", objIn: "leqa7h4pd", objOut: "j4exj9jwp" }, { portIn: "Diffuse G", portOut: "Value", objIn: "leqa7h4pd", objOut: "j4exj9jwp" }, { portIn: "Diffuse B", portOut: "Value", objIn: "leqa7h4pd", objOut: "j4exj9jwp" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "c4hww7lmi", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_tone" }], portsOut: [{ name: "Value", links: [{ portIn: "Value", portOut: "Value", objIn: "3gcrjukfk", objOut: "c4hww7lmi" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "33hdtkr51", uiAttribs: {}, portsIn: [{ name: "x", value: 0 }, { name: "y", value: 0.22 }, { name: "z", value: -0.01 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "flor1ge09", objOut: "33hdtkr51" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "pn1vr4quv", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_finalTextOut" }], objName: "Ops.Vars.VarGetTexture_v2" }, { id: "3gcrjukfk", uiAttribs: {}, portsIn: [{ name: "Min", value: 0 }, { name: "Max", value: 1 }, { name: "Easing index", value: 11 }, { name: "Easing", value: "Sin Out" }], portsOut: [{ name: "Result", links: [{ portIn: "Opacity", portOut: "Result", objIn: "flor1ge09", objOut: "3gcrjukfk" }] }], objName: "Ops.Math.Ease" }, { id: "62voq6obk", uiAttribs: {}, portsIn: [{ name: "Value", value: 0 }, { name: "Variable", value: "ui_scapeDiffusion" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "l7fhi163a", uiAttribs: {}, portsIn: [{ name: "Nth", value: 2 }], portsOut: [{ name: "Next", links: [{ portIn: "exe", portOut: "Next", objIn: "l3284qrsh", objOut: "l7fhi163a" }] }], objName: "Ops.Trigger.NthTrigger_v2" }, { id: "zpf6nadj7", uiAttribs: {}, portsOut: [{ name: "Result", value: 0.9 }], objName: "Ops.Math.OneMinus" }, { id: "oba4wt0jq", uiAttribs: {}, portsIn: [{ name: "scale", value: 0.8 }, { name: "x", value: 1 }, { name: "y", value: 1 }, { name: "z", value: 0.86 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "o4q65sx2h", objOut: "oba4wt0jq" }] }], objName: "Ops.Gl.Matrix.Scale" }, { id: "62jtojeuu", uiAttribs: {}, portsIn: [{ name: "posX", value: 0 }, { name: "posY", value: -1.15 }, { name: "posZ", value: -3.52 }, { name: "scale", value: 3.57 }, { name: "rotX", value: -83.76 }, { name: "rotY", value: 0 }, { name: "rotZ", value: 180 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "9dqwuc8l6", objOut: "62jtojeuu" }] }], objName: "Ops.Gl.Matrix.TransformView" }, { id: "rw14ave8u", uiAttribs: {}, portsIn: [{ name: "easing index", value: 8 }, { name: "easing", value: "Expo Out" }, { name: "duration", value: 0.75 }, { name: "Direction index", value: 0 }, { name: "Direction", value: "Both" }, { name: "value false", value: 0 }, { name: "value true", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "Update", portOut: "trigger", objIn: "zpbecbb56", objOut: "rw14ave8u" }] }, { name: "value", links: [{ portIn: "Value", portOut: "value", objIn: "62fo5emt0", objOut: "rw14ave8u" }, { portIn: "Value", portOut: "value", objIn: "zpbecbb56", objOut: "rw14ave8u" }] }, { name: "finished", value: 1 }], objName: "Ops.Anim.BoolAnim" }, { id: "73bb2nz0u", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_hitBodyName" }], portsOut: [{ name: "Value", links: [{ portIn: "String", portOut: "Value", objIn: "vgzr81mxh", objOut: "73bb2nz0u" }] }], objName: "Ops.Vars.VarGetString" }, { id: "vgzr81mxh", uiAttribs: {}, portsOut: [{ name: "Result", links: [{ portIn: "bool", portOut: "Result", objIn: "rw14ave8u", objOut: "vgzr81mxh" }] }], objName: "Ops.String.StringLength_v2" }, { id: "n9u25c6ax", uiAttribs: {}, portsIn: [{ name: "posX", value: -0.51 }, { name: "posY", value: -0.26 }, { name: "posZ", value: 0 }, { name: "scale", value: 1 }, { name: "rotX", value: 0 }, { name: "rotY", value: 180 }, { name: "rotZ", value: 180 }], portsOut: [{ name: "trigger", links: [{ portIn: "exe", portOut: "trigger", objIn: "124910bf-e88f-4da5-847e-888a7ac73020", objOut: "n9u25c6ax" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "st6y5rwmi", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Speed", value: 0.025 }, { name: "Play", value: 1 }, { name: "Sync to timeline", value: 0 }], portsOut: [{ name: "Time", links: [{ portIn: "Value 1", portOut: "Time", objIn: "c0ib2t71q", objOut: "st6y5rwmi" }] }], objName: "Ops.Anim.Timer_v2" }, { id: "t1ryttgy8", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsOut: [{ name: "Next", links: [{ portIn: "Reset", portOut: "Next", objIn: "st6y5rwmi", objOut: "t1ryttgy8" }] }, { name: "Number", value: false }], objName: "Ops.Number.TriggerOnChangeNumber" }, { id: "c0ib2t71q", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Value 2", value: 0.02 }], portsOut: [{ name: "result", links: [{ portIn: "number1", portOut: "result", objIn: "gl8rvk911", objOut: "c0ib2t71q" }] }], objName: "Ops.Math.Min_v3" }, { id: "gl8rvk911", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "number2", value: -1 }], portsOut: [{ name: "result", links: [{ portIn: "Speed", portOut: "result", objIn: "b65ca0b8-40c9-4d0a-9e22-aba7d89f3abf", objOut: "gl8rvk911" }] }], objName: "Ops.Math.Multiply" }, { id: "csl3j7cy1", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "When False index", value: 0 }, { name: "When False", value: "keep last number" }], portsOut: [{ name: "Value Out", links: [{ portIn: "out0 DeltaSum Absolute Value", portOut: "Value Out", objIn: "7bebb5f0-9d69-43ee-98be-27a13edd98db", objOut: "csl3j7cy1" }] }], objName: "Ops.Number.GateNumber" }, { id: "na2pda15t", uiAttribs: { subPatch: "66dae55a-8297-4120-81e2-d946cc6b2b60" }, portsIn: [{ name: "Separate inc/dec", value: 0 }, { name: "Value", value: 0 }, { name: "Inc factor", value: 4, title: "Inc/Dec factor" }, { name: "Dec factor", value: 4 }], portsOut: [{ name: "Result", links: [{ portIn: "Custom Value", portOut: "Result", objIn: "csl3j7cy1", objOut: "na2pda15t" }] }], objName: "Ops.Anim.Smooth" }, { id: "ge3zj70cy", uiAttribs: {}, portsIn: [{ name: "x", value: -0.83 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Trigger", portOut: "trigger", objIn: "jrkdakvqd", objOut: "ge3zj70cy" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "jrkdakvqd", uiAttribs: {}, portsIn: [{ name: "Shape index", value: 1 }, { name: "Shape", value: "BoxAA" }, { name: "Name", value: "dial.1" }, { name: "Radius", value: 0.25 }, { name: "Size X", value: 0.55 }, { name: "Size Y", value: 1 }, { name: "Size Z", value: 0 }, { name: "Positions" }, { name: "Append Index to name", value: 1 }], objName: "Ops.Graphics.Intersection.IntersectBody" }, { id: "lb4ss1de9", uiAttribs: {}, portsIn: [{ name: "mul", value: -0.92 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "2p7s5nsc9", objOut: "lb4ss1de9" }] }], objName: "Ops.Gl.Matrix.TransformMul" }, { id: "9f43w7192", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_currentIndexInsideRepeat2D" }], portsOut: [{ name: "Value", links: [{ portIn: "number1", portOut: "Value", objIn: "6kwkmfn9z", objOut: "9f43w7192" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "6kwkmfn9z", uiAttribs: {}, portsIn: [{ name: "number2", value: 5 }], portsOut: [{ name: "result", links: [{ portIn: "x", portOut: "result", objIn: "j447574nb", objOut: "6kwkmfn9z" }] }], objName: "Ops.Math.Multiply" }, { id: "62fo5emt0", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__labelBoolAnim" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "3zhcjuyyj", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__labelBoolAnim" }], portsOut: [{ name: "Value", links: [{ portIn: "a", portOut: "Value", objIn: "uc9r4wu0r", objOut: "3zhcjuyyj" }, { portIn: "B", portOut: "Value", objIn: "v11enlha4", objOut: "3zhcjuyyj" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "zpbecbb56", uiAttribs: {}, portsIn: [{ name: "Delay", value: 0.5 }, { name: "Clear on Change", value: 0 }, { name: "easing index", value: 2 }, { name: "easing", value: "smoothstep" }], portsOut: [{ name: "Result", links: [{ portIn: "a", portOut: "Result", objIn: "kgtq6kbqp", objOut: "zpbecbb56" }] }], objName: "Ops.Number.DelayedNumber" }, { id: "v11enlha4", uiAttribs: {}, portsIn: [{ name: "C", value: 2 }, { name: "D", value: 3 }, { name: "Expression", value: "(a*0.15) * b" }], portsOut: [{ name: "Result", links: [{ portIn: "height", portOut: "Result", objIn: "2p7s5nsc9", objOut: "v11enlha4" }] }, { name: "Expression Valid", value: true }], objName: "Ops.Math.MathExpression" }, { id: "vw32ba4ay", uiAttribs: {}, portsIn: [{ name: "Maximum", value: 0.1 }], portsOut: [{ name: "result", links: [{ portIn: "Value", portOut: "result", objIn: "8dnvznngh", objOut: "vw32ba4ay" }] }], objName: "Ops.Math.Max" }, { id: "k1xasfekl", uiAttribs: {}, portsIn: [{ name: "Separate inc/dec", value: 0 }, { name: "Inc factor", value: 4, title: "Inc/Dec factor" }, { name: "Dec factor", value: 4 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "a1dx328je", objOut: "k1xasfekl" }] }, { name: "Array Out", links: [{ portIn: "array", portOut: "Array Out", objIn: "scp4776vv", objOut: "k1xasfekl" }, { portIn: "array", portOut: "Array Out", objIn: "ffpua72y1", objOut: "k1xasfekl" }, { portIn: "array", portOut: "Array Out", objIn: "0yopgevxd", objOut: "k1xasfekl" }, { portIn: "array", portOut: "Array Out", objIn: "jj4a1wi34", objOut: "k1xasfekl" }] }], objName: "Ops.User.cristianvogel.LofiSmoothArray" }, { id: "98iul8y9a", uiAttribs: {}, portsIn: [{ name: "Maximum", value: 5e-3 }], portsOut: [{ name: "result", links: [{ portIn: "Value", portOut: "result", objIn: "iwrkcxo1s", objOut: "98iul8y9a" }] }], objName: "Ops.Math.Max" }, { id: "8dnvznngh", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_size" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "ok235i5ag", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_mix" }], portsOut: [{ name: "Value", links: [{ portIn: "number", portOut: "Value", objIn: "nf37ruj15", objOut: "ok235i5ag" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "6xynvbmkd", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_mix" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "hlukndsg2", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_tone" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "iwrkcxo1s", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_diffusion" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "6htv77yjw", uiAttribs: {}, portsIn: [{ name: "Title", value: "Warping" }], objName: "Ops.Ui.Area" }, { id: "scp4776vv", uiAttribs: {}, portsIn: [{ name: "index", value: 0 }, { name: "Value Invalid Index", value: 0 }], portsOut: [{ name: "value", links: [{ portIn: "Value", portOut: "value", objIn: "6xynvbmkd", objOut: "scp4776vv" }] }, { name: "Valid Index", value: 1 }], objName: "Ops.Array.ArrayGetNumber" }, { id: "ffpua72y1", uiAttribs: {}, portsIn: [{ name: "index", value: 3 }, { name: "Value Invalid Index", value: 0 }], portsOut: [{ name: "value", links: [{ portIn: "value", portOut: "value", objIn: "vw32ba4ay", objOut: "ffpua72y1" }] }, { name: "Valid Index", value: 1 }], objName: "Ops.Array.ArrayGetNumber" }, { id: "0yopgevxd", uiAttribs: {}, portsIn: [{ name: "index", value: 2 }, { name: "Value Invalid Index", value: 0 }], portsOut: [{ name: "value", links: [{ portIn: "Value", portOut: "value", objIn: "hlukndsg2", objOut: "0yopgevxd" }] }, { name: "Valid Index", value: 1 }], objName: "Ops.Array.ArrayGetNumber" }, { id: "jj4a1wi34", uiAttribs: {}, portsIn: [{ name: "index", value: 1 }, { name: "Value Invalid Index", value: 0 }], portsOut: [{ name: "value", links: [{ portIn: "value", portOut: "value", objIn: "98iul8y9a", objOut: "jj4a1wi34" }] }, { name: "Valid Index", value: 1 }], objName: "Ops.Array.ArrayGetNumber" }, { id: "34zmy4a4l", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "mainExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "Execute", portOut: "Triggered", objIn: "k1xasfekl", objOut: "34zmy4a4l" }, { portIn: "Render", portOut: "Triggered", objIn: "51ldwg650", objOut: "34zmy4a4l" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "g8s0zafv1", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_dialValues_array" }], portsOut: [{ name: "Value", links: [{ portIn: "Array In", portOut: "Value", objIn: "k1xasfekl", objOut: "g8s0zafv1" }] }], objName: "Ops.Vars.VarGetArray_v2" }, { id: "lxdfer2oi", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__lensFlareTexts" }], objName: "Ops.Vars.VarGetTexture_v2" }, { id: "qgzxy88cq", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "exeNoCamera" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "z979y6li5", objOut: "qgzxy88cq" }, { portIn: "render", portOut: "Triggered", objIn: "p3udn0kt2", objOut: "qgzxy88cq" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "uya80wz6f", uiAttribs: {}, portsIn: [{ name: "x", value: 2.55 }, { name: "y", value: 0.62 }, { name: "z", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "blls2amps", portOut: "trigger", objIn: "5jrf5b006", objOut: "uya80wz6f" }] }], objName: "Ops.Gl.Matrix.ScaleXYZViewMatrix" }, { id: "z979y6li5", uiAttribs: {}, portsIn: [{ name: "x", value: 0 }, { name: "y", value: -1.63 }, { name: "z", value: 0.02 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "uya80wz6f", objOut: "z979y6li5" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "e2dgivql3", uiAttribs: {}, portsIn: [{ name: "value", value: "slider_scapeLength" }], portsOut: [{ name: "String", links: [{ portIn: "btagbs7z2", portOut: "String", objIn: "5jrf5b006", objOut: "e2dgivql3" }] }], objName: "Ops.String.String_v2" }, { id: "lsscrp8mo", uiAttribs: {}, portsIn: [{ name: "Font", value: "chivo" }, { name: "Scale", value: 0.12 }, { name: "Letter Spacing", value: -0.02 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 1 }, { name: "Align", value: "Center" }, { name: "Vertical Align index", value: 2 }, { name: "Vertical Align", value: "Middle" }, { name: "r", value: 0.75 }, { name: "g", value: 0.75 }, { name: "b", value: 0.75 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.108 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.222 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 0 }, { name: "Border g", value: 0 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 0 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Rotations", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Num Lines", value: 1 }, { name: "Width", value: 0.17356875 }, { name: "Height", value: 0.06918352272727271 }, { name: "Start Y", value: 0.027042897727272718 }, { name: "Num Chars", value: 6 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "vh92hy3y9", uiAttribs: {}, portsIn: [{ name: "y", value: -0.94 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "lsscrp8mo", objOut: "vh92hy3y9" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "1kt28jybk", uiAttribs: {}, portsIn: [{ name: "Repeats", value: 4 }, { name: "Direction index", value: 0 }, { name: "Direction", value: "Forward" }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "vh92hy3y9", objOut: "1kt28jybk" }] }, { name: "index", links: [{ portIn: "number1", portOut: "index", objIn: "x156qdz90", objOut: "1kt28jybk" }, { portIn: "Index", portOut: "index", objIn: "pu033f5xy", objOut: "1kt28jybk" }] }], objName: "Ops.Trigger.Repeat_v2" }, { id: "x156qdz90", uiAttribs: {}, portsIn: [{ name: "number2", value: 0.8 }], portsOut: [{ name: "result", links: [{ portIn: "x", portOut: "result", objIn: "vh92hy3y9", objOut: "x156qdz90" }] }], objName: "Ops.Math.Multiply" }, { id: "p3udn0kt2", uiAttribs: {}, portsIn: [{ name: "x", value: -1.2 }, { name: "y", value: 0.03 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Execute", portOut: "trigger", objIn: "1kt28jybk", objOut: "p3udn0kt2" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "3ph9rgnw8", uiAttribs: {}, portsIn: [{ name: "Title", value: "scape length" }], objName: "Ops.Ui.Area" }, { id: "pu033f5xy", uiAttribs: {}, portsIn: [{ name: "String 0", value: "room" }, { name: "String 1", value: "plate" }, { name: "String 2", value: "tanglewood" }, { name: "String 3", value: "europa" }, { name: "String 4", value: "" }, { name: "String 5", value: "" }, { name: "String 6", value: "" }, { name: "String 7", value: "" }, { name: "String 8", value: "" }, { name: "String 9", value: "" }], portsOut: [{ name: "Result", links: [{ portIn: "Text", portOut: "Result", objIn: "lsscrp8mo", objOut: "pu033f5xy" }] }], objName: "Ops.String.SwitchString" }, { id: "kvx1qrhxt", uiAttribs: {}, portsIn: [{ name: "number2", value: 0.33 }], portsOut: [{ name: "result", links: [{ portIn: "a", portOut: "result", objIn: "lsscrp8mo", objOut: "kvx1qrhxt" }] }], objName: "Ops.Math.Sum" }, { id: "p4a68w5bu", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "exeNoCamera" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "twry568y4", objOut: "p4a68w5bu" }, { portIn: "render", portOut: "Triggered", objIn: "nzkzp15a9", objOut: "p4a68w5bu" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "ku7u5pd7o", uiAttribs: {}, portsIn: [{ name: "x", value: 2.55 }, { name: "y", value: 0.51 }, { name: "z", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "blls2amps", portOut: "trigger", objIn: "827hbx7y7", objOut: "ku7u5pd7o" }] }], objName: "Ops.Gl.Matrix.ScaleXYZViewMatrix" }, { id: "twry568y4", uiAttribs: {}, portsIn: [{ name: "x", value: 0 }, { name: "y", value: -1.56 }, { name: "z", value: 0.02 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "ku7u5pd7o", objOut: "twry568y4" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "2ccc5csp8", uiAttribs: {}, portsIn: [{ name: "value", value: "slider_scapeLevel" }], portsOut: [{ name: "String", links: [{ portIn: "btagbs7z2", portOut: "String", objIn: "827hbx7y7", objOut: "2ccc5csp8" }] }], objName: "Ops.String.String_v2" }, { id: "nptv5gu82", uiAttribs: {}, portsIn: [{ name: "Text", value: "*Scape" }, { name: "Font", value: "chivo" }, { name: "Scale", value: 0.24 }, { name: "Letter Spacing", value: -0.02 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 2 }, { name: "Align", value: "Right" }, { name: "Vertical Align index", value: 2 }, { name: "Vertical Align", value: "Middle" }, { name: "r", value: 0.75 }, { name: "g", value: 0.75 }, { name: "b", value: 0.75 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.085 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.222 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 0 }, { name: "Border g", value: 0 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 0 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Rotations", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Num Lines", value: 1 }, { name: "Width", value: 0.341925 }, { name: "Height", value: 0.15647954545454545 }, { name: "Start Y", value: 0.08125454545454545 }, { name: "Num Chars", value: 6 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "t6jogaz9t", uiAttribs: {}, portsIn: [{ name: "Title", value: "scape mix" }], objName: "Ops.Ui.Area" }, { id: "xagcljatm", uiAttribs: {}, portsIn: [{ name: "number2", value: 0.4 }], portsOut: [{ name: "result", links: [{ portIn: "a", portOut: "result", objIn: "nptv5gu82", objOut: "xagcljatm" }, { portIn: "value", portOut: "result", objIn: "qkhcjgu05", objOut: "xagcljatm" }] }], objName: "Ops.Math.Sum" }, { id: "nzkzp15a9", uiAttribs: {}, portsIn: [{ name: "x", value: -1.58 }, { name: "y", value: -0.68 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "nptv5gu82", objOut: "nzkzp15a9" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "l0tg11bqe", uiAttribs: {}, portsIn: [{ name: "width", value: 10 }, { name: "height", value: 0.49 }, { name: "Logarithmic", value: 1 }, { name: "pivot x index", value: 0 }, { name: "pivot x", value: "center" }, { name: "pivot y index", value: 0 }, { name: "pivot y", value: "center" }, { name: "num columns", value: 8 }, { name: "num rows", value: 12 }, { name: "axis index", value: 0 }, { name: "axis", value: "xy" }], portsOut: [{ name: "Point Arrays", links: [{ portIn: "Points", portOut: "Point Arrays", objIn: "bjn0972ht", objOut: "l0tg11bqe" }] }], objName: "Ops.Gl.Meshes.LinesArray" }, { id: "bjn0972ht", uiAttribs: {}, portsIn: [{ name: "Tesselate Edges", value: 0 }, { name: "Render Mesh", value: 1 }], objName: "Ops.Gl.Meshes.SplineMesh_v2" }, { id: "yte4ra0uu", uiAttribs: {}, portsIn: [{ name: "Width", value: 1.03 }, { name: "Width Perspective", value: 0 }, { name: "Mapping index", value: 1 }, { name: "Mapping", value: "Face" }, { name: "Colorize Texture", value: 0 }, { name: "Offset", value: 0 }, { name: "r", value: 0.179 }, { name: "g", value: 1 }, { name: "b", value: 0.692 }], portsOut: [{ name: "Trigger", links: [{ portIn: "render", portOut: "Trigger", objIn: "kom6mxww1", objOut: "yte4ra0uu" }] }], objName: "Ops.Gl.Meshes.SplineMeshMaterial_v2" }, { id: "ertlqmhh5", uiAttribs: {}, portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "l0tg11bqe", objOut: "ertlqmhh5" }] }, { name: "Was Triggered", value: 1 }], objName: "Ops.Trigger.TriggerOnce" }, { id: "kom6mxww1", uiAttribs: {}, portsIn: [{ name: "posX", value: 0 }, { name: "posY", value: -0.75 }, { name: "posZ", value: 0.45 }, { name: "scale", value: 1 }, { name: "rotX", value: 180 }, { name: "rotY", value: 0 }, { name: "rotZ", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "bjn0972ht", objOut: "kom6mxww1" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "9li4kwtsh", uiAttribs: {}, portsIn: [{ name: "number1", value: 1 }, { name: "number2", value: 0.2 }], portsOut: [{ name: "result", links: [{ portIn: "a", portOut: "result", objIn: "yte4ra0uu", objOut: "9li4kwtsh" }] }], objName: "Ops.Math.Multiply" }, { id: "99du8h3y9", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "preSequenceFlow" }], portsOut: [{ name: "Triggered", links: [{ portIn: "Render", portOut: "Triggered", objIn: "yte4ra0uu", objOut: "99du8h3y9" }, { portIn: "Exec", portOut: "Triggered", objIn: "ertlqmhh5", objOut: "99du8h3y9" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "0oj6cpo44", uiAttribs: {}, portsIn: [{ name: "Title", value: "LInes" }], objName: "Ops.Ui.Area" }, { id: "0aj10qlpy", uiAttribs: {}, portsIn: [{ name: "Width", value: 0.35 }, { name: "Height", value: 0.3 }, { name: "ID", value: "" }, { name: "Class", value: "" }, { name: "Pivot x index", value: 0 }, { name: "Pivot x", value: "center" }, { name: "Pivot y index", value: 0 }, { name: "Pivot y", value: "center" }, { name: "Axis index", value: 0 }, { name: "Axis", value: "xy" }, { name: "Is Interactive", value: 1 }, { name: "Render Rectangle", value: 0 }, { name: "Show Boundings", value: 0 }, { name: "Cursor index", value: 2 }, { name: "Cursor", value: "pointer" }, { name: "Render", value: 1, title: "Active" }], portsOut: [{ name: "Trigger out", links: [{ portIn: "exe", portOut: "Trigger out", objIn: "txw282mz1", objOut: "0aj10qlpy" }] }, { name: "Pointer Hover", links: [{ portIn: "bool", portOut: "Pointer Hover", objIn: "txw282mz1", objOut: "0aj10qlpy" }, { portIn: "Value", portOut: "Pointer Hover", objIn: "xlw1du0hx", objOut: "0aj10qlpy" }] }, { name: "Pointer Down", links: [{ portIn: "Value", portOut: "Pointer Down", objIn: "kkiqqacrp", objOut: "0aj10qlpy" }] }, { name: "Pointer X", value: 0.4350305544289238 }, { name: "Pointer Y", value: 0.6499753072201939 }, { name: "Top", value: 691.6479304432869 }, { name: "Left", value: 15.244142353534698 }, { name: "Right", value: 148.56811100244522 }, { name: "Bottom", value: 805.9255823493004 }], objName: "Ops.Gl.InteractiveRectangle_v2" }, { id: "skw3mtb13", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "exeNoCamera" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "0tooxrj1w", objOut: "skw3mtb13" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "0tooxrj1w", uiAttribs: {}, portsIn: [{ name: "x", value: -1.83 }, { name: "y", value: -0.85 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Trigger in", portOut: "trigger", objIn: "0aj10qlpy", objOut: "0tooxrj1w" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "8jcmfxmos", uiAttribs: {}, portsIn: [{ name: "File", value: "assets/6697c3b245eb5d333bae2007_NEL_SRVB.webp", display: "file" }, { name: "Filter index", value: 2 }, { name: "Filter", value: "mipmap" }, { name: "Wrap index", value: 0 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 3 }, { name: "Anisotropic", value: "4" }, { name: "Data Format index", value: 3 }, { name: "Data Format", value: "RGBA" }, { name: "Flip", value: 0 }, { name: "Pre Multiplied Alpha", value: 0 }, { name: "Active", value: 1 }, { name: "Save Memory", value: 1 }, { name: "Add Cachebuster", value: 0 }], portsOut: [{ name: "Texture", links: [{ portIn: "texture", portOut: "Texture", objIn: "alnrfm1xt", objOut: "8jcmfxmos" }, { portIn: "Value", portOut: "Texture", objIn: "n6i2w7q6s", objOut: "8jcmfxmos" }] }, { name: "Width", value: 256 }, { name: "Height", value: 256 }, { name: "Aspect Ratio", value: 1 }, { name: "Loaded", value: 1 }, { name: "Loading", value: 0 }], objName: "Ops.Gl.Texture_v2" }, { id: "cnlt8pfqr", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "exeNoCamera" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "k9oj9uhcw", objOut: "cnlt8pfqr" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "k9oj9uhcw", uiAttribs: {}, portsIn: [{ name: "x", value: -2.68 }, { name: "y", value: -1.29 }, { name: "z", value: -1 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "alnrfm1xt", objOut: "k9oj9uhcw" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "alnrfm1xt", uiAttribs: {}, portsIn: [{ name: "r", value: 0.9084857245945317 }, { name: "g", value: 0.10570856602655021 }, { name: "b", value: 0.6349807163120653 }, { name: "a", value: 1 }, { name: "colorizeTexture", value: 0 }, { name: "Vertex Colors", value: 0 }, { name: "Alpha Mask Source index", value: 0 }, { name: "Alpha Mask Source", value: "Luminance" }, { name: "Opacity TexCoords Transform", value: 0 }, { name: "Discard Transparent Pixels", value: 1 }, { name: "diffuseRepeatX", value: 1 }, { name: "diffuseRepeatY", value: 1 }, { name: "Tex Offset X", value: 1 }, { name: "Tex Offset Y", value: 1 }, { name: "Crop TexCoords", value: 0 }, { name: "billboard", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "update", portOut: "trigger", objIn: "zte2jkdci", objOut: "alnrfm1xt" }] }], objName: "Ops.Gl.Shader.BasicMaterial_v3" }, { id: "txw282mz1", uiAttribs: {}, portsIn: [{ name: "easing index", value: 9 }, { name: "easing", value: "Expo In Out" }, { name: "duration", value: 0.25 }, { name: "Direction index", value: 0 }, { name: "Direction", value: "Both" }, { name: "value false", value: 0.79 }, { name: "value true", value: -1 }], portsOut: [{ name: "trigger", links: [{ portIn: "Execute", portOut: "trigger", objIn: "u2xal6b27", objOut: "txw282mz1" }] }, { name: "value", links: [{ portIn: "innerRadius", portOut: "value", objIn: "1u49ak691", objOut: "txw282mz1" }] }, { name: "finished", links: [{ portIn: "Boolean", portOut: "finished", objIn: "m56qbr4ki", objOut: "txw282mz1" }] }], objName: "Ops.Anim.BoolAnim" }, { id: "1u49ak691", uiAttribs: {}, portsIn: [{ name: "radius", value: 0.5 }, { name: "segments", value: 3 }, { name: "percent", value: 1 }, { name: "steps", value: 0 }, { name: "invertSteps", value: 1 }, { name: "mapping index", value: 1 }, { name: "mapping", value: "round" }, { name: "Spline", value: 0 }, { name: "Draw", value: 0, title: "Render mesh" }], portsOut: [{ name: "geometry", links: [{ portIn: "Geometry", portOut: "geometry", objIn: "ee0okj3wi", objOut: "1u49ak691" }] }], objName: "Ops.Gl.Meshes.Circle_v3" }, { id: "kkiqqacrp", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeDirection" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "f4t828wlp", uiAttribs: {}, portsIn: [{ name: "Title", value: "rev" }], objName: "Ops.Ui.Area" }, { id: "6lh7g16he", uiAttribs: {}, portsIn: [{ name: "Value 0", value: 0.52 }, { name: "Value 1", value: -0.53 }], portsOut: [{ name: "Out Value", links: [{ portIn: "Speed", portOut: "Out Value", objIn: "40fnzsucx", objOut: "6lh7g16he" }] }], objName: "Ops.Boolean.BoolToNumber_v2" }, { id: "6fb2f0244", uiAttribs: {}, portsIn: [{ name: "Passes", value: 1 }, { name: "Clamp", value: 0 }, { name: "direction index", value: 0 }, { name: "direction", value: "both" }, { name: "Mask Invert", value: 0 }], objName: "Ops.Gl.ImageCompose.FastBlur_v2" }, { id: "iw9wg4r88", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_finalTextOut" }], objName: "Ops.Vars.VarGetTexture_v2" }, { id: "k2von2tr1", uiAttribs: {}, portsIn: [{ name: "Title", value: "reverse" }], objName: "Ops.Ui.Area" }, { id: "cr8zmkk1u", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeLength" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "bwbixjrcv", uiAttribs: {}, portsIn: [{ name: "B", value: 1 }, { name: "C", value: 2 }, { name: "D", value: 3 }, { name: "Expression", value: "a + 0.5" }], portsOut: [{ name: "Result", links: [{ portIn: "Value", portOut: "Result", objIn: "cr8zmkk1u", objOut: "bwbixjrcv" }] }, { name: "Expression Valid", value: true }], objName: "Ops.Math.MathExpression" }, { id: "8s8geqgwx", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeLevel" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "6e04u3uk4", uiAttribs: {}, portsIn: [{ name: "B", value: 1 }, { name: "C", value: 2 }, { name: "D", value: 3 }, { name: "Expression", value: "a + 0.5" }], portsOut: [{ name: "Result", links: [{ portIn: "Value", portOut: "Result", objIn: "8s8geqgwx", objOut: "6e04u3uk4" }] }, { name: "Expression Valid", value: true }], objName: "Ops.Math.MathExpression" }, { id: "z3hsmrlsw", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_size" }], portsOut: [{ name: "Value", links: [{ portIn: "Percentage", portOut: "Value", objIn: "o5rkdhq2k", objOut: "z3hsmrlsw" }, { portIn: "Percentage", portOut: "Value", objIn: "4jk31qlcv", objOut: "z3hsmrlsw" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "o5rkdhq2k", uiAttribs: {}, portsIn: [{ name: "Value 1", value: 9 }, { name: "Value 2", value: 24 }], portsOut: [{ name: "Result", links: [{ portIn: "rows", portOut: "Result", objIn: "eb7wv37c6", objOut: "o5rkdhq2k" }] }], objName: "Ops.Math.Interpolate" }, { id: "4jk31qlcv", uiAttribs: {}, portsIn: [{ name: "Value 1", value: 1 }, { name: "Value 2", value: 2.6 }], portsOut: [{ name: "Result", links: [{ portIn: "z", portOut: "Result", objIn: "o4q65sx2h", objOut: "4jk31qlcv" }] }], objName: "Ops.Math.Interpolate" }, { id: "hr05yjyy0", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__heightMapGeometry" }], objName: "Ops.Vars.VarSetObject_v2" }, { id: "w2fqrmovh", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeLength" }], portsOut: [{ name: "Value", links: [{ portIn: "Percentage", portOut: "Value", objIn: "69bvpidqa", objOut: "w2fqrmovh" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "69bvpidqa", uiAttribs: {}, portsIn: [{ name: "Value 1", value: 16 }, { name: "Value 2", value: 512 }], portsOut: [{ name: "Result", links: [{ portIn: "Number", portOut: "Result", objIn: "7pg8sq01l", objOut: "69bvpidqa" }] }], objName: "Ops.Math.Interpolate" }, { id: "7pg8sq01l", uiAttribs: {}, portsOut: [{ name: "Result", links: [{ portIn: "texture width", portOut: "Result", objIn: "v2qv1ozh2", objOut: "7pg8sq01l" }] }], objName: "Ops.Math.Ceil" }, { id: "3so3f33cf", uiAttribs: {}, portsIn: [{ name: "Diffuse R", value: 0.21561448295683894 }, { name: "Diffuse G", value: 1 }, { name: "Diffuse B", value: 0.666 }, { name: "Diffuse A", value: 1 }, { name: "Double Sided", value: 0 }, { name: "Colorize Texture", value: 0 }], portsOut: [{ name: "next", links: [{ portIn: "render", portOut: "next", objIn: "oba4wt0jq", objOut: "3so3f33cf" }] }], objName: "Ops.Gl.Phong.LambertMaterial_v2" }, { id: "65mpod5qd", uiAttribs: {}, portsIn: [{ name: "value", value: -0.15 }], portsOut: [{ name: "result", links: [{ portIn: "y", portOut: "result", objIn: "aupoduf7d", objOut: "65mpod5qd" }, { portIn: "y", portOut: "result", objIn: "7qikt1vaf", objOut: "65mpod5qd" }, { portIn: "y", portOut: "result", objIn: "mbk4m8pcr", objOut: "65mpod5qd" }, { portIn: "y", portOut: "result", objIn: "ge3zj70cy", objOut: "65mpod5qd" }] }], objName: "Ops.Number.Number" }, { id: "ee0okj3wi", uiAttribs: {}, portsIn: [{ name: "Translate X", value: 0 }, { name: "Translate Y", value: 0.03 }, { name: "Translate Z", value: 0 }, { name: "Rotation X", value: 0 }, { name: "Rotation Z", value: 0 }], portsOut: [{ name: "Result", links: [{ portIn: "Geometry", portOut: "Result", objIn: "iaywmhxb7", objOut: "ee0okj3wi" }] }], objName: "Ops.Graphics.Geometry.TransformGeometry" }, { id: "iaywmhxb7", uiAttribs: {}, portsIn: [{ name: "Render Mesh", value: 1 }, { name: "Add Vertex Numbers", value: 1 }], objName: "Ops.Gl.RenderGeometry_v2" }, { id: "u2xal6b27", uiAttribs: {}, portsOut: [{ name: "Trigger out", links: [{ portIn: "render", portOut: "Trigger out", objIn: "1u49ak691", objOut: "u2xal6b27" }] }], objName: "Ops.Trigger.GateTrigger" }, { id: "m56qbr4ki", uiAttribs: {}, portsOut: [{ name: "Result", links: [{ portIn: "bool 1", portOut: "Result", objIn: "2td6endox", objOut: "m56qbr4ki" }] }], objName: "Ops.Boolean.Not" }, { id: "zy3ewhgid", uiAttribs: {}, portsIn: [{ name: "easing index", value: 8 }, { name: "easing", value: "Expo Out" }, { name: "duration", value: 2 }, { name: "Direction index", value: 0 }, { name: "Direction", value: "Both" }, { name: "value false", value: 0 }, { name: "value true", value: 180 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "iaywmhxb7", objOut: "zy3ewhgid" }] }, { name: "value", links: [{ portIn: "Rotation Y", portOut: "value", objIn: "ee0okj3wi", objOut: "zy3ewhgid" }] }, { name: "finished", value: 1 }], objName: "Ops.Anim.BoolAnim" }, { id: "14rplnqfv", uiAttribs: {}, portsIn: [{ name: "value", value: 0.3 }], portsOut: [{ name: "result", links: [{ portIn: "Scale X", portOut: "result", objIn: "ee0okj3wi", objOut: "14rplnqfv" }, { portIn: "Scale Y", portOut: "result", objIn: "ee0okj3wi", objOut: "14rplnqfv" }, { portIn: "Scale Z", portOut: "result", objIn: "ee0okj3wi", objOut: "14rplnqfv" }] }], objName: "Ops.Number.Number" }, { id: "xlw1du0hx", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__directionHover" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "zte2jkdci", uiAttribs: {}, portsIn: [{ name: "Duration", value: 0.1 }, { name: "Invert", value: 0 }], portsOut: [{ name: "Trigger Out", links: [{ portIn: "exe", portOut: "Trigger Out", objIn: "zy3ewhgid", objOut: "zte2jkdci" }] }, { name: "Value", links: [{ portIn: "bool 2", portOut: "Value", objIn: "2td6endox", objOut: "zte2jkdci" }] }], objName: "Ops.Anim.Bang" }, { id: "2td6endox", uiAttribs: {}, portsIn: [{ name: "bool 3", value: 0 }, { name: "bool 4", value: 0 }, { name: "bool 5", value: 0 }, { name: "bool 6", value: 0 }, { name: "bool 7", value: 0 }, { name: "bool 8", value: 0 }, { name: "bool 9", value: 0 }, { name: "bool 10", value: 0 }], portsOut: [{ name: "result", links: [{ portIn: "Pass Through", portOut: "result", objIn: "u2xal6b27", objOut: "2td6endox" }] }], objName: "Ops.Boolean.Or" }, { id: "3cv6rdwm5", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "mainExe" }], portsOut: [{ name: "Triggered", links: [{ portIn: "Exec", portOut: "Triggered", objIn: "litlcklxl", objOut: "3cv6rdwm5" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "litlcklxl", uiAttribs: {}, portsOut: [{ name: "Next", links: [{ portIn: "Bang", portOut: "Next", objIn: "zte2jkdci", objOut: "litlcklxl" }] }, { name: "Was Triggered", value: 1 }], objName: "Ops.Trigger.TriggerOnce" }, { id: "5jrf5b006", uiAttribs: {}, storage: { blueprintVer: 2, subPatchVer: 2 }, portsIn: [{ name: "blls2amps", title: "Trigger in" }, { name: "btagbs7z2", title: "Class" }, { name: "lj06d561p", value: 0, title: "Show Boundings" }, { name: "patchId", value: "bp2sub_5jrf5b006" }], portsOut: [{ name: "nti406vwi", title: "Result", links: [{ portIn: "A", portOut: "nti406vwi", objIn: "bwbixjrcv", objOut: "5jrf5b006" }] }, { name: "gjvx0zyv5", title: "value", links: [{ portIn: "number1", portOut: "gjvx0zyv5", objIn: "kvx1qrhxt", objOut: "5jrf5b006" }] }], objName: "Ops.Patch.PmhkN4m.BasicSlider_v2" }, { id: "827hbx7y7", uiAttribs: {}, storage: { blueprintVer: 2, subPatchVer: 2 }, portsIn: [{ name: "blls2amps", title: "Trigger in" }, { name: "btagbs7z2", title: "Class" }, { name: "lj06d561p", value: 0, title: "Show Boundings" }, { name: "patchId", value: "bp2sub_827hbx7y7" }], portsOut: [{ name: "nti406vwi", title: "Result", links: [{ portIn: "A", portOut: "nti406vwi", objIn: "6e04u3uk4", objOut: "827hbx7y7" }] }, { name: "gjvx0zyv5", title: "value", links: [{ portIn: "number1", portOut: "gjvx0zyv5", objIn: "xagcljatm", objOut: "827hbx7y7" }] }], objName: "Ops.Patch.PmhkN4m.BasicSlider_v1" }, { id: "hvxfadyo3", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "exeNoCamera" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "vr3j7sk4c", objOut: "hvxfadyo3" }, { portIn: "render", portOut: "Triggered", objIn: "zcqvrg63v", objOut: "hvxfadyo3" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "vr3j7sk4c", uiAttribs: {}, portsIn: [{ name: "posX", value: 0.98 }, { name: "posY", value: 0.89 }, { name: "posZ", value: 0 }, { name: "scale", value: 0.71 }, { name: "rotX", value: 0 }, { name: "rotY", value: 0 }, { name: "rotZ", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Exec", portOut: "trigger", objIn: "r9i8nkt5v", objOut: "vr3j7sk4c" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "kbcni5wpf", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__buttonShader" }], objName: "Ops.Vars.VarSetObject_v2" }, { id: "n6i2w7q6s", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__buttonMat" }], objName: "Ops.Vars.VarSetTexture_v2" }, { id: "akq5o2oet", uiAttribs: {}, portsIn: [{ name: "Text", value: "* structure" }, { name: "Font", value: "chivo" }, { name: "Scale", value: 0.14 }, { name: "Letter Spacing", value: 0 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 0 }, { name: "Align", value: "Left" }, { name: "Vertical Align index", value: 1 }, { name: "Vertical Align", value: "Top" }, { name: "r", value: 0.75 }, { name: "g", value: 0.75 }, { name: "b", value: 0.75 }, { name: "a", value: 1 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.048 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.5 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 1 }, { name: "Border g", value: 1 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 1 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Rotations", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "utt0283xl", objOut: "akq5o2oet" }] }, { name: "Num Lines", value: 1 }, { name: "Width", value: 0.3912562500000001 }, { name: "Height", value: 0.08395160984848485 }, { name: "Start Y", value: 0.04530710227272727 }, { name: "Num Chars", value: 11 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "r9i8nkt5v", uiAttribs: {}, portsOut: [{ name: "Next", links: [{ portIn: "Render", portOut: "Next", objIn: "akq5o2oet", objOut: "r9i8nkt5v" }] }], objName: "Ops.Gl.Matrix.Billboard" }, { id: "l01dmydzd", uiAttribs: {}, portsIn: [{ name: "Font", value: "chivo" }, { name: "Scale", value: 0.14 }, { name: "Letter Spacing", value: 0 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 0 }, { name: "Align", value: "Left" }, { name: "Vertical Align index", value: 1 }, { name: "Vertical Align", value: "Top" }, { name: "r", value: 0.75 }, { name: "g", value: 0.75 }, { name: "b", value: 0.75 }, { name: "a", value: 1 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.096 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.5 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 1 }, { name: "Border g", value: 1 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 1 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "d394u2tn6", objOut: "l01dmydzd" }] }, { name: "Num Lines", value: 1 }, { name: "Width", value: 0.257884375 }, { name: "Height", value: 0.08088910984848484 }, { name: "Start Y", value: 0.04346960227272727 }, { name: "Num Chars", value: 7 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "utt0283xl", uiAttribs: {}, portsIn: [{ name: "x", value: 0.43 }, { name: "y", value: 0 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "l01dmydzd", objOut: "utt0283xl" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "1murfi3uv", uiAttribs: {}, portsIn: [{ name: "Speed", value: 0.01 }, { name: "Play", value: 1 }, { name: "Sync to timeline", value: 0 }], portsOut: [{ name: "Time", value: 1.6572000000000047 }], objName: "Ops.Anim.Timer_v2" }, { id: "qt0hony1d", uiAttribs: {}, portsIn: [{ name: "Width", value: 0.56 }, { name: "Height", value: 0.12 }, { name: "ID", value: "" }, { name: "Class", value: "" }, { name: "Pivot x index", value: 0 }, { name: "Pivot x", value: "center" }, { name: "Pivot y index", value: 0 }, { name: "Pivot y", value: "center" }, { name: "Axis index", value: 0 }, { name: "Axis", value: "xy" }, { name: "Is Interactive", value: 1 }, { name: "Render Rectangle", value: 0 }, { name: "Show Boundings", value: 0 }, { name: "Cursor index", value: 2 }, { name: "Cursor", value: "pointer" }, { name: "Render", value: 1, title: "Active" }], portsOut: [{ name: "Trigger out", links: [{ portIn: "update", portOut: "Trigger out", objIn: "zarq8c2tv", objOut: "qt0hony1d" }, { portIn: "exe", portOut: "Trigger out", objIn: "b4bc3876u", objOut: "qt0hony1d" }] }, { name: "Pointer Hover", links: [{ portIn: "bool", portOut: "Pointer Hover", objIn: "b4bc3876u", objOut: "qt0hony1d" }] }, { name: "Pointer Down", value: 0 }, { name: "Pointer X", value: 0.5719152930241806 }, { name: "Pointer Y", value: 0.8687408274963967 }, { name: "Top", value: 63.12069296836853 }, { name: "Left", value: 1186.5903786420822 }, { name: "Right", value: 1399.9086820483208 }, { name: "Bottom", value: 108.83178412914276 }, { name: "Left Click", links: [{ portIn: "Bang", portOut: "Left Click", objIn: "zarq8c2tv", objOut: "qt0hony1d" }, { portIn: "trigger in", portOut: "Left Click", objIn: "giylicm3u", objOut: "qt0hony1d" }] }], objName: "Ops.Gl.InteractiveRectangle_v2" }, { id: "zcqvrg63v", uiAttribs: {}, portsIn: [{ name: "x", value: 1.35 }, { name: "y", value: 0.89 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Trigger in", portOut: "trigger", objIn: "qt0hony1d", objOut: "zcqvrg63v" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "zarq8c2tv", uiAttribs: {}, portsIn: [{ name: "Duration", value: 0.5 }, { name: "Invert", value: 0 }], portsOut: [{ name: "Value", links: [{ portIn: "Random Seed ", portOut: "Value", objIn: "dssq1axq2", objOut: "zarq8c2tv" }, { portIn: "number1", portOut: "Value", objIn: "tusq6xfh3", objOut: "zarq8c2tv" }] }], objName: "Ops.Anim.Bang" }, { id: "giylicm3u", uiAttribs: {}, portsIn: [{ name: "Loop min", value: 0 }, { name: "Loop max", value: 15 }], portsOut: [{ name: "current count", links: [{ portIn: "Value", portOut: "current count", objIn: "pnzzc7ulm", objOut: "giylicm3u" }] }], objName: "Ops.Trigger.TriggerCounterLoop" }, { id: "djbr6tym4", uiAttribs: {}, portsOut: [{ name: "result", links: [{ portIn: "Text", portOut: "result", objIn: "l01dmydzd", objOut: "djbr6tym4" }] }], objName: "Ops.Array.ArrayGetString" }, { id: "pnzzc7ulm", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_structure" }], objName: "Ops.Vars.VarSetNumber_v2" }, { id: "26j6rhozk", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_structure" }], portsOut: [{ name: "Value", links: [{ portIn: "index", portOut: "Value", objIn: "djbr6tym4", objOut: "26j6rhozk" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "iijz0ye9r", uiAttribs: {}, portsIn: [{ name: "text", value: "A035506\nA007604\nA227413\nA000040\nA052330\nA000607\nA01401\nA064356\nA096441\nA000009\nA199535\nA000010\nA316667\nA111133\nA000124\nA005132" }, { name: "separator", value: " " }, { name: "Numbers", value: 0 }, { name: "Trim", value: 1 }, { name: "Split Lines", value: 1 }], portsOut: [{ name: "array", links: [{ portIn: "array", portOut: "array", objIn: "djbr6tym4", objOut: "iijz0ye9r" }] }, { name: "length", value: 16 }], objName: "Ops.Array.StringToArray_v2" }, { id: "d394u2tn6", uiAttribs: {}, portsIn: [{ name: "x", value: 0.14 }, { name: "y", value: -0.04 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "hm7bbicrb", objOut: "d394u2tn6" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "b4bc3876u", uiAttribs: {}, portsIn: [{ name: "easing index", value: 0 }, { name: "easing", value: "linear" }, { name: "duration", value: 0.25 }, { name: "Direction index", value: 0 }, { name: "Direction", value: "Both" }, { name: "value false", value: 3e-3 }, { name: "value true", value: 0.01 }], portsOut: [{ name: "value", links: [{ portIn: "height", portOut: "value", objIn: "hm7bbicrb", objOut: "b4bc3876u" }] }, { name: "finished", value: 1 }], objName: "Ops.Anim.BoolAnim" }, { id: "hm7bbicrb", uiAttribs: {}, portsIn: [{ name: "render", title: "Trigger" }, { name: "Render Mesh", value: 1, title: "Render" }, { name: "width", value: 0.99 }, { name: "pivot x index", value: 1 }, { name: "pivot x", value: "center" }, { name: "pivot y index", value: 1 }, { name: "pivot y", value: "center" }, { name: "axis index", value: 0 }, { name: "axis", value: "xy" }, { name: "Flip TexCoord X", value: 0 }, { name: "Flip TexCoord Y", value: 1 }, { name: "num columns", value: 1 }, { name: "num rows", value: 1 }], objName: "Ops.Gl.Meshes.Rectangle_v4" }, { id: "dssq1axq2", uiAttribs: {}, portsIn: [{ name: "Num Values", value: 15 }, { name: "Mode index", value: 0 }, { name: "Mode", value: "A" }, { name: "Integer", value: 0 }, { name: "Last == First", value: 0 }, { name: "Min A", value: 0 }, { name: "Min B", value: -1 }, { name: "Max B", value: 1 }, { name: "Min C", value: -1 }, { name: "Max C", value: 1 }, { name: "Min D", value: -1 }, { name: "Max D", value: 1 }], portsOut: [{ name: "Array Out", links: [{ portIn: "Rotations", portOut: "Array Out", objIn: "l01dmydzd", objOut: "dssq1axq2" }] }, { name: "Chunks Amount", value: 15 }, { name: "Array length", value: 15 }], objName: "Ops.Array.RandomNumbersArray_v4" }, { id: "tusq6xfh3", uiAttribs: {}, portsIn: [{ name: "number2", value: 1e-4 }], portsOut: [{ name: "result", links: [{ portIn: "number1", portOut: "result", objIn: "q51297pyv", objOut: "tusq6xfh3" }] }], objName: "Ops.Math.Compare.GreaterThan" }, { id: "q51297pyv", uiAttribs: {}, portsIn: [{ name: "number2", value: 360 }], portsOut: [{ name: "result", links: [{ portIn: "Max A", portOut: "result", objIn: "dssq1axq2", objOut: "q51297pyv" }] }], objName: "Ops.Math.Multiply" }, { id: "fm66pbek9", uiAttribs: {}, portsIn: [{ name: "Title", value: "structure" }], objName: "Ops.Ui.Area" }, { id: "arhmrhidy", uiAttribs: {}, portsIn: [{ name: "Active", value: 1 }], portsOut: [{ name: "Next", links: [{ portIn: "Update", portOut: "Next", objIn: "9uhsdl04w", objOut: "arhmrhidy" }] }], objName: "Ops.Data.Compose.Array.CompArray" }, { id: "9uhsdl04w", uiAttribs: {}, portsIn: [{ name: "Array", value: 0 }], objName: "Ops.Data.Compose.Array.CompArrayPushArray" }, { id: "tisruac8h", uiAttribs: {}, portsOut: [{ name: "WebGl Version Short", value: 2 }, { name: "WebGl Version", links: [{ portIn: "String D", portOut: "WebGl Version", objIn: "r3pfs6ub1", objOut: "tisruac8h" }] }, { name: "GLSL Version", links: [{ portIn: "String A", portOut: "GLSL Version", objIn: "r3pfs6ub1", objOut: "tisruac8h" }] }, { name: "Max Frag uniforms", value: 1024 }, { name: "Max Vert uniforms", value: 1024 }, { name: "Max Texture Size", value: 16384 }, { name: "Max Texture Units", value: 16 }, { name: "Max Varying Vectors", value: 30 }, { name: "Max MSAA Samples", value: 8 }, { name: "Vendor", links: [{ portIn: "String B", portOut: "Vendor", objIn: "r3pfs6ub1", objOut: "tisruac8h" }] }, { name: "Renderer", links: [{ portIn: "String C", portOut: "Renderer", objIn: "r3pfs6ub1", objOut: "tisruac8h" }] }], objName: "Ops.Gl.GlInfo_v2" }, { id: "iz33ymh7n", uiAttribs: {}, portsIn: [{ name: "Id", value: "" }], objName: "Ops.Sidebar.SidebarText_v2" }, { id: "vhl5pctzs", uiAttribs: {}, portsIn: [{ name: "Visible", value: 1 }, { name: "Opacity", value: 1 }, { name: "Default Minimized", value: 1 }, { name: "Minimized Opacity", value: 0.5 }, { name: "Show undo button", value: 0 }, { name: "Show Minimize", value: 1 }, { name: "Title", value: "" }, { name: "Side", value: 0 }, { name: "Default CSS", value: 1 }], portsOut: [{ name: "childs", title: "Children", links: [{ portIn: "link", portOut: "childs", objIn: "iz33ymh7n", objOut: "vhl5pctzs" }, { portIn: "link", portOut: "childs", objIn: "3byjf86ub", objOut: "vhl5pctzs" }] }, { name: "Opfened", value: false, title: "Opened" }], objName: "Ops.Sidebar.Sidebar" }, { id: "r3pfs6ub1", uiAttribs: {}, portsIn: [{ name: "Format", value: "$a, $b $c $d fps: $e" }, { name: "String F", value: "" }], portsOut: [{ name: "Result", links: [{ portIn: "Text", portOut: "Result", objIn: "iz33ymh7n", objOut: "r3pfs6ub1" }] }], objName: "Ops.String.StringCompose_v3" }, { id: "3byjf86ub", uiAttribs: {}, portsIn: [{ name: "Width", value: 506 }, { name: "Round Corners", value: 10 }, { name: "Special Color", value: "#07f78c" }], objName: "Ops.Sidebar.SideBarStyle" }, { id: "5stzrl502", uiAttribs: {}, portsOut: [{ name: "FPS", links: [{ portIn: "Number", portOut: "FPS", objIn: "vzpandudz", objOut: "5stzrl502" }] }, { name: "MS", value: 5.27 }], objName: "Ops.Cables.FPS_v2" }, { id: "vzpandudz", uiAttribs: {}, portsIn: [{ name: "Decimal Places", value: 4 }], portsOut: [{ name: "Result", links: [{ portIn: "String E", portOut: "Result", objIn: "r3pfs6ub1", objOut: "vzpandudz" }] }], objName: "Ops.String.NumberToString_v2" }, { id: "nme067fl0", uiAttribs: {}, portsIn: [{ name: "number2", value: 90 }], portsOut: [{ name: "result", links: [{ portIn: "Rotate", portOut: "result", objIn: "1qwtcdiny", objOut: "nme067fl0" }] }], objName: "Ops.Math.Multiply" }, { id: "55gbye0uh", uiAttribs: {}, portsIn: [{ name: "number2", value: 4 }, { name: "pingpong", value: 0 }], portsOut: [{ name: "result", links: [{ portIn: "Waveform index", portOut: "result", objIn: "1qwtcdiny", objOut: "55gbye0uh" }] }], objName: "Ops.Math.Modulo" }, { id: "qfhia7ec3", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_structure" }], portsOut: [{ name: "Value", links: [{ portIn: "number1", portOut: "Value", objIn: "nme067fl0", objOut: "qfhia7ec3" }, { portIn: "number1", portOut: "Value", objIn: "55gbye0uh", objOut: "qfhia7ec3" }, { portIn: "Offset X", portOut: "Value", objIn: "1qwtcdiny", objOut: "qfhia7ec3" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "p8itm86lw", uiAttribs: {}, portsIn: [{ name: "posX", value: -1.71 }, { name: "posY", value: -0.56 }, { name: "posZ", value: 0 }, { name: "scale", value: 1.29 }, { name: "rotX", value: 0 }, { name: "rotY", value: 0 }, { name: "rotZ", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "djh55ojh2", objOut: "p8itm86lw" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "ud198sc5z", uiAttribs: {}, portsOut: [{ name: "Geometry Result", links: [{ portIn: "Geometry", portOut: "Geometry Result", objIn: "djh55ojh2", objOut: "ud198sc5z" }] }], objName: "Ops.Graphics.GeometryMergeSimple" }, { id: "djh55ojh2", uiAttribs: {}, portsIn: [{ name: "Render Mesh", value: 1 }, { name: "Add Vertex Numbers", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "di9yoxov9", objOut: "djh55ojh2" }, { portIn: "Render", portOut: "trigger", objIn: "eerqtlpnp", objOut: "djh55ojh2" }] }], objName: "Ops.Gl.RenderGeometry_v2" }, { id: "absd3d4hb", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__heightMapGeometry" }], portsOut: [{ name: "Value", links: [{ portIn: "Geometry 2", portOut: "Value", objIn: "ud198sc5z", objOut: "absd3d4hb" }] }], objName: "Ops.Vars.VarGetObject_v2" }, { id: "vi3ol2srw", uiAttribs: {}, portsIn: [{ name: "Value 1", value: 0.35 }, { name: "Value 2", value: 0.6 }], portsOut: [{ name: "Result", links: [{ portIn: "Amount", portOut: "Result", objIn: "tgeyutq71", objOut: "vi3ol2srw" }] }], objName: "Ops.Math.Interpolate" }, { id: "5rr738syp", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeLevel" }], portsOut: [{ name: "Value", links: [{ portIn: "Percentage", portOut: "Value", objIn: "vi3ol2srw", objOut: "5rr738syp" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "cdrv5rrjk", uiAttribs: {}, portsOut: [{ name: "Result", links: [{ portIn: "number1", portOut: "Result", objIn: "jax75maya", objOut: "cdrv5rrjk" }] }], objName: "Ops.Math.OneMinus" }, { id: "tj2cnloqq", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__lensFlareTexts" }], objName: "Ops.Vars.VarGetTexture_v2" }, { id: "5dbgajlcv", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeLength" }], portsOut: [{ name: "Value", links: [{ portIn: "r", portOut: "Value", objIn: "1qwtcdiny", objOut: "5dbgajlcv" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "grj3uhv6e", uiAttribs: {}, portsIn: [{ name: "number2", value: 0.25 }], portsOut: [{ name: "result", links: [{ portIn: "Line Glow", portOut: "result", objIn: "1qwtcdiny", objOut: "grj3uhv6e" }] }], objName: "Ops.Math.Multiply" }, { id: "yaju7ahmk", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_diffusion" }], portsOut: [{ name: "Value", links: [{ portIn: "number1", portOut: "Value", objIn: "grj3uhv6e", objOut: "yaju7ahmk" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "1to9oiory", uiAttribs: {}, portsIn: [{ name: "Show Info", value: 0 }, { name: "Visualize outside 0-1 index", value: 1 }, { name: "Visualize outside 0-1", value: "Anim" }, { name: "Alpha index", value: 0 }, { name: "Alpha", value: "A" }, { name: "Show Color", value: 0 }, { name: "X", value: 0.5 }, { name: "Y", value: 0.5 }], portsOut: [{ name: "Info", value: "" }], objName: "Ops.Ui.VizTexture" }, { id: "1qwtcdiny", uiAttribs: {}, portsIn: [{ name: "Blend Mode index", value: 18 }, { name: "Blend Mode", value: "Math Add" }, { name: "Amount", value: 1 }, { name: "Alpha Mask index", value: 0 }, { name: "Alpha Mask", value: "Off" }, { name: "Waveform", value: "Sine" }, { name: "Amplitude", value: 0.318 }, { name: "Frequency", value: 1.83 }, { name: "Line Width", value: 0 }, { name: "invert color", value: 0 }, { name: "Solid fill", value: 0 }, { name: "Offset Y", value: 0.5 }, { name: "g", value: 0.897 }, { name: "b", value: 1 }], objName: "Ops.Gl.ImageCompose.Waveform_v3" }, { id: "pu5boj419", uiAttribs: {}, portsIn: [{ name: "render", title: "Trigger" }, { name: "Render Mesh", value: 1, title: "Render" }, { name: "width", value: 6.22 }, { name: "height", value: 1.18 }, { name: "pivot x index", value: 1 }, { name: "pivot x", value: "center" }, { name: "pivot y index", value: 1 }, { name: "pivot y", value: "center" }, { name: "axis index", value: 0 }, { name: "axis", value: "xy" }, { name: "Flip TexCoord X", value: 0 }, { name: "Flip TexCoord Y", value: 1 }, { name: "num columns", value: 1 }, { name: "num rows", value: 1 }], portsOut: [{ name: "trigger", title: "Next", links: [{ portIn: "render", portOut: "trigger", objIn: "p8itm86lw", objOut: "pu5boj419" }] }, { name: "geometry", links: [{ portIn: "Geometry", portOut: "geometry", objIn: "ud198sc5z", objOut: "pu5boj419" }] }], objName: "Ops.Gl.Meshes.Rectangle_v4" }, { id: "6t34impxr", uiAttribs: {}, portsIn: [{ name: "x", value: 1.16 }, { name: "y", value: 2.05 }, { name: "z", value: 1.59 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "pvmeev0jc", objOut: "6t34impxr" }] }], objName: "Ops.Gl.Matrix.ScaleXYZViewMatrix" }, { id: "pvmeev0jc", uiAttribs: {}, portsIn: [{ name: "posX", value: 0 }, { name: "posY", value: 0.2 }, { name: "posZ", value: -1.01 }, { name: "scale", value: 1 }, { name: "rotX", value: 0 }, { name: "rotY", value: 0 }, { name: "rotZ", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "pu5boj419", objOut: "pvmeev0jc" }] }], objName: "Ops.Gl.Matrix.Transform" }, { id: "a1dx328je", uiAttribs: {}, portsIn: [{ name: "g", value: 0.8266594326686372 }, { name: "b", value: 0.047299581303328786 }, { name: "colorizeTexture", value: 0 }, { name: "Vertex Colors", value: 0 }, { name: "Alpha Mask Source index", value: 0 }, { name: "Alpha Mask Source", value: "Luminance" }, { name: "Opacity TexCoords Transform", value: 0 }, { name: "Discard Transparent Pixels", value: 1 }, { name: "diffuseRepeatX", value: 1 }, { name: "diffuseRepeatY", value: 0.77 }, { name: "Tex Offset X", value: 0 }, { name: "Tex Offset Y", value: 0 }, { name: "Crop TexCoords", value: 0 }, { name: "billboard", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "6t34impxr", objOut: "a1dx328je" }] }], objName: "Ops.Gl.Shader.BasicMaterial_v3" }, { id: "mdoafoast", uiAttribs: {}, portsIn: [{ name: "Show Info", value: 0 }, { name: "Visualize outside 0-1 index", value: 1 }, { name: "Visualize outside 0-1", value: "Anim" }, { name: "Alpha index", value: 0 }, { name: "Alpha", value: "A" }, { name: "Show Color", value: 0 }, { name: "X", value: 0.5 }, { name: "Y", value: 0.5 }], portsOut: [{ name: "Texture Out", links: [{ portIn: "Diffuse Texture", portOut: "Texture Out", objIn: "3so3f33cf", objOut: "mdoafoast" }] }, { name: "Info", value: "" }], objName: "Ops.Ui.VizTexture" }, { id: "o0tqxxwkq", uiAttribs: {}, portsIn: [{ name: "Variable", value: "__lensFlareTexts" }], objName: "Ops.Vars.VarSetTexture_v2" }, { id: "87k6oec5j", uiAttribs: {}, portsIn: [{ name: "Gradient", value: '{"keys":[{"pos":0,"posy":0.5,"r":0.7693767103347384,"g":0.3982758441339165,"b":0.34728693678178457},{"pos":0,"posy":0.5,"r":0.8732415300882184,"g":0.5897433839602795,"b":0.41439701773996673},{"pos":1,"posy":0.5,"r":0.296043481280317,"g":0.4754506761298627,"b":0.5736275467351939},{"pos":1,"posy":0.5,"r":0.9055825531146728,"g":0.6864838426415525,"b":0.5673987684568402}]}' }, { name: "Direction index", value: 1 }, { name: "Direction", value: "Y" }, { name: "Smoothstep", value: 0 }, { name: "Step", value: 0 }, { name: "Flip", value: 0 }, { name: "sRGB", value: 0 }, { name: "Oklab", value: 0 }, { name: "Size", value: 64 }, { name: "filter index", value: 1 }, { name: "filter", value: "linear" }, { name: "wrap index", value: 1 }, { name: "wrap", value: "repeat" }, { name: "Gradient Array", value: 0 }], portsOut: [{ name: "Texture", links: [{ portIn: "Texture In", portOut: "Texture", objIn: "mdoafoast", objOut: "87k6oec5j" }] }], objName: "Ops.Gl.GradientTexture" }, { id: "di9yoxov9", uiAttribs: {}, portsIn: [{ name: "Size index", value: 0 }, { name: "Size", value: "Auto" }, { name: "Width", value: 640 }, { name: "Height", value: 480 }, { name: "Filter index", value: 1 }, { name: "Filter", value: "linear" }, { name: "Wrap index", value: 1 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Pixel Format index", value: 4 }, { name: "Pixel Format", value: "RGBA 8bit ubyte" }, { name: "R", value: 0 }, { name: "G", value: 0 }, { name: "B", value: 0 }, { name: "A", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "1qwtcdiny", objOut: "di9yoxov9" }] }, { name: "texture_out", links: [{ portIn: "Texture In", portOut: "texture_out", objIn: "1to9oiory", objOut: "di9yoxov9" }, { portIn: "Texture 2", portOut: "texture_out", objIn: "jc2ggn9up", objOut: "di9yoxov9" }] }, { name: "Aspect Ratio", value: 1.8329411764705883 }, { name: "Texture Width", value: 1558 }, { name: "Texture Height", value: 850 }], objName: "Ops.Gl.ImageCompose.ImageCompose_v4" }, { id: "9s6v7pnlp", uiAttribs: {}, portsIn: [{ name: "Size index", value: 2 }, { name: "Size", value: "Manual" }, { name: "Width", value: 640 }, { name: "Height", value: 480 }, { name: "Filter index", value: 1 }, { name: "Filter", value: "linear" }, { name: "Wrap index", value: 1 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Pixel Format index", value: 4 }, { name: "Pixel Format", value: "RGBA 8bit ubyte" }, { name: "R", value: 0 }, { name: "G", value: 0 }, { name: "B", value: 0 }, { name: "A", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Render", portOut: "Next", objIn: "jc2ggn9up", objOut: "9s6v7pnlp" }] }, { name: "texture_out", links: [{ portIn: "Base Texture", portOut: "texture_out", objIn: "51ldwg650", objOut: "9s6v7pnlp" }] }, { name: "Aspect Ratio", value: 1.3333333333333333 }, { name: "Texture Width", value: 640 }, { name: "Texture Height", value: 480 }], objName: "Ops.Gl.ImageCompose.ImageCompose_v4" }, { id: "51ldwg650", uiAttribs: {}, portsIn: [{ name: "Size index", value: 2 }, { name: "Size", value: "Manual" }, { name: "Width", value: 512 }, { name: "Height", value: 512 }, { name: "Filter index", value: 1 }, { name: "Filter", value: "linear" }, { name: "Wrap index", value: 1 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Pixel Format index", value: 4 }, { name: "Pixel Format", value: "RGBA 8bit ubyte" }, { name: "R", value: 0 }, { name: "G", value: 0 }, { name: "B", value: 0 }, { name: "A", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "Render", portOut: "Next", objIn: "bf9v1uys8", objOut: "51ldwg650" }] }, { name: "texture_out", links: [{ portIn: "texture", portOut: "texture_out", objIn: "a1dx328je", objOut: "51ldwg650" }, { portIn: "Value", portOut: "texture_out", objIn: "3hamtvj79", objOut: "51ldwg650" }] }, { name: "Aspect Ratio", value: 1 }, { name: "Texture Width", value: 512 }, { name: "Texture Height", value: 512 }], objName: "Ops.Gl.ImageCompose.ImageCompose_v4" }, { id: "ui62hd3xv", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_diffusion" }], portsOut: [{ name: "Value", links: [{ portIn: "Value", portOut: "Value", objIn: "cdrv5rrjk", objOut: "ui62hd3xv" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "nf37ruj15", uiAttribs: {}, portsIn: [{ name: "min", value: -0.1 }, { name: "max", value: 0.7 }], portsOut: [{ name: "result", links: [{ portIn: "Fade", portOut: "result", objIn: "jc2ggn9up", objOut: "nf37ruj15" }] }], objName: "Ops.Math.SmoothStep_v2" }, { id: "4bj7hjqvt", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_tone" }], portsOut: [{ name: "Value", value: 0.51319 }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "9902kom8s", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_diffusion" }], portsOut: [{ name: "Value", value: 5e-3 }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "xeu596ai6", uiAttribs: {}, portsIn: [{ name: "Blend Mode index", value: 18 }, { name: "Blend Mode", value: "Math Add" }, { name: "Rotate", value: 0.948 }, { name: "Crop", value: 1 }, { name: "Clear", value: 1 }], objName: "Ops.Gl.ImageCompose.RotateTexture_v2" }, { id: "gefz2cj4x", uiAttribs: {}, portsIn: [{ name: "Show Info", value: 0 }, { name: "Visualize outside 0-1 index", value: 1 }, { name: "Visualize outside 0-1", value: "Anim" }, { name: "Alpha index", value: 0 }, { name: "Alpha", value: "A" }, { name: "Show Color", value: 0 }, { name: "X", value: 0.5 }, { name: "Y", value: 0.5 }], portsOut: [{ name: "Texture Out", links: [{ portIn: "Value", portOut: "Texture Out", objIn: "o0tqxxwkq", objOut: "gefz2cj4x" }] }, { name: "Info", value: "" }], objName: "Ops.Ui.VizTexture" }, { id: "3hamtvj79", uiAttribs: {}, portsIn: [{ name: "Variable", value: "_finalTextOut" }], objName: "Ops.Vars.VarSetTexture_v2" }, { id: "r0my206wt", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_structure" }], portsOut: [{ name: "Value", value: 0 }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "jax75maya", uiAttribs: {}, portsIn: [{ name: "number2", value: -200 }], portsOut: [{ name: "result", links: [{ portIn: "Stretch Left", portOut: "result", objIn: "tgeyutq71", objOut: "jax75maya" }] }], objName: "Ops.Math.Multiply" }, { id: "tgeyutq71", uiAttribs: {}, portsIn: [{ name: "Blend Mode index", value: 18 }, { name: "Blend Mode", value: "Math Add" }, { name: "Clamp", value: 0 }, { name: "Stretch Top", value: 1 }, { name: "Stretch Bottom", value: 1 }, { name: "Stretch Right", value: -6 }], objName: "Ops.Gl.ImageCompose.SkewStretchImage_v2" }, { id: "jc2ggn9up", uiAttribs: {}, portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "tgeyutq71", objOut: "jc2ggn9up" }] }], objName: "Ops.Gl.ImageCompose.Mix" }, { id: "eerqtlpnp", uiAttribs: {}, portsIn: [{ name: "Size index", value: 0 }, { name: "Size", value: "Auto" }, { name: "Width", value: 512 }, { name: "Height", value: 512 }, { name: "Filter index", value: 1 }, { name: "Filter", value: "linear" }, { name: "Wrap index", value: 1 }, { name: "Wrap", value: "repeat" }, { name: "Anisotropic index", value: 0 }, { name: "Anisotropic", value: "0" }, { name: "Pixel Format index", value: 4 }, { name: "Pixel Format", value: "RGBA 8bit ubyte" }, { name: "R", value: 0 }, { name: "G", value: 0 }, { name: "B", value: 0 }, { name: "A", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "xeu596ai6", objOut: "eerqtlpnp" }] }, { name: "texture_out", links: [{ portIn: "Texture 1", portOut: "texture_out", objIn: "jc2ggn9up", objOut: "eerqtlpnp" }, { portIn: "Texture In", portOut: "texture_out", objIn: "gefz2cj4x", objOut: "eerqtlpnp" }] }, { name: "Aspect Ratio", value: 0.03125 }, { name: "Texture Width", value: 16 }, { name: "Texture Height", value: 512 }], objName: "Ops.Gl.ImageCompose.ImageCompose_v4" }, { id: "7afkrw4hx", uiAttribs: {}, portsIn: [{ name: "Blend Mode index", value: 1 }, { name: "Blend Mode", value: "lighten" }, { name: "Amount", value: 0.274 }, { name: "Alpha Mask index", value: 0 }, { name: "Alpha Mask", value: "Off" }, { name: "Offset X", value: 0 }, { name: "Offset Y", value: 12.85 }, { name: "Zoom", value: 800 }, { name: "Iterations", value: 25 }, { name: "Seed", value: 1 }, { name: "Spot edge", value: 0 }, { name: "Gamma", value: 0.88 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "lsqdg33wg", objOut: "7afkrw4hx" }] }], objName: "Ops.Gl.ImageCompose.LensDirt_v2" }, { id: "a5ao9xvu0", uiAttribs: {}, portsIn: [{ name: "Text", value: "off -" }, { name: "Font", value: "chivo" }, { name: "Scale", value: 0.14 }, { name: "Letter Spacing", value: 0.03 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 2 }, { name: "Align", value: "Right" }, { name: "Vertical Align index", value: 1 }, { name: "Vertical Align", value: "Top" }, { name: "r", value: 0.848 }, { name: "g", value: 0.865 }, { name: "b", value: 0.878 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.085 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.222 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 0 }, { name: "Border g", value: 0 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 0 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Rotations", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Next", links: [{ portIn: "render", portOut: "Next", objIn: "e9dkzz9vp", objOut: "a5ao9xvu0" }] }, { name: "Num Lines", value: 1 }, { name: "Width", value: 0.19982812500000005 }, { name: "Height", value: 0.08320785984848485 }, { name: "Start Y", value: 0.04596335227272727 }, { name: "Num Chars", value: 5 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "xwjvzec0g", uiAttribs: {}, portsIn: [{ name: "x", value: -1.33 }, { name: "y", value: -0.77 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "a5ao9xvu0", objOut: "xwjvzec0g" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "b4m9f71kh", uiAttribs: {}, portsIn: [{ name: "Text", value: "- max" }, { name: "Font", value: "chivo" }, { name: "Scale", value: 0.14 }, { name: "Letter Spacing", value: 0.03 }, { name: "Line Height", value: 1 }, { name: "Align index", value: 2 }, { name: "Align", value: "Right" }, { name: "Vertical Align index", value: 1 }, { name: "Vertical Align", value: "Top" }, { name: "r", value: 0.9 }, { name: "g", value: 0.9 }, { name: "b", value: 0.9 }, { name: "SDF", value: 1 }, { name: "Smoothing", value: 0.085 }, { name: "Border", value: 0 }, { name: "Border Width", value: 0.222 }, { name: "Smoothness", value: 0.25 }, { name: "Border r", value: 0 }, { name: "Border g", value: 0 }, { name: "Border b", value: 1 }, { name: "Shadow", value: 0 }, { name: "Positions", value: 0 }, { name: "Scalings", value: 0 }, { name: "Rotations", value: 0 }, { name: "Colors", value: 0 }], portsOut: [{ name: "Num Lines", value: 1 }, { name: "Width", value: 0.19687500000000005 }, { name: "Height", value: 0.08086723484848486 }, { name: "Start Y", value: 0.04346960227272727 }, { name: "Num Chars", value: 5 }], objName: "Ops.Gl.TextMeshMSDF_v2" }, { id: "e9dkzz9vp", uiAttribs: {}, portsIn: [{ name: "x", value: 2.83 }, { name: "y", value: 0 }, { name: "z", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "b4m9f71kh", objOut: "e9dkzz9vp" }] }], objName: "Ops.Gl.Matrix.Translate" }, { id: "0cmu1ry52", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeLevel" }], portsOut: [{ name: "Value", links: [{ portIn: "Amount", portOut: "Value", objIn: "xeu596ai6", objOut: "0cmu1ry52" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "4a37xki1m", uiAttribs: {}, storage: { blueprintVer: 2, subPatchVer: 2 }, portsIn: [{ name: "patchId", value: "bp2sub_4a37xki1m" }], portsOut: [{ name: "pmu87y53p", title: "result", links: [{ portIn: "Use Value 1", portOut: "pmu87y53p", objIn: "6lh7g16he", objOut: "4a37xki1m" }] }, { name: "1u3pcbd78", value: 0, title: "Number" }], objName: "Ops.Patch.PmhkN4m.TriggerOnReverseButton_v2" }, { id: "hfwy2vpuu", uiAttribs: {}, storage: { blueprintVer: 2, subPatchVer: 2 }, portsIn: [{ name: "patchId", value: "bp2sub_hfwy2vpuu" }], portsOut: [{ name: "pmu87y53p", title: "result", links: [{ portIn: "bool", portOut: "pmu87y53p", objIn: "zy3ewhgid", objOut: "hfwy2vpuu" }] }, { name: "1u3pcbd78", value: 0, title: "Number" }], objName: "Ops.Patch.PmhkN4m.TriggerOnReverseButton_v2" }, { id: "wfso8k7od", uiAttribs: {}, storage: { blueprintVer: 2, subPatchVer: 2 }, portsIn: [{ name: "patchId", value: "bp2sub_wfso8k7od" }], portsOut: [{ name: "pmu87y53p", value: 0, title: "result" }, { name: "1u3pcbd78", value: 0, title: "Number" }, { name: "hv192zqa4", title: "Next", links: [{ portIn: "Randomize Colors", portOut: "hv192zqa4", objIn: "87k6oec5j", objOut: "wfso8k7od" }] }], objName: "Ops.Patch.PmhkN4m.TriggerOnReverseButton_v2" }, { id: "tbn2qgqn9", uiAttribs: {}, portsIn: [{ name: "Gradient", value: '{"keys":[{"pos":0,"posy":0.5,"r":0,"g":0,"b":0},{"pos":0,"posy":0.5,"r":0,"g":0,"b":0},{"pos":0.494140625,"posy":0.56,"r":1,"g":1,"b":1},{"pos":1,"posy":0.5,"r":0,"g":0,"b":0},{"pos":1,"posy":0.5,"r":0,"g":0,"b":0}]}' }, { name: "Direction index", value: 2 }, { name: "Direction", value: "XY" }, { name: "Smoothstep", value: 0 }, { name: "Step", value: 0 }, { name: "Flip", value: 0 }, { name: "sRGB", value: 0 }, { name: "Oklab", value: 0 }, { name: "Size", value: 16 }, { name: "filter index", value: 0 }, { name: "filter", value: "nearest" }, { name: "wrap index", value: 0 }, { name: "wrap", value: "clamp to edge" }, { name: "Gradient Array", value: 0 }], objName: "Ops.Gl.GradientTexture" }, { id: "kjs0gomie", uiAttribs: {}, portsIn: [{ name: "Show Info", value: 0 }, { name: "Visualize outside 0-1 index", value: 1 }, { name: "Visualize outside 0-1", value: "Anim" }, { name: "Alpha index", value: 0 }, { name: "Alpha", value: "A" }, { name: "Show Color", value: 0 }, { name: "X", value: 0.5 }, { name: "Y", value: 0.5 }], portsOut: [{ name: "Info", value: "" }], objName: "Ops.Ui.VizTexture" }, { id: "fvg1zz75v", uiAttribs: {}, portsIn: [{ name: "Size index", value: 0 }, { name: "Size", value: "Canvas" }, { name: "texture width", value: 1558 }, { name: "texture height", value: 850 }, { name: "Auto Aspect", value: 1 }, { name: "filter index", value: 0 }, { name: "filter", value: "nearest" }, { name: "Wrap index", value: 0 }, { name: "Wrap", value: "Clamp" }, { name: "MSAA index", value: 0 }, { name: "MSAA", value: "none" }, { name: "Pixel Format index", value: 4 }, { name: "Pixel Format", value: "RGBA 8bit ubyte" }, { name: "Depth", value: 1 }, { name: "Clear", value: 1 }], portsOut: [{ name: "trigger", links: [{ portIn: "render", portOut: "trigger", objIn: "n9u25c6ax", objOut: "fvg1zz75v" }] }, { name: "texture", links: [{ portIn: "Base Texture", portOut: "texture", objIn: "48vrkn65x", objOut: "fvg1zz75v" }] }], objName: "Ops.Gl.RenderToTexture_v3" }, { id: "pxbd6eh63", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_smoothedParam_tone" }], portsOut: [{ name: "Value", links: [{ portIn: "Percentage", portOut: "Value", objIn: "uo6mpre8c", objOut: "pxbd6eh63" }, { portIn: "Value", portOut: "Value", objIn: "5ulr7vh4p", objOut: "pxbd6eh63" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "uo6mpre8c", uiAttribs: {}, portsIn: [{ name: "Value 1", value: 0.43 }, { name: "Value 2", value: 1 }], portsOut: [{ name: "Result", links: [{ portIn: "a", portOut: "Result", objIn: "a1dx328je", objOut: "uo6mpre8c" }, { portIn: "r", portOut: "Result", objIn: "a1dx328je", objOut: "uo6mpre8c" }] }], objName: "Ops.Math.Interpolate" }, { id: "bf9v1uys8", uiAttribs: {}, portsIn: [{ name: "Blend Mode index", value: 19 }, { name: "Blend Mode", value: "Math Subtract" }, { name: "Alpha Mask index", value: 0 }, { name: "Alpha Mask", value: "Off" }, { name: "Strength", value: 1 }, { name: "Radius", value: 0.208 }, { name: "Sharp", value: 0.539 }, { name: "Aspect", value: 1 }, { name: "r", value: 0 }, { name: "g", value: 0 }, { name: "b", value: 0 }, { name: "Alpha", value: 0 }], portsOut: [{ name: "Trigger", links: [{ portIn: "render", portOut: "Trigger", objIn: "7afkrw4hx", objOut: "bf9v1uys8" }] }], objName: "Ops.Gl.ImageCompose.Vignette_v3" }, { id: "5ulr7vh4p", uiAttribs: {}, portsOut: [{ name: "Result", links: [{ portIn: "Amount", portOut: "Result", objIn: "bf9v1uys8", objOut: "5ulr7vh4p" }] }], objName: "Ops.Math.OneMinus" }, { id: "lsqdg33wg", uiAttribs: {}, portsIn: [{ name: "Clamp", value: 1 }, { name: "direction index", value: 2 }, { name: "direction", value: "horizontal" }, { name: "Mask Invert", value: 0 }], portsOut: [{ name: "trigger", links: [{ portIn: "Render", portOut: "trigger", objIn: "9s6v7pnlp", objOut: "lsqdg33wg" }] }], objName: "Ops.Gl.ImageCompose.FastBlur_v2" }, { id: "fogdsmdt8", uiAttribs: {}, portsIn: [{ name: "Gradient", value: '{"keys":[{"pos":0,"posy":0.5,"r":0,"g":0,"b":0},{"pos":0,"posy":0.5,"r":0,"g":0,"b":0},{"pos":0.46875,"posy":0.51,"r":0.998046875,"g":0.998046875,"b":0.998046875},{"pos":1,"posy":0.5,"r":0,"g":0,"b":0},{"pos":1,"posy":0.5,"r":0,"g":0,"b":0}]}' }, { name: "Direction index", value: 1 }, { name: "Direction", value: "Y" }, { name: "Smoothstep", value: 0 }, { name: "Step", value: 1 }, { name: "Flip", value: 0 }, { name: "sRGB", value: 0 }, { name: "Oklab", value: 0 }, { name: "Size", value: 16 }, { name: "filter index", value: 1 }, { name: "filter", value: "linear" }, { name: "wrap index", value: 0 }, { name: "wrap", value: "clamp to edge" }, { name: "Gradient Array", value: 0 }], portsOut: [{ name: "Texture", links: [{ portIn: "Mask", portOut: "Texture", objIn: "lsqdg33wg", objOut: "fogdsmdt8" }] }], objName: "Ops.Gl.GradientTexture" }, { id: "v9g4w5w8m", uiAttribs: {}, portsIn: [{ name: "Variable", value: "ui_scapeLevel" }], portsOut: [{ name: "Value", links: [{ portIn: "number1", portOut: "Value", objIn: "qhu04l7zy", objOut: "v9g4w5w8m" }] }], objName: "Ops.Vars.VarGetNumber_v2" }, { id: "qhu04l7zy", uiAttribs: {}, portsIn: [{ name: "number2", value: 4 }], portsOut: [{ name: "result", links: [{ portIn: "Passes", portOut: "result", objIn: "lsqdg33wg", objOut: "qhu04l7zy" }] }], objName: "Ops.Math.Multiply" }, { id: "8jbyekrb8", uiAttribs: {}, portsIn: [{ name: "Named Trigger", value: "exeNoCamera" }], portsOut: [{ name: "Triggered", links: [{ portIn: "render", portOut: "Triggered", objIn: "xwjvzec0g", objOut: "8jbyekrb8" }] }], objName: "Ops.Trigger.TriggerReceive" }, { id: "qkhcjgu05", uiAttribs: {}, portsOut: [{ name: "result", links: [{ portIn: "a", portOut: "result", objIn: "a5ao9xvu0", objOut: "qkhcjgu05" }, { portIn: "a", portOut: "result", objIn: "b4m9f71kh", objOut: "qkhcjgu05" }] }], objName: "Ops.Ui.Routing.RouteNumber" }], export: { time: "2024-08-21 18:19", service: "download", exportNumber: 5 } };
if (!CABLES.exportedPatch) {
  CABLES.exportedPatch = CABLES.exportedPatches["mhkN4m"];
}
"use strict";
var CABLES = CABLES || {};
CABLES.OPS = CABLES.OPS || {};
var Ops = Ops || {};
Ops.Gl = Ops.Gl || {};
Ops.Ui = Ops.Ui || {};
Ops.Anim = Ops.Anim || {};
Ops.Data = Ops.Data || {};
Ops.Json = Ops.Json || {};
Ops.Math = Ops.Math || {};
Ops.User = Ops.User || {};
Ops.Vars = Ops.Vars || {};
Ops.Array = Ops.Array || {};
Ops.Patch = Ops.Patch || {};
Ops.Cables = Ops.Cables || {};
Ops.Number = Ops.Number || {};
Ops.String = Ops.String || {};
Ops.Boolean = Ops.Boolean || {};
Ops.Devices = Ops.Devices || {};
Ops.Gl.GLTF = Ops.Gl.GLTF || {};
Ops.Sidebar = Ops.Sidebar || {};
Ops.Trigger = Ops.Trigger || {};
Ops.Gl.Phong = Ops.Gl.Phong || {};
Ops.Graphics = Ops.Graphics || {};
Ops.Gl.Matrix = Ops.Gl.Matrix || {};
Ops.Gl.Meshes = Ops.Gl.Meshes || {};
Ops.Gl.Shader = Ops.Gl.Shader || {};
Ops.Ui.Routing = Ops.Ui.Routing || {};
Ops.Data.Compose = Ops.Data.Compose || {};
Ops.Math.Compare = Ops.Math.Compare || {};
Ops.Devices.Mouse = Ops.Devices.Mouse || {};
Ops.Patch.PmhkN4m = Ops.Patch.PmhkN4m || {};
Ops.Gl.ImageCompose = Ops.Gl.ImageCompose || {};
Ops.Devices.Keyboard = Ops.Devices.Keyboard || {};
Ops.Graphics.Geometry = Ops.Graphics.Geometry || {};
Ops.Data.Compose.Array = Ops.Data.Compose.Array || {};
Ops.User.cristianvogel = Ops.User.cristianvogel || {};
Ops.Data.Compose.Object = Ops.Data.Compose.Object || {};
Ops.Graphics.Intersection = Ops.Graphics.Intersection || {};
Ops.Patch.PmhkN4m.SubPatch2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const t = A.attachments = { inc_gen_ports_js: "op.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\n    }\nif(addedOps[i].innerOutput)\n{\n}\n}\n};\n", subpatch_json: '{"ops":[{"id":"bp0-0","uiAttribs":{"subPatch":"6d80loy1x"},"portsOut":[{"name":"Number","links":[{"portIn":"number1","portOut":"Number","objIn":"bp0-3","objOut":"bp0-0"},{"portIn":"Value In","portOut":"Number","objIn":"bp0-5","objOut":"bp0-0"}]}],"storage":{"ref":"bp0-0"},"objName":"Ops.String.ParseInt_v2"},{"id":"bp0-1","uiAttribs":{"subPatch":"6d80loy1x"},"portsIn":[{"name":"Variable","value":"ui_hitBodyName"}],"portsOut":[{"name":"Value","links":[{"portIn":"String","portOut":"Value","objIn":"bp0-2","objOut":"bp0-1"}]}],"storage":{"ref":"bp0-1"},"objName":"Ops.Vars.VarGetString"},{"id":"bp0-2","uiAttribs":{"subPatch":"6d80loy1x"},"portsIn":[{"name":"Search For","value":"dial."},{"name":"Replace","value":""},{"name":"Replace What index","value":0},{"name":"Replace What","value":"All"}],"portsOut":[{"name":"Result","links":[{"portIn":"String","portOut":"Result","objIn":"bp0-0","objOut":"bp0-2"}]}],"storage":{"ref":"bp0-2"},"objName":"Ops.String.StringReplace"},{"id":"bp0-3","uiAttribs":{"subPatch":"6d80loy1x"},"portsIn":[{"name":"number2","value":0}],"portsOut":[{"name":"result","links":[{"portIn":"Pass Through","portOut":"result","objIn":"bp0-5","objOut":"bp0-3"}]}],"storage":{"ref":"bp0-3"},"objName":"Ops.Math.Compare.GreaterThan"},{"id":"bp0-4","uiAttribs":{"subPatch":"6d80loy1x"},"portsIn":[{"name":"Variable","value":"ui_activeDial_ID"}],"storage":{"ref":"bp0-4"},"objName":"Ops.Vars.VarSetNumber_v2"},{"id":"bp0-5","uiAttribs":{"subPatch":"6d80loy1x"},"portsOut":[{"name":"Value Out","links":[{"portIn":"Value","portOut":"Value Out","objIn":"bp0-4","objOut":"bp0-5"}]}],"storage":{"ref":"bp0-5"},"objName":"Ops.Number.GateNumber"},{"id":"bp0-6","uiAttribs":{"subPatch":"6d80loy1x"},"storage":{"ref":"bp0-6"},"objName":"Ops.Ui.SubPatchInput"},{"id":"bp0-7","uiAttribs":{"subPatch":"6d80loy1x"},"storage":{"ref":"bp0-7"},"objName":"Ops.Ui.SubPatchOutput"}]}' };
  A.initInnerPorts = function(e2) {
    for (let A2 = 0; A2 < e2.length; A2++) {
      if (e2[A2].innerInput) {
      }
      if (e2[A2].innerOutput) {
      }
    }
  };
  const g = "bp2sub_" + A.id;
  new CABLES.SubPatchOp(A, { subId: g });
  e();
  function e() {
    const e2 = JSON.parse(t.subpatch_json);
    CABLES.Patch.replaceOpIds(e2, { parentSubPatchId: g, prefixHash: g, oldIdAsRef: true, doNotUnlinkLostLinks: true });
    for (let A2 = 0; A2 < e2.ops.length; A2++) {
      e2.ops[A2].uiAttribs.blueprintSubpatch2 = true;
    }
    A.patch.deSerialize(e2, { opsCreated: A.initInnerPorts });
    if (CABLES.UI)
      gui.savedState.setSaved("blueprintloaded", g);
    A.patch.emitEvent("subpatchExpose", g);
    A.setStorage({ blueprintVer: 2 });
    A.patch.emitEvent("subpatchExpose", g);
  }
};
Ops.Patch.PmhkN4m.SubPatch2.prototype = new CABLES.Op();
CABLES.OPS["a7339d7e-e080-4f98-af85-6e14ba1b6e7f"] = { f: Ops.Patch.PmhkN4m.SubPatch2, objName: "Ops.Patch.PmhkN4m.SubPatch2" };
Ops.Patch.PmhkN4m.BasicSlider_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const t = A.attachments = { inc_gen_ports_js: 'const port_blls2amps=op.inTrigger("blls2amps");\nport_blls2amps.setUiAttribs({title:"Trigger in",});\n\nconst port_btagbs7z2=op.inString("btagbs7z2","");\nport_btagbs7z2.setUiAttribs({title:"Class",});\n\nconst port_lj06d561p=op.inFloat("lj06d561p",0);\nport_lj06d561p.setUiAttribs({title:"Show Boundings",display:"bool",});\n\nconst port_nti406vwi=op.outNumber("nti406vwi");\nport_nti406vwi.setUiAttribs({title:"Result",});\n\nconst port_gjvx0zyv5=op.outNumber("gjvx0zyv5");\nport_gjvx0zyv5.setUiAttribs({title:"value",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_blls2amps = addedOps[i].outTrigger("innerOut_blls2amps");\ninnerOut_blls2amps.setUiAttribs({title:"Trigger in"});\nport_blls2amps.onTriggered = () => { innerOut_blls2amps.trigger(); };\n\nconst innerOut_btagbs7z2 = addedOps[i].outString("innerOut_btagbs7z2");\ninnerOut_btagbs7z2.set(port_btagbs7z2.get() );\ninnerOut_btagbs7z2.setUiAttribs({title:"Class"});\nport_btagbs7z2.on("change", (a,v) => { innerOut_btagbs7z2.set(a); });\n\nconst innerOut_lj06d561p = addedOps[i].outNumber("innerOut_lj06d561p");\ninnerOut_lj06d561p.set(port_lj06d561p.get() );\ninnerOut_lj06d561p.setUiAttribs({title:"Show Boundings"});\nport_lj06d561p.on("change", (a,v) => { innerOut_lj06d561p.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_nti406vwi = addedOps[i].inFloat("innerIn_nti406vwi");\ninnerIn_nti406vwi.setUiAttribs({title:"Result"});\ninnerIn_nti406vwi.on("change", (a,v) => { port_nti406vwi.set(a); });\n\nconst innerIn_gjvx0zyv5 = addedOps[i].inFloat("innerIn_gjvx0zyv5");\ninnerIn_gjvx0zyv5.setUiAttribs({title:"value"});\ninnerIn_gjvx0zyv5.on("change", (a,v) => { port_gjvx0zyv5.set(a); });\n\n}\n}\n};\n', subpatch_json: '{"ops":[{"id":"bp1-0","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"Width","value":1.02},{"name":"Height","value":0.22},{"name":"Class","value":"slider_track"},{"name":"Pivot x index","value":0},{"name":"Pivot x","value":"center"},{"name":"Pivot y index","value":2},{"name":"Pivot y","value":"bottom"},{"name":"Axis index","value":0},{"name":"Axis","value":"xy"},{"name":"Is Interactive","value":1},{"name":"Show Boundings","value":0},{"name":"Cursor index","value":5},{"name":"Cursor","value":"n-resize"},{"name":"Render","value":1,"title":"Active"}],"portsOut":[{"name":"Trigger out","links":[{"portIn":"Update","portOut":"Trigger out","objIn":"bp1-3","objOut":"bp1-0"}]},{"name":"Pointer Hover","links":[{"portIn":"bool","portOut":"Pointer Hover","objIn":"bp1-9","objOut":"bp1-0"}]},{"name":"Pointer Down","links":[{"portIn":"Pass Through","portOut":"Pointer Down","objIn":"bp1-7","objOut":"bp1-0"}]},{"name":"Pointer X","links":[{"portIn":"Value In","portOut":"Pointer X","objIn":"bp1-7","objOut":"bp1-0"}]},{"name":"Pointer Y","value":0.8016852908308879},{"name":"Top","value":908.0684179067612},{"name":"Left","value":367.07094287872314},{"name":"Right","value":1520.9290571212769},{"name":"Bottom","value":968.5783016681671}],"objName":"Ops.Gl.InteractiveRectangle_v2"},{"id":"bp1-1","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"r","value":0.179},{"name":"g","value":1},{"name":"b","value":0.692},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp1-4","objOut":"bp1-1"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp1-2","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"posY","value":0.09},{"name":"posZ","value":0},{"name":"scale","value":0.7},{"name":"rotX","value":0},{"name":"rotY","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp1-1","objOut":"bp1-2"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp1-3","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":2,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Next","links":[{"portIn":"render","portOut":"Next","objIn":"bp1-2","objOut":"bp1-3"},{"portIn":"exe","portOut":"Next","objIn":"bp1-9","objOut":"bp1-3"}]},{"name":"Result","links":[{"portIn":"posX","portOut":"Result","objIn":"bp1-2","objOut":"bp1-3"},{"portIn":"innerIn_nti406vwi","portOut":"Result","objIn":"bp1-6","objOut":"bp1-3"},{"portIn":"number1","portOut":"Result","objIn":"bp1-10","objOut":"bp1-3"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp1-4","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"width","value":0.017},{"name":"height","value":0.05},{"name":"Draw","value":1}],"objName":"Ops.Gl.Meshes.Triangle_v2"},{"id":"bp1-5","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsOut":[{"name":"innerOut_blls2amps","title":"Trigger in","links":[{"portIn":"Trigger in","portOut":"innerOut_blls2amps","objIn":"bp1-0","objOut":"bp1-5"}]},{"name":"innerOut_btagbs7z2","title":"Class","links":[{"portIn":"ID","portOut":"innerOut_btagbs7z2","objIn":"bp1-0","objOut":"bp1-5"}]},{"name":"innerOut_lj06d561p","title":"Show Boundings","links":[{"portIn":"Render Rectangle","portOut":"innerOut_lj06d561p","objIn":"bp1-0","objOut":"bp1-5"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp1-6","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"innerIn_nti406vwi","title":"Result"},{"name":"innerIn_gjvx0zyv5","title":"value"}],"objName":"Ops.Ui.SubPatchOutput"},{"id":"bp1-7","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"When False index","value":0},{"name":"When False","value":"keep last number"},{"name":"Custom Value","value":0}],"portsOut":[{"name":"Value Out","links":[{"portIn":"number1","portOut":"Value Out","objIn":"bp1-8","objOut":"bp1-7"}]}],"objName":"Ops.Number.GateNumber"},{"id":"bp1-8","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"number2","value":0.5}],"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp1-3","objOut":"bp1-8"}]}],"objName":"Ops.Math.Subtract"},{"id":"bp1-9","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"easing index","value":0},{"name":"easing","value":"linear"},{"name":"duration","value":0.25},{"name":"Direction index","value":0},{"name":"Direction","value":"Both"},{"name":"value false","value":0.49},{"name":"value true","value":1}],"portsOut":[{"name":"value","links":[{"portIn":"a","portOut":"value","objIn":"bp1-1","objOut":"bp1-9"},{"portIn":"innerIn_gjvx0zyv5","portOut":"value","objIn":"bp1-6","objOut":"bp1-9"}]},{"name":"finished","value":1}],"objName":"Ops.Anim.BoolAnim"},{"id":"bp1-10","uiAttribs":{"subPatch":"eg5mesb23"},"storage":{},"portsIn":[{"name":"number2","value":5}],"portsOut":[{"name":"result","links":[{"portIn":"rotZ","portOut":"result","objIn":"bp1-2","objOut":"bp1-10"}]}],"objName":"Ops.Math.Multiply"}]}' };
  const o = A.inTrigger("blls2amps");
  o.setUiAttribs({ title: "Trigger in" });
  const C = A.inString("btagbs7z2", "");
  C.setUiAttribs({ title: "Class" });
  const a = A.inFloat("lj06d561p", 0);
  a.setUiAttribs({ title: "Show Boundings", display: "bool" });
  const r = A.outNumber("nti406vwi");
  r.setUiAttribs({ title: "Result" });
  const s = A.outNumber("gjvx0zyv5");
  s.setUiAttribs({ title: "value" });
  A.initInnerPorts = function(e2) {
    for (let A2 = 0; A2 < e2.length; A2++) {
      if (e2[A2].innerInput) {
        const t2 = e2[A2].outTrigger("innerOut_blls2amps");
        t2.setUiAttribs({ title: "Trigger in" });
        o.onTriggered = () => {
          t2.trigger();
        };
        const g2 = e2[A2].outString("innerOut_btagbs7z2");
        g2.set(C.get());
        g2.setUiAttribs({ title: "Class" });
        C.on("change", (A3, e3) => {
          g2.set(A3);
        });
        const i = e2[A2].outNumber("innerOut_lj06d561p");
        i.set(a.get());
        i.setUiAttribs({ title: "Show Boundings" });
        a.on("change", (A3, e3) => {
          i.set(A3);
        });
      }
      if (e2[A2].innerOutput) {
        const I = e2[A2].inFloat("innerIn_nti406vwi");
        I.setUiAttribs({ title: "Result" });
        I.on("change", (A3, e3) => {
          r.set(A3);
        });
        const n = e2[A2].inFloat("innerIn_gjvx0zyv5");
        n.setUiAttribs({ title: "value" });
        n.on("change", (A3, e3) => {
          s.set(A3);
        });
      }
    }
  };
  const g = "bp2sub_" + A.id;
  new CABLES.SubPatchOp(A, { subId: g });
  e();
  function e() {
    const e2 = JSON.parse(t.subpatch_json);
    CABLES.Patch.replaceOpIds(e2, { parentSubPatchId: g, prefixHash: g, oldIdAsRef: true, doNotUnlinkLostLinks: true });
    for (let A2 = 0; A2 < e2.ops.length; A2++) {
      e2.ops[A2].uiAttribs.blueprintSubpatch2 = true;
    }
    A.loadDependencies(e2, () => {
      A.patch.deSerialize(e2, { opsCreated: A.initInnerPorts });
      if (CABLES.UI)
        gui.savedState.setSaved("blueprintloaded", g);
      A.patch.emitEvent("subpatchExpose", g);
      A.setStorage({ blueprintVer: 2 });
      A.patch.emitEvent("subpatchExpose", g);
    });
  }
};
Ops.Patch.PmhkN4m.BasicSlider_v2.prototype = new CABLES.Op();
CABLES.OPS["61602cdf-c672-40ce-9f79-b337ae14a192"] = { f: Ops.Patch.PmhkN4m.BasicSlider_v2, objName: "Ops.Patch.PmhkN4m.BasicSlider_v2" };
Ops.Patch.PmhkN4m.BasicSlider_v1 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const t = A.attachments = { inc_gen_ports_js: 'const port_blls2amps=op.inTrigger("blls2amps");\nport_blls2amps.setUiAttribs({title:"Trigger in",});\n\nconst port_btagbs7z2=op.inString("btagbs7z2","");\nport_btagbs7z2.setUiAttribs({title:"Class",});\n\nconst port_lj06d561p=op.inFloat("lj06d561p",0);\nport_lj06d561p.setUiAttribs({title:"Show Boundings",display:"bool",});\n\nconst port_nti406vwi=op.outNumber("nti406vwi");\nport_nti406vwi.setUiAttribs({title:"Result",});\n\nconst port_gjvx0zyv5=op.outNumber("gjvx0zyv5");\nport_gjvx0zyv5.setUiAttribs({title:"value",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_blls2amps = addedOps[i].outTrigger("innerOut_blls2amps");\ninnerOut_blls2amps.setUiAttribs({title:"Trigger in"});\nport_blls2amps.onTriggered = () => { innerOut_blls2amps.trigger(); };\n\nconst innerOut_btagbs7z2 = addedOps[i].outString("innerOut_btagbs7z2");\ninnerOut_btagbs7z2.set(port_btagbs7z2.get() );\ninnerOut_btagbs7z2.setUiAttribs({title:"Class"});\nport_btagbs7z2.on("change", (a,v) => { innerOut_btagbs7z2.set(a); });\n\nconst innerOut_lj06d561p = addedOps[i].outNumber("innerOut_lj06d561p");\ninnerOut_lj06d561p.set(port_lj06d561p.get() );\ninnerOut_lj06d561p.setUiAttribs({title:"Show Boundings"});\nport_lj06d561p.on("change", (a,v) => { innerOut_lj06d561p.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_nti406vwi = addedOps[i].inFloat("innerIn_nti406vwi");\ninnerIn_nti406vwi.setUiAttribs({title:"Result"});\ninnerIn_nti406vwi.on("change", (a,v) => { port_nti406vwi.set(a); });\n\nconst innerIn_gjvx0zyv5 = addedOps[i].inFloat("innerIn_gjvx0zyv5");\ninnerIn_gjvx0zyv5.setUiAttribs({title:"value"});\ninnerIn_gjvx0zyv5.on("change", (a,v) => { port_gjvx0zyv5.set(a); });\n\n}\n}\n};\n', subpatch_json: '{"ops":[{"id":"bp2-0","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"Width","value":1},{"name":"Height","value":0.33},{"name":"Class","value":"slider_track"},{"name":"Pivot x index","value":0},{"name":"Pivot x","value":"center"},{"name":"Pivot y index","value":2},{"name":"Pivot y","value":"bottom"},{"name":"Axis index","value":0},{"name":"Axis","value":"xy"},{"name":"Is Interactive","value":1},{"name":"Show Boundings","value":0},{"name":"Cursor index","value":5},{"name":"Cursor","value":"n-resize"},{"name":"Render","value":1,"title":"Active"}],"portsOut":[{"name":"Trigger out","links":[{"portIn":"Update","portOut":"Trigger out","objIn":"bp2-3","objOut":"bp2-0"}]},{"name":"Pointer Hover","links":[{"portIn":"bool","portOut":"Pointer Hover","objIn":"bp2-9","objOut":"bp2-0"}]},{"name":"Pointer Down","links":[{"portIn":"Pass Through","portOut":"Pointer Down","objIn":"bp2-7","objOut":"bp2-0"}]},{"name":"Pointer X","links":[{"portIn":"Value In","portOut":"Pointer X","objIn":"bp2-7","objOut":"bp2-0"}]},{"name":"Pointer Y","value":0.8612481506097802},{"name":"Top","value":779.8482092022896},{"name":"Left","value":341.00669050216675},{"name":"Right","value":1432.9933094978333},{"name":"Bottom","value":851.9193206429482}],"objName":"Ops.Gl.InteractiveRectangle_v2"},{"id":"bp2-1","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"r","value":0.179},{"name":"g","value":1},{"name":"b","value":0.692},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp2-4","objOut":"bp2-1"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp2-2","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"posY","value":0.09},{"name":"posZ","value":0},{"name":"scale","value":0.7},{"name":"rotX","value":0},{"name":"rotY","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp2-1","objOut":"bp2-2"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp2-3","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":2,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Next","links":[{"portIn":"render","portOut":"Next","objIn":"bp2-2","objOut":"bp2-3"},{"portIn":"exe","portOut":"Next","objIn":"bp2-9","objOut":"bp2-3"}]},{"name":"Result","links":[{"portIn":"posX","portOut":"Result","objIn":"bp2-2","objOut":"bp2-3"},{"portIn":"innerIn_nti406vwi","portOut":"Result","objIn":"bp2-6","objOut":"bp2-3"},{"portIn":"number1","portOut":"Result","objIn":"bp2-10","objOut":"bp2-3"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp2-4","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"width","value":0.017},{"name":"height","value":0.05},{"name":"Draw","value":1}],"objName":"Ops.Gl.Meshes.Triangle_v2"},{"id":"bp2-5","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsOut":[{"name":"innerOut_blls2amps","title":"Trigger in","links":[{"portIn":"Trigger in","portOut":"innerOut_blls2amps","objIn":"bp2-0","objOut":"bp2-5"}]},{"name":"innerOut_btagbs7z2","title":"Class","links":[{"portIn":"ID","portOut":"innerOut_btagbs7z2","objIn":"bp2-0","objOut":"bp2-5"}]},{"name":"innerOut_lj06d561p","title":"Show Boundings","links":[{"portIn":"Render Rectangle","portOut":"innerOut_lj06d561p","objIn":"bp2-0","objOut":"bp2-5"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp2-6","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"innerIn_nti406vwi","title":"Result"},{"name":"innerIn_gjvx0zyv5","title":"value"}],"objName":"Ops.Ui.SubPatchOutput"},{"id":"bp2-7","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"When False index","value":0},{"name":"When False","value":"keep last number"},{"name":"Custom Value","value":0}],"portsOut":[{"name":"Value Out","links":[{"portIn":"number1","portOut":"Value Out","objIn":"bp2-8","objOut":"bp2-7"}]}],"objName":"Ops.Number.GateNumber"},{"id":"bp2-8","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"number2","value":0.5}],"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp2-3","objOut":"bp2-8"}]}],"objName":"Ops.Math.Subtract"},{"id":"bp2-9","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"easing index","value":0},{"name":"easing","value":"linear"},{"name":"duration","value":0.25},{"name":"Direction index","value":0},{"name":"Direction","value":"Both"},{"name":"value false","value":0.49},{"name":"value true","value":1}],"portsOut":[{"name":"value","links":[{"portIn":"a","portOut":"value","objIn":"bp2-1","objOut":"bp2-9"},{"portIn":"innerIn_gjvx0zyv5","portOut":"value","objIn":"bp2-6","objOut":"bp2-9"}]},{"name":"finished","value":1}],"objName":"Ops.Anim.BoolAnim"},{"id":"bp2-10","uiAttribs":{"subPatch":"f9bafa28k"},"storage":{},"portsIn":[{"name":"number2","value":5}],"portsOut":[{"name":"result","links":[{"portIn":"rotZ","portOut":"result","objIn":"bp2-2","objOut":"bp2-10"}]}],"objName":"Ops.Math.Multiply"}]}' };
  const o = A.inTrigger("blls2amps");
  o.setUiAttribs({ title: "Trigger in" });
  const C = A.inString("btagbs7z2", "");
  C.setUiAttribs({ title: "Class" });
  const a = A.inFloat("lj06d561p", 0);
  a.setUiAttribs({ title: "Show Boundings", display: "bool" });
  const r = A.outNumber("nti406vwi");
  r.setUiAttribs({ title: "Result" });
  const s = A.outNumber("gjvx0zyv5");
  s.setUiAttribs({ title: "value" });
  A.initInnerPorts = function(e2) {
    for (let A2 = 0; A2 < e2.length; A2++) {
      if (e2[A2].innerInput) {
        const t2 = e2[A2].outTrigger("innerOut_blls2amps");
        t2.setUiAttribs({ title: "Trigger in" });
        o.onTriggered = () => {
          t2.trigger();
        };
        const g2 = e2[A2].outString("innerOut_btagbs7z2");
        g2.set(C.get());
        g2.setUiAttribs({ title: "Class" });
        C.on("change", (A3, e3) => {
          g2.set(A3);
        });
        const i = e2[A2].outNumber("innerOut_lj06d561p");
        i.set(a.get());
        i.setUiAttribs({ title: "Show Boundings" });
        a.on("change", (A3, e3) => {
          i.set(A3);
        });
      }
      if (e2[A2].innerOutput) {
        const I = e2[A2].inFloat("innerIn_nti406vwi");
        I.setUiAttribs({ title: "Result" });
        I.on("change", (A3, e3) => {
          r.set(A3);
        });
        const n = e2[A2].inFloat("innerIn_gjvx0zyv5");
        n.setUiAttribs({ title: "value" });
        n.on("change", (A3, e3) => {
          s.set(A3);
        });
      }
    }
  };
  const g = "bp2sub_" + A.id;
  new CABLES.SubPatchOp(A, { subId: g });
  e();
  function e() {
    const e2 = JSON.parse(t.subpatch_json);
    CABLES.Patch.replaceOpIds(e2, { parentSubPatchId: g, prefixHash: g, oldIdAsRef: true, doNotUnlinkLostLinks: true });
    for (let A2 = 0; A2 < e2.ops.length; A2++) {
      e2.ops[A2].uiAttribs.blueprintSubpatch2 = true;
    }
    A.loadDependencies(e2, () => {
      A.patch.deSerialize(e2, { opsCreated: A.initInnerPorts });
      if (CABLES.UI)
        gui.savedState.setSaved("blueprintloaded", g);
      A.patch.emitEvent("subpatchExpose", g);
      A.setStorage({ blueprintVer: 2 });
      A.patch.emitEvent("subpatchExpose", g);
    });
  }
};
Ops.Patch.PmhkN4m.BasicSlider_v1.prototype = new CABLES.Op();
CABLES.OPS["542b7cd7-c7fe-4837-bebd-b491873bde76"] = { f: Ops.Patch.PmhkN4m.BasicSlider_v1, objName: "Ops.Patch.PmhkN4m.BasicSlider_v1" };
Ops.Patch.PmhkN4m.TriggerOnReverseButton_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const t = A.attachments = { inc_gen_ports_js: 'const port_pmu87y53p=op.outNumber("pmu87y53p");\nport_pmu87y53p.setUiAttribs({title:"result",display:"boolnum",});\n\nconst port_1u3pcbd78=op.outNumber("1u3pcbd78");\nport_1u3pcbd78.setUiAttribs({title:"Number",});\n\nconst port_hv192zqa4=op.outTrigger("hv192zqa4");\nport_hv192zqa4.setUiAttribs({title:"Next",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_pmu87y53p = addedOps[i].inFloat("innerIn_pmu87y53p");\ninnerIn_pmu87y53p.setUiAttribs({title:"result"});\ninnerIn_pmu87y53p.on("change", (a,v) => { port_pmu87y53p.set(a); });\n\nconst innerIn_1u3pcbd78 = addedOps[i].inFloat("innerIn_1u3pcbd78");\ninnerIn_1u3pcbd78.setUiAttribs({title:"Number"});\ninnerIn_1u3pcbd78.on("change", (a,v) => { port_1u3pcbd78.set(a); });\n\nconst innerIn_hv192zqa4 = addedOps[i].inTrigger("innerIn_hv192zqa4");\ninnerIn_hv192zqa4.setUiAttribs({title:"Next"});\ninnerIn_hv192zqa4.onTriggered = () => { port_hv192zqa4.trigger(); };\n\n}\n}\n};\n', subpatch_json: '{"ops":[{"id":"bp3-0","uiAttribs":{"subPatch":"51rrof35z"},"storage":{},"portsIn":[{"name":"Variable","value":"ui_scapeDirection"}],"portsOut":[{"name":"Value","links":[{"portIn":"Value","portOut":"Value","objIn":"bp3-4","objOut":"bp3-0"}]}],"objName":"Ops.Vars.VarGetNumber_v2"},{"id":"bp3-1","uiAttribs":{"subPatch":"51rrof35z"},"storage":{},"portsIn":[{"name":"Default","value":0}],"portsOut":[{"name":"Next","links":[{"portIn":"innerIn_hv192zqa4","portOut":"Next","objIn":"bp3-3","objOut":"bp3-1"}]},{"name":"result","links":[{"portIn":"innerIn_pmu87y53p","portOut":"result","objIn":"bp3-3","objOut":"bp3-1"}]}],"objName":"Ops.Boolean.ToggleBool_v2"},{"id":"bp3-2","uiAttribs":{"subPatch":"51rrof35z"},"storage":{},"objName":"Ops.Ui.SubPatchInput"},{"id":"bp3-3","uiAttribs":{"subPatch":"51rrof35z"},"storage":{},"portsIn":[{"name":"innerIn_pmu87y53p","title":"result"},{"name":"innerIn_1u3pcbd78","value":0,"title":"Number"},{"name":"innerIn_hv192zqa4","title":"Next"}],"objName":"Ops.Ui.SubPatchOutput"},{"id":"bp3-4","uiAttribs":{"subPatch":"51rrof35z"},"storage":{},"portsOut":[{"name":"Next","links":[{"portIn":"trigger","portOut":"Next","objIn":"bp3-1","objOut":"bp3-4"}]}],"objName":"Ops.Boolean.TriggerChangedTrue"}]}' };
  const I = A.outNumber("pmu87y53p");
  I.setUiAttribs({ title: "result", display: "boolnum" });
  const n = A.outNumber("1u3pcbd78");
  n.setUiAttribs({ title: "Number" });
  const o = A.outTrigger("hv192zqa4");
  o.setUiAttribs({ title: "Next" });
  A.initInnerPorts = function(e2) {
    for (let A2 = 0; A2 < e2.length; A2++) {
      if (e2[A2].innerInput) {
      }
      if (e2[A2].innerOutput) {
        const t2 = e2[A2].inFloat("innerIn_pmu87y53p");
        t2.setUiAttribs({ title: "result" });
        t2.on("change", (A3, e3) => {
          I.set(A3);
        });
        const g2 = e2[A2].inFloat("innerIn_1u3pcbd78");
        g2.setUiAttribs({ title: "Number" });
        g2.on("change", (A3, e3) => {
          n.set(A3);
        });
        const i = e2[A2].inTrigger("innerIn_hv192zqa4");
        i.setUiAttribs({ title: "Next" });
        i.onTriggered = () => {
          o.trigger();
        };
      }
    }
  };
  const g = "bp2sub_" + A.id;
  new CABLES.SubPatchOp(A, { subId: g });
  e();
  function e() {
    const e2 = JSON.parse(t.subpatch_json);
    CABLES.Patch.replaceOpIds(e2, { parentSubPatchId: g, prefixHash: g, oldIdAsRef: true, doNotUnlinkLostLinks: true });
    for (let A2 = 0; A2 < e2.ops.length; A2++) {
      e2.ops[A2].uiAttribs.blueprintSubpatch2 = true;
    }
    A.loadDependencies(e2, () => {
      A.patch.deSerialize(e2, { opsCreated: A.initInnerPorts });
      if (CABLES.UI)
        gui.savedState.setSaved("blueprintloaded", g);
      A.patch.emitEvent("subpatchExpose", g);
      A.setStorage({ blueprintVer: 2 });
      A.patch.emitEvent("subpatchExpose", g);
    });
  }
};
Ops.Patch.PmhkN4m.TriggerOnReverseButton_v2.prototype = new CABLES.Op();
CABLES.OPS["fc641f25-ac35-407d-80f5-149ef87f401b"] = { f: Ops.Patch.PmhkN4m.TriggerOnReverseButton_v2, objName: "Ops.Patch.PmhkN4m.TriggerOnReverseButton_v2" };
Ops.String.ParseInt_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("String", 5711), g = A.outNumber("Number");
  t.onChange = function() {
    let A2 = parseInt(t.get());
    if (A2 != A2)
      A2 = 0;
    g.set(A2);
  };
};
Ops.String.ParseInt_v2.prototype = new CABLES.Op();
CABLES.OPS["6d208424-daf2-4a2b-874f-daac406c1f66"] = { f: Ops.String.ParseInt_v2, objName: "Ops.String.ParseInt_v2" };
Ops.Vars.VarGetString = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  var t = A.outString("Value");
  A.varName = A.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(A, "string", A.varName, t);
};
Ops.Vars.VarGetString.prototype = new CABLES.Op();
CABLES.OPS["3ad08cfc-bce6-4175-9746-fef2817a3b12"] = { f: Ops.Vars.VarGetString, objName: "Ops.Vars.VarGetString" };
Ops.String.StringReplace = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inString("String"), g = e.inString("Search For", "foo"), i = e.inString("Replace", "bar"), I = e.inSwitch("Replace What", ["All", "First"], "All"), n = e.outString("Result");
  i.onChange = t.onChange = I.onChange = g.onChange = o;
  function o() {
    e.setUiError("exception", null);
    let A2 = "";
    try {
      if (I.get() == "All")
        A2 = String(t.get()).replace(new RegExp(g.get(), "g"), i.get());
      else
        A2 = String(t.get()).replace(g.get(), i.get());
    } catch (A3) {
      e.setUiError("exception", "exception " + A3.message);
    }
    n.set(A2);
  }
};
Ops.String.StringReplace.prototype = new CABLES.Op();
CABLES.OPS["4a053e7a-6b00-4e71-bd51-90cdb190994c"] = { f: Ops.String.StringReplace, objName: "Ops.String.StringReplace" };
Ops.Math.Compare.GreaterThan = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("number1"), g = A.inValueFloat("number2"), i = A.outBoolNum("result");
  A.setUiAttribs({ mathTitle: true });
  t.onChange = g.onChange = I;
  function I() {
    i.set(t.get() > g.get());
  }
};
Ops.Math.Compare.GreaterThan.prototype = new CABLES.Op();
CABLES.OPS["b250d606-f7f8-44d3-b099-c29efff2608a"] = { f: Ops.Math.Compare.GreaterThan, objName: "Ops.Math.Compare.GreaterThan" };
Ops.Vars.VarSetNumber_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("Value", 0);
  A.varName = A.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(A, "number", t, A.varName);
};
Ops.Vars.VarSetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["b5249226-6095-4828-8a1c-080654e192fa"] = { f: Ops.Vars.VarSetNumber_v2, objName: "Ops.Vars.VarSetNumber_v2" };
Ops.Number.GateNumber = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("Value In", 0), g = A.inValueBool("Pass Through"), i = A.inSwitch("When False", ["keep last number", "custom"], "keep last number"), I = A.inFloat("Custom Value", 0), n = A.outNumber("Value Out");
  t.onChange = C;
  g.onChange = C;
  t.changeAlways = n.changeAlways = true;
  i.onChange = o;
  function o() {
    I.setUiAttribs({ greyout: i.get() != "custom" });
    C();
  }
  function C() {
    if (g.get()) {
      n.set(t.get());
    } else {
      if (i.get() == "custom")
        n.set(I.get());
    }
  }
};
Ops.Number.GateNumber.prototype = new CABLES.Op();
CABLES.OPS["594105c8-1fdb-4f3c-bbd5-29b9ad6b33e0"] = { f: Ops.Number.GateNumber, objName: "Ops.Number.GateNumber" };
Ops.Ui.SubPatchInput = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  e.innerInput = true;
  const t = e.inTriggerButton("Goto SubPatchOp");
  t.setUiAttribs({ hidePort: true });
  t.onTriggered = () => {
    const A2 = e.patch.getSubPatchOuterOp(e.uiAttribs.subPatch);
    gui.patchView.centerSelectOp(A2.id);
  };
};
Ops.Ui.SubPatchInput.prototype = new CABLES.Op();
CABLES.OPS["c4e4e933-136e-479e-8de8-0b35b75d9217"] = { f: Ops.Ui.SubPatchInput, objName: "Ops.Ui.SubPatchInput" };
Ops.Ui.SubPatchOutput = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  A.innerOutput = true;
};
Ops.Ui.SubPatchOutput.prototype = new CABLES.Op();
CABLES.OPS["02d45073-7936-4830-81ad-59a162febf1f"] = { f: Ops.Ui.SubPatchOutput, objName: "Ops.Ui.SubPatchOutput" };
Ops.Gl.InteractiveRectangle_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const u = this;
  const v = u.attachments = {};
  const O = u.inTrigger("Trigger in"), k = u.outTrigger("Trigger out"), p = u.inValue("Width", 1), d = u.inValue("Height", 1), A = u.inString("ID"), e = u.inString("Class"), m = u.inValueSelect("Pivot x", ["center", "left", "right"]), f = u.inValueSelect("Pivot y", ["center", "top", "bottom"]), D = u.inValueSelect("Axis", ["xy", "xz"]), t = u.inValueBool("Is Interactive", true), x = u.inValueBool("Render Rectangle", true), g = u.inValueBool("Show Boundings", true), i = u.inValueSelect("Cursor", ["auto", "crosshair", "pointer", "Hand", "move", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize", "text", "wait", "help", "none"], "pointer"), I = u.inValueBool("Render", true);
  const y = u.outObject("geometry");
  y.ignoreValueSerialize = true;
  const n = u.outBoolNum("Pointer Hover", false), o = u.outBoolNum("Pointer Down", false), T = u.outNumber("Pointer X"), J = u.outNumber("Pointer Y"), Y = u.outNumber("Top"), K = u.outNumber("Left"), j = u.outNumber("Right"), V = u.outNumber("Bottom"), H = u.outTrigger("Left Click");
  const q = u.outObject("Dom Element");
  I.setUiAttribs({ title: "Active" });
  const b = u.patch.cgl;
  D.set("xy");
  m.set("center");
  f.set("center");
  const N = new CGL.Geometry(u.name);
  let S = null;
  let c = null;
  const P = mat4.create();
  const h = mat4.create();
  const w = vec3.create();
  const R = vec3.create();
  const G = vec3.create();
  D.onChange = C;
  m.onChange = C;
  f.onChange = C;
  p.onChange = C;
  d.onChange = C;
  i.onChange = $;
  C();
  const W = mat4.create();
  const X = mat4.create();
  const z = vec3.create();
  O.onTriggered = function() {
    if (!c) {
      gA();
      l();
      Z();
      Q();
    }
    eA();
    if (I.get() && x.get() && S)
      S.render(b.getShader());
    k.trigger();
  };
  function C() {
    let A2 = p.get();
    let e2 = d.get();
    let t2 = 0;
    let g2 = 0;
    if (typeof A2 == "string")
      A2 = parseFloat(A2);
    if (typeof e2 == "string")
      e2 = parseFloat(e2);
    if (m.get() == "center") {
      t2 = 0;
      R[0] = -A2 / 2;
    }
    if (m.get() == "right") {
      t2 = -A2 / 2;
    }
    if (m.get() == "left") {
      t2 = A2 / 2;
    }
    if (f.get() == "center") {
      g2 = 0;
      R[1] = -e2 / 2;
    }
    if (f.get() == "top")
      g2 = -e2 / 2;
    if (f.get() == "bottom")
      g2 = +e2 / 2;
    const i2 = [];
    const I2 = [];
    const n2 = [];
    const o2 = [];
    const C2 = 1;
    const a2 = 1;
    const r2 = A2 / a2;
    const s2 = e2 / C2;
    let B2, Q2;
    for (Q2 = 0; Q2 <= C2; Q2++) {
      for (B2 = 0; B2 <= a2; B2++) {
        i2.push(B2 * r2 - p.get() / 2 + t2);
        if (D.get() == "xz")
          i2.push(0);
        i2.push(Q2 * s2 - d.get() / 2 + g2);
        if (D.get() == "xy")
          i2.push(0);
        I2.push(B2 / a2);
        I2.push(1 - Q2 / C2);
        if (D.get() == "xz") {
          n2.push(0);
          n2.push(1);
          n2.push(0);
        }
        if (D.get() == "xy") {
          n2.push(0);
          n2.push(0);
          n2.push(-1);
        }
      }
    }
    for (B2 = 0; B2 < a2; B2++) {
      for (Q2 = 0; Q2 < C2; Q2++) {
        const E2 = B2 + (a2 + 1) * Q2;
        const l2 = E2;
        const u2 = E2 + 1;
        const c2 = E2 + a2 + 1;
        const h2 = E2 + 1 + a2 + 1;
        o2.push(l2);
        o2.push(c2);
        o2.push(u2);
        o2.push(u2);
        o2.push(c2);
        o2.push(h2);
      }
    }
    N.clear();
    N.vertices = i2;
    N.texCoords = I2;
    N.verticesIndices = o2;
    N.vertexNormals = n2;
    if (!S)
      S = new CGL.Mesh(b, N);
    else
      S.setGeom(N);
    y.set(null);
    y.set(N);
  }
  let _ = 0;
  let F = 0;
  let M = 0;
  let U = 0;
  const L = mat4.create();
  g.onChange = Z;
  A.onChange = AA;
  e.onChange = tA;
  function Z() {
    if (c) {
      if (g.get())
        c.style.border = "1px solid red";
      else
        c.style.border = "none";
    }
  }
  function $() {
    if (c) {
      c.style.cursor = i.get();
    }
  }
  function AA() {
    if (c) {
      c.setAttribute("id", A.get());
    }
  }
  function eA() {
    mat4.multiply(L, b.vMatrix, b.mMatrix);
    vec3.transformMat4(w, R, L);
    vec3.transformMat4(h, w, b.pMatrix);
    const A2 = b.canvas.styleMarginTop || 0;
    const e2 = b.canvas.styleMarginLeft || 0;
    const t2 = h[0] * b.canvasWidth / 2 + b.canvasWidth / 2 + e2;
    const g2 = h[1] * b.canvasHeight / 2 + b.canvasHeight / 2 + A2;
    G[0] = R[0] + p.get();
    G[1] = R[1];
    vec3.transformMat4(w, G, L);
    vec3.transformMat4(h, w, b.pMatrix);
    const i2 = h[0] * b.canvasWidth / 2 + b.canvasWidth / 2 + e2;
    const I2 = h[1] * b.canvasHeight / 2 + b.canvasHeight / 2 + A2;
    G[0] = R[0];
    G[1] = R[1] + d.get();
    vec3.transformMat4(w, G, L);
    vec3.transformMat4(h, w, b.pMatrix);
    const n2 = h[0] * b.canvasWidth / 2 + b.canvasWidth / 2 + e2;
    const o2 = h[1] * b.canvasHeight / 2 + b.canvasHeight / 2 + A2;
    G[0] = R[0] + p.get();
    G[1] = R[1] + d.get();
    vec3.transformMat4(w, G, L);
    vec3.transformMat4(h, w, b.pMatrix);
    const C2 = h[0] * b.canvasWidth / 2 + b.canvasWidth / 2 + e2;
    const a2 = h[1] * b.canvasHeight / 2 + b.canvasHeight / 2 + A2;
    _ = Math.min(t2, i2, n2, C2);
    F = Math.min(b.canvasHeight - g2, b.canvasHeight - I2, b.canvasHeight - o2, b.canvasHeight - a2);
    const r2 = Math.max(t2, i2, n2, C2);
    const s2 = Math.max(b.canvasHeight - g2, b.canvasHeight - I2, b.canvasHeight - o2, b.canvasHeight - a2);
    Y.set(F);
    K.set(_);
    j.set(r2);
    V.set(s2);
    M = Math.abs(r2 - _);
    U = Math.abs(s2 - F);
    _ /= u.patch.cgl.pixelDensity;
    F /= u.patch.cgl.pixelDensity;
    M /= u.patch.cgl.pixelDensity;
    U /= u.patch.cgl.pixelDensity;
    const B2 = _ + "px";
    const Q2 = F + "px";
    const E2 = M + "px";
    const l2 = U + "px";
    if (B2 != c.style.left)
      c.style.left = B2;
    if (Q2 != c.style.top)
      c.style.top = Q2;
    if (c.style.width != E2)
      c.style.width = E2;
    if (c.style.height != l2)
      c.style.height = l2;
  }
  function tA() {
    if (c) {
      c.className = e.get();
    }
  }
  u.onDelete = function() {
    if (c)
      c.remove();
  };
  function gA() {
    if (!c) {
      c = document.createElement("div");
      c.dataset.op = u.id;
      c.oncontextmenu = function(A3) {
        A3.preventDefault();
      };
      c.style.padding = "0px";
      c.style.position = "absolute";
      c.style["box-sizing"] = "border-box";
      c.style.border = "1px solid red";
      c.style["z-index"] = "500";
      c.style["-webkit-user-select"] = "none";
      c.style["user-select"] = "none";
      c.style["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)";
      c.style["-webkit-touch-callout"] = "none";
      const A2 = u.patch.cgl.canvas.parentElement;
      A2.appendChild(c);
      $();
      Q();
      AA();
      tA();
    }
    eA();
    q.set(c);
  }
  let a = null;
  function r(A2) {
    const e2 = -p.get() / 2;
    const t2 = -d.get() / 2;
    T.set(Math.max(0, Math.min(1, A2.offsetX / M)));
    J.set(Math.max(0, Math.min(1, 1 - A2.offsetY / U)));
  }
  function iA(A2) {
    o.set(false);
    n.set(false);
  }
  function IA(A2) {
    n.set(true);
  }
  function s(A2) {
    o.set(true);
  }
  function B(A2) {
    o.set(false);
  }
  function nA(A2) {
    H.trigger();
  }
  function oA(A2) {
    const e2 = document.elementFromPoint(A2.targetTouches[0].pageX, A2.targetTouches[0].pageY);
    if (e2 == c) {
      n.set(true);
      if (A2.touches && A2.touches.length > 0) {
        const t2 = c.getBoundingClientRect();
        const g2 = A2.targetTouches[0].pageX - t2.left;
        const i2 = A2.targetTouches[0].pageY - t2.top;
        const I2 = A2.touches[0];
        T.set(Math.max(0, Math.min(1, g2 / M)));
        J.set(Math.max(0, Math.min(1, 1 - i2 / U)));
        r(I2);
      }
    } else {
      n.set(false);
    }
  }
  I.onChange = CA;
  function CA() {
    if (I.get()) {
      l();
      if (c)
        c.style.display = "block";
    } else {
      E();
      if (c)
        c.style.display = "none";
    }
  }
  t.onChange = Q;
  function Q() {
    if (t.get()) {
      l();
      if (c)
        c.style["pointer-events"] = "initial";
    } else {
      E();
      o.set(false);
      n.set(false);
      if (c)
        c.style["pointer-events"] = "none";
    }
  }
  function E() {
    if (a) {
      document.removeEventListener("touchmove", oA);
      a.removeEventListener("touchend", B);
      a.removeEventListener("touchstart", s);
      a.removeEventListener("click", nA);
      a.removeEventListener("mousemove", r);
      a.removeEventListener("mouseleave", iA);
      a.removeEventListener("mousedown", s);
      a.removeEventListener("mouseup", B);
      a.removeEventListener("mouseenter", IA);
      a = null;
    }
  }
  function l() {
    if (a)
      E();
    a = c;
    if (a) {
      document.addEventListener("touchmove", oA);
      a.addEventListener("touchend", B);
      a.addEventListener("touchstart", s);
      a.addEventListener("click", nA);
      a.addEventListener("mousemove", r);
      a.addEventListener("mouseleave", iA);
      a.addEventListener("mousedown", s);
      a.addEventListener("mouseup", B);
      a.addEventListener("mouseenter", IA);
    }
  }
};
Ops.Gl.InteractiveRectangle_v2.prototype = new CABLES.Op();
CABLES.OPS["334728ca-60a2-4a42-a059-d9b5f3fe4d32"] = { f: Ops.Gl.InteractiveRectangle_v2, objName: "Ops.Gl.InteractiveRectangle_v2" };
Ops.Gl.Shader.BasicMaterial_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { basicmaterial_frag: "{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n\n#ifdef VERTEX_COLORS\nIN vec4 vertCol;\n#endif\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\n\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=color;\n\n\n    #ifdef HAS_TEXTURES\n        vec2 uv=texCoord;\n\n        #ifdef CROP_TEXCOORDS\n            if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;\n        #endif\n\n        #ifdef HAS_TEXTURE_DIFFUSE\n            col=texture(tex,uv);\n\n            #ifdef COLORIZE_TEXTURE\n                col.r*=color.r;\n                col.g*=color.g;\n                col.b*=color.b;\n            #endif\n        #endif\n        col.a*=color.a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                uv=texCoordOrig;\n            #endif\n            #ifdef ALPHA_MASK_IR\n                col.a*=1.0-texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_IALPHA\n                col.a*=1.0-texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_ALPHA\n                col.a*=texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_LUMI\n                col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,uv).rgb);\n            #endif\n            #ifdef ALPHA_MASK_R\n                col.a*=texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_G\n                col.a*=texture(texOpacity,uv).g;\n            #endif\n            #ifdef ALPHA_MASK_B\n                col.a*=texture(texOpacity,uv).b;\n            #endif\n            // #endif\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col*=vertCol;\n    #endif\n\n    outColor = col;\n}\n", basicmaterial_vert: "\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI float diffuseRepeatX;\n    UNI float diffuseRepeatY;\n    UNI float texOffsetX;\n    UNI float texOffsetY;\n#endif\n\n#ifdef VERTEX_COLORS\n    in vec4 attrVertColor;\n    out vec4 vertCol;\n\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 modelViewMatrix;\n\n    norm=attrVertNormal;\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n        texCoord.y=(1.0-texCoord.y)*diffuseRepeatY+texOffsetY;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol=attrVertColor;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.0);\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       modelViewMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * modelViewMatrix * vec4((\n           position.x * vec3(\n               modelViewMatrix[0][0],\n               modelViewMatrix[1][0],\n               modelViewMatrix[2][0] ) +\n           position.y * vec3(\n               modelViewMatrix[0][1],\n               modelViewMatrix[1][1],\n               modelViewMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        modelViewMatrix=viewMatrix * mMatrix;\n\n        {{MODULE_VERTEX_MOVELVIEW}}\n\n    #endif\n\n    // mat4 modelViewMatrix=viewMatrix*mMatrix;\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * modelViewMatrix * pos;\n    #endif\n}\n" };
  const t = A.inTrigger("render");
  const g = A.outTrigger("trigger");
  const i = A.outObject("shader", null, "shader");
  i.ignoreValueSerialize = true;
  A.toWorkPortsNeedToBeLinked(t);
  A.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);
  const I = A.patch.cgl;
  const n = new CGL.Shader(I, "basicmaterialnew", this);
  n.addAttribute({ type: "vec3", name: "vPosition" });
  n.addAttribute({ type: "vec2", name: "attrTexCoord" });
  n.addAttribute({ type: "vec3", name: "attrVertNormal", nameFrag: "norm" });
  n.addAttribute({ type: "float", name: "attrVertIndex" });
  n.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MOVELVIEW"]);
  n.setSource(e.basicmaterial_vert, e.basicmaterial_frag);
  i.setRef(n);
  t.onTriggered = S;
  const o = A.inValueSlider("r", Math.random());
  const C = A.inValueSlider("g", Math.random());
  const a = A.inValueSlider("b", Math.random());
  const r = A.inValueSlider("a", 1);
  o.setUiAttribs({ colorPick: true });
  const s = n.addUniformFrag("4f", "color", o, C, a, r);
  n.uniformColorDiffuse = s;
  const B = A.inTexture("texture");
  let Q = null;
  B.onChange = R;
  const E = A.inValueBool("colorizeTexture", false);
  const l = A.inValueBool("Vertex Colors", false);
  const u = A.inTexture("textureOpacity");
  let c = null;
  const h = A.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A", "1-A", "1-R"], "Luminance");
  h.setUiAttribs({ greyout: true });
  u.onChange = w;
  const p = A.inValueBool("Opacity TexCoords Transform", false);
  const d = A.inValueBool("Discard Transparent Pixels");
  const m = A.inValue("diffuseRepeatX", 1), f = A.inValue("diffuseRepeatY", 1), D = A.inValue("Tex Offset X", 0), y = A.inValue("Tex Offset Y", 0), b = A.inBool("Crop TexCoords", false);
  n.addUniformFrag("f", "diffuseRepeatX", m);
  n.addUniformFrag("f", "diffuseRepeatY", f);
  n.addUniformFrag("f", "texOffsetX", D);
  n.addUniformFrag("f", "texOffsetY", y);
  const N = A.inValueBool("billboard", false);
  h.onChange = N.onChange = d.onChange = p.onChange = b.onChange = l.onChange = E.onChange = _;
  A.setPortGroup("Color", [o, C, a, r]);
  A.setPortGroup("Color Texture", [B, l, E]);
  A.setPortGroup("Opacity", [u, h, d, p]);
  A.setPortGroup("Texture Transform", [m, f, D, y, b]);
  w();
  R();
  A.preRender = function() {
    n.bind();
    S();
  };
  function S() {
    if (!n)
      return;
    I.pushShader(n);
    n.popTextures();
    if (Q && B.get())
      n.pushTexture(Q, B.get());
    if (c && u.get())
      n.pushTexture(c, u.get());
    g.trigger();
    I.popShader();
  }
  function w() {
    if (u.get()) {
      if (c !== null)
        return;
      n.removeUniform("texOpacity");
      n.define("HAS_TEXTURE_OPACITY");
      if (!c)
        c = new CGL.Uniform(n, "t", "texOpacity");
    } else {
      n.removeUniform("texOpacity");
      n.removeDefine("HAS_TEXTURE_OPACITY");
      c = null;
    }
    _();
  }
  function R() {
    if (B.get()) {
      if (!n.hasDefine("HAS_TEXTURE_DIFFUSE"))
        n.define("HAS_TEXTURE_DIFFUSE");
      if (!Q)
        Q = new CGL.Uniform(n, "t", "texDiffuse");
    } else {
      n.removeUniform("texDiffuse");
      n.removeDefine("HAS_TEXTURE_DIFFUSE");
      Q = null;
    }
    G();
  }
  function G() {
    const A2 = B.isLinked() || u.isLinked();
    m.setUiAttribs({ greyout: !A2 });
    f.setUiAttribs({ greyout: !A2 });
    D.setUiAttribs({ greyout: !A2 });
    y.setUiAttribs({ greyout: !A2 });
    E.setUiAttribs({ greyout: !A2 });
    h.setUiAttribs({ greyout: !u.get() });
    p.setUiAttribs({ greyout: !u.get() });
    let e2 = true;
    e2 = B.get() && !E.get();
    o.setUiAttribs({ greyout: e2 });
    C.setUiAttribs({ greyout: e2 });
    a.setUiAttribs({ greyout: e2 });
  }
  function _() {
    n.toggleDefine("VERTEX_COLORS", l.get());
    n.toggleDefine("CROP_TEXCOORDS", b.get());
    n.toggleDefine("COLORIZE_TEXTURE", E.get());
    n.toggleDefine("TRANSFORMALPHATEXCOORDS", p.get());
    n.toggleDefine("DISCARDTRANS", d.get());
    n.toggleDefine("BILLBOARD", N.get());
    n.toggleDefine("ALPHA_MASK_ALPHA", h.get() == "A");
    n.toggleDefine("ALPHA_MASK_IALPHA", h.get() == "1-A");
    n.toggleDefine("ALPHA_MASK_IR", h.get() == "1-R");
    n.toggleDefine("ALPHA_MASK_LUMI", h.get() == "Luminance");
    n.toggleDefine("ALPHA_MASK_R", h.get() == "R");
    n.toggleDefine("ALPHA_MASK_G", h.get() == "G");
    n.toggleDefine("ALPHA_MASK_B", h.get() == "B");
    G();
  }
};
Ops.Gl.Shader.BasicMaterial_v3.prototype = new CABLES.Op();
CABLES.OPS["ec55d252-3843-41b1-b731-0482dbd9e72b"] = { f: Ops.Gl.Shader.BasicMaterial_v3, objName: "Ops.Gl.Shader.BasicMaterial_v3" };
Ops.Gl.Matrix.Transform = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = {};
  const e = t.inTrigger("render"), g = t.inValue("posX", 0), i = t.inValue("posY", 0), I = t.inValue("posZ", 0), n = t.inValue("scale", 1), o = t.inValue("rotX", 0), C = t.inValue("rotY", 0), a = t.inValue("rotZ", 0), r = t.outTrigger("trigger");
  t.setPortGroup("Rotation", [o, C, a]);
  t.setPortGroup("Position", [g, i, I]);
  t.setPortGroup("Scale", [n]);
  t.setUiAxisPorts(g, i, I);
  t.toWorkPortsNeedToBeLinked(e, r);
  const s = vec3.create();
  const B = vec3.create();
  const Q = mat4.create();
  mat4.identity(Q);
  let E = false, l = false, u = true, c = true, h = true;
  o.onChange = C.onChange = a.onChange = y;
  g.onChange = i.onChange = I.onChange = f;
  n.onChange = D;
  e.onTriggered = function() {
    let A2 = false;
    if (u) {
      d();
      A2 = true;
    }
    if (c) {
      m();
      A2 = true;
    }
    if (h)
      A2 = true;
    if (A2)
      p();
    const e2 = t.patch.cg || t.patch.cgl;
    e2.pushModelMatrix();
    mat4.multiply(e2.mMatrix, e2.mMatrix, Q);
    r.trigger();
    e2.popModelMatrix();
    if (CABLES.UI) {
      if (!g.isLinked() && !i.isLinked() && !I.isLinked()) {
        gui.setTransform(t.id, g.get(), i.get(), I.get());
        if (t.isCurrentUiOp())
          gui.setTransformGizmo({ posX: g, posY: i, posZ: I });
      }
    }
  };
  function p() {
    mat4.identity(Q);
    if (l)
      mat4.translate(Q, Q, s);
    if (o.get() !== 0)
      mat4.rotateX(Q, Q, o.get() * CGL.DEG2RAD);
    if (C.get() !== 0)
      mat4.rotateY(Q, Q, C.get() * CGL.DEG2RAD);
    if (a.get() !== 0)
      mat4.rotateZ(Q, Q, a.get() * CGL.DEG2RAD);
    if (E)
      mat4.scale(Q, Q, B);
    h = false;
  }
  function d() {
    l = false;
    if (g.get() !== 0 || i.get() !== 0 || I.get() !== 0)
      l = true;
    vec3.set(s, g.get(), i.get(), I.get());
    u = false;
  }
  function m() {
    E = true;
    vec3.set(B, n.get(), n.get(), n.get());
    c = false;
  }
  function f() {
    u = true;
  }
  function D() {
    c = true;
  }
  function y() {
    h = true;
  }
  p();
};
Ops.Gl.Matrix.Transform.prototype = new CABLES.Op();
CABLES.OPS["650baeb1-db2d-4781-9af6-ab4e9d4277be"] = { f: Ops.Gl.Matrix.Transform, objName: "Ops.Gl.Matrix.Transform" };
Ops.Anim.Smooth = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Update"), g = A.inBool("Separate inc/dec", false), i = A.inValue("Value"), I = A.outTrigger("Next"), n = A.inValue("Inc factor", 4), o = A.inValue("Dec factor", 4), C = A.outNumber("Result", 0);
  let a = 0;
  let r = 0;
  let s = 0;
  let B = 0;
  A.toWorkPortsNeedToBeLinked(t);
  let Q;
  let E;
  let l = 4;
  let u = true;
  let c = 0;
  const h = 0;
  const p = 1;
  d();
  m();
  g.setUiAttribs({ hidePort: true });
  n.onChange = o.onChange = m;
  g.onChange = d;
  f();
  function d() {
    const A2 = g.get();
    if (!A2)
      c = h;
    else
      c = p;
    if (c == h) {
      o.setUiAttribs({ greyout: true });
      n.setUiAttribs({ title: "Inc/Dec factor" });
    } else if (c == p) {
      o.setUiAttribs({ greyout: false });
      n.setUiAttribs({ title: "Inc factor" });
    }
    m();
    f();
  }
  function m() {
    if (c == h) {
      Q = n.get();
      E = n.get();
    } else if (c == p) {
      Q = n.get();
      E = o.get();
    }
    if (Q <= 0.2 || Q != Q)
      Q = 0.2;
    if (E <= 0.2 || E != E)
      E = 0.2;
  }
  i.onChange = function() {
    u = false;
    let A2 = r;
    r = i.get();
  };
  n.onChange = function() {
    m();
  };
  function f() {
    let A2 = 1;
    if (performance.now() - B > 500 || B === 0)
      a = i.get() || 0;
    else
      A2 = (performance.now() - B) / (performance.now() - B);
    B = performance.now();
    if (a != a)
      a = 0;
    if (l <= 0)
      l = 1e-4;
    const e2 = r - a;
    if (e2 >= 0)
      a += e2 / (E * A2);
    else
      a += e2 / (Q * A2);
    if (Math.abs(e2) < 1e-5)
      a = r;
    if (l != l)
      a = 0;
    if (a != a || a == -Infinity || a == Infinity)
      a = i.get();
    if (s != a) {
      C.set(a);
      s = a;
    }
    if (a == r && !u) {
      u = true;
      C.set(a);
    }
    I.trigger();
  }
  t.onTriggered = function() {
    f();
  };
};
Ops.Anim.Smooth.prototype = new CABLES.Op();
CABLES.OPS["5677b5b5-753a-4fbf-9e91-64c81ec68a2f"] = { f: Ops.Anim.Smooth, objName: "Ops.Anim.Smooth" };
Ops.Gl.Meshes.Triangle_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("render"), g = A.outTrigger("trigger"), i = A.inValueFloat("width", 1), I = A.inValueFloat("height", 1), n = A.inValueBool("Draw", true), o = new CGL.Geometry("triangle"), C = A.outObject("geometry");
  C.ignoreValueSerialize = true;
  A.toWorkPortsNeedToBeLinked(t);
  A.setPortGroup("Size", [i, I]);
  const a = A.patch.cgl;
  let r = null;
  i.onChange = I.onChange = () => {
    r = null;
  };
  t.onLinkChanged = () => {
    if (!t.isLinked())
      C.set(null);
    else
      s();
  };
  t.onTriggered = function() {
    if (!r)
      s();
    if (n.get() && r)
      r.render(a.getShader());
    g.trigger();
  };
  function s() {
    o.vertices = [0, I.get(), 0, -i.get(), -I.get(), 0, i.get(), -I.get(), 0];
    o.vertexNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1];
    o.tangents = [1, 0, 0, 1, 0, 0, 1, 0, 0];
    o.biTangents = [0, 1, 0, 0, 1, 0, 0, 1, 0];
    o.texCoords = [0.5, 0, 1, 1, 0, 1];
    o.verticesIndices = [0, 1, 2];
    r = new CGL.Mesh(a, o);
    C.setRef(o);
  }
};
Ops.Gl.Meshes.Triangle_v2.prototype = new CABLES.Op();
CABLES.OPS["ef522d4a-9712-4063-8a99-c6b409f26456"] = { f: Ops.Gl.Meshes.Triangle_v2, objName: "Ops.Gl.Meshes.Triangle_v2" };
Ops.Math.Subtract = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("number1", 1), g = A.inValue("number2", 1), i = A.outNumber("result");
  A.setUiAttribs({ mathTitle: true });
  t.onChange = g.onChange = I;
  I();
  function I() {
    let A2 = t.get() - g.get();
    if (!isNaN(A2))
      i.set(A2);
  }
};
Ops.Math.Subtract.prototype = new CABLES.Op();
CABLES.OPS["a4ffe852-d200-4b96-9347-68feb01122ca"] = { f: Ops.Math.Subtract, objName: "Ops.Math.Subtract" };
Ops.Anim.BoolAnim = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = new CABLES.Anim();
  const g = A.inTrigger("exe"), i = A.inValueBool("bool"), I = t.createPort(A, "easing"), n = A.inValue("duration", 0.25), o = A.inValueSelect("Direction", ["Both", "Only True", "Only False"], "Both"), C = A.inValue("value false", 0), a = A.inValue("value true", 1), r = A.outTrigger("trigger"), s = A.outNumber("value"), B = A.outBoolNum("finished"), Q = A.outTrigger("Finished Trigger");
  const E = CABLES.now();
  A.toWorkPortsNeedToBeLinked(g);
  A.setPortGroup("Animation", [n, I]);
  A.setPortGroup("Values", [C, a]);
  o.onChange = i.onChange = C.onChange = a.onChange = n.onChange = l;
  l();
  function l() {
    if (o.get() == "Animate Both")
      o.set("Both");
    B.set(false);
    const A2 = (CABLES.now() - E) / 1e3;
    const e2 = t.getValue(A2);
    t.clear();
    t.setValue(A2, e2);
    if (!i.get()) {
      if (o.get() != "Only True")
        t.setValue(A2 + n.get(), C.get());
      else
        t.setValue(A2, C.get());
    } else {
      if (o.get() != "Only False")
        t.setValue(A2 + n.get(), a.get());
      else
        t.setValue(A2, a.get());
    }
  }
  g.onTriggered = function() {
    const A2 = (CABLES.now() - E) / 1e3;
    s.set(t.getValue(A2));
    if (t.hasEnded(A2)) {
      if (!B.get())
        Q.trigger();
      B.set(true);
    }
    r.trigger();
  };
};
Ops.Anim.BoolAnim.prototype = new CABLES.Op();
CABLES.OPS["06ad9d35-ccf5-4d31-889c-e23fa062588a"] = { f: Ops.Anim.BoolAnim, objName: "Ops.Anim.BoolAnim" };
Ops.Math.Multiply = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("number1", 1), g = A.inValueFloat("number2", 1), i = A.outNumber("result");
  A.setUiAttribs({ mathTitle: true });
  t.onChange = g.onChange = I;
  I();
  function I() {
    const A2 = t.get();
    const e2 = g.get();
    i.set(A2 * e2);
  }
};
Ops.Math.Multiply.prototype = new CABLES.Op();
CABLES.OPS["1bbdae06-fbb2-489b-9bcc-36c9d65bd441"] = { f: Ops.Math.Multiply, objName: "Ops.Math.Multiply" };
Ops.Vars.VarGetNumber_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.outNumber("Value");
  A.varName = A.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(A, "number", A.varName, t);
};
Ops.Vars.VarGetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["421f5b52-c0fa-47c4-8b7a-012b9e1c864a"] = { f: Ops.Vars.VarGetNumber_v2, objName: "Ops.Vars.VarGetNumber_v2" };
Ops.Boolean.ToggleBool_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTriggerButton("trigger"), g = A.inTriggerButton("reset"), i = A.inBool("Default", false), I = A.outTrigger("Next"), n = A.outBoolNum("result");
  let o = false;
  A.onLoadedValueSet = () => {
    n.set(i.get());
    I.trigger();
  };
  t.onTriggered = function() {
    o = !o;
    n.set(o);
    I.trigger();
  };
  g.onTriggered = function() {
    o = i.get();
    n.set(o);
    I.trigger();
  };
};
Ops.Boolean.ToggleBool_v2.prototype = new CABLES.Op();
CABLES.OPS["4313d9bb-96b6-43bc-9190-6068cfb2593c"] = { f: Ops.Boolean.ToggleBool_v2, objName: "Ops.Boolean.ToggleBool_v2" };
Ops.Boolean.TriggerChangedTrue = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  let t = A.inValueBool("Value", false);
  let g = A.outTrigger("Next");
  let i = 0;
  t.onChange = function() {
    let A2 = t.get();
    if (!i && A2) {
      i = true;
      g.trigger();
    } else {
      i = false;
    }
  };
};
Ops.Boolean.TriggerChangedTrue.prototype = new CABLES.Op();
CABLES.OPS["385197e1-8b34-4d1c-897f-d1386d99e3b3"] = { f: Ops.Boolean.TriggerChangedTrue, objName: "Ops.Boolean.TriggerChangedTrue" };
Ops.Gl.MainLoop = function() {
  CABLES.Op.apply(this, arguments);
  const g = this;
  const A = g.attachments = {};
  const e = g.inValue("FPS Limit", 0), t = g.outTrigger("trigger"), i = g.outNumber("width"), I = g.outNumber("height"), n = g.inValueBool("Reduce FPS not focussed", false), o = g.inValueBool("Reduce FPS loading"), C = g.inValueBool("Clear", true), a = g.inValueBool("ClearAlpha", true), r = g.inValueBool("Fullscreen Button", false), s = g.inValueBool("Active", true), B = g.inValueBool("Hires Displays", false), Q = g.inSwitch("Pixel Unit", ["Display", "CSS"], "Display");
  g.onAnimFrame = N;
  B.onChange = function() {
    if (B.get())
      g.patch.cgl.pixelDensity = window.devicePixelRatio;
    else
      g.patch.cgl.pixelDensity = 1;
    g.patch.cgl.updateSize();
    if (CABLES.UI)
      gui.setLayout();
  };
  s.onChange = function() {
    g.patch.removeOnAnimFrame(g);
    if (s.get()) {
      g.setUiAttrib({ extendTitle: "" });
      g.onAnimFrame = N;
      g.patch.addOnAnimFrame(g);
      g.log("adding again!");
    } else {
      g.setUiAttrib({ extendTitle: "Inactive" });
    }
  };
  const E = g.patch.cgl;
  let l = 0;
  let u = 0;
  let c = null;
  let h = false;
  if (!g.patch.cgl)
    g.uiAttr({ error: "No webgl cgl context" });
  const p = vec3.create();
  vec3.set(p, 0, 0, 0);
  const d = vec3.create();
  vec3.set(d, 0, 0, -2);
  r.onChange = b;
  setTimeout(b, 100);
  let m = null;
  let f = true;
  let D = true;
  window.addEventListener("blur", () => {
    f = false;
  });
  window.addEventListener("focus", () => {
    f = true;
  });
  document.addEventListener("visibilitychange", () => {
    D = !document.hidden;
  });
  S();
  E.mainloopOp = this;
  Q.onChange = () => {
    i.set(0);
    I.set(0);
  };
  function y() {
    if (o.get() && g.patch.loading.getProgress() < 1)
      return 5;
    if (n.get()) {
      if (!D)
        return 10;
      if (!f)
        return 30;
    }
    return e.get();
  }
  function b() {
    function A2() {
      if (m)
        m.style.display = "block";
    }
    function e2() {
      if (m)
        m.style.display = "none";
    }
    g.patch.cgl.canvas.addEventListener("mouseleave", e2);
    g.patch.cgl.canvas.addEventListener("mouseenter", A2);
    if (r.get()) {
      if (!m) {
        m = document.createElement("div");
        const t2 = g.patch.cgl.canvas.parentElement;
        if (t2)
          t2.appendChild(m);
        m.addEventListener("mouseenter", A2);
        m.addEventListener("click", function(A3) {
          if (CABLES.UI && !A3.shiftKey)
            gui.cycleFullscreen();
          else
            E.fullScreen();
        });
      }
      m.style.padding = "10px";
      m.style.position = "absolute";
      m.style.right = "5px";
      m.style.top = "5px";
      m.style.width = "20px";
      m.style.height = "20px";
      m.style.cursor = "pointer";
      m.style["border-radius"] = "40px";
      m.style.background = "#444";
      m.style["z-index"] = "9999";
      m.style.display = "none";
      m.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Capa_1" x="0px" y="0px" viewBox="0 0 490 490" style="width:20px;height:20px;" xml:space="preserve" width="512px" height="512px"><g><path d="M173.792,301.792L21.333,454.251v-80.917c0-5.891-4.776-10.667-10.667-10.667C4.776,362.667,0,367.442,0,373.333V480     c0,5.891,4.776,10.667,10.667,10.667h106.667c5.891,0,10.667-4.776,10.667-10.667s-4.776-10.667-10.667-10.667H36.416     l152.459-152.459c4.093-4.237,3.975-10.99-0.262-15.083C184.479,297.799,177.926,297.799,173.792,301.792z" fill="#FFFFFF"/><path d="M480,0H373.333c-5.891,0-10.667,4.776-10.667,10.667c0,5.891,4.776,10.667,10.667,10.667h80.917L301.792,173.792     c-4.237,4.093-4.354,10.845-0.262,15.083c4.093,4.237,10.845,4.354,15.083,0.262c0.089-0.086,0.176-0.173,0.262-0.262     L469.333,36.416v80.917c0,5.891,4.776,10.667,10.667,10.667s10.667-4.776,10.667-10.667V10.667C490.667,4.776,485.891,0,480,0z" fill="#FFFFFF"/><path d="M36.416,21.333h80.917c5.891,0,10.667-4.776,10.667-10.667C128,4.776,123.224,0,117.333,0H10.667     C4.776,0,0,4.776,0,10.667v106.667C0,123.224,4.776,128,10.667,128c5.891,0,10.667-4.776,10.667-10.667V36.416l152.459,152.459     c4.237,4.093,10.99,3.975,15.083-0.262c3.992-4.134,3.992-10.687,0-14.82L36.416,21.333z" fill="#FFFFFF"/><path d="M480,362.667c-5.891,0-10.667,4.776-10.667,10.667v80.917L316.875,301.792c-4.237-4.093-10.99-3.976-15.083,0.261     c-3.993,4.134-3.993,10.688,0,14.821l152.459,152.459h-80.917c-5.891,0-10.667,4.776-10.667,10.667s4.776,10.667,10.667,10.667     H480c5.891,0,10.667-4.776,10.667-10.667V373.333C490.667,367.442,485.891,362.667,480,362.667z" fill="#FFFFFF"/></g></svg>';
    } else {
      if (m) {
        m.style.display = "none";
        m.remove();
        m = null;
      }
    }
  }
  g.onDelete = function() {
    E.gl.clearColor(0, 0, 0, 0);
    E.gl.clear(E.gl.COLOR_BUFFER_BIT | E.gl.DEPTH_BUFFER_BIT);
  };
  function N(A2) {
    if (!s.get())
      return;
    if (E.aborted || E.canvas.clientWidth === 0 || E.canvas.clientHeight === 0)
      return;
    g.patch.cg = E;
    if (B.get())
      g.patch.cgl.pixelDensity = window.devicePixelRatio;
    const e2 = performance.now();
    g.patch.config.fpsLimit = y();
    if (E.canvasWidth == -1) {
      E.setCanvas(g.patch.config.glCanvasId);
      return;
    }
    if (E.canvasWidth != i.get() || E.canvasHeight != I.get()) {
      let A3 = 1;
      if (Q.get() == "CSS")
        A3 = g.patch.cgl.pixelDensity;
      i.set(E.canvasWidth / A3);
      I.set(E.canvasHeight / A3);
    }
    if (CABLES.now() - u > 1e3) {
      CGL.fpsReport = CGL.fpsReport || [];
      if (g.patch.loading.getProgress() >= 1 && u !== 0)
        CGL.fpsReport.push(l);
      l = 0;
      u = CABLES.now();
    }
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;
    E.renderStart(E, p, d);
    if (C.get()) {
      E.gl.clearColor(0, 0, 0, 1);
      E.gl.clear(E.gl.COLOR_BUFFER_BIT | E.gl.DEPTH_BUFFER_BIT);
    }
    t.trigger();
    if (CGL.MESH.lastMesh)
      CGL.MESH.lastMesh.unBind();
    if (CGL.Texture.previewTexture) {
      if (!CGL.Texture.texturePreviewer)
        CGL.Texture.texturePreviewer = new CGL.Texture.texturePreview(E);
      CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture);
    }
    E.renderEnd(E);
    g.patch.cg = null;
    if (a.get()) {
      E.gl.clearColor(1, 1, 1, 1);
      E.gl.colorMask(false, false, false, true);
      E.gl.clear(E.gl.COLOR_BUFFER_BIT);
      E.gl.colorMask(true, true, true, true);
    }
    if (!E.frameStore.phong)
      E.frameStore.phong = {};
    l++;
    g.patch.cgl.profileData.profileMainloopMs = performance.now() - e2;
  }
  function S() {
    clearTimeout(c);
    c = setTimeout(() => {
      if (g.patch.getOpsByObjName(g.name).length > 1) {
        g.setUiError("multimainloop", "there should only be one mainloop op!");
        if (!h)
          h = g.patch.addEventListener("onOpDelete", S);
      } else
        g.setUiError("multimainloop", null, 1);
    }, 500);
  }
};
Ops.Gl.MainLoop.prototype = new CABLES.Op();
CABLES.OPS["b0472a1d-db16-4ba6-8787-f300fbdc77bb"] = { f: Ops.Gl.MainLoop, objName: "Ops.Gl.MainLoop" };
Ops.Trigger.Sequence = function() {
  CABLES.Op.apply(this, arguments);
  const I = this;
  const A = I.attachments = {};
  const e = I.inTrigger("exe"), t = I.inTriggerButton("Clean up connections");
  I.setUiAttrib({ resizable: true, resizableY: false, stretchPorts: true });
  const g = [], n = [], i = 16;
  let o = null, C = [];
  e.onTriggered = s;
  t.onTriggered = B;
  t.setUiAttribs({ hideParam: true, hidePort: true });
  for (let e2 = 0; e2 < i; e2++) {
    const Q = I.outTrigger("trigger " + e2);
    n.push(Q);
    Q.onLinkChanged = r;
    if (e2 < i - 1) {
      let A2 = I.inTrigger("exe " + e2);
      A2.onTriggered = s;
      g.push(A2);
    }
  }
  a();
  function a() {
    C.length = 0;
    for (let A2 = 0; A2 < n.length; A2++)
      if (n[A2].links.length > 0)
        C.push(n[A2]);
  }
  function r() {
    a();
    clearTimeout(o);
    o = setTimeout(() => {
      let e2 = false;
      for (let A2 = 0; A2 < n.length; A2++)
        if (n[A2].links.length > 1)
          e2 = true;
      t.setUiAttribs({ hideParam: !e2 });
      if (I.isCurrentUiOp())
        I.refreshParams();
    }, 60);
  }
  function s() {
    for (let A2 = 0; A2 < C.length; A2++)
      C[A2].trigger();
  }
  function B() {
    let g2 = 0;
    for (let t2 = 0; t2 < n.length; t2++) {
      let e2 = [];
      if (n[t2].links.length > 1)
        for (let A2 = 1; A2 < n[t2].links.length; A2++) {
          while (n[g2].links.length > 0)
            g2++;
          e2.push(n[t2].links[A2]);
          const i2 = n[t2].links[A2].getOtherPort(n[t2]);
          I.patch.link(I, "trigger " + g2, i2.op, i2.name);
          g2++;
        }
      for (let A2 = 0; A2 < e2.length; A2++)
        e2[A2].remove();
    }
    r();
    a();
  }
};
Ops.Trigger.Sequence.prototype = new CABLES.Op();
CABLES.OPS["a466bc1f-06e9-4595-8849-bffb9fe22f99"] = { f: Ops.Trigger.Sequence, objName: "Ops.Trigger.Sequence" };
Ops.Devices.Mouse.Mouse_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const L = A.attachments = {};
  const e = A.inSwitch("Coordinates", ["-1 to 1", "Pixel Display", "Pixel", "0 to 1"], "-1 to 1"), i = A.inValueSelect("Area", ["Canvas", "Document", "Parent Element", "Canvas Area"], "Canvas"), I = A.inValueBool("flip y", true), t = A.inBool("right click prevent default", true), g = A.inValueBool("Touch support", true), n = A.inValueBool("Passive Events", false), o = A.inValueBool("Active", true), C = A.outNumber("x", 0), a = A.outNumber("y", 0), r = A.outTrigger("click"), s = A.outTrigger("click right"), B = A.outBoolNum("Button is down"), Q = A.outBoolNum("Mouse is hovering"), E = A.outNumber("Movement X", 0), l = A.outNumber("Movement Y", 0);
  const u = A.patch.cgl;
  let c = 1;
  let h = null;
  let p = null;
  n.onChange = i.onChange = U;
  e.onChange = O;
  A.onDelete = M;
  U();
  A.on("loadedValueSet", d);
  function d() {
    if (c == 0) {
      if (p.clientWidth === 0)
        setTimeout(d, 50);
      C.set(p.clientWidth / 2);
      a.set(p.clientHeight / 2);
    } else if (c == 1) {
      C.set(0);
      a.set(0);
    } else if (c == 2) {
      C.set(0.5);
      a.set(0.5);
    } else if (c == 3) {
      if (p.clientWidth === 0) {
        setTimeout(d, 50);
      }
      C.set(p.clientWidth / 2 / u.pixelDensity);
      a.set(p.clientHeight / 2 / u.pixelDensity);
    } else
      console.error("unknown normalize mouse", c);
  }
  function v(i2, I2) {
    i2 = i2 || 0;
    I2 = I2 || 0;
    if (c == 0) {
      C.set(i2);
      a.set(I2);
    } else if (c == 3) {
      C.set(i2 * u.pixelDensity);
      a.set(I2 * u.pixelDensity);
    } else {
      let t2 = p.clientWidth / u.pixelDensity;
      let g2 = p.clientHeight / u.pixelDensity;
      t2 = t2 || 1;
      g2 = g2 || 1;
      if (c == 1) {
        let A2 = i2 / t2 * 2 - 1;
        let e2 = I2 / g2 * 2 - 1;
        A2 = CABLES.clamp(A2, -1, 1);
        e2 = CABLES.clamp(e2, -1, 1);
        C.set(A2);
        a.set(e2);
      } else if (c == 2) {
        let A2 = i2 / t2;
        let e2 = I2 / g2;
        A2 = CABLES.clamp(A2, 0, 1);
        e2 = CABLES.clamp(e2, 0, 1);
        C.set(A2);
        a.set(e2);
      }
    }
  }
  function m(A2) {
    const e2 = p.getBoundingClientRect();
    return A2.clientX > e2.left && A2.clientX < e2.left + e2.width && A2.clientY > e2.top && A2.clientY < e2.top + e2.height;
  }
  g.onChange = function() {
    M();
    U();
  };
  o.onChange = function() {
    if (h)
      M();
    if (o.get())
      U();
  };
  function O() {
    if (e.get() == "Pixel")
      c = 0;
    else if (e.get() == "-1 to 1")
      c = 1;
    else if (e.get() == "0 to 1")
      c = 2;
    else if (e.get() == "Pixel Display")
      c = 3;
  }
  function f(A2) {
    B.set(false);
    Q.set(m(A2));
  }
  function D(A2) {
    if (!m(A2))
      return;
    B.set(true);
  }
  function y(A2) {
    B.set(false);
  }
  function b(A2) {
    if (!m(A2))
      return;
    s.trigger();
    if (t.get())
      A2.preventDefault();
  }
  function N(A2) {
    if (!m(A2))
      return;
    r.trigger();
  }
  function S(A2) {
    B.set(false);
    Q.set(m(A2));
  }
  function w(A2) {
    let e2 = A2.clientX;
    let t2 = A2.clientY;
    if (i.get() != "Document") {
      e2 = A2.offsetX;
      t2 = A2.offsetY;
    }
    if (i.get() === "Canvas Area") {
      const g2 = p.getBoundingClientRect();
      e2 = A2.clientX - g2.left;
      t2 = A2.clientY - g2.top;
    }
    if (I.get())
      t2 = p.clientHeight - t2;
    v(e2 / u.pixelDensity, t2 / u.pixelDensity);
  }
  function R(A2) {
    Q.set(m(A2));
    w(A2);
    E.set(A2.movementX / u.pixelDensity);
    l.set(A2.movementY / u.pixelDensity);
  }
  function G(A2) {
    if (event.touches && event.touches.length > 0)
      w(A2.touches[0]);
  }
  function _(A2) {
    B.set(true);
    if (A2.touches && A2.touches.length > 0)
      D(A2.touches[0]);
  }
  function F(A2) {
    B.set(false);
    y();
  }
  function M() {
    if (!h)
      return;
    h.removeEventListener("touchend", F);
    h.removeEventListener("touchstart", _);
    h.removeEventListener("touchmove", G);
    h.removeEventListener("click", N);
    h.removeEventListener("mousemove", R);
    h.removeEventListener("mouseleave", S);
    h.removeEventListener("mousedown", D);
    h.removeEventListener("mouseup", y);
    h.removeEventListener("mouseenter", f);
    h.removeEventListener("contextmenu", b);
    h = null;
  }
  function U() {
    if (h || !o.get())
      M();
    if (!o.get())
      return;
    h = p = u.canvas;
    if (i.get() == "Canvas Area") {
      p = u.canvas.parentElement;
      h = document.body;
    }
    if (i.get() == "Document")
      p = h = document.body;
    if (i.get() == "Parent Element")
      h = p = u.canvas.parentElement;
    let A2 = false;
    if (n.get())
      A2 = { passive: true };
    if (g.get()) {
      h.addEventListener("touchend", F, A2);
      h.addEventListener("touchstart", _, A2);
      h.addEventListener("touchmove", G, A2);
    }
    h.addEventListener("mousemove", R, A2);
    h.addEventListener("mouseleave", S, A2);
    h.addEventListener("mousedown", D, A2);
    h.addEventListener("mouseup", y, A2);
    h.addEventListener("mouseenter", f, A2);
    h.addEventListener("contextmenu", b, A2);
    h.addEventListener("click", N, A2);
  }
};
Ops.Devices.Mouse.Mouse_v3.prototype = new CABLES.Op();
CABLES.OPS["6d1edbc0-088a-43d7-9156-918fb3d7f24b"] = { f: Ops.Devices.Mouse.Mouse_v3, objName: "Ops.Devices.Mouse.Mouse_v3" };
Ops.Math.DeltaSum = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const o = A.inValue("Delta Value"), t = A.inValue("Default Value", 0), C = A.inValue("Multiply", 1), g = A.inTriggerButton("Reset"), I = A.inValueBool("Limit", false), a = A.inValue("Min", 0), r = A.inValue("Max", 100), s = A.inValue("Rubberband", 0), n = A.outNumber("Absolute Value");
  o.changeAlways = true;
  A.setPortGroup("Limit", [I, a, r, s]);
  let B = 0;
  let Q = CABLES.now();
  let E = null;
  I.onChange = l;
  t.onChange = g.onTriggered = i;
  r.onChange = a.onChange = c;
  l();
  function i() {
    let A2 = t.get();
    if (I.get()) {
      A2 = Math.max(a.get(), A2);
      A2 = Math.min(r.get(), A2);
    }
    B = A2;
    n.set(B);
  }
  function l() {
    a.setUiAttribs({ greyout: !I.get() });
    r.setUiAttribs({ greyout: !I.get() });
    s.setUiAttribs({ greyout: !I.get() });
    c();
  }
  function u() {
    const A2 = a.get();
    const e2 = r.get();
    if (B < A2)
      B = A2;
    if (B > e2)
      B = e2;
    n.set(B);
  }
  function c() {
    if (I.get()) {
      const A2 = a.get();
      const e2 = r.get();
      const t2 = s.get();
      const g2 = a.get() - t2;
      const i2 = r.get() + t2;
      if (B < g2)
        B = g2;
      if (B > i2)
        B = i2;
      if (t2 !== 0) {
        clearTimeout(E);
        E = setTimeout(u.bind(this), 300);
      }
    }
    n.set(B);
  }
  o.onChange = function() {
    let A2 = o.get();
    const e2 = s.get();
    if (e2 !== 0) {
      const t2 = a.get();
      const g2 = r.get();
      const i2 = a.get() - e2;
      const I2 = r.get() + e2;
      if (B < t2) {
        const n2 = Math.abs(B - i2) / e2;
        A2 *= n2 * n2;
      }
      if (B > g2) {
        const n2 = Math.abs(I2 - B) / e2;
        A2 *= n2 * n2;
      }
    }
    Q = CABLES.now();
    B += A2 * C.get();
    c();
  };
};
Ops.Math.DeltaSum.prototype = new CABLES.Op();
CABLES.OPS["d9d4b3db-c24b-48da-b798-9e6230d861f7"] = { f: Ops.Math.DeltaSum, objName: "Ops.Math.DeltaSum" };
Ops.Ui.PatchInput = function() {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const A = i.attachments = {};
  const I = i.addOutPort(new CABLES.Port(i, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));
  function n() {
    for (let A2 in i.patch.ops) {
      if (i.patch.ops[A2].patchId) {
        if (i.patch.ops[A2].patchId.get() == i.uiAttribs.subPatch) {
          return i.patch.ops[A2];
        }
      }
    }
  }
  I.onLinkChanged = () => {
    const A2 = n();
    if (!I.links.length || !A2 || !A2.addNewInPort)
      return;
    const e = I.links[0].getOtherPort(I);
    I.removeLinks();
    const t = A2.addNewInPort(e);
    const g = gui.scene().link(e.parent, e.getName(), i, t);
    A2.saveData();
  };
};
Ops.Ui.PatchInput.prototype = new CABLES.Op();
CABLES.OPS["e3f68bc3-892a-4c78-9974-aca25c27025d"] = { f: Ops.Ui.PatchInput, objName: "Ops.Ui.PatchInput" };
Ops.Ui.PatchOutput = function() {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const A = i.attachments = {};
  const I = i.addInPort(new CABLES.Port(i, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));
  function n() {
    for (let A2 in i.patch.ops) {
      if (i.patch.ops[A2].patchId) {
        if (i.patch.ops[A2].patchId.get() == i.uiAttribs.subPatch) {
          return i.patch.ops[A2];
        }
      }
    }
  }
  I.onLinkChanged = () => {
    const A2 = n();
    if (!I.links.length)
      return;
    const e = I.links[0].getOtherPort(I);
    I.removeLinks();
    const t = A2.addNewOutPort(e);
    const g = gui.scene().link(e.parent, e.getName(), i, t);
    A2.saveData();
  };
};
Ops.Ui.PatchOutput.prototype = new CABLES.Op();
CABLES.OPS["851b44cb-5667-4140-9800-5aeb7031f1d7"] = { f: Ops.Ui.PatchOutput, objName: "Ops.Ui.PatchOutput" };
Ops.Ui.SubPatch = function() {
  CABLES.Op.apply(this, arguments);
  const a = this;
  const A = a.attachments = {};
  a.dyn = a.addInPort(new CABLES.Port(a, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));
  a.dynOut = a.addOutPort(new CABLES.Port(a, "create port out", CABLES.OP_PORT_TYPE_DYNAMIC));
  const e = a.addInPort(new CABLES.Port(a, "dataStr", CABLES.OP_PORT_TYPE_VALUE, { display: "readonly" }));
  a.patchId = a.addInPort(new CABLES.Port(a, "patchId", CABLES.OP_PORT_TYPE_VALUE, { display: "readonly" }));
  e.setUiAttribs({ hideParam: true });
  a.patchId.setUiAttribs({ hidePort: true });
  let r = { ports: [], portsOut: [] };
  let t = CABLES.generateUUID();
  a.patchId.set(t);
  E();
  Q();
  let s = false;
  a.saveData = n;
  a.init = () => {
    a.setStorage({ subPatchVer: 1 });
  };
  a.patchId.onChange = function() {
    if (!a.patch.isEditorMode())
      return;
    const e2 = a.patch.getSubPatchOps(t);
    if (e2.length === 2) {
      if (a.patch.isEditorMode() && CABLES.UI.DEFAULTOPS.isInBlueprint(a))
        CABLES.UI.undo.pause();
      for (let A2 = 0; A2 < e2.length; A2++) {
        a.patch.deleteOp(e2[A2].id);
      }
      if (a.patch.isEditorMode() && CABLES.UI.DEFAULTOPS.isInBlueprint(a))
        CABLES.UI.undo.resume();
    }
  };
  a.onLoaded = function() {
  };
  a.onLoadedValueSet = function() {
    r = JSON.parse(e.get());
    if (!r) {
      r = { ports: [], portsOut: [] };
    }
    I();
  };
  function g() {
  }
  e.onChange = function() {
    if (s)
      return;
    if (!e.get())
      return;
    try {
      g();
    } catch (A2) {
      a.logError("cannot load subpatch data...");
      a.logError(A2);
    }
  };
  function n() {
    try {
      e.set(JSON.stringify(r));
    } catch (A2) {
      a.log(A2);
    }
  }
  a.addPortListener = B;
  function B(t2, A2) {
    if (!t2.hasSubpatchLstener) {
      t2.hasSubpatchLstener = true;
      t2.addEventListener("onUiAttrChange", function(e2) {
        if (e2.title) {
          let A3 = 0;
          for (A3 = 0; A3 < r.portsOut.length; A3++)
            if (r.portsOut[A3].name == t2.name)
              r.portsOut[A3].title = e2.title;
          for (A3 = 0; A3 < r.ports.length; A3++)
            if (r.ports[A3].name == t2.name)
              r.ports[A3].title = e2.title;
          n();
        }
      });
    }
    if (t2.direction == CABLES.PORT_DIR_IN) {
      if (t2.type == CABLES.OP_PORT_TYPE_FUNCTION) {
        t2.onTriggered = function() {
          if (A2.isLinked())
            A2.trigger();
        };
      } else {
        t2.onChange = function() {
          A2.set(t2.get());
          if (!t2.isLinked()) {
            for (let A3 = 0; A3 < r.ports.length; A3++) {
              if (r.ports[A3].name === t2.name) {
                r.ports[A3].value = t2.get();
              }
            }
            n();
          }
        };
      }
    }
  }
  a.setupPorts = I;
  function I() {
    if (!a.patchId.get())
      return;
    const A2 = r.ports || [];
    const e2 = r.portsOut || [];
    let t2 = 0;
    for (t2 = 0; t2 < A2.length; t2++) {
      if (!a.getPortByName(A2[t2].name)) {
        const g2 = a.addInPort(new CABLES.Port(a, A2[t2].name, A2[t2].type));
        const i = E();
        const I2 = i.addOutPort(new CABLES.Port(i, A2[t2].name, A2[t2].type));
        g2.ignoreValueSerialize = true;
        g2.setUiAttribs({ editableTitle: true });
        if (A2[t2].title) {
          g2.setUiAttribs({ title: A2[t2].title });
          I2.setUiAttribs({ title: A2[t2].title });
        }
        if (A2[t2].objType) {
          g2.setUiAttribs({ objType: A2[t2].objType });
          I2.setUiAttribs({ objType: A2[t2].objType });
        }
        if (A2[t2].value) {
          g2.set(A2[t2].value);
          I2.set(A2[t2].value);
        }
        B(g2, I2);
      }
    }
    for (t2 = 0; t2 < e2.length; t2++) {
      if (!a.getPortByName(e2[t2].name)) {
        const n2 = a.addOutPort(new CABLES.Port(a, e2[t2].name, e2[t2].type));
        const o = Q();
        const C = o.addInPort(new CABLES.Port(o, e2[t2].name, e2[t2].type));
        n2.ignoreValueSerialize = true;
        n2.setUiAttribs({ editableTitle: true });
        if (e2[t2].title) {
          n2.setUiAttribs({ title: e2[t2].title });
          C.setUiAttribs({ title: e2[t2].title });
        }
        if (e2[t2].objType) {
          n2.setUiAttribs({ objType: e2[t2].objType });
          C.setUiAttribs({ objType: e2[t2].objType });
        }
        B(C, n2);
      }
    }
    s = true;
  }
  a.addNewInPort = function(A2, e2, t2) {
    const g2 = "in" + r.ports.length + " " + A2.op.name + " " + A2.name;
    const i = { name: g2, type: A2.type };
    if (A2.uiAttribs.objType)
      i.objType = A2.uiAttribs.objType;
    r.ports.push(i);
    I();
    return g2;
  };
  a.dyn.onLinkChanged = function() {
    if (a.dyn.isLinked()) {
      const A2 = a.dyn.links[0].getOtherPort(a.dyn);
      a.dyn.removeLinks();
      A2.removeLinkTo(a.dyn);
      a.log("dyn link changed!!!");
      const e2 = a.addNewInPort(A2);
      const t2 = gui.scene().link(A2.op, A2.getName(), a, e2);
      s = true;
      n();
    } else {
      setTimeout(function() {
        a.dyn.removeLinks();
      }, 100);
    }
  };
  a.addNewOutPort = function(A2, e2, t2) {
    const g2 = "out" + r.portsOut.length + " " + A2.op.name + " " + A2.name;
    const i = { name: g2, type: A2.type };
    if (A2.uiAttribs.objType)
      i.objType = A2.uiAttribs.objType;
    r.portsOut.push(i);
    I();
    return g2;
  };
  a.dynOut.onLinkChanged = function() {
    if (a.dynOut.isLinked()) {
      const A2 = a.dynOut.links[0].getOtherPort(a.dynOut);
      a.dynOut.removeLinks();
      if (A2) {
        A2.removeLinkTo(a.dynOut);
        const e2 = a.addNewOutPort(A2);
        gui.scene().link(A2.op, A2.getName(), a, e2);
      }
      s = true;
      n();
    } else {
      setTimeout(function() {
        a.dynOut.removeLinks();
      }, 100);
      a.log("dynOut unlinked...");
    }
  };
  function Q() {
    let A2 = a.patch.getSubPatchOp(a.patchId.get(), "Ops.Ui.PatchOutput");
    if (!A2) {
      a.patch.addOp("Ops.Ui.PatchOutput", { subPatch: a.patchId.get(), translate: { x: 0, y: 0 } });
      A2 = a.patch.getSubPatchOp(a.patchId.get(), "Ops.Ui.PatchOutput");
      if (!A2)
        a.warn("no patchoutput!");
    }
    return A2;
  }
  function E() {
    let A2 = a.patch.getSubPatchOp(a.patchId.get(), "Ops.Ui.PatchInput");
    if (!A2) {
      a.patch.addOp("Ops.Ui.PatchInput", { subPatch: a.patchId.get(), translate: { x: 0, y: 0 } });
      A2 = a.patch.getSubPatchOp(a.patchId.get(), "Ops.Ui.PatchInput");
      if (!A2)
        a.warn("no patchinput2!");
    }
    return A2;
  }
  a.addSubLink = function(A2, e2) {
    const t2 = r.ports.length;
    const g2 = "in" + (t2 - 1) + " " + e2.op.name + " " + e2.name;
    if (A2.direction == CABLES.PORT_DIR_IN) {
      gui.scene().link(A2.op, A2.getName(), E(), g2);
    } else {
      const I2 = r.portsOut.length;
      gui.scene().link(A2.op, A2.getName(), Q(), "out" + (I2 - 1) + " " + e2.op.name + " " + e2.name);
    }
    const i = gui.patchView.getSubPatchBounds(a.patchId.get());
    E().uiAttr({ translate: { x: i.minx, y: i.miny - 100 } });
    Q().uiAttr({ translate: { x: i.minx, y: i.maxy + 100 } });
    n();
    return g2;
  };
  a.onDelete = function() {
    for (let A2 = a.patch.ops.length - 1; A2 >= 0; A2--) {
      if (a.patch.ops[A2] && a.patch.ops[A2].uiAttribs && a.patch.ops[A2].uiAttribs.subPatch == a.patchId.get()) {
        a.patch.deleteOp(a.patch.ops[A2].id);
      }
    }
  };
  a.rebuildListeners = () => {
    a.log("rebuild listeners...");
    const e2 = Q();
    for (let A2 = 0; A2 < e2.portsIn.length; A2++) {
      if (e2.portsIn[A2].isLinked()) {
        B(e2.portsIn[A2], this.portsOut[A2]);
      }
    }
  };
};
Ops.Ui.SubPatch.prototype = new CABLES.Op();
CABLES.OPS["84d9a6f0-ed7a-466d-b386-225ed9e89c60"] = { f: Ops.Ui.SubPatch, objName: "Ops.Ui.SubPatch" };
Ops.Gl.ClearColor = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("render"), g = A.outTrigger("trigger"), i = A.inFloatSlider("r", 0.1), I = A.inFloatSlider("g", 0.1), n = A.inFloatSlider("b", 0.1), o = A.inFloatSlider("a", 1);
  i.setUiAttribs({ colorPick: true });
  const C = A.patch.cgl;
  t.onTriggered = function() {
    C.gl.clearColor(i.get(), I.get(), n.get(), o.get());
    C.gl.clear(C.gl.COLOR_BUFFER_BIT | C.gl.DEPTH_BUFFER_BIT);
    g.trigger();
  };
};
Ops.Gl.ClearColor.prototype = new CABLES.Op();
CABLES.OPS["19b441eb-9f63-4f35-ba08-b87841517c4d"] = { f: Ops.Gl.ClearColor, objName: "Ops.Gl.ClearColor" };
Ops.Patch.PmhkN4m.MouseDrag = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inValueBool("Active", true), g = e.inValue("Speed", 0.01), i = e.inSwitch("Input Type", ["All", "Mouse", "Touch"], "All"), I = e.inSwitch("Area", ["Canvas Area", "Canvas", "Document"], "Canvas Area"), n = e.outNumber("Delta X"), o = e.outNumber("Delta Y"), C = e.outNumber("Is Dragging");
  let a = null;
  let r = null;
  const s = 0;
  const B = 0;
  let Q = false;
  let E = 0;
  let l = 0;
  let u = true;
  i.onChange = I.onChange = f;
  f();
  function c(A2) {
    if (I.get() === "Canvas Area") {
      const e2 = r.getBoundingClientRect();
      return A2.clientX > e2.left && A2.clientX < e2.left + e2.width && A2.clientY > e2.top && A2.clientY < e2.top + e2.height;
    }
    return true;
  }
  function h(A2) {
    if (A2.touches)
      A2 = A2.touches[0];
    if (Q && A2 && c(A2)) {
      if (!u) {
        C.set(true);
        const e2 = (A2.clientX - E) * g.get();
        const t2 = (A2.clientY - l) * g.get();
        n.set(0);
        o.set(0);
        n.set(e2);
        o.set(t2);
      }
      u = false;
      E = A2.clientX;
      l = A2.clientY;
    }
  }
  function p(A2) {
    try {
      a.setPointerCapture(A2.pointerId);
    } catch (A3) {
    }
    Q = true;
  }
  function d(A2) {
    try {
      a.releasePointerCapture(A2.pointerId);
    } catch (A3) {
    }
    Q = false;
    C.set(false);
    E = 0;
    l = 0;
    u = true;
  }
  function m() {
    const A2 = e.patch.cg.canvas;
    if (document.pointerLockElement === A2 || document.mozPointerLockElement === A2 || document.webkitPointerLockElement === A2) {
      document.addEventListener("mousemove", onmousemove, false);
    }
  }
  function f() {
    y();
    if (I.get() == "Canvas Area") {
      a = document;
      r = e.patch.cgl.canvas;
    } else if (I.get() == "Document")
      a = r = document;
    else
      a = r = e.patch.cgl.canvas;
    if (t.get())
      D();
  }
  function D() {
    if (!a)
      f();
    if (i.get() == "All" || i.get() == "Mouse") {
      a.addEventListener("mousemove", h);
      a.addEventListener("mousedown", p);
      a.addEventListener("mouseup", d);
      a.addEventListener("mouseenter", d);
      a.addEventListener("mouseleave", d);
    }
    if (i.get() == "All" || i.get() == "Touch") {
      a.addEventListener("touchmove", h);
      a.addEventListener("touchend", d);
      a.addEventListener("touchstart", p);
    }
  }
  function y() {
    if (!a)
      return;
    a.removeEventListener("mousemove", h);
    a.removeEventListener("mousedown", p);
    a.removeEventListener("mouseup", d);
    a.removeEventListener("mouseenter", d);
    a.removeEventListener("mouseleave", d);
    a.removeEventListener("touchmove", h);
    a.removeEventListener("touchend", d);
    a.removeEventListener("touchstart", p);
  }
  t.onChange = function() {
    if (t.get())
      D();
    else
      y();
  };
  e.onDelete = function() {
    y();
  };
};
Ops.Patch.PmhkN4m.MouseDrag.prototype = new CABLES.Op();
CABLES.OPS["5a3d7332-e06e-4f88-a82e-8920449079b2"] = { f: Ops.Patch.PmhkN4m.MouseDrag, objName: "Ops.Patch.PmhkN4m.MouseDrag" };
Ops.Trigger.TriggerSend = function() {
  CABLES.Op.apply(this, arguments);
  const g = this;
  const A = g.attachments = {};
  const e = g.inTriggerButton("Trigger");
  g.varName = g.inValueSelect("Named Trigger", [], "", true);
  g.varName.onChange = i;
  e.onTriggered = I;
  g.patch.addEventListener("namedTriggersChanged", t);
  t();
  function t() {
    if (CABLES.UI) {
      const A2 = [];
      const e2 = g.patch.namedTriggers;
      A2.push("+ create new one");
      for (const t2 in e2)
        A2.push(t2);
      g.varName.uiAttribs.values = A2;
    }
  }
  function i() {
    if (CABLES.UI) {
      if (g.varName.get() == "+ create new one") {
        new CABLES.UI.ModalDialog({ prompt: true, title: "New Trigger", text: "Enter a name for the new trigger", promptValue: "", promptOk: (A2) => {
          g.varName.set(A2);
          g.patch.namedTriggers[A2] = g.patch.namedTriggers[A2] || [];
          t();
        } });
        return;
      }
      g.refreshParams();
    }
    if (!g.patch.namedTriggers[g.varName.get()]) {
      g.patch.namedTriggers[g.varName.get()] = g.patch.namedTriggers[g.varName.get()] || [];
      g.patch.emitEvent("namedTriggersChanged");
    }
    g.setTitle(">" + g.varName.get());
    g.refreshParams();
    g.patch.emitEvent("opTriggerNameChanged", g, g.varName.get());
  }
  function I() {
    const e2 = g.patch.namedTriggers[g.varName.get()];
    g.patch.emitEvent("namedTriggerSent", g.varName.get());
    if (!e2) {
      g.setUiError("unknowntrigger", "unknown trigger");
      return;
    } else
      g.setUiError("unknowntrigger", null);
    for (let A2 = 0; A2 < e2.length; A2++) {
      e2[A2]();
    }
  }
};
Ops.Trigger.TriggerSend.prototype = new CABLES.Op();
CABLES.OPS["ce1eaf2b-943b-4dc0-ab5e-ee11b63c9ed0"] = { f: Ops.Trigger.TriggerSend, objName: "Ops.Trigger.TriggerSend" };
Ops.Ui.Area = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("Title", "");
  t.setUiAttribs({ hidePort: true });
  A.setUiAttrib({ hasArea: true });
  A.init = t.onChange = A.onLoaded = g;
  g();
  function g() {
    if (CABLES.UI) {
      gui.savedState.setUnSaved("areaOp");
      A.uiAttr({ comment_title: t.get() || " " });
      A.name = t.get();
    }
  }
};
Ops.Ui.Area.prototype = new CABLES.Op();
CABLES.OPS["38f79614-b0de-4960-8da5-2827e7f43415"] = { f: Ops.Ui.Area, objName: "Ops.Ui.Area" };
Ops.Graphics.Intersection.IntersectWorld = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Trigger"), g = A.inBool("Check Body Collisions", false), i = A.outTrigger("Next"), I = A.outNumber("Total Bodies"), n = A.outArray("Collisions", []);
  t.onTriggered = s;
  const C = 1;
  const a = 2;
  const r = 3;
  const o = A.patch.cgl;
  function s() {
    o.frameStore.collisionWorld = { bodies: [], testCollision: B };
    i.trigger();
    I.set(o.frameStore.collisionWorld.bodies.length);
    if (g.get())
      Q();
  }
  function B(I2, n2) {
    if (I2.type === C && n2.type === C) {
      const t2 = vec3.distance(I2.pos, n2.pos);
      if (t2 < I2.radius + n2.radius) {
        return { body0: I2, name0: I2.name, body1: n2, name1: n2.name };
      }
    } else if (I2.type === r && n2.type === r) {
      if (I2.pos[0] === n2.pos[0] && I2.pos[1] === n2.pos[1] && I2.pos[2] === n2.pos[2]) {
        return { body0: I2, name0: I2.name, body1: n2, name1: n2.name };
      }
    } else if (n2.type === C && I2.type === r || I2.type === C && n2.type === r) {
      let A2 = I2;
      let e2 = n2;
      if (I2.type === C) {
        A2 = n2;
        e2 = I2;
      }
      const g2 = Math.abs(A2.pos[0] - e2.pos[0]);
      const i2 = Math.abs(A2.pos[1] - e2.pos[1]);
      const o2 = Math.abs(A2.pos[2] - e2.pos[2]);
      const t2 = Math.sqrt(g2 * g2 + i2 * i2 + o2 * o2);
      if (t2 < e2.radius) {
        return { body0: I2, name0: I2.name, body1: n2, name1: n2.name };
      }
    } else if (n2.type === a && I2.type === r || I2.type === a && n2.type === r) {
      let A2 = I2;
      let e2 = n2;
      if (I2.type === a) {
        A2 = n2;
        e2 = I2;
      }
      if (A2.pos[0] > e2.minX && A2.pos[0] < e2.maxX && (A2.pos[1] > e2.minY && A2.pos[1] < e2.maxY) && (A2.pos[2] > e2.minZ && A2.pos[2] < e2.maxZ)) {
        return { body0: I2, name0: I2.name, body1: n2, name1: n2.name };
      }
    } else if (I2.type === C && n2.type === a || I2.type === a && n2.type === C) {
      let A2 = I2;
      let e2 = n2;
      if (n2.type === a) {
        A2 = n2;
        e2 = I2;
      }
      let t2 = e2.radius * e2.radius;
      let g2 = 0;
      let i2 = e2.radius * e2.radius;
      if (e2.pos[0] < A2.minX)
        i2 -= (e2.pos[0] - A2.minX) ** 2;
      else if (e2.pos[0] > A2.maxX)
        i2 -= (e2.pos[0] - A2.maxX) ** 2;
      if (e2.pos[1] < A2.minY)
        i2 -= (e2.pos[1] - A2.minY) ** 2;
      else if (e2.pos[1] > A2.maxY)
        i2 -= (e2.pos[1] - A2.maxY) ** 2;
      if (e2.pos[2] < A2.minZ)
        i2 -= (e2.pos[2] - A2.minZ) ** 2;
      else if (e2.pos[2] > A2.maxZ)
        i2 -= (e2.pos[2] - A2.maxZ) ** 2;
      if (i2 > 0) {
        return { body0: I2, name0: I2.name, body1: n2, name1: n2.name };
      }
    } else {
      console.warn("unknown collision pair...", I2.type, n2.type);
    }
  }
  function Q() {
    const t2 = [];
    const g2 = o.frameStore.collisionWorld.bodies;
    for (let e2 = 0; e2 < g2.length; e2++) {
      for (let A2 = e2 + 1; A2 < g2.length; A2++) {
        if (A2 != e2) {
          const i2 = B(g2[A2], g2[e2]);
          if (i2)
            t2.push(i2);
        }
      }
    }
    n.setRef(t2, []);
  }
};
Ops.Graphics.Intersection.IntersectWorld.prototype = new CABLES.Op();
CABLES.OPS["6ebdec23-6e10-48c9-87cf-43d488e4290f"] = { f: Ops.Graphics.Intersection.IntersectWorld, objName: "Ops.Graphics.Intersection.IntersectWorld" };
Ops.Graphics.Intersection.IntersectTestRaycast = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Trigger"), p = A.inSwitch("Coordinate Format", ["-1 to 1", "XYZ-XYZ"], "-1 to 1"), d = A.inValueFloat("X"), m = A.inValueFloat("Y"), f = A.inValueFloat("Z"), D = A.inValueFloat("To X"), y = A.inValueFloat("To Y"), b = A.inValueFloat("To Z"), g = A.inBool("Active", true), i = A.inBool("Change Cursor", true), N = A.outTrigger("Next"), S = A.outBoolNum("Has Hit", false), w = A.outString("Hit Body Name", ""), R = A.outNumber("Hit X"), G = A.outNumber("Hit Y"), _ = A.outNumber("Hit Z");
  const F = A.patch.cgl;
  const M = vec3.create();
  const U = mat4.create();
  const L = vec3.create();
  let I = false;
  let n = true;
  A.toWorkPortsNeedToBeLinked(t);
  t.onTriggered = C;
  p.onChange = o;
  o();
  function o() {
    f.setUiAttribs({ greyout: p.get() != "XYZ-XYZ" });
    D.setUiAttribs({ greyout: p.get() != "XYZ-XYZ" });
    y.setUiAttribs({ greyout: p.get() != "XYZ-XYZ" });
    b.setUiAttribs({ greyout: p.get() != "XYZ-XYZ" });
  }
  function C() {
    N.trigger();
    if (F.frameStore.collisionWorld) {
      let e2 = vec3.create();
      if (p.get() == "-1 to 1") {
        e2 = vec3.fromValues(d.get(), m.get(), -1);
        mat4.mul(U, F.pMatrix, F.vMatrix);
        mat4.invert(U, U);
        vec3.transformMat4(e2, e2, U);
      }
      if (p.get() == "XYZ-XYZ") {
        e2 = vec3.fromValues(d.get(), m.get(), f.get());
      }
      let A2 = vec3.create();
      if (p.get() == "-1 to 1") {
        A2 = vec3.fromValues(d.get(), m.get(), 1);
        mat4.mul(U, F.pMatrix, F.vMatrix);
        mat4.invert(U, U);
        vec3.transformMat4(A2, A2, U);
      }
      if (p.get() == "XYZ-XYZ") {
        A2 = vec3.fromValues(D.get(), y.get(), b.get());
      }
      vec3.sub(L, A2, e2);
      vec3.normalize(L, L);
      const i2 = vec3.dot(L, L);
      let t2 = 9999999;
      let g2 = false;
      const I2 = F.frameStore.collisionWorld.bodies;
      for (let A3 = 0; A3 < I2.length; A3++) {
        const n2 = I2[A3];
        if (n2.type == 1) {
          vec3.sub(M, e2, n2.pos);
          const o2 = 2 * vec3.dot(M, L);
          const C2 = vec3.dot(M, M) - n2.radius * n2.radius;
          const a = o2 * o2 - 4 * i2 * C2;
          if (a > 0) {
            const r = (-o2 - Math.sqrt(a)) / (2 + i2);
            if (r < t2) {
              g2 = true;
              w.set(n2.name);
              S.set(true);
              t2 = r;
              vec3.mul(M, L, [r, r, r]);
              vec3.add(M, M, e2);
              R.set(M[0]);
              G.set(M[1]);
              _.set(M[2]);
            }
          }
        } else if (n2.type == 2) {
          const s = (n2.minX - e2[0]) / L[0];
          const B = (n2.maxX - e2[0]) / L[0];
          const Q = (n2.minY - e2[1]) / L[1];
          const E = (n2.maxY - e2[1]) / L[1];
          const l = (n2.minZ - e2[2]) / L[2];
          const u = (n2.maxZ - e2[2]) / L[2];
          const c = Math.max(Math.max(Math.min(s, B), Math.min(Q, E)), Math.min(l, u));
          const h = Math.min(Math.min(Math.max(s, B), Math.max(Q, E)), Math.max(l, u));
          if (h < 0)
            continue;
          if (c > h)
            continue;
          g2 = true;
          w.set(n2.name);
          S.set(true);
          vec3.mul(M, L, [c, c, c]);
          vec3.add(M, M, e2);
          R.set(M[0]);
          G.set(M[1]);
          _.set(M[2]);
        }
      }
      if (!g2) {
        w.set("");
        S.set(false);
        R.set(0);
        G.set(0);
        _.set(0);
      }
    }
  }
};
Ops.Graphics.Intersection.IntersectTestRaycast.prototype = new CABLES.Op();
CABLES.OPS["dd5d9b39-75c2-40b1-98a4-7a0fdafdb5cb"] = { f: Ops.Graphics.Intersection.IntersectTestRaycast, objName: "Ops.Graphics.Intersection.IntersectTestRaycast" };
Ops.Trigger.TriggerReceive = function() {
  CABLES.Op.apply(this, arguments);
  const g = this;
  const A = g.attachments = {};
  const e = g.outTrigger("Triggered");
  g.varName = g.inValueSelect("Named Trigger", [], "", true);
  I();
  g.patch.addEventListener("namedTriggersChanged", I);
  let t = null;
  function i() {
    e.trigger();
  }
  function I() {
    if (CABLES.UI) {
      let e2 = [];
      let t2 = g.patch.namedTriggers;
      for (let A2 in t2)
        e2.push(A2);
      g.varName.uiAttribs.values = e2;
    }
  }
  g.varName.onChange = function() {
    if (t) {
      let A3 = g.patch.namedTriggers[t];
      let e2 = A3.indexOf(i);
      if (e2 != -1)
        A3.splice(e2, 1);
    }
    g.setTitle(">" + g.varName.get());
    g.patch.namedTriggers[g.varName.get()] = g.patch.namedTriggers[g.varName.get()] || [];
    let A2 = g.patch.namedTriggers[g.varName.get()];
    A2.push(i);
    t = g.varName.get();
    n();
    g.patch.emitEvent("opTriggerNameChanged", g, g.varName.get());
  };
  g.on("uiParamPanel", n);
  function n() {
    if (!g.varName.get()) {
      g.setUiError("unknowntrigger", "unknown trigger");
    } else
      g.setUiError("unknowntrigger", null);
  }
};
Ops.Trigger.TriggerReceive.prototype = new CABLES.Op();
CABLES.OPS["0816c999-f2db-466b-9777-2814573574c5"] = { f: Ops.Trigger.TriggerReceive, objName: "Ops.Trigger.TriggerReceive" };
Ops.Graphics.Intersection.IntersectBody = function() {
  CABLES.Op.apply(this, arguments);
  const I = this;
  const A = I.attachments = {};
  const e = ["Sphere", "BoxAA", "Point"], t = I.inTrigger("Trigger"), g = I.inSwitch("Shape", e, "Sphere"), n = I.inString("Name", ""), o = I.inFloat("Radius", 0.5), C = I.inFloat("Size X", 1), a = I.inFloat("Size Y", 1), r = I.inFloat("Size Z", 1), s = I.inArray("Positions", null, 3), B = I.inBool("Append Index to name", true), Q = I.outTrigger("Next");
  I.setPortGroup("Array", [s, B]);
  const E = I.patch.cgl;
  const i = vec3.create();
  const l = vec3.create();
  p();
  let u = [];
  let c = { name: "???", type: 1 };
  t.onTriggered = b;
  function h() {
    return { name: c.name, type: c.type };
  }
  g.onChange = () => {
    c.type = e.indexOf(g.get()) + 1;
    p();
  };
  function p() {
    o.setUiAttribs({ greyout: g.get() != "Sphere" });
    C.setUiAttribs({ greyout: g.get() != "BoxAA" });
    a.setUiAttribs({ greyout: g.get() != "BoxAA" });
    r.setUiAttribs({ greyout: g.get() != "BoxAA" });
  }
  function d(A2) {
    A2.minX = A2.pos[0] - A2.size[0] / 2;
    A2.maxX = A2.pos[0] + A2.size[0] / 2;
    A2.minY = A2.pos[1] - A2.size[1] / 2;
    A2.maxY = A2.pos[1] + A2.size[1] / 2;
    A2.minZ = A2.pos[2] - A2.size[2] / 2;
    A2.maxZ = A2.pos[2] + A2.size[2] / 2;
  }
  const m = 1;
  const f = 2;
  const D = 3;
  function y(A2) {
    if (!CABLES.UI)
      return;
    if (!E.shouldDrawHelpers(I))
      return;
    if (A2.type === m) {
      E.pushModelMatrix();
      CABLES.UI.OverlayMeshes.drawSphere(I, A2.radius, true);
      E.popModelMatrix();
    } else if (A2.type === f) {
      E.pushModelMatrix();
      CABLES.UI.OverlayMeshes.drawCube(I, A2.size[0] / 2, A2.size[1] / 2, A2.size[2] / 2);
      E.popModelMatrix();
    } else if (A2.type === D) {
      E.pushModelMatrix();
      CABLES.UI.OverlayMeshes.drawAxisMarker(I, 0.05);
      E.popModelMatrix();
    } else
      console.warn("[intersectWorld] unknown col shape");
  }
  function b() {
    if (!E.frameStore || !E.frameStore.collisionWorld)
      return;
    const e2 = I.patch.cgl;
    const t2 = s.get();
    const g2 = o.get();
    if (t2 && t2.length > 0 && t2.length % 3 == 0) {
      u.length = t2.length / 3;
      for (let A2 = 0; A2 < t2.length; A2 += 3) {
        const i2 = u[A2 / 3] || {};
        if (B.get())
          i2.name = n.get() + "." + A2 / 3;
        else
          i2.name = n.get();
        i2.pos = [t2[A2 + 0], t2[A2 + 1], t2[A2 + 2]];
        vec3.transformMat4(i2.pos, i2.pos, e2.mMatrix);
        i2.type = c.type;
        i2.size = [C.get(), a.get(), r.get()];
        if (i2.type == 2)
          d(i2);
        if (i2.type == 1)
          i2.radius = g2;
        E.frameStore.collisionWorld.bodies.push(i2);
        y(i2);
      }
    } else {
      const A2 = h();
      E.frameStore.collisionWorld.bodies.push(A2);
      A2.name = n.get();
      A2.pos = [0, 0, 0];
      vec3.transformMat4(A2.pos, A2.pos, e2.mMatrix);
      A2.size = [C.get(), a.get(), r.get()];
      if (A2.type == 2)
        d(A2);
      if (A2.type == 1)
        A2.radius = g2;
      y(A2);
    }
    Q.trigger();
  }
};
Ops.Graphics.Intersection.IntersectBody.prototype = new CABLES.Op();
CABLES.OPS["b2e39096-8a02-4a50-b2f5-3e68f2c16ad7"] = { f: Ops.Graphics.Intersection.IntersectBody, objName: "Ops.Graphics.Intersection.IntersectBody" };
Ops.Gl.Matrix.Translate = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("render"), g = e.outTrigger("trigger"), i = e.inValue("x"), I = e.inValue("y"), n = e.inValue("z");
  const o = vec3.create();
  t.onTriggered = function() {
    const A2 = e.patch.cg;
    vec3.set(o, i.get(), I.get(), n.get());
    A2.pushModelMatrix();
    mat4.translate(A2.mMatrix, A2.mMatrix, o);
    g.trigger();
    A2.popModelMatrix();
  };
};
Ops.Gl.Matrix.Translate.prototype = new CABLES.Op();
CABLES.OPS["1f89ba0e-e7eb-46d7-8c66-7814b7c528b9"] = { f: Ops.Gl.Matrix.Translate, objName: "Ops.Gl.Matrix.Translate" };
Ops.Trigger.Repeat2d = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("exe"), n = A.inValueInt("num x", 5), o = A.inValueInt("num y", 5), C = A.inValueFloat("mul", 1), a = A.inValueBool("center"), r = A.outTrigger("trigger"), s = A.outNumber("x"), B = A.outNumber("y"), Q = A.outNumber("index"), E = A.outNumber("total iterations");
  t.onTriggered = function() {
    let t2 = 0;
    let A2 = 0;
    const g = C.get();
    const i = n.get();
    const I = o.get();
    if (a.get()) {
      t2 = (i - 1) * g / 2;
      A2 = (I - 1) * g / 2;
    }
    for (let e2 = 0; e2 < I; e2++) {
      B.set(e2 * g - A2);
      for (let A3 = 0; A3 < i; A3++) {
        s.set(A3 * g - t2);
        Q.set(A3 + e2 * i);
        r.trigger();
      }
    }
    E.set(n.get() * o.get());
  };
};
Ops.Trigger.Repeat2d.prototype = new CABLES.Op();
CABLES.OPS["79934693-5887-4173-8b48-3e3a18fcf225"] = { f: Ops.Trigger.Repeat2d, objName: "Ops.Trigger.Repeat2d" };
Ops.Vars.VarSetString_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("Value", "New String");
  A.varName = A.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(A, "string", t, A.varName);
};
Ops.Vars.VarSetString_v2.prototype = new CABLES.Op();
CABLES.OPS["0b4d9229-8024-4a30-9cc0-f6653942c2e4"] = { f: Ops.Vars.VarSetString_v2, objName: "Ops.Vars.VarSetString_v2" };
Ops.Math.Compare.Equals = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("number1", 1), g = A.inValue("number2", 1), i = A.outBoolNum("result");
  t.onChange = g.onChange = I;
  I();
  function I() {
    i.set(t.get() == g.get());
  }
};
Ops.Math.Compare.Equals.prototype = new CABLES.Op();
CABLES.OPS["4dd3cc55-eebc-4187-9d4e-2e053a956fab"] = { f: Ops.Math.Compare.Equals, objName: "Ops.Math.Compare.Equals" };
Ops.Array.ArrayGetNumber = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inArray("array"), g = A.inValueInt("index"), i = A.inFloat("Value Invalid Index", 0), I = A.outNumber("value"), n = A.outBoolNum("Valid Index", true);
  t.ignoreValueSerialize = true;
  g.onChange = t.onChange = o;
  function o() {
    if (t.get()) {
      const A2 = t.get()[g.get()];
      if (isNaN(A2)) {
        I.set(i.get());
        n.set(false);
      } else {
        n.set(true);
        I.set(parseFloat(A2));
      }
    }
  }
};
Ops.Array.ArrayGetNumber.prototype = new CABLES.Op();
CABLES.OPS["d1189078-70cf-437d-9a37-b2ebe89acdaf"] = { f: Ops.Array.ArrayGetNumber, objName: "Ops.Array.ArrayGetNumber" };
Ops.Vars.VarSetArray_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inArray("Value", null);
  A.varName = A.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(A, "array", t, A.varName);
};
Ops.Vars.VarSetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["8088290f-45d4-4312-b4ca-184d34ca4667"] = { f: Ops.Vars.VarSetArray_v2, objName: "Ops.Vars.VarSetArray_v2" };
Ops.Vars.VarGetArray_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.outArray("Value");
  A.varName = A.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(A, "array", A.varName, t);
};
Ops.Vars.VarGetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["afa79294-aa9c-43bc-a49a-cade000a1de5"] = { f: Ops.Vars.VarGetArray_v2, objName: "Ops.Vars.VarGetArray_v2" };
Ops.Gl.Matrix.Camera = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const L = A.attachments = {};
  const e = A.inTrigger("render");
  const t = A.outTrigger("trigger");
  const g = A.inValueSelect("projection mode", ["prespective", "ortogonal"], "prespective");
  const i = A.inValue("frustum near", 0.01);
  const I = A.inValue("frustum far", 5e3);
  const n = A.inValue("fov", 45);
  const o = A.inValueBool("Auto Aspect Ratio", true);
  const C = A.inValue("Aspect Ratio", 1);
  const a = A.inValue("eye X", 0);
  const r = A.inValue("eye Y", 0);
  const s = A.inValue("eye Z", 5);
  const B = A.inValue("center X", 0);
  const Q = A.inValue("center Y", 0);
  const E = A.inValue("center Z", 0);
  const l = A.inValue("truck", 0);
  const u = A.inValue("boom", 0);
  const c = A.inValue("dolly", 0);
  const h = A.inValue("tilt", 0);
  const p = A.inValue("pan", 0);
  const d = A.inValue("roll", 0);
  const m = A.outNumber("Aspect");
  const f = A.outArray("Look At Array");
  const D = A.patch.cgl;
  let y = 0;
  const b = vec3.create();
  const N = vec3.create();
  const S = vec3.create();
  const w = mat4.create();
  mat4.identity(w);
  const R = [];
  const G = vec3.create();
  const _ = mat4.create();
  mat4.identity(_);
  let F = true;
  e.onTriggered = function() {
    if (D.frameStore.shadowPass)
      return t.trigger();
    if (!o.get())
      y = C.get();
    else
      y = D.getViewPort()[2] / D.getViewPort()[3];
    m.set(y);
    D.pushViewMatrix();
    if (F) {
      mat4.identity(_);
      vec3.set(G, l.get(), u.get(), c.get());
      if (l.get() !== 0 || u.get() !== 0 || c.get() !== 0)
        mat4.translate(_, _, G);
      if (h.get() !== 0)
        mat4.rotateX(_, _, h.get() * CGL.DEG2RAD);
      if (p.get() !== 0)
        mat4.rotateY(_, _, p.get() * CGL.DEG2RAD);
      if (d.get() !== 0)
        mat4.rotateZ(_, _, d.get() * CGL.DEG2RAD);
      F = false;
    }
    mat4.multiply(D.vMatrix, D.vMatrix, _);
    D.pushPMatrix();
    D.pushViewMatrix();
    if (g.get() == "prespective") {
      mat4.perspective(D.pMatrix, n.get() * 0.0174533, y, i.get(), I.get());
    } else if (g.get() == "ortogonal") {
      mat4.ortho(D.pMatrix, -1 * (n.get() / 14), 1 * (n.get() / 14), -1 * (n.get() / 14) / y, 1 * (n.get() / 14) / y, i.get(), I.get());
    }
    R[0] = a.get();
    R[1] = r.get();
    R[2] = s.get();
    R[3] = B.get();
    R[4] = Q.get();
    R[5] = E.get();
    R[6] = 0;
    R[7] = 1;
    R[8] = 0;
    f.setRef(R);
    vec3.set(b, 0, 1, 0);
    vec3.set(N, a.get(), r.get(), s.get());
    vec3.set(S, B.get(), Q.get(), E.get());
    mat4.lookAt(w, N, S, b);
    mat4.multiply(D.vMatrix, D.vMatrix, w);
    t.trigger();
    D.popViewMatrix();
    D.popPMatrix();
    D.popViewMatrix();
    if (A.isCurrentUiOp())
      gui.setTransformGizmo({ posX: l, posY: u, posZ: c });
  };
  const M = function() {
    if (!o.get()) {
      C.setUiAttribs({ greyout: false });
    } else {
      C.setUiAttribs({ greyout: true });
    }
  };
  const U = function() {
    F = true;
  };
  l.onChange = U;
  u.onChange = U;
  c.onChange = U;
  h.onChange = U;
  p.onChange = U;
  d.onChange = U;
  o.onChange = M;
  M();
};
Ops.Gl.Matrix.Camera.prototype = new CABLES.Op();
CABLES.OPS["b24dbfdc-485c-49d2-92a1-7258efd9239a"] = { f: Ops.Gl.Matrix.Camera, objName: "Ops.Gl.Matrix.Camera" };
Ops.Math.Ease = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("Value"), g = A.inValue("Min", 0), i = A.inValue("Max", 1), I = A.outNumber("Result"), n = new CABLES.Anim();
  n.createPort(A, "Easing", C);
  n.setValue(0, 0);
  n.setValue(1, 1);
  A.onLoaded = g.onChange = i.onChange = o;
  function o() {
    n.keys[0].time = n.keys[0].value = Math.min(g.get(), i.get());
    n.keys[1].time = n.keys[1].value = Math.max(g.get(), i.get());
  }
  function C() {
    n.keys[0].setEasing(n.defaultEasing);
  }
  t.onChange = function() {
    const A2 = n.getValue(t.get());
    I.set(A2);
  };
};
Ops.Math.Ease.prototype = new CABLES.Op();
CABLES.OPS["8f6e4a08-33e6-408f-ac4a-198bd03b417b"] = { f: Ops.Math.Ease, objName: "Ops.Math.Ease" };
Ops.Gl.Shader.MatCapMaterial_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { matcap_frag: "{{MODULES_HEAD}}\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoord;\n#endif\n\nIN vec3 transformedNormal;\nIN vec3 viewSpacePosition;\n\nUNI vec4 inColor;\n\nUNI sampler2D texMatcap;\n\n#ifdef HAS_DIFFUSE_TEXTURE\n   UNI sampler2D texDiffuse;\n#endif\n\n#ifdef USE_SPECULAR_TEXTURE\n   UNI sampler2D texSpec;\n   UNI sampler2D texSpecMatCap;\n#endif\n\n#ifdef HAS_AO_TEXTURE\n    UNI sampler2D texAo;\n    UNI float aoIntensity;\n#endif\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 vBiTangent;\n    IN vec3 vTangent;\n    IN mat3 normalMatrix;\n\n    UNI sampler2D texNormal;\n    UNI float normalMapIntensity;\n#endif\n\n#ifdef HAS_TEXTURE_OPACITY\n    UNI sampler2D texOpacity;\n#endif\n\n#ifdef CALC_SSNORMALS\n    IN vec3 eye_relative_pos;\n\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    vec3 CalculateScreenSpaceNormals() {\n    	vec3 dFdxPos = dFdx(eye_relative_pos);\n    	vec3 dFdyPos = dFdy(eye_relative_pos);\n    	vec3 screenSpaceNormal = normalize( cross(dFdxPos, dFdyPos));\n        return normalize(screenSpaceNormal);\n    }\n#endif\n\n// * taken & modified from https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js\nvec2 getMatCapUV(vec3 viewSpacePosition, vec3 normal) {\n    vec3 viewDir = normalize(-viewSpacePosition);\n	vec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\n	vec3 y = normalize(cross(viewDir, x));\n	vec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n	return uv;\n}\n\nvoid main()\n{\n    vec3 viewSpaceNormal = normalize(transformedNormal);\n\n    #ifdef HAS_TEXTURES\n        vec2 texCoords = texCoord;\n        {{MODULE_BEGIN_FRAG}}\n    #endif\n\n\n    #ifdef CALC_SSNORMALS\n        viewSpaceNormal = CalculateScreenSpaceNormals();\n    #endif\n\n\n   #ifdef HAS_NORMAL_TEXTURE\n        vec3 normalFromMap = texture( texNormal, texCoord ).xyz * 2.0 - 1.0;\n        normalFromMap = normalize(normalFromMap);\n\n        vec3 tangent;\n        vec3 binormal;\n\n        #ifdef CALC_TANGENT\n            vec3 c1 = cross(normalFromMap, vec3(0.0, 0.0, 1.0));\n            vec3 c2 = cross(normalFromMap, vec3(0.0, 1.0, 0.0));\n\n            tangent = c1;\n            tangent = normalize(tangent);\n            binormal = cross(viewSpaceNormal, tangent);\n            binormal = normalize(binormal);\n        #endif\n\n        #ifndef CALC_TANGENT\n            tangent = normalize(normalMatrix * vTangent);\n            vec3 bitangent = normalize(normalMatrix * vBiTangent);\n            binormal = normalize(cross(viewSpaceNormal, bitangent));\n        #endif\n\n        normalFromMap = normalize(\n            tangent * normalFromMap.x\n            + binormal * normalFromMap.y\n            + viewSpaceNormal * normalFromMap.z\n        );\n\n        vec3 mixedNormal = normalize(viewSpaceNormal + normalFromMap * normalMapIntensity);\n\n        viewSpaceNormal = mixedNormal;\n    #endif\n\n    vec4 col = texture(texMatcap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n\n    #ifdef HAS_DIFFUSE_TEXTURE\n        col = col*texture(texDiffuse, texCoords);\n    #endif\n\n    col.rgb *= inColor.rgb;\n\n\n    #ifdef HAS_AO_TEXTURE\n        col = col\n            * mix(\n                vec4(1.0,1.0,1.0,1.0),\n                texture(texAo, texCoords),\n                aoIntensity\n            );\n    #endif\n\n    #ifdef USE_SPECULAR_TEXTURE\n        vec4 spec = texture(texSpecMatCap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n        spec *= texture(texSpec, texCoords);\n        col += spec;\n    #endif\n\n    col.a *= inColor.a;\n\n    #ifdef HAS_TEXTURE_OPACITY\n        #ifdef TRANSFORMALPHATEXCOORDS\n            texCoords=vec2(texCoord.s,1.0-texCoord.t);\n            texCoords.y = 1. - texCoords.y;\n        #endif\n        #ifdef ALPHA_MASK_ALPHA\n            col.a*=texture(texOpacity,texCoords).a;\n        #endif\n        #ifdef ALPHA_MASK_LUMI\n            col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,texCoords).rgb);\n        #endif\n        #ifdef ALPHA_MASK_R\n            col.a*=texture(texOpacity,texCoords).r;\n        #endif\n        #ifdef ALPHA_MASK_G\n            col.a*=texture(texOpacity,texCoords).g;\n        #endif\n        #ifdef ALPHA_MASK_B\n            col.a*=texture(texOpacity,texCoords).b;\n        #endif\n\n        #ifdef DISCARDTRANS\n            if(col.a < 0.2) discard;\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}", matcap_vert: "IN vec3 vPosition;\n\n#ifdef HAS_TEXTURES\n    IN vec2 attrTexCoord;\n#endif\n\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 attrTangent;\n    IN vec3 attrBiTangent;\n    OUT vec3 vBiTangent;\n    OUT vec3 vTangent;\n#endif\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI vec3 camPos;\n\n#ifdef HAS_TEXTURES\n    UNI vec2 texOffset;\n    UNI vec2 texRepeat;\n    OUT vec2 texCoord;\n#endif\n\nOUT mat3 normalMatrix;\nOUT vec3 viewSpacePosition;\nOUT vec3 transformedNormal;\n\n{{MODULES_HEAD}}\n\n#ifdef CALC_SSNORMALS\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    OUT vec3 eye_relative_pos;\n#endif\n\nmat3 transposeMat3(mat3 m) {\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\n mat3 inverseMat3(mat3 m) {\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    #ifdef HAS_TEXTURES\n        texCoord = texRepeat * vec2(attrTexCoord.x, attrTexCoord.y) + texOffset;\n        texCoord.y = 1. - texCoord.y;\n    #endif\n\n    mat4 mMatrix = modelMatrix;\n    mat4 mvMatrix;\n\n    #ifdef HAS_NORMAL_TEXTURE\n        vec3 tangent = attrTangent;\n        vec3 bitangent = attrBiTangent;\n        vTangent = attrTangent;\n        vBiTangent = attrBiTangent;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.);\n    vec3 norm = attrVertNormal;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mvMatrix = viewMatrix * mMatrix;\n    vec3 normal = norm;\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mvMatrix)));\n\n    vec3 fragPos = vec3((mvMatrix) * pos);\n    viewSpacePosition = normalize(fragPos);\n\n    #ifdef CALC_SSNORMALS\n        eye_relative_pos = -(vec3(viewMatrix * vec4(camPos, 1.)) - fragPos);\n    #endif\n\n    transformedNormal = normalize(mat3(normalMatrix) * normal);\n\n    mat4 modelViewMatrix=mvMatrix;\n    {{MODULE_VERTEX_MOVELVIEW}}\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n\n}" };
  const t = A.patch.cgl;
  const v = A.inTrigger("Render"), g = A.inTexture("MatCap"), i = A.inTexture("Diffuse"), I = A.inTexture("Normal"), n = A.inTexture("Specular Mask"), o = A.inTexture("Specular MatCap"), C = A.inTexture("AO Texture"), a = A.inTexture("Opacity Texture"), r = A.inValueSlider("r", 1), s = A.inValueSlider("g", 1), B = A.inValueSlider("b", 1), Q = A.inValueSlider("Opacity", 1), E = A.inValueSlider("AO Intensity", 1), l = A.inFloatSlider("Normal Map Intensity", 1), u = A.inValue("Repeat X", 1), c = A.inValue("Repeat Y", 1), h = A.inValue("Offset X", 0), p = A.inValue("Offset Y", 0), d = A.inValueBool("Screen Space Normals"), m = A.inValueBool("Calc normal tangents", true), f = A.inValueBool("Opacity TexCoords Transform", false), D = A.inValueBool("Discard Transparent Pixels"), O = A.outTrigger("Next"), k = A.outObject("Shader");
  r.setUiAttribs({ colorPick: true });
  const y = A.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A"], "Luminance");
  y.setUiAttribs({ greyout: true });
  A.setPortGroup("Texture Opacity", [y, f, D]);
  A.setPortGroup("Texture Transforms", [E, l, u, c, h, p, m, d]);
  A.setPortGroup("Texture Maps", [i, I, n, o, C, a]);
  A.setPortGroup("Color", [r, s, B, Q]);
  const b = new CGL.Shader(t, "MatCapMaterialNew3");
  const x = new CGL.Uniform(b, "f", "opacity", Q);
  b.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MOVELVIEW"]);
  b.setSource(e.matcap_vert, e.matcap_frag);
  k.set(b);
  const T = new CGL.Uniform(b, "t", "texMatcap");
  let N = null;
  let S = null;
  let w = null;
  let R = null;
  let G = null;
  let _ = null;
  const J = new CGL.Uniform(b, "2f", "texOffset", h, p);
  const Y = new CGL.Uniform(b, "2f", "texRepeat", u, c);
  const K = new CGL.Uniform(b, "f", "aoIntensity", E);
  const j = new CGL.Uniform(b, "4f", "inColor", r, s, B, Q);
  m.onChange = F;
  F();
  function F() {
    if (m.get())
      b.define("CALC_TANGENT");
    else
      b.removeDefine("CALC_TANGENT");
  }
  d.onChange = function() {
    if (d.get()) {
      if (t.glVersion < 2) {
        t.gl.getExtension("OES_standard_derivatives");
        b.enableExtension("GL_OES_standard_derivatives");
      }
      b.define("CALC_SSNORMALS");
    } else
      b.removeDefine("CALC_SSNORMALS");
  };
  g.onChange = M;
  function M() {
    if (!t.defaultMatcapTex3) {
      const g2 = new Uint8Array(256 * 4);
      for (let t2 = 0; t2 < 16; t2++) {
        for (let e2 = 0; e2 < 16; e2++) {
          let A2 = e2 * 16;
          A2 *= Math.min(1, (t2 + e2 / 3) / 8);
          g2[(t2 + e2 * 16) * 4 + 0] = g2[(t2 + e2 * 16) * 4 + 1] = g2[(t2 + e2 * 16) * 4 + 2] = A2;
          g2[(t2 + e2 * 16) * 4 + 3] = 255;
        }
      }
      t.defaultMatcapTex3 = new CGL.Texture(t);
      t.defaultMatcapTex3.initFromData(g2, 16, 16, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);
    }
  }
  i.onChange = function() {
    if (i.get()) {
      if (N !== null)
        return;
      b.define("HAS_DIFFUSE_TEXTURE");
      b.removeUniform("texDiffuse");
      N = new CGL.Uniform(b, "t", "texDiffuse");
    } else {
      b.removeDefine("HAS_DIFFUSE_TEXTURE");
      b.removeUniform("texDiffuse");
      N = null;
    }
  };
  I.onChange = function() {
    if (I.get()) {
      if (S !== null)
        return;
      b.define("HAS_NORMAL_TEXTURE");
      b.removeUniform("texNormal");
      S = new CGL.Uniform(b, "t", "texNormal");
      if (!w)
        w = new CGL.Uniform(b, "f", "normalMapIntensity", l);
    } else {
      b.removeDefine("HAS_NORMAL_TEXTURE");
      b.removeUniform("texNormal");
      S = null;
    }
  };
  C.onChange = function() {
    if (C.get()) {
      if (_ !== null)
        return;
      b.define("HAS_AO_TEXTURE");
      b.removeUniform("texAo");
      _ = new CGL.Uniform(b, "t", "texAo");
    } else {
      b.removeDefine("HAS_AO_TEXTURE");
      b.removeUniform("texAo");
      _ = null;
    }
  };
  n.onChange = o.onChange = function() {
    if (n.get() && o.get()) {
      if (R !== null)
        return;
      b.define("USE_SPECULAR_TEXTURE");
      b.removeUniform("texSpec");
      b.removeUniform("texSpecMatCap");
      R = new CGL.Uniform(b, "t", "texSpec");
      G = new CGL.Uniform(b, "t", "texSpecMatCap");
    } else {
      b.removeDefine("USE_SPECULAR_TEXTURE");
      b.removeUniform("texSpec");
      b.removeUniform("texSpecMatCap");
      R = null;
      G = null;
    }
  };
  function U() {
    if (y.get() == "Alpha Channel")
      b.define("ALPHA_MASK_ALPHA");
    else
      b.removeDefine("ALPHA_MASK_ALPHA");
    if (y.get() == "Luminance")
      b.define("ALPHA_MASK_LUMI");
    else
      b.removeDefine("ALPHA_MASK_LUMI");
    if (y.get() == "R")
      b.define("ALPHA_MASK_R");
    else
      b.removeDefine("ALPHA_MASK_R");
    if (y.get() == "G")
      b.define("ALPHA_MASK_G");
    else
      b.removeDefine("ALPHA_MASK_G");
    if (y.get() == "B")
      b.define("ALPHA_MASK_B");
    else
      b.removeDefine("ALPHA_MASK_B");
  }
  y.onChange = U;
  a.onChange = V;
  let L = null;
  function V() {
    if (a.get()) {
      if (L !== null)
        return;
      b.removeUniform("texOpacity");
      b.define("HAS_TEXTURE_OPACITY");
      if (!L)
        L = new CGL.Uniform(b, "t", "texOpacity");
      y.setUiAttribs({ greyout: false });
      D.setUiAttribs({ greyout: false });
      f.setUiAttribs({ greyout: false });
    } else {
      b.removeUniform("texOpacity");
      b.removeDefine("HAS_TEXTURE_OPACITY");
      L = null;
      y.setUiAttribs({ greyout: true });
      D.setUiAttribs({ greyout: true });
      f.setUiAttribs({ greyout: true });
    }
    U();
  }
  D.onChange = function() {
    if (D.get())
      b.define("DISCARDTRANS");
    else
      b.removeDefine("DISCARDTRANS");
  };
  f.onChange = function() {
    if (f.get())
      b.define("TRANSFORMALPHATEXCOORDS");
    else
      b.removeDefine("TRANSFORMALPHATEXCOORDS");
  };
  function H() {
    if (n.get() && !o.get()) {
      A.setUiError("specNoMatCapSpec", "You connected a specular texture but have not connected a specular matcap texture. You need to connect both texture inputs for the specular input to work.", 1);
      A.setUiError("noSpecMatCapSpec", null);
    } else if (!n.get() && o.get()) {
      A.setUiError("noSpecMatCapSpec", "You connected a specular matcap texture but have not connected a specular texture. You need to connect both texture inputs for the specular input to work.", 1);
      A.setUiError("specNoMatCapSpec", null);
    } else if (n.get() && o.get()) {
      A.setUiError("specNoMatCapSpec", null);
      A.setUiError("noSpecMatCapSpec", null);
    } else {
      A.setUiError("specNoMatCapSpec", null);
      A.setUiError("noSpecMatCapSpec", null);
    }
  }
  v.onTriggered = function() {
    H();
    if (!t.defaultMatcapTex3)
      M();
    b.popTextures();
    const A2 = g.get() || t.defaultMatcapTex3;
    b.pushTexture(T, A2.tex);
    if (i.get() && N)
      b.pushTexture(N, i.get().tex);
    if (I.get() && S)
      b.pushTexture(S, I.get().tex);
    if (n.get() && R)
      b.pushTexture(R, n.get().tex);
    if (o.get() && G)
      b.pushTexture(G, o.get().tex);
    if (C.get() && _)
      b.pushTexture(_, C.get().tex);
    if (a.get() && L)
      b.pushTexture(L, a.get().tex);
    t.pushShader(b);
    O.trigger();
    t.popShader();
  };
};
Ops.Gl.Shader.MatCapMaterial_v3.prototype = new CABLES.Op();
CABLES.OPS["c1dd6e76-61b4-471a-b8d1-f550a5a9a4f4"] = { f: Ops.Gl.Shader.MatCapMaterial_v3, objName: "Ops.Gl.Shader.MatCapMaterial_v3" };
Ops.Gl.Texture_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const A = i.attachments = {};
  const I = i.inUrl("File", [".jpg", ".png", ".webp", ".jpeg", ".avif"]), e = i.inSwitch("Filter", ["nearest", "linear", "mipmap"]), t = i.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"), g = i.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"), n = i.inSwitch("Data Format", ["R", "RG", "RGB", "RGBA", "SRGBA"], "RGBA"), o = i.inValueBool("Flip", false), C = i.inValueBool("Pre Multiplied Alpha", false), a = i.inValueBool("Active", true), r = i.inBool("Save Memory", true), s = i.outTexture("Texture"), B = i.inBool("Add Cachebuster", false), Q = i.inTriggerButton("Reload"), E = i.outNumber("Width"), l = i.outNumber("Height"), u = i.outNumber("Aspect Ratio"), c = i.outBoolNum("Loaded", 0), h = i.outBoolNum("Loading", 0);
  const p = i.patch.cgl;
  i.toWorkPortsNeedToBeLinked(s);
  i.setPortGroup("Size", [E, l]);
  let d = null;
  let m = null;
  let f = null;
  let D = CGL.Texture.FILTER_MIPMAP;
  let y = CGL.Texture.WRAP_REPEAT;
  let b = 0;
  let N = 0;
  C.setUiAttribs({ hidePort: true });
  C.onChange = I.onChange = n.onChange = B.onChange = o.onChange = w;
  g.onChange = e.onChange = _;
  t.onChange = F;
  e.set("mipmap");
  t.set("repeat");
  s.set(CGL.Texture.getEmptyTexture(p));
  Q.onTriggered = w;
  a.onChange = function() {
    if (a.get()) {
      if (d != I.get() || !f)
        w();
      else
        s.set(f);
    } else {
      s.set(CGL.Texture.getEmptyTexture(p));
      E.set(CGL.Texture.getEmptyTexture(p).width);
      l.set(CGL.Texture.getEmptyTexture(p).height);
      if (f)
        f.delete();
      i.setUiAttrib({ extendTitle: "" });
      f = null;
    }
  };
  const S = function() {
    const A2 = CGL.Texture.getTempTexture(p);
    s.set(A2);
  };
  function w(A2) {
    clearTimeout(N);
    N = setTimeout(function() {
      G(A2);
    }, 1);
  }
  function R() {
    if (n.get() == "R")
      return CGL.Texture.PFORMATSTR_R8UB;
    if (n.get() == "RG")
      return CGL.Texture.PFORMATSTR_RG8UB;
    if (n.get() == "RGB")
      return CGL.Texture.PFORMATSTR_RGB8UB;
    if (n.get() == "SRGBA")
      return CGL.Texture.PFORMATSTR_SRGBA8;
    return CGL.Texture.PFORMATSTR_RGBA8UB;
  }
  function G(A2) {
    i.checkMainloopExists();
    if (!a.get())
      return;
    if (m)
      m = p.patch.loading.finished(m);
    m = p.patch.loading.start(i.objName, I.get(), i);
    let e2 = i.patch.getFilePath(String(I.get()));
    if (B.get() || A2 === true)
      e2 = CABLES.cacheBust(e2);
    if (String(I.get()).indexOf("data:") == 0)
      e2 = I.get();
    let t2 = false;
    d = I.get();
    if (I.get() && I.get().length > 1) {
      c.set(false);
      h.set(true);
      const g2 = I.get();
      i.setUiAttrib({ extendTitle: CABLES.basename(e2) });
      if (t2)
        i.refreshParams();
      p.patch.loading.addAssetLoadingTask(() => {
        i.setUiError("urlerror", null);
        CGL.Texture.load(p, e2, function(A3, e3) {
          p.checkFrameStarted("texture inittexture");
          if (I.get() != g2) {
            m = p.patch.loading.finished(m);
            return;
          }
          if (f)
            f.delete();
          if (A3) {
            const t3 = CGL.Texture.getErrorTexture(p);
            s.setRef(t3);
            i.setUiError("urlerror", 'could not load texture: "' + I.get() + '"', 2);
            m = p.patch.loading.finished(m);
            return;
          }
          E.set(e3.width);
          l.set(e3.height);
          u.set(e3.width / e3.height);
          f = e3;
          s.setRef(f);
          h.set(false);
          c.set(true);
          if (r.get())
            f.image = null;
          if (m) {
            m = p.patch.loading.finished(m);
          }
          i.checkMainloopExists();
        }, { anisotropic: b, wrap: y, flip: o.get(), unpackAlpha: C.get(), pixelFormat: R(), filter: D });
        i.checkMainloopExists();
      });
    } else {
      S();
      m = p.patch.loading.finished(m);
    }
  }
  function _() {
    if (e.get() == "nearest")
      D = CGL.Texture.FILTER_NEAREST;
    else if (e.get() == "linear")
      D = CGL.Texture.FILTER_LINEAR;
    else if (e.get() == "mipmap")
      D = CGL.Texture.FILTER_MIPMAP;
    else if (e.get() == "Anisotropic")
      D = CGL.Texture.FILTER_ANISOTROPIC;
    g.setUiAttribs({ greyout: D != CGL.Texture.FILTER_MIPMAP });
    b = parseFloat(g.get());
    w();
  }
  function F() {
    if (t.get() == "repeat")
      y = CGL.Texture.WRAP_REPEAT;
    if (t.get() == "mirrored repeat")
      y = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (t.get() == "clamp to edge")
      y = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    w();
  }
  i.onFileChanged = function(A2) {
    if (I.get() && I.get().indexOf(A2) > -1) {
      s.set(CGL.Texture.getEmptyTexture(i.patch.cgl));
      s.set(CGL.Texture.getTempTexture(p));
      G(true);
    }
  };
};
Ops.Gl.Texture_v2.prototype = new CABLES.Op();
CABLES.OPS["790f3702-9833-464e-8e37-6f0f813f7e16"] = { f: Ops.Gl.Texture_v2, objName: "Ops.Gl.Texture_v2" };
Ops.Gl.TextMeshMSDF_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const p = i.attachments = { textmeshsdf_frag: "\nUNI sampler2D tex0;\nUNI sampler2D tex1;\nUNI sampler2D tex2;\nUNI sampler2D tex3;\n\nIN vec2 texCoord;\nIN vec4 fragAttrColors;\n\nUNI vec4 color;\nUNI vec2 texSize;\n\n#ifdef BORDER\n    UNI float borderWidth;\n    UNI float borderSmooth;\n    UNI vec3 colorBorder;\n#endif\n\n#ifdef TEXTURE_COLOR\nUNI sampler2D texMulColor;\n#endif\n#ifdef TEXTURE_MASK\nUNI sampler2D texMulMask;\n#endif\n\nUNI float smoothing;\nIN float texIndex;\n\n#ifdef SHADOW\n    UNI float shadowWidth;\n#endif\n\n\nfloat median(float r, float g, float b)\n{\n    return max(min(r, g), min(max(r, g), b));\n}\n\nvoid main()\n{\n    vec4 bgColor=vec4(0.0,0.0,0.0,0.0);\n    vec4 fgColor=color;\n    float opacity=1.0;\n\n    #ifndef SDF\n        if(int(texIndex)==0) outColor = texture(tex0, texCoord);\n        if(int(texIndex)==1) outColor = texture(tex1, texCoord);\n        if(int(texIndex)==2) outColor = texture(tex2, texCoord);\n        if(int(texIndex)==3) outColor = texture(tex3, texCoord);\n\n        return;\n    #endif\n\n\n    #ifdef TEXTURE_COLOR\n        fgColor.rgb *= texture(texMulColor, vec2(0.0,0.0)).rgb; //todo texcoords from char positioning\n    #endif\n    #ifdef TEXTURE_MASK\n        opacity *= texture(texMulMask, vec2(0.0,0.0)).r; //todo texcoords from char positioning\n    #endif\n\n\n    #ifdef SHADOW\n        vec2 msdfUnit1 = texSize;\n        vec2 tcv=vec2(texCoord.x-0.002,texCoord.y-0.002);\n        vec3 smpl1;\n        if(int(texIndex)==0) smpl1 = texture(tex0, tcv).rgb;\n        if(int(texIndex)==1) smpl1 = texture(tex1, tcv).rgb;\n        if(int(texIndex)==2) smpl1 = texture(tex2, tcv).rgb;\n        if(int(texIndex)==3) smpl1 = texture(tex3, tcv).rgb;\n\n        float sigDist1 = median(smpl1.r, smpl1.g, smpl1.b) - 0.001;\n        float opacity1 = smoothstep(0.0,0.9,sigDist1*sigDist1);\n        outColor = mix(bgColor, vec4(0.0,0.0,0.0,1.0), opacity1);\n    #endif\n\n    vec2 msdfUnit = 8.0/texSize;\n    vec3 smpl;\n\n    if(int(texIndex)==0) smpl = texture(tex0, texCoord).rgb;\n    if(int(texIndex)==1) smpl = texture(tex1, texCoord).rgb;\n    if(int(texIndex)==2) smpl = texture(tex2, texCoord).rgb;\n    if(int(texIndex)==3) smpl = texture(tex3, texCoord).rgb;\n\n\n    float sigDist = median(smpl.r, smpl.g, smpl.b) - 0.5;\n    sigDist *= dot(msdfUnit, (0.5+(smoothing-0.5))/fwidth(texCoord));\n    opacity *= clamp(sigDist + 0.5, 0.0, 1.0);\n\n    #ifdef BORDER\n        float sigDist2 = median(smpl.r, smpl.g, smpl.b) - 0.01;\n        float bw=borderWidth*0.6+0.24;\n        float opacity2 = smoothstep(bw-borderSmooth,bw+borderSmooth,sigDist2*sigDist2);\n        fgColor=mix(fgColor,vec4(colorBorder,1.0),1.0-opacity2);\n    #endif\n\n    if(color.a==0.0)discard;\n\n    outColor = mix(outColor, fgColor, opacity*color.a);\n\n#ifdef HAS_ATTR_COLORS\n    outColor*=fragAttrColors;\n#endif\n}\n\n", textmeshsdf_vert: "UNI sampler2D tex1;\nUNI sampler2D tex2;\nUNI sampler2D tex3;\nUNI sampler2D tex4;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN mat4 instMat;\nIN vec2 attrTexOffsets;\nIN vec2 attrSize;\nIN vec2 attrTcSize;\nIN float attrPage;\nIN vec4 attrColors;\n\nOUT vec2 texCoord;\nOUT float texIndex;\nOUT vec4 fragAttrColors;\n\n\n\n\nconst float mulSize=0.01;\n\nvoid main()\n{\n    texCoord=(attrTexOffsets+attrTexCoord*attrTcSize);\n    texCoord.y=1.0-texCoord.y;\n\n    mat4 instMVMat=instMat;\n    vec4 vert=vec4( vPosition, 1. );\n    vert.x*=attrSize.x*mulSize;\n    vert.y*=attrSize.y*mulSize;\n\n    fragAttrColors=attrColors;\n\n    texIndex=attrPage+0.4; // strange ios rounding errors?!\n\n    mat4 mvMatrix=viewMatrix * modelMatrix * instMVMat;\n\n    gl_Position = projMatrix * mvMatrix * vert;\n}\n" };
  const d = i.inTrigger("Render"), J = i.inString("Text", "cables"), I = i.inDropDown("Font", [], "", true), e = i.inFloat("Scale", 0.25), y = i.inFloat("Letter Spacing", 0), b = i.inFloat("Line Height", 1), N = i.inSwitch("Align", ["Left", "Center", "Right"], "Center"), A = i.inSwitch("Vertical Align", ["Zero", "Top", "Middle", "Bottom"], "Middle"), t = i.inValueSlider("r", 1), m = i.inValueSlider("g", 1), f = i.inValueSlider("b", 1), D = i.inValueSlider("a", 1), g = i.inBool("SDF", true), Y = i.inValueSlider("Smoothing", 0.3), n = i.inBool("Border", false), o = i.inFloatSlider("Border Width", 0.5), C = i.inFloatSlider("Smoothness", 0.25), a = i.inValueSlider("Border r", 1), K = i.inValueSlider("Border g", 1), j = i.inValueSlider("Border b", 1), V = i.inBool("Shadow", false), r = i.inTexture("Texture Color"), s = i.inTexture("Texture Mask"), H = i.inArray("Positions"), q = i.inArray("Scalings"), P = i.inArray("Rotations"), S = i.inArray("Colors"), W = i.outTrigger("Next"), X = i.outArray("Positions Original", null, 3), z = i.outArray("Scales", null, 2), Z = i.outNumber("Num Lines"), $ = i.outNumber("Width"), AA = i.outNumber("Height"), eA = i.outNumber("Start Y"), tA = i.outNumber("Num Chars");
  i.setPortGroup("Size", [y, b, e]);
  i.setPortGroup("Character Transformations", [q, P, H]);
  i.setPortGroup("Alignment", [N, A]);
  i.setPortGroup("Color", [t, m, f, D, g]);
  i.setPortGroup("Border", [a, K, j, C, o, n]);
  t.setUiAttribs({ colorPick: true });
  a.setUiAttribs({ colorPick: true });
  const w = i.patch.cgl;
  const gA = "font_data_";
  const iA = gA.length;
  const IA = vec3.create();
  const nA = vec3.create();
  const B = new CGL.Shader(w, "TextMeshSDF");
  B.define("INSTANCING");
  let Q = null;
  let R = null;
  let G = null;
  let E = true;
  let _ = null;
  let F = null;
  let M = false;
  let l = 1;
  let u = 0, oA = 0;
  let U = 0;
  let L, v, O, k;
  let x = true;
  let T = null;
  let c = 0;
  if (w.glVersion == 1) {
    w.gl.getExtension("OES_standard_derivatives");
    B.enableExtension("GL_OES_standard_derivatives");
  }
  B.setSource(p.textmeshsdf_vert, p.textmeshsdf_frag);
  const CA = new CGL.Uniform(B, "t", "tex0", 0), aA = new CGL.Uniform(B, "t", "tex1", 1), rA = new CGL.Uniform(B, "t", "tex2", 2), sA = new CGL.Uniform(B, "t", "tex3", 3), BA = new CGL.Uniform(B, "t", "texMulColor", 4), QA = new CGL.Uniform(B, "t", "texMulMask", 5), EA = new CGL.Uniform(B, "4f", "color", t, m, f, D), lA = new CGL.Uniform(B, "3f", "colorBorder", a, K, j), uA = new CGL.Uniform(B, "2f", "texSize", 0, 0), cA = new CGL.Uniform(B, "f", "smoothing", Y), hA = new CGL.Uniform(B, "f", "borderSmooth", C), pA = new CGL.Uniform(B, "f", "borderWidth", o);
  e.onChange = fA;
  P.onChange = H.onChange = q.onChange = function() {
    x = true;
  };
  r.onChange = s.onChange = V.onChange = n.onChange = g.onChange = dA;
  S.onLinkChanged = () => {
    dA();
    x = true;
    E = true;
  };
  S.onChange = () => {
    E = true;
    if (F && S.get() && S.isLinked())
      F.setAttribute("attrColors", new Float32Array(S.get()), 4, { instanced: true });
  };
  N.onChange = J.onChange = y.onChange = b.onChange = function() {
    E = true;
  };
  A.onChange = DA;
  i.patch.addEventListener("variablesChanged", h);
  i.patch.addEventListener("FontLoadedMSDF", h);
  I.onChange = mA;
  dA();
  fA();
  h();
  function dA() {
    B.toggleDefine("SDF", g.get());
    B.toggleDefine("SHADOW", V.get());
    B.toggleDefine("BORDER", n.get());
    B.toggleDefine("TEXTURE_COLOR", r.isLinked());
    B.toggleDefine("TEXTURE_MASK", s.isLinked());
    B.toggleDefine("HAS_ATTR_COLORS", S.isLinked());
    a.setUiAttribs({ greyout: !n.get() });
    K.setUiAttribs({ greyout: !n.get() });
    j.setUiAttribs({ greyout: !n.get() });
    C.setUiAttribs({ greyout: !n.get() });
    o.setUiAttribs({ greyout: !n.get() });
  }
  function mA() {
    h();
    const A2 = gA + I.get();
    R = null;
    Q = null;
    G = {};
    const e2 = i.patch.getVar(A2);
    if (!e2 || !e2.getValue()) {
      R = null;
      i.warn("no varname", A2);
      return;
    }
    R = e2.getValue().data;
    if (!R) {
      return;
    }
    const t2 = e2.getValue().basename;
    const g2 = i.patch.getVar("font_tex_" + t2);
    if (!g2) {
      Q = null;
      R = null;
      return;
    }
    Q = g2.getValue();
    for (let A3 = 0; A3 < R.chars.length; A3++)
      G[R.chars[A3].char] = R.chars[A3];
    E = true;
  }
  function h() {
    const A2 = i.patch.getVars();
    const e2 = ["..."];
    for (const t2 in A2)
      if (A2[t2].type == "fontData")
        e2.push(t2.substr(iA));
    I.uiAttribs.values = e2;
  }
  function fA() {
    const A2 = e.get();
    vec3.set(nA, A2, A2, A2);
    vec3.set(IA, 0, c * A2, 0);
    $.set(oA * A2);
    AA.set(u * A2);
    eA.set((v + c) * A2);
  }
  function DA() {
    if (O == void 0)
      return;
    if (A.get() == "Top")
      l = 0;
    else if (A.get() == "Middle")
      l = 1;
    else if (A.get() == "Bottom")
      l = 2;
    else if (A.get() == "Zero")
      l = 3;
    c = 0;
    oA = Math.abs(O - k);
    u = Math.abs(L - v);
    if (l === 1)
      c = u / 2;
    else if (l === 2)
      c = u;
    if (l != 0)
      c -= U;
    fA();
  }
  function yA() {
    x = false;
    const e2 = [];
    const t2 = H.get() || X.get();
    const g2 = q.get();
    const i2 = P.get();
    for (let A2 = 0; A2 < F.numInstances; A2++) {
      const I2 = mat4.create();
      mat4.translate(I2, I2, [t2[A2 * 3 + 0], t2[A2 * 3 + 1], t2[A2 * 3 + 2]]);
      if (g2)
        mat4.scale(I2, I2, [g2[A2 * 3 + 0], g2[A2 * 3 + 1], g2[A2 * 3 + 2]]);
      if (i2) {
        mat4.rotateX(I2, I2, i2[A2 * 3 + 0] * CGL.DEG2RAD);
        mat4.rotateY(I2, I2, i2[A2 * 3 + 1] * CGL.DEG2RAD);
        mat4.rotateZ(I2, I2, i2[A2 * 3 + 2] * CGL.DEG2RAD);
      }
      e2.push(Array.prototype.slice.call(I2));
    }
    T = [].concat.apply([], e2);
  }
  d.onTriggered = function() {
    if (!R || !Q) {
      mA();
    }
    if (!R) {
      i.setUiError("nodata", "No font data!");
      i.setUiError("msdfhint", "Use the FontMSDF op to create font and texture.", 0);
    }
    if (!Q) {
      i.setUiError("nodata", "No font texture");
      i.setUiError("msdfhint", "Use the FontMSDF op to create font and texture.", 0);
    }
    if (Q && R) {
      i.setUiError("nodata", null);
      i.setUiError("msdfhint", null);
    }
    if (E) {
      NA();
      E = false;
    }
    if (F && F.numInstances > 0) {
      w.pushShader(B);
      w.setTexture(0, CGL.Texture.getEmptyTexture(w).tex);
      if (Q[0])
        uA.setValue([Q[0].width, Q[0].height]);
      if (Q[0])
        w.setTexture(0, Q[0].tex);
      else
        w.setTexture(0, CGL.Texture.getEmptyTexture(w).tex);
      if (Q[1])
        w.setTexture(1, Q[1].tex);
      else
        w.setTexture(1, CGL.Texture.getEmptyTexture(w).tex);
      if (Q[2])
        w.setTexture(2, Q[2].tex);
      else
        w.setTexture(2, CGL.Texture.getEmptyTexture(w).tex);
      if (Q[3])
        w.setTexture(3, Q[3].tex);
      else
        w.setTexture(3, CGL.Texture.getEmptyTexture(w).tex);
      if (r.get())
        w.setTexture(4, r.get().tex);
      if (s.get())
        w.setTexture(5, s.get().tex);
      w.pushModelMatrix();
      mat4.translate(w.mMatrix, w.mMatrix, IA);
      if (x)
        yA();
      if (T)
        F.setAttribute("instMat", new Float32Array(T), 16, { instanced: true });
      if (!M) {
        mat4.scale(w.mMatrix, w.mMatrix, nA);
        F.render(w.getShader());
      }
      w.popModelMatrix();
      w.popShader();
    }
    W.trigger();
  };
  function bA(A2) {
    return G[String(A2)] || G["?"] || G._ || G.X;
  }
  function NA() {
    if (!R || !G) {
      tA.set(0);
      return;
    }
    const A2 = String(J.get() + "");
    if (!_) {
      _ = new CGL.Geometry("textmesh");
      _.vertices = [0.5, 0.5, 0, -0.5, 0.5, 0, 0.5, -0.5, 0, -0.5, -0.5, 0];
      _.normals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      _.texCoords = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]);
      _.verticesIndices = [0, 1, 2, 2, 1, 3];
    }
    if (F)
      F.dispose();
    F = new CGL.Mesh(w, _);
    const i2 = A2.split("\n");
    const I2 = [];
    const n2 = [];
    const o2 = [];
    const e2 = [];
    const C2 = [];
    const a2 = [];
    let r2 = 0;
    const s2 = [];
    const B2 = 0.01;
    Z.set(i2.length);
    L = 99999;
    v = -99999;
    O = 99999;
    k = -99999;
    U = 0;
    for (let A3 = 0; A3 < R.chars.length; A3++) {
      if (R.chars[A3].height)
        U += R.chars[A3].height;
    }
    U /= R.chars.length;
    U *= B2;
    for (let g2 = 0; g2 < i2.length; g2++) {
      const Q2 = i2[g2];
      const E2 = Q2.length;
      let e3 = 0;
      for (let A3 = 0; A3 < E2; A3++) {
        const l2 = Q2.substring(A3, A3 + 1);
        const u2 = bA(l2);
        if (u2)
          e3 += u2.xadvance * B2 + y.get();
      }
      let t2 = 0;
      if (N.get() == "Right")
        t2 -= e3;
      else if (N.get() == "Center")
        t2 -= e3 / 2;
      for (let e4 = 0; e4 < E2; e4++) {
        const c2 = mat4.create();
        const l2 = Q2.substring(e4, e4 + 1);
        const u2 = bA(l2);
        if (!u2)
          continue;
        a2.push(u2.page || 0);
        o2.push(u2.width, u2.height);
        n2.push(u2.x / R.common.scaleW, u2.y / R.common.scaleH);
        const h2 = u2.width / R.common.scaleW;
        const p2 = u2.height / R.common.scaleH;
        const d2 = u2.yoffset / R.common.scaleH;
        const m2 = u2.xoffset / R.common.scaleW;
        if (l2 == " ")
          C2.push(0, 0);
        else
          C2.push(h2, p2);
        mat4.identity(c2);
        let A3 = u2.xadvance / 2 * B2;
        t2 += A3;
        const f2 = t2 + u2.xoffset / 2 * B2;
        const D2 = g2 * -b.get() + U - B2 * (u2.yoffset + u2.height / 2);
        O = Math.min(f2 - h2, O);
        k = Math.max(f2 + h2, k);
        L = Math.min(D2 - p2 - U / 2, L);
        v = Math.max(D2 + p2 + U / 2, v);
        mat4.translate(c2, c2, [f2, D2, 0]);
        s2.push(f2, D2, 0);
        A3 = u2.xadvance / 2 * B2 + y.get();
        t2 += A3;
        O = Math.min(t2 - h2, O);
        k = Math.max(t2 + h2, k);
        I2.push(Array.prototype.slice.call(c2));
        r2++;
      }
    }
    T = [].concat.apply([], I2);
    M = false;
    if (T.length == 0)
      M = true;
    F.numInstances = T.length / 16;
    tA.set(F.numInstances);
    if (F.numInstances == 0) {
      M = true;
      return;
    }
    F.setAttribute("instMat", new Float32Array(T), 16, { instanced: true });
    F.setAttribute("attrTexOffsets", new Float32Array(n2), 2, { instanced: true });
    F.setAttribute("attrTcSize", new Float32Array(C2), 2, { instanced: true });
    F.setAttribute("attrSize", new Float32Array(o2), 2, { instanced: true });
    F.setAttribute("attrPage", new Float32Array(a2), 1, { instanced: true });
    if (S.isLinked())
      F.setAttribute("attrColors", new Float32Array(S.get()), 4, { instanced: true });
    z.set(o2);
    DA();
    x = true;
    X.setRef(s2);
  }
};
Ops.Gl.TextMeshMSDF_v2.prototype = new CABLES.Op();
CABLES.OPS["b5c99363-a749-4040-884b-66f91294bcad"] = { f: Ops.Gl.TextMeshMSDF_v2, objName: "Ops.Gl.TextMeshMSDF_v2" };
Ops.Math.Round = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("number"), g = A.inInt("Decimal Places", 0), i = A.outNumber("result");
  let I = 0;
  t.onChange = o;
  g.onChange = n;
  n();
  function n() {
    I = Math.pow(10, g.get());
    o();
  }
  function o() {
    i.set(Math.round(t.get() * I) / I);
  }
};
Ops.Math.Round.prototype = new CABLES.Op();
CABLES.OPS["1a1ef636-6d02-42ba-ae1e-627b917d0d2b"] = { f: Ops.Math.Round, objName: "Ops.Math.Round" };
Ops.String.NumberToString_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("Number"), g = A.inInt("Decimal Places", 4), i = A.outString("Result");
  let I = false;
  let n = 1;
  g.onChange = o;
  t.onChange = C;
  o();
  C();
  function o() {
    I = g.get() < 100;
    n = Math.pow(10, g.get());
    C();
  }
  function C() {
    if (I)
      i.set(String(Math.round(t.get() * n) / n));
    else
      i.set(String(t.get() || 0));
  }
};
Ops.String.NumberToString_v2.prototype = new CABLES.Op();
CABLES.OPS["5c6d375a-82db-4366-8013-93f56b4061a9"] = { f: Ops.String.NumberToString_v2, objName: "Ops.String.NumberToString_v2" };
Ops.Gl.Matrix.TransformView = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = {};
  const e = t.inTrigger("render"), g = t.inValueFloat("posX"), i = t.inValueFloat("posY"), I = t.inValueFloat("posZ"), n = t.inValueFloat("scale"), o = t.inValueFloat("rotX"), C = t.inValueFloat("rotY"), a = t.inValueFloat("rotZ"), r = t.outTrigger("trigger");
  t.setPortGroup("Position", [g, i, I]);
  t.setPortGroup("Scale", [n]);
  t.setPortGroup("Rotation", [o, a, C]);
  const s = vec3.create();
  const B = vec3.create();
  const Q = mat4.create();
  mat4.identity(Q);
  let E = false;
  let l = false;
  let u = true;
  let c = true;
  let h = true;
  e.onTriggered = function() {
    const A2 = t.patch.cgl;
    let e2 = false;
    if (u) {
      d();
      e2 = true;
    }
    if (c) {
      m();
      e2 = true;
    }
    if (h) {
      e2 = true;
    }
    if (e2)
      p();
    A2.pushViewMatrix();
    mat4.multiply(A2.vMatrix, A2.vMatrix, Q);
    r.trigger();
    A2.popViewMatrix();
    if (t.isCurrentUiOp())
      gui.setTransformGizmo({ posX: g, posY: i, posZ: I });
  };
  t.transform3d = function() {
    return { pos: [g, i, I] };
  };
  function p() {
    mat4.identity(Q);
    if (l)
      mat4.translate(Q, Q, s);
    if (o.get() !== 0)
      mat4.rotateX(Q, Q, o.get() * CGL.DEG2RAD);
    if (C.get() !== 0)
      mat4.rotateY(Q, Q, C.get() * CGL.DEG2RAD);
    if (a.get() !== 0)
      mat4.rotateZ(Q, Q, a.get() * CGL.DEG2RAD);
    if (E)
      mat4.scale(Q, Q, B);
    y = false;
  }
  function d() {
    l = false;
    if (g.get() !== 0 || i.get() !== 0 || I.get() !== 0)
      l = true;
    vec3.set(s, g.get(), i.get(), I.get());
    u = false;
  }
  function m() {
    E = false;
    if (n.get() !== 0)
      E = true;
    vec3.set(B, n.get(), n.get(), n.get());
    D = false;
  }
  function f() {
    u = true;
  }
  function D() {
    c = true;
  }
  function y() {
    h = true;
  }
  o.onChange = C.onChange = a.onChange = y;
  n.onChange = D;
  g.onChange = i.onChange = I.onChange = f;
  o.set(0);
  C.set(0);
  a.set(0);
  n.set(1);
  g.set(0);
  i.set(0);
  I.set(0);
  p();
};
Ops.Gl.Matrix.TransformView.prototype = new CABLES.Op();
CABLES.OPS["0b3e04f7-323e-4ac8-8a22-a21e2f36e0e9"] = { f: Ops.Gl.Matrix.TransformView, objName: "Ops.Gl.Matrix.TransformView" };
Ops.Math.Incrementor = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTriggerButton("Increment"), g = A.inTriggerButton("Decrement"), i = A.inBool("Limit", false), I = A.inValueInt("Length"), n = A.inSwitch("Mode", ["Rewind", "Stop at Max"], "Rewind"), o = A.inValueInt("Default", 0), C = A.inTriggerButton("Reset"), a = A.outTrigger("Changed"), r = A.outNumber("Value"), s = A.outTrigger("Restarted");
  const B = 0;
  const Q = 1;
  r.ignoreValueSerialize = true;
  I.set(10);
  let E = 0;
  let l = B;
  r.set(0);
  I.onTriggered = C;
  o.onChange = c;
  C.onTriggered = c;
  i.onChange = u;
  u();
  n.onChange = () => {
    if (n.get() == "Rewind") {
      l = B;
    }
    if (n.get() == "Stop at Max") {
      l = Q;
    }
  };
  function u() {
    I.setUiAttribs({ greyout: !i.get() });
    n.setUiAttribs({ greyout: !i.get() });
  }
  function c() {
    r.set(null);
    E = o.get();
    r.set(E);
    s.trigger();
  }
  g.onTriggered = function() {
    E--;
    if (i.get()) {
      if (l == B && E < 0)
        E = I.get() - 1;
      if (l == Q && E < 0)
        E = 0;
    }
    r.set(E);
    a.trigger();
  };
  t.onTriggered = function() {
    E++;
    if (i.get()) {
      if (l == B && E >= I.get()) {
        E = 0;
        s.trigger();
      }
      if (l == Q && E >= I.get())
        E = I.get() - 1;
    }
    r.set(E);
    a.trigger();
  };
};
Ops.Math.Incrementor.prototype = new CABLES.Op();
CABLES.OPS["45cc0011-ada8-4423-8f5b-39a3810b8389"] = { f: Ops.Math.Incrementor, objName: "Ops.Math.Incrementor" };
Ops.Math.SmootherStep = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("val", 0), g = A.inValueFloat("min", 0), i = A.inValueFloat("max", 1), I = A.outNumber("result");
  t.onChange = i.onChange = g.onChange = n;
  n();
  function n() {
    let A2 = Math.max(0, Math.min(1, (t.get() - g.get()) / (i.get() - g.get())));
    I.set(A2 * A2 * A2 * (A2 * (A2 * 6 - 15) + 10) * (i.get() - g.get()));
  }
};
Ops.Math.SmootherStep.prototype = new CABLES.Op();
CABLES.OPS["c66da84f-ff2f-45de-b3c2-557bdf1cb946"] = { f: Ops.Math.SmootherStep, objName: "Ops.Math.SmootherStep" };
Ops.String.StringCompose_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("Format", "hello $a, $b $c und $d"), g = A.inString("String A", "world"), i = A.inString("String B", 1), I = A.inString("String C", 2), n = A.inString("String D", 3), o = A.inString("String E"), C = A.inString("String F"), a = A.outString("Result");
  t.onChange = g.onChange = i.onChange = I.onChange = n.onChange = o.onChange = C.onChange = r;
  r();
  function r() {
    var A2 = t.get() || "";
    if (typeof A2 != "string")
      A2 = "";
    A2 = A2.replace(/\$a/g, g.get());
    A2 = A2.replace(/\$b/g, i.get());
    A2 = A2.replace(/\$c/g, I.get());
    A2 = A2.replace(/\$d/g, n.get());
    A2 = A2.replace(/\$e/g, o.get());
    A2 = A2.replace(/\$f/g, C.get());
    a.set(A2);
  }
};
Ops.String.StringCompose_v3.prototype = new CABLES.Op();
CABLES.OPS["6afea9f4-728d-4f3c-9e75-62ddc1448bf0"] = { f: Ops.String.StringCompose_v3, objName: "Ops.String.StringCompose_v3" };
Ops.Array.StringToArray_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const g = this;
  const A = g.attachments = {};
  const i = g.inStringEditor("text", "1,2,3"), I = g.inString("separator", ","), n = g.inValueBool("Numbers", true), o = g.inValueBool("Trim", true), C = g.inBool("Split Lines", false), a = g.outArray("array"), r = g.outTrigger("Parsed"), s = g.outNumber("length");
  i.setUiAttribs({ ignoreBigPort: true });
  i.onChange = I.onChange = n.onChange = o.onChange = e;
  C.onChange = () => {
    I.setUiAttribs({ greyout: C.get() });
    e();
  };
  e();
  function e() {
    if (!i.get()) {
      a.set(null);
      a.set([]);
      s.set(0);
      return;
    }
    let A2 = i.get();
    if (o.get() && A2) {
      A2 = A2.replace(/^\s+|\s+$/g, "");
      A2 = A2.trim();
    }
    let t;
    let e2 = I.get();
    if (I.get() === "\\n")
      e2 = "\n";
    if (C.get())
      t = A2.split("\n");
    else
      t = A2.split(e2);
    if (t[t.length - 1] === "")
      t.length -= 1;
    s.set(t.length);
    if (o.get()) {
      for (let A3 = 0; A3 < t.length; A3++) {
        t[A3] = t[A3].replace(/^\s+|\s+$/g, "");
        t[A3] = t[A3].trim();
      }
    }
    g.setUiError("notnum", null);
    if (n.get()) {
      let e3 = false;
      for (let A3 = 0; A3 < t.length; A3++) {
        t[A3] = Number(t[A3]);
        if (!CABLES.UTILS.isNumeric(t[A3])) {
          e3 = true;
        }
      }
      if (e3) {
        g.setUiError("notnum", "Parse Error / Not all values numerical!", 1);
      }
    }
    a.setRef(t);
    r.trigger();
  }
};
Ops.Array.StringToArray_v2.prototype = new CABLES.Op();
CABLES.OPS["c974de41-4ce4-4432-b94d-724741109c71"] = { f: Ops.Array.StringToArray_v2, objName: "Ops.Array.StringToArray_v2" };
Ops.Array.ArrayGetString = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inArray("array"), g = A.inValueInt("index"), i = A.outString("result");
  t.ignoreValueSerialize = true;
  g.onChange = I;
  t.onChange = function() {
    I();
  };
  function I() {
    const A2 = t.get();
    if (A2)
      i.set(A2[g.get()]);
  }
};
Ops.Array.ArrayGetString.prototype = new CABLES.Op();
CABLES.OPS["be8f16c0-0c8a-48a2-a92b-45dbf88c76c1"] = { f: Ops.Array.ArrayGetString, objName: "Ops.Array.ArrayGetString" };
Ops.Gl.RenderToTexture_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const A = i.attachments = {};
  const e = i.inTrigger("render"), t = i.inSwitch("Size", ["Canvas", "Manual"], "Canvas"), g = i.inValueInt("texture width", 512), I = i.inValueInt("texture height", 512), n = i.inBool("Auto Aspect", true), o = i.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"), C = i.inSwitch("Wrap", ["Clamp", "Repeat", "Mirror"], "Repeat"), a = i.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none"), r = i.outTrigger("trigger"), s = i.outTexture("texture"), B = i.outTexture("textureDepth"), Q = i.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB), E = i.inValueBool("Depth", true), l = i.inValueBool("Clear", true);
  const u = i.patch.cgl;
  let c = null;
  let h = true;
  i.setPortGroup("Size", [t, g, I, n]);
  Q.onChange = E.onChange = l.onChange = o.onChange = C.onChange = a.onChange = d;
  t.onChange = p;
  e.onTriggered = i.preRender = m;
  p();
  function p() {
    g.setUiAttribs({ greyout: t.get() != "Manual" });
    I.setUiAttribs({ greyout: t.get() != "Manual" });
    n.setUiAttribs({ greyout: t.get() != "Manual" });
  }
  function d() {
    h = true;
  }
  function m() {
    CGL.TextureEffect.checkOpNotInTextureEffect(i);
    if (!c || h) {
      if (c)
        c.delete();
      let t2 = CGL.Texture.WRAP_REPEAT;
      if (C.get() == "Clamp")
        t2 = CGL.Texture.WRAP_CLAMP_TO_EDGE;
      else if (C.get() == "Mirror")
        t2 = CGL.Texture.WRAP_MIRRORED_REPEAT;
      let g2 = CGL.Texture.FILTER_NEAREST;
      if (o.get() == "nearest")
        g2 = CGL.Texture.FILTER_NEAREST;
      else if (o.get() == "linear")
        g2 = CGL.Texture.FILTER_LINEAR;
      else if (o.get() == "mipmap")
        g2 = CGL.Texture.FILTER_MIPMAP;
      if (Q.get().indexOf("loat") && o.get() == "mipmap")
        i.setUiError("fpmipmap", "Can't use mipmap and float texture at the same time");
      else
        i.setUiError("fpmipmap", null);
      if (u.glVersion >= 2) {
        let A3 = true;
        let e2 = 4;
        if (a.get() == "none") {
          e2 = 0;
          A3 = false;
        }
        if (a.get() == "2x")
          e2 = 2;
        if (a.get() == "4x")
          e2 = 4;
        if (a.get() == "8x")
          e2 = 8;
        c = new CGL.Framebuffer2(u, 8, 8, { name: "render2texture " + i.id, pixelFormat: Q.get(), multisampling: A3, multisamplingSamples: e2, wrap: t2, filter: g2, depth: E.get(), clear: l.get() });
      } else {
        c = new CGL.Framebuffer(u, 8, 8, { isFloatingPointTexture: false, clear: l.get() });
      }
      if (c && c.valid) {
        B.set(c.getTextureDepth());
        h = false;
      } else {
        c = null;
        h = true;
      }
    }
    let A2 = n.get();
    if (t.get() == "Canvas") {
      A2 = true;
      g.set(i.patch.cgl.checkTextureSize(u.canvasWidth));
      I.set(i.patch.cgl.checkTextureSize(u.canvasHeight));
    }
    if (c.getWidth() != i.patch.cgl.checkTextureSize(g.get()) || c.getHeight() != i.patch.cgl.checkTextureSize(I.get())) {
      c.setSize(i.patch.cgl.checkTextureSize(g.get()), i.patch.cgl.checkTextureSize(I.get()));
    }
    c.renderStart(u);
    u.pushViewPort(0, 0, g.get(), I.get());
    if (A2)
      mat4.perspective(u.pMatrix, 45, g.get() / I.get(), 0.1, 1e3);
    r.trigger();
    c.renderEnd(u);
    u.popViewPort();
    B.setRef(c.getTextureDepth());
    s.setRef(c.getTextureColor());
  }
};
Ops.Gl.RenderToTexture_v3.prototype = new CABLES.Op();
CABLES.OPS["41eec5c7-c480-477a-be81-04c3efac8357"] = { f: Ops.Gl.RenderToTexture_v3, objName: "Ops.Gl.RenderToTexture_v3" };
Ops.Devices.Mouse.MouseButtons = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.outTrigger("Click Left"), g = A.outTrigger("Click Right"), i = A.outTrigger("Double Click"), I = A.outBoolNum("Button pressed Left", false), n = A.outBoolNum("Button pressed Middle", false), o = A.outBoolNum("Button pressed Right", false), C = A.outTrigger("Mouse Down Left"), a = A.outTrigger("Mouse Down Middle"), r = A.outTrigger("Mouse Down Right"), s = A.outTrigger("Mouse Up Left"), B = A.outTrigger("Mouse Up Middle"), Q = A.outTrigger("Mouse Up Right"), E = A.inValueSelect("Area", ["Canvas", "Document"], "Canvas"), l = A.inValueBool("Active", true);
  const u = A.patch.cgl;
  let c = null;
  E.onChange = S;
  A.onDelete = b;
  S();
  function h(A2) {
    if (A2.which == 1) {
      I.set(true);
      C.trigger();
    } else if (A2.which == 2) {
      n.set(true);
      a.trigger();
    } else if (A2.which == 3) {
      o.set(true);
      r.trigger();
    }
  }
  function p(A2) {
    if (A2.which == 1) {
      I.set(false);
      s.trigger();
    } else if (A2.which == 2) {
      n.set(false);
      B.trigger();
    } else if (A2.which == 3) {
      o.set(false);
      Q.trigger();
    }
  }
  function d(A2) {
    g.trigger();
    A2.preventDefault();
  }
  function m(A2) {
    i.trigger();
  }
  function f(A2) {
    t.trigger();
  }
  function D(A2) {
    if (A2.touches && A2.touches.length > 0) {
      A2.touches[0].which = 1;
      h(A2.touches[0]);
    }
  }
  function y(A2) {
    p({ which: 1 });
  }
  function b() {
    if (!c)
      return;
    c.removeEventListener("touchend", y);
    c.removeEventListener("touchcancel", y);
    c.removeEventListener("touchstart", D);
    c.removeEventListener("dblclick", m);
    c.removeEventListener("click", f);
    c.removeEventListener("mousedown", h);
    c.removeEventListener("mouseup", p);
    c.removeEventListener("contextmenu", d);
    c.removeEventListener("mouseleave", p);
    c = null;
  }
  function N() {
    if (c)
      b();
    c = u.canvas;
    if (E.get() == "Document")
      c = document.body;
    c.addEventListener("touchend", y);
    c.addEventListener("touchcancel", y);
    c.addEventListener("touchstart", D);
    c.addEventListener("dblclick", m);
    c.addEventListener("click", f);
    c.addEventListener("mousedown", h);
    c.addEventListener("mouseup", p);
    c.addEventListener("contextmenu", d);
    c.addEventListener("mouseleave", p);
  }
  A.onLoaded = S;
  l.onChange = S;
  function S() {
    b();
    if (l.get())
      N();
  }
};
Ops.Devices.Mouse.MouseButtons.prototype = new CABLES.Op();
CABLES.OPS["c7e5e545-c8a1-4fef-85c2-45422b947f0d"] = { f: Ops.Devices.Mouse.MouseButtons, objName: "Ops.Devices.Mouse.MouseButtons" };
Ops.Boolean.BoolToNumber_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inBool("Use Value 1", false), g = A.inFloat("Value 0", 0), i = A.inFloat("Value 1", 1), I = A.outNumber("Out Value", 0);
  g.onChange = i.onChange = t.onChange = n;
  function n() {
    const A2 = t.get();
    if (A2) {
      I.set(i.get());
    } else {
      I.set(g.get());
    }
  }
};
Ops.Boolean.BoolToNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["400eea7d-5a68-4dda-a94d-2bb2ee7c2331"] = { f: Ops.Boolean.BoolToNumber_v2, objName: "Ops.Boolean.BoolToNumber_v2" };
Ops.Boolean.Or = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueBool("bool 1"), g = A.inValueBool("bool 2"), i = A.inValueBool("bool 3"), I = A.inValueBool("bool 4"), n = A.inValueBool("bool 5"), o = A.inValueBool("bool 6"), C = A.inValueBool("bool 7"), a = A.inValueBool("bool 8"), r = A.inValueBool("bool 9"), s = A.inValueBool("bool 10"), B = A.outBoolNum("result");
  t.onChange = g.onChange = i.onChange = I.onChange = n.onChange = o.onChange = C.onChange = a.onChange = r.onChange = s.onChange = Q;
  function Q() {
    B.set(t.get() || g.get() || i.get() || I.get() || n.get() || o.get() || C.get() || a.get() || r.get() || s.get());
  }
};
Ops.Boolean.Or.prototype = new CABLES.Op();
CABLES.OPS["b3b36238-4592-4e11-afe3-8361c4fd6be5"] = { f: Ops.Boolean.Or, objName: "Ops.Boolean.Or" };
Ops.Gl.FontMSDF_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const o = this;
  const A = o.attachments = {};
  const C = o.inString("Font Name", CABLES.uuid()), a = o.inUrl("Font Data", "/assets/library/fonts_msdf/worksans-regular_int.json"), r = o.inUrl("Font Image", "/assets/library/fonts_msdf/worksans-regular_int.png"), s = o.inUrl("Font Image 1"), B = o.inUrl("Font Image 2"), Q = o.inUrl("Font Image 3"), E = o.outBool("Loaded"), l = o.outNumber("Total Chars"), u = o.outString("Chars"), c = o.patch.cgl;
  let h = false, p = false, d = 0;
  C.onChange = a.onChange = r.onChange = s.onChange = B.onChange = Q.onChange = t;
  const m = [];
  function f() {
    const A2 = h && p;
    if (!E.get() && A2)
      o.patch.emitEvent("FontLoadedMSDF");
    E.set(A2);
  }
  o.onFileChanged = function(A2) {
    if (r.get() && r.get().indexOf(A2) > -1 || s.get() && s.get().indexOf(A2) > -1 || B.get() && B.get().indexOf(A2) > -1 || Q.get() && Q.get().indexOf(A2) > -1) {
      t();
    }
  };
  let e = "";
  function t() {
    if (!a.get() || !r.get())
      return;
    m.length = 0;
    o.patch.deleteVar("font_data_" + e);
    o.patch.deleteVar("font_tex_" + e);
    e = C.get();
    const i = "font_data_" + C.get();
    const t2 = "font_tex_" + C.get();
    o.patch.setVarValue(i, {});
    o.patch.setVarValue(t2, m);
    o.patch.getVar(i).type = "fontData";
    o.patch.getVar(t2).type = "fontTexture";
    h = p = false;
    f();
    o.patch.loading.finished(d);
    d = o.patch.loading.start("jsonFile", "" + a.get(), o);
    o.setUiError("invaliddata", null);
    o.setUiError("jsonerr", null);
    o.setUiError("texurlerror", null);
    const A2 = o.patch.getFilePath(String(a.get()));
    c.patch.loading.addAssetLoadingTask(() => {
      CABLES.ajax(A2, (A3, g, e2) => {
        if (A3) {
          o.logError(A3);
          return;
        }
        try {
          let e3 = g;
          if (typeof e3 === "string")
            e3 = JSON.parse(g);
          if (!e3.chars || !e3.info || !e3.info.face) {
            o.setUiError("invaliddata", "data file is invalid");
            return;
          }
          l.set(e3.chars.length);
          let t3 = "";
          for (let A4 = 0; A4 < e3.chars.length; A4++)
            t3 += e3.chars[A4].char;
          u.set(t3);
          o.setUiAttrib({ extendTitle: e3.info.face });
          o.patch.setVarValue(i, null);
          o.patch.setVarValue(i, { name: CABLES.basename(a.get()), basename: C.get(), data: e3 });
          o.patch.loading.finished(d);
          h = true;
          f();
        } catch (A4) {
          o.patch.setVarValue(i, null);
          o.patch.setVarValue(t2, null);
          o.logError(A4);
          o.setUiError("jsonerr", "Problem while loading json:<br/>" + A4);
          o.patch.loading.finished(d);
          f();
          E.set(false);
        }
      });
    });
    for (let e2 = 0; e2 < 4; e2++) {
      const g = e2;
      let A3 = r;
      if (e2 == 1)
        A3 = s;
      if (e2 == 2)
        A3 = B;
      if (e2 == 3)
        A3 = Q;
      if (!A3.get())
        continue;
      const I = c.patch.loading.start(o.objName, A3.get(), o);
      const n = o.patch.getFilePath(String(A3.get()));
      CGL.Texture.load(c, n, function(A4, e3) {
        if (A4) {
          o.setUiError("texurlerror", "could not load texture");
          c.patch.loading.finished(I);
          p = false;
          return;
        }
        m[g] = e3;
        o.patch.setVarValue(t2, null);
        o.patch.setVarValue(t2, m);
        p = true;
        c.patch.loading.finished(I);
        f();
      }, { filter: CGL.Texture.FILTER_LINEAR, flip: false });
    }
  }
};
Ops.Gl.FontMSDF_v2.prototype = new CABLES.Op();
CABLES.OPS["6cbd5d67-25d5-4936-a2ad-3ee8ed478570"] = { f: Ops.Gl.FontMSDF_v2, objName: "Ops.Gl.FontMSDF_v2" };
Ops.Anim.Timer_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const I = A.inValue("Speed", 1), t = A.inValueBool("Play", true), g = A.inTriggerButton("Reset"), i = A.inValueBool("Sync to timeline", false), n = A.outNumber("Time");
  A.setPortGroup("Controls", [t, g, I]);
  const o = new CABLES.Timer();
  let C = null;
  let a = 0;
  let r = false;
  t.onChange = s;
  s();
  function s() {
    if (t.get()) {
      o.play();
      A.patch.addOnAnimFrame(A);
    } else {
      o.pause();
      A.patch.removeOnAnimFrame(A);
    }
  }
  g.onTriggered = B;
  function B() {
    a = 0;
    C = null;
    o.setTime(0);
    n.set(0);
  }
  i.onChange = function() {
    r = i.get();
    t.setUiAttribs({ greyout: r });
    g.setUiAttribs({ greyout: r });
  };
  A.onAnimFrame = function(A2, e2, t2) {
    if (o.isPlaying()) {
      if (CABLES.overwriteTime !== void 0) {
        n.set(CABLES.overwriteTime * I.get());
      } else if (r) {
        n.set(A2 * I.get());
      } else {
        o.update();
        const g2 = o.get();
        if (C === null) {
          C = g2;
          return;
        }
        const i2 = Math.abs(g2 - C);
        C = g2;
        a += i2 * I.get();
        if (a != a)
          a = 0;
        n.set(a);
      }
    }
  };
};
Ops.Anim.Timer_v2.prototype = new CABLES.Op();
CABLES.OPS["aac7f721-208f-411a-adb3-79adae2e471a"] = { f: Ops.Anim.Timer_v2, objName: "Ops.Anim.Timer_v2" };
Ops.Anim.LFO_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("Time"), g = A.inFloat("Frequency", 1), i = A.inValueSelect("Type", ["sine", "triangle", "ramp up", "ramp down", "square"], "sine"), I = A.inValue("Phase", 0), n = A.inValue("Range Min", -1), o = A.inValue("Range Max", 1), C = A.outNumber("Result");
  let a = 0;
  i.onChange = s;
  s();
  const r = Math.PI / 2;
  function s() {
    if (i.get() == "sine")
      t.onChange = c;
    if (i.get() == "ramp up")
      t.onChange = E;
    if (i.get() == "ramp down")
      t.onChange = l;
    if (i.get() == "square")
      t.onChange = Q;
    if (i.get() == "triangle")
      t.onChange = u;
  }
  function B() {
    return t.get() * g.get() + I.get();
  }
  function Q() {
    let A2 = B() + 0.5;
    a = A2 % 2;
    if (a <= 1)
      a = -1;
    else
      a = 1;
    a = CABLES.map(a, -1, 1, n.get(), o.get());
    C.set(a);
  }
  function E() {
    let A2 = B() + 1;
    A2 *= 0.5;
    a = A2 % 1;
    a -= 0.5;
    a *= 2;
    a = CABLES.map(a, -1, 1, n.get(), o.get());
    C.set(a);
  }
  function l() {
    let A2 = B();
    a = A2 % 1;
    a -= 0.5;
    a *= -2;
    a = CABLES.map(a, -1, 1, n.get(), o.get());
    C.set(a);
  }
  function u() {
    let A2 = B();
    a = A2 % 2;
    if (a > 1)
      a = 2 - a;
    a -= 0.5;
    a *= 2;
    a = CABLES.map(a, -1, 1, n.get(), o.get());
    C.set(a);
  }
  function c() {
    let A2 = B() * Math.PI - r;
    a = Math.sin(A2);
    a = CABLES.map(a, -1, 1, n.get(), o.get());
    C.set(a);
  }
};
Ops.Anim.LFO_v2.prototype = new CABLES.Op();
CABLES.OPS["621f3334-f428-4310-b0da-66eb8259df33"] = { f: Ops.Anim.LFO_v2, objName: "Ops.Anim.LFO_v2" };
Ops.Boolean.And = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueBool("bool 1"), g = A.inValueBool("bool 2"), i = A.outBoolNum("result");
  t.onChange = g.onChange = I;
  function I() {
    i.set(g.get() && t.get());
  }
};
Ops.Boolean.And.prototype = new CABLES.Op();
CABLES.OPS["c26e6ce0-8047-44bb-9bc8-5a4f911ed8ad"] = { f: Ops.Boolean.And, objName: "Ops.Boolean.And" };
Ops.String.StringContains_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("String"), g = A.inString("SearchValue"), i = A.outBoolNum("Found", false), I = A.outNumber("Index", -1);
  g.onChange = t.onChange = n;
  n();
  function n() {
    if (t.get() && g.get() && g.get().length > 0) {
      const A2 = t.get().indexOf(g.get());
      I.set(A2);
      i.set(A2 > -1);
    } else {
      I.set(-1);
      i.set(false);
    }
  }
};
Ops.String.StringContains_v2.prototype = new CABLES.Op();
CABLES.OPS["2ca3e5d7-e6b4-46a7-8381-3fe1ad8b6879"] = { f: Ops.String.StringContains_v2, objName: "Ops.String.StringContains_v2" };
Ops.Gl.GLTF.GltfDracoCompression = function() {
  CABLES.Op.apply(this, arguments);
  const l = this;
  const A = l.attachments = {};
  class e {
    constructor() {
      this.workerLimit = 4;
      this.workerPool = [];
      this.workerNextTaskID = 1;
      this.workerSourceURL = "";
      this.config = { wasm: Uint8Array.from(atob(DracoDecoderWASM), (A3) => {
        return A3.charCodeAt(0);
      }), wrapper: DracoWASMWrapperCode, decoderSettings: {} };
      const A2 = this._DracoWorker.toString();
      const e2 = A2.substring(A2.indexOf("{") + 1, A2.lastIndexOf("}"));
      const t = this.config.wrapper;
      const g = ["/* draco decoder */", t, "", "/* worker */", e2].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([g]));
    }
    _getWorker(A2, e2) {
      if (this.workerPool.length < this.workerLimit) {
        const t2 = new Worker(this.workerSourceURL);
        t2._callbacks = {};
        t2._taskCosts = {};
        t2._taskLoad = 0;
        t2.postMessage({ type: "init", decoderConfig: this.config });
        t2.onmessage = (A3) => {
          const e3 = A3.data;
          switch (e3.type) {
            case "done":
              t2._callbacks[e3.taskID].finishedCallback(e3.geometry);
              break;
            case "error":
              t2._callbacks[e3.taskID].errorCallback(e3);
              break;
            default:
              l.error('THREE.DRACOLoader: Unexpected message, "' + e3.type + '"');
          }
          this._releaseTask(t2, e3.taskID);
        };
        this.workerPool.push(t2);
      } else {
        this.workerPool.sort(function(A3, e3) {
          return A3._taskLoad > e3._taskLoad ? -1 : 1;
        });
      }
      const t = this.workerPool[this.workerPool.length - 1];
      t._taskCosts[A2] = e2;
      t._taskLoad += e2;
      return t;
    }
    decodeGeometry(A2, e2, t = null) {
      const g = this.workerNextTaskID++;
      const i = A2.byteLength;
      const I = this._getWorker(g, i);
      I._callbacks[g] = { finishedCallback: e2, errorCallback: t };
      I.postMessage({ type: "decode", taskID: g, buffer: A2 }, [A2]);
    }
    _releaseTask(A2, e2) {
      A2._taskLoad -= A2._taskCosts[e2];
      delete A2._callbacks[e2];
      delete A2._taskCosts[e2];
    }
    _DracoWorker() {
      let e2;
      onmessage = function(A2) {
        const r = A2.data;
        switch (r.type) {
          case "init":
            const t = r.decoderConfig;
            const g = t.decoderSettings;
            e2 = new Promise(function(e3) {
              g.onModuleLoaded = function(A3) {
                e3({ draco: A3 });
              };
              g.wasmBinary = t.wasm;
              DracoDecoderModule(g);
            });
            break;
          case "decode":
            e2.then((A3) => {
              const e3 = A3.draco;
              const t2 = new e3.Decoder();
              const g2 = new Int8Array(r.buffer);
              const i = t2.GetEncodedGeometryType(g2);
              const I = new e3.DecoderBuffer();
              I.Init(g2, g2.byteLength);
              let n = new e3.Mesh();
              const o = t2.DecodeBufferToMesh(I, n);
              const C = t2.GetAttributeByUniqueId(n, 1);
              const a = s(e3, t2, n, i, name);
              this.postMessage({ type: "done", taskID: r.taskID, geometry: a });
              e3.destroy(t2);
              e3.destroy(I);
            });
            break;
        }
      };
      let s = function(t, g, i, A2, e3) {
        const I = { position: t.POSITION, normal: t.NORMAL, color: t.COLOR, uv: t.TEX_COORD, joints: t.GENERIC, weights: t.GENERIC };
        const n = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", weights: "Float32Array", joints: "Uint8Array", uv: "Float32Array" };
        const o = { index: null, attributes: [] };
        let C = 0;
        for (const a in I) {
          const r = n[a];
          let e4 = g.GetAttributeId(i, I[a]);
          C++;
          if (e4 != -1) {
            let A3 = g.GetAttribute(i, e4);
            o.attributes.push(Q(t, g, i, a, r, A3));
          }
        }
        if (A2 === t.TRIANGULAR_MESH)
          o.index = B(t, g, i);
        else
          l.warn("unknown draco geometryType", A2);
        t.destroy(i);
        return o;
      };
      let B = function(A2, e3, t) {
        const g = t.num_faces();
        const i = g * 3;
        const I = i * 4;
        const n = A2._malloc(I);
        e3.GetTrianglesUInt32Array(t, I, n);
        const o = new Uint32Array(A2.HEAPF32.buffer, n, i).slice();
        A2._free(n);
        return { array: o, itemSize: 1 };
      };
      let Q = function(A2, e3, t, g, i, I) {
        let n = 4;
        if (i === "Float32Array")
          n = 4;
        else if (i === "Uint8Array")
          n = 1;
        else
          l.warn("unknown attrtype bytesPerElement", i);
        const o = I.num_components();
        const C = t.num_points();
        const a = C * o;
        const r = a * n;
        const s2 = E(A2, i);
        const B2 = A2._malloc(r);
        let Q2 = null;
        e3.GetAttributeDataArrayForAllPoints(t, I, s2, r, B2);
        if (i === "Float32Array")
          Q2 = new Float32Array(A2.HEAPF32.buffer, B2, a).slice();
        else if (i === "Uint8Array")
          Q2 = new Uint8Array(A2.HEAPF32.buffer, B2, a).slice();
        else
          l.warn("unknown attrtype", i);
        A2._free(B2);
        return { name: g, array: Q2, itemSize: o };
      };
      let E = function(A2, e3) {
        switch (e3) {
          case "Float32Array":
            return A2.DT_FLOAT32;
          case "Int8Array":
            return A2.DT_INT8;
          case "Int16Array":
            return A2.DT_INT16;
          case "Int32Array":
            return A2.DT_INT32;
          case "Uint8Array":
            return A2.DT_UINT8;
          case "Uint16Array":
            return A2.DT_UINT16;
          case "Uint32Array":
            return A2.DT_UINT32;
        }
      };
    }
  }
  window.DracoDecoder = new e();
};
Ops.Gl.GLTF.GltfDracoCompression.prototype = new CABLES.Op();
CABLES.OPS["4ecdc2ef-a242-4548-ad74-13f617119a64"] = { f: Ops.Gl.GLTF.GltfDracoCompression, objName: "Ops.Gl.GLTF.GltfDracoCompression" };
Ops.Gl.GLTF.GltfScene_v4 = function() {
  CABLES.Op.apply(this, arguments);
  const m = this;
  const C = m.attachments = { inc_camera_js: "const gltfCamera = class\n{\n    constructor(gltf, node)\n    {\n        this.node = node;\n        this.name = node.name;\n        // console.log(gltf);\n        this.config = gltf.json.cameras[node.camera];\n\n        this.pos = vec3.create();\n        this.quat = quat.create();\n        this.vCenter = vec3.create();\n        this.vUp = vec3.create();\n        this.vMat = mat4.create();\n    }\n\n    updateAnim(time)\n    {\n        if (this.node && this.node._animTrans)\n        {\n            vec3.set(this.pos,\n                this.node._animTrans[0].getValue(time),\n                this.node._animTrans[1].getValue(time),\n                this.node._animTrans[2].getValue(time));\n\n            quat.set(this.quat,\n                this.node._animRot[0].getValue(time),\n                this.node._animRot[1].getValue(time),\n                this.node._animRot[2].getValue(time),\n                this.node._animRot[3].getValue(time));\n        }\n    }\n\n    start(time)\n    {\n        if (cgl.frameStore.shadowPass) return;\n\n        this.updateAnim(time);\n        const asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];\n\n        cgl.pushPMatrix();\n        // mat4.perspective(\n        //     cgl.pMatrix,\n        //     this.config.perspective.yfov*0.5,\n        //     asp,\n        //     this.config.perspective.znear,\n        //     this.config.perspective.zfar);\n\n        cgl.pushViewMatrix();\n        // mat4.identity(cgl.vMatrix);\n\n        // if(this.node && this.node.parent)\n        // {\n        //     console.log(this.node.parent)\n        // vec3.add(this.pos,this.pos,this.node.parent._node.translation);\n        // vec3.sub(this.vCenter,this.vCenter,this.node.parent._node.translation);\n        // mat4.translate(cgl.vMatrix,cgl.vMatrix,\n        // [\n        //     -this.node.parent._node.translation[0],\n        //     -this.node.parent._node.translation[1],\n        //     -this.node.parent._node.translation[2]\n        // ])\n        // }\n\n        // vec3.set(this.vUp, 0, 1, 0);\n        // vec3.set(this.vCenter, 0, -1, 0);\n        // // vec3.set(this.vCenter, 0, 1, 0);\n        // vec3.transformQuat(this.vCenter, this.vCenter, this.quat);\n        // vec3.normalize(this.vCenter, this.vCenter);\n        // vec3.add(this.vCenter, this.vCenter, this.pos);\n\n        // mat4.lookAt(cgl.vMatrix, this.pos, this.vCenter, this.vUp);\n\n        let mv = mat4.create();\n        mat4.invert(mv, this.node.modelMatAbs());\n\n        // console.log(this.node.modelMatAbs());\n\n        this.vMat = mv;\n\n        mat4.identity(cgl.vMatrix);\n        // console.log(mv);\n        mat4.mul(cgl.vMatrix, cgl.vMatrix, mv);\n    }\n\n    end()\n    {\n        if (cgl.frameStore.shadowPass) return;\n        cgl.popPMatrix();\n        cgl.popViewMatrix();\n    }\n};\n", inc_gltf_js: 'const le = true; // little endian\n\nconst Gltf = class\n{\n    constructor()\n    {\n        this.json = {};\n        this.accBuffers = [];\n        this.meshes = [];\n        this.nodes = [];\n        this.shaders = [];\n        this.timing = [];\n        this.cams = [];\n        this.startTime = performance.now();\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.loaded = Date.now();\n        this.accBuffersDelete = [];\n    }\n\n    getNode(n)\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            if (this.nodes[i].name == n) return this.nodes[i];\n        }\n    }\n\n    unHideAll()\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            this.nodes[i].unHide();\n        }\n    }\n};\n\nfunction Utf8ArrayToStr(array)\n{\n    if (window.TextDecoder) return new TextDecoder("utf-8").decode(array);\n\n    let out, i, len, c;\n    let char2, char3;\n\n    out = "";\n    len = array.length;\n    i = 0;\n    while (i < len)\n    {\n        c = array[i++];\n        switch (c >> 4)\n        {\n        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n        case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n        case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode(((c & 0x0F) << 12) |\n                    ((char2 & 0x3F) << 6) |\n                    ((char3 & 0x3F) << 0));\n            break;\n        }\n    }\n\n    return out;\n}\n\nfunction readChunk(dv, bArr, arrayBuffer, offset)\n{\n    const chunk = {};\n\n    if (offset >= dv.byteLength)\n    {\n        op.log("could not read chunk...");\n        return;\n    }\n    chunk.size = dv.getUint32(offset + 0, le);\n\n    // chunk.type = new TextDecoder("utf-8").decode(bArr.subarray(offset+4, offset+4+4));\n    chunk.type = Utf8ArrayToStr(bArr.subarray(offset + 4, offset + 4 + 4));\n\n    if (chunk.type == "BIN\\0")\n    {\n        // console.log(chunk.size,arrayBuffer.length,offset);\n        // try\n        // {\n        chunk.dataView = new DataView(arrayBuffer, offset + 8, chunk.size);\n        // }\n        // catch(e)\n        // {\n        //     chunk.dataView = null;\n        //     console.log(e);\n        // }\n    }\n    else\n    if (chunk.type == "JSON")\n    {\n        const json = Utf8ArrayToStr(bArr.subarray(offset + 8, offset + 8 + chunk.size));\n\n        try\n        {\n            const obj = JSON.parse(json);\n            chunk.data = obj;\n            outGenerator.set(obj.asset.generator);\n        }\n        catch (e)\n        {\n        }\n    }\n    else\n    {\n        op.warn("unknown type", chunk.type);\n    }\n\n    return chunk;\n}\n\nfunction loadAnims(gltf)\n{\n    const uniqueAnimNames = {};\n\n    for (let i = 0; i < gltf.json.animations.length; i++)\n    {\n        const an = gltf.json.animations[i];\n\n        an.name = an.name || "unknown";\n\n        for (let ia = 0; ia < an.channels.length; ia++)\n        {\n            const chan = an.channels[ia];\n\n            const node = gltf.nodes[chan.target.node];\n            const sampler = an.samplers[chan.sampler];\n\n            const acc = gltf.json.accessors[sampler.input];\n            const bufferIn = gltf.accBuffers[sampler.input];\n\n            const accOut = gltf.json.accessors[sampler.output];\n            const bufferOut = gltf.accBuffers[sampler.output];\n\n            gltf.accBuffersDelete.push(sampler.output, sampler.input);\n\n            if (bufferIn && bufferOut)\n            {\n                let numComps = 1;\n                if (accOut.type === "VEC2")numComps = 2;\n                else if (accOut.type === "VEC3")numComps = 3;\n                else if (accOut.type === "VEC4")numComps = 4;\n                else if (accOut.type === "SCALAR")\n                {\n                    numComps = bufferOut.length / bufferIn.length; // is this really the way to find out ? cant find any other way,except number of morph targets, but not really connected...\n                }\n                else op.log("[] UNKNOWN accOut.type", accOut.type);\n\n                const anims = [];\n\n                uniqueAnimNames[an.name] = true;\n\n                for (let k = 0; k < numComps; k++)\n                {\n                    const newAnim = new CABLES.Anim();\n                    // newAnim.name=an.name;\n                    anims.push(newAnim);\n                }\n\n                if (sampler.interpolation === "LINEAR") {}\n                else if (sampler.interpolation === "STEP") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_ABSOLUTE;\n                else if (sampler.interpolation === "CUBICSPLINE") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_CUBICSPLINE;\n                else op.warn("unknown interpolation", sampler.interpolation);\n\n                // console.log(bufferOut)\n\n                // if there is no keyframe for time 0 copy value of first keyframe at time 0\n                if (bufferIn[0] !== 0.0)\n                    for (let k = 0; k < numComps; k++)\n                        anims[k].setValue(0, bufferOut[0 * numComps + k]);\n\n                for (let j = 0; j < bufferIn.length; j++)\n                {\n                    maxTime = Math.max(bufferIn[j], maxTime);\n\n                    for (let k = 0; k < numComps; k++)\n                    {\n                        if (anims[k].defaultEasing === CABLES.EASING_CUBICSPLINE)\n                        {\n                            const idx = ((j * numComps) * 3 + k);\n\n                            const key = anims[k].setValue(bufferIn[j], bufferOut[idx + numComps]);\n                            key.bezTangIn = bufferOut[idx];\n                            key.bezTangOut = bufferOut[idx + (numComps * 2)];\n\n                            // console.log(an.name,k,bufferOut[idx+1]);\n                        }\n                        else\n                        {\n                            // console.log(an.name,k,bufferOut[j * numComps + k]);\n                            anims[k].setValue(bufferIn[j], bufferOut[j * numComps + k]);\n                        }\n                    }\n                }\n\n                node.setAnim(chan.target.path, an.name, anims);\n            }\n            else\n            {\n                op.warn("loadAmins bufferIn undefined ", bufferIn === undefined);\n                op.warn("loadAmins bufferOut undefined ", bufferOut === undefined);\n                op.warn("loadAmins ", sampler, accOut);\n                op.warn("loadAmins num accBuffers", gltf.accBuffers.length);\n                op.warn("loadAmins num accessors", gltf.json.accessors.length);\n            }\n        }\n    }\n\n    gltf.uniqueAnimNames = uniqueAnimNames;\n\n    outAnims.setRef(Object.keys(uniqueAnimNames));\n}\n\nfunction loadCams(gltf)\n{\n    if (!gltf || !gltf.json.cameras) return;\n\n    gltf.cameras = gltf.cameras || [];\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (gltf.nodes[i].hasOwnProperty("camera"))\n        {\n            const cam = new gltfCamera(gltf, gltf.nodes[i]);\n            gltf.cameras.push(cam);\n        }\n    }\n}\n\nfunction loadAfterDraco()\n{\n    if (!window.DracoDecoder)\n    {\n        setTimeout(() =>\n        {\n            loadAfterDraco();\n        }, 100);\n    }\n\n    reloadSoon();\n}\n\nfunction parseGltf(arrayBuffer)\n{\n    const CHUNK_HEADER_SIZE = 8;\n\n    let j = 0, i = 0;\n\n    const gltf = new Gltf();\n    gltf.timing.push(["Start parsing", Math.round((performance.now() - gltf.startTime))]);\n\n    if (!arrayBuffer) return;\n    const byteArray = new Uint8Array(arrayBuffer);\n    let pos = 0;\n\n    // var string = new TextDecoder("utf-8").decode(byteArray.subarray(pos, 4));\n    const string = Utf8ArrayToStr(byteArray.subarray(pos, 4));\n    pos += 4;\n    if (string != "glTF") return;\n\n    gltf.timing.push(["dataview", Math.round((performance.now() - gltf.startTime))]);\n\n    const dv = new DataView(arrayBuffer);\n    const version = dv.getUint32(pos, le);\n    pos += 4;\n    const size = dv.getUint32(pos, le);\n    pos += 4;\n\n    outVersion.set(version);\n\n    const chunks = [];\n    gltf.chunks = chunks;\n\n    chunks.push(readChunk(dv, byteArray, arrayBuffer, pos));\n    pos += chunks[0].size + CHUNK_HEADER_SIZE;\n    gltf.json = chunks[0].data;\n\n    gltf.cables = {\n        "fileUrl": inFile.get(),\n        "shortFileName": CABLES.basename(inFile.get())\n    };\n\n    outJson.setRef(gltf.json);\n    outExtensions.setRef(gltf.json.extensionsUsed || []);\n\n    let ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    while (ch)\n    {\n        chunks.push(ch);\n        pos += ch.size + CHUNK_HEADER_SIZE;\n        ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    }\n\n    gltf.chunks = chunks;\n\n    const views = chunks[0].data.bufferViews;\n    const accessors = chunks[0].data.accessors;\n\n    gltf.timing.push(["Parse buffers", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.extensionsUsed && gltf.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1)\n    {\n        if (!window.DracoDecoder)\n        {\n            op.setUiError("gltfdraco", "GLTF draco compression lib not found / add draco op to your patch!");\n\n            loadAfterDraco();\n            return gltf;\n        }\n        else\n        {\n            gltf.useDraco = true;\n        }\n    }\n\n    op.setUiError("gltfdraco", null);\n    // let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n\n    if (views)\n    {\n        for (i = 0; i < accessors.length; i++)\n        {\n            const acc = accessors[i];\n            const view = views[acc.bufferView];\n\n            let numComps = 0;\n            if (acc.type == "SCALAR")numComps = 1;\n            else if (acc.type == "VEC2")numComps = 2;\n            else if (acc.type == "VEC3")numComps = 3;\n            else if (acc.type == "VEC4")numComps = 4;\n            else if (acc.type == "MAT4")numComps = 16;\n            else console.error("unknown accessor type", acc.type);\n\n            //   const decoder = new decoderModule.Decoder();\n            //   const decodedGeometry = decodeDracoData(data, decoder);\n            //   // Encode mesh\n            //   encodeMeshToFile(decodedGeometry, decoder);\n\n            //   decoderModule.destroy(decoder);\n            //   decoderModule.destroy(decodedGeometry);\n\n            // 5120 (BYTE)	1\n            // 5121 (UNSIGNED_BYTE)	1\n            // 5122 (SHORT)	2\n\n            if (chunks[1].dataView)\n            {\n                if (view)\n                {\n                    const num = acc.count * numComps;\n                    let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n                    let stride = view.byteStride || 0;\n                    let dataBuff = null;\n\n                    if (acc.componentType == 5126 || acc.componentType == 5125) // 4byte FLOAT or INT\n                    {\n                        stride = stride || 4;\n\n                        const isInt = acc.componentType == 5125;\n                        if (isInt)dataBuff = new Uint32Array(num);\n                        else dataBuff = new Float32Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            if (isInt) dataBuff[j] = chunks[1].dataView.getUint32(accPos, le);\n                            else dataBuff[j] = chunks[1].dataView.getFloat32(accPos, le);\n\n                            if (stride != 4 && (j + 1) % numComps === 0)accPos += stride - (numComps * 4);\n                            accPos += 4;\n                        }\n                    }\n                    else if (acc.componentType == 5123) // UNSIGNED_SHORT\n                    {\n                        stride = stride || 2;\n\n                        dataBuff = new Uint16Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint16(accPos, le);\n\n                            if (stride != 2 && (j + 1) % numComps === 0) accPos += stride - (numComps * 2);\n\n                            accPos += 2;\n                        }\n                    }\n                    else if (acc.componentType == 5121) // UNSIGNED_BYTE\n                    {\n                        stride = stride || 1;\n\n                        dataBuff = new Uint8Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint8(accPos, le);\n\n                            if (stride != 1 && (j + 1) % numComps === 0) accPos += stride - (numComps * 1);\n\n                            accPos += 1;\n                        }\n                    }\n\n                    else\n                    {\n                        console.error("unknown component type", acc.componentType);\n                    }\n\n                    gltf.accBuffers.push(dataBuff);\n                }\n                else\n                {\n                    // console.log("has no dataview");\n                }\n            }\n        }\n    }\n\n    gltf.timing.push(["Parse mesh groups", Math.round((performance.now() - gltf.startTime))]);\n\n    gltf.json.meshes = gltf.json.meshes || [];\n\n    if (gltf.json.meshes)\n    {\n        for (i = 0; i < gltf.json.meshes.length; i++)\n        {\n            const mesh = new gltfMeshGroup(gltf, gltf.json.meshes[i]);\n            gltf.meshes.push(mesh);\n        }\n    }\n\n    gltf.timing.push(["Parse nodes", Math.round((performance.now() - gltf.startTime))]);\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        if (gltf.json.nodes[i].children)\n            for (j = 0; j < gltf.json.nodes[i].children.length; j++)\n            {\n                gltf.json.nodes[gltf.json.nodes[i].children[j]].isChild = true;\n            }\n    }\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        const node = new gltfNode(gltf.json.nodes[i], gltf);\n        gltf.nodes.push(node);\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        const node = gltf.nodes[i];\n\n        if (!node.children) continue;\n        for (let j = 0; j < node.children.length; j++)\n        {\n            gltf.nodes[node.children[j]].parent = node;\n        }\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        gltf.nodes[i].initSkin();\n    }\n\n    needsMatUpdate = true;\n\n    gltf.timing.push(["load anims", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.animations) loadAnims(gltf);\n\n    gltf.timing.push(["load cameras", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.cameras) loadCams(gltf);\n\n    gltf.timing.push(["finished", Math.round((performance.now() - gltf.startTime))]);\n    return gltf;\n}\n', inc_mesh_js: 'let gltfMesh = class\n{\n    constructor(name, prim, gltf, finished)\n    {\n        this.POINTS = 0;\n        this.LINES = 1;\n        this.LINE_LOOP = 2;\n        this.LINE_STRIP = 3;\n        this.TRIANGLES = 4;\n        this.TRIANGLE_STRIP = 5;\n        this.TRIANGLE_FAN = 6;\n\n        this.test = 0;\n        this.name = name;\n        this.submeshIndex = 0;\n        this.material = prim.material;\n        // console.log(prim);\n        this.mesh = null;\n        this.geom = new CGL.Geometry("gltf_" + this.name);\n        this.geom.verticesIndices = [];\n        this.bounds = null;\n        this.primitive = 4;\n        this.morphTargetsRenderMod = null;\n        this.weights = prim.weights;\n\n        if (prim.hasOwnProperty("mode")) this.primitive = prim.mode;\n\n        if (prim.hasOwnProperty("indices")) this.geom.verticesIndices = gltf.accBuffers[prim.indices];\n\n        gltf.loadingMeshes = gltf.loadingMeshes || 0;\n        gltf.loadingMeshes++;\n\n        this.materialJson =\n            this._matPbrMetalness =\n            this._matPbrRoughness =\n            this._matDiffuseColor = null;\n\n        if (gltf.json.materials)\n        {\n            if (this.material != -1) this.materialJson = gltf.json.materials[this.material];\n\n            if (this.materialJson && this.materialJson.pbrMetallicRoughness)\n            {\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor"))\n                {\n                    this._matDiffuseColor = [1, 1, 1, 1];\n                }\n                else\n                {\n                    this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n                }\n\n                this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor"))\n                {\n                    this._matPbrMetalness = 1.0;\n                }\n                else\n                {\n                    this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null;\n                }\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor"))\n                {\n                    this._matPbrRoughness = 1.0;\n                }\n                else\n                {\n                    this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null;\n                }\n            }\n        }\n\n        if (gltf.useDraco && prim.extensions.KHR_draco_mesh_compression)\n        {\n            const view = gltf.chunks[0].data.bufferViews[prim.extensions.KHR_draco_mesh_compression.bufferView];\n            const num = view.byteLength;\n            const dataBuff = new Int8Array(num);\n            let accPos = (view.byteOffset || 0);// + (acc.byteOffset || 0);\n            for (let j = 0; j < num; j++)\n            {\n                dataBuff[j] = gltf.chunks[1].dataView.getInt8(accPos, le);\n                accPos++;\n            }\n\n            const dracoDecoder = window.DracoDecoder;\n            dracoDecoder.decodeGeometry(dataBuff.buffer, (geometry) =>\n            {\n                const geom = new CGL.Geometry("draco mesh " + name);\n\n                for (let i = 0; i < geometry.attributes.length; i++)\n                {\n                    const attr = geometry.attributes[i];\n\n                    if (attr.name === "position") geom.vertices = attr.array;\n                    else if (attr.name === "normal") geom.vertexNormals = attr.array;\n                    else if (attr.name === "uv") geom.texCoords = attr.array;\n                    else if (attr.name === "color") geom.vertexColors = this.calcVertexColors(attr.array);\n                    else if (attr.name === "joints") geom.setAttribute("attrJoints", Array.from(attr.array), 4);\n                    else if (attr.name === "weights")\n                    {\n                        const arr4 = new Float32Array(attr.array.length / attr.itemSize * 4);\n\n                        for (let k = 0; k < attr.array.length / attr.itemSize; k++)\n                        {\n                            arr4[k * 4] = arr4[k * 4 + 1] = arr4[k * 4 + 2] = arr4[k * 4 + 3] = 0;\n                            for (let j = 0; j < attr.itemSize; j++)\n                                arr4[k * 4 + j] = attr.array[k * attr.itemSize + j];\n                        }\n                        geom.setAttribute("attrWeights", arr4, 4);\n                    }\n                    else op.logWarn("unknown draco attrib", attr);\n                }\n\n                geometry.attributes = null;\n                geom.verticesIndices = geometry.index.array;\n\n                this.setGeom(geom);\n\n                this.mesh = null;\n                gltf.loadingMeshes--;\n                gltf.timing.push(["draco decode", Math.round((performance.now() - gltf.startTime))]);\n\n                if (finished)finished(this);\n            }, (error) => { op.logError(error); });\n        }\n        else\n        {\n            gltf.loadingMeshes--;\n            this.fillGeomAttribs(gltf, this.geom, prim.attributes);\n\n            if (prim.targets)\n            {\n                for (let j = 0; j < prim.targets.length; j++)\n                {\n                    const tgeom = new CGL.Geometry("gltf_target_" + j);\n\n                    // if (prim.hasOwnProperty("indices")) tgeom.verticesIndices = gltf.accBuffers[prim.indices];\n\n                    this.fillGeomAttribs(gltf, tgeom, prim.targets[j], false);\n\n                    // { // calculate normals for final position of morphtarget for later...\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] += this.geom.vertices[i];\n                    //     tgeom.calculateNormals();\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] -= this.geom.vertices[i];\n                    // }\n\n                    this.geom.morphTargets.push(tgeom);\n                }\n            }\n            if (finished)finished(this);\n        }\n    }\n\n    _linearToSrgb(x)\n    {\n        if (x <= 0)\n            return 0;\n        else if (x >= 1)\n            return 1;\n        else if (x < 0.0031308)\n            return x * 12.92;\n        else\n            return x ** (1 / 2.2) * 1.055 - 0.055;\n    }\n\n    calcVertexColors(arr)\n    {\n        let vertexColors = null;\n        if (arr instanceof Float32Array)\n        {\n            let div = false;\n            for (let i = 0; i < arr.length; i++)\n            {\n                if (arr[i] > 1)\n                {\n                    div = true;\n                    continue;\n                }\n            }\n\n            if (div)\n                for (let i = 0; i < arr.length; i++) arr[i] /= 65535;\n\n            vertexColors = arr;\n        }\n\n        else if (arr instanceof Uint16Array)\n        {\n            const fb = new Float32Array(arr.length);\n            for (let i = 0; i < arr.length; i++) fb[i] = arr[i] / 65535;\n\n            vertexColors = fb;\n        }\n        else vertexColors = arr;\n\n        for (let i = 0; i < vertexColors.length; i++)\n        {\n            vertexColors[i] = this._linearToSrgb(vertexColors[i]);\n        }\n\n        return vertexColors;\n    }\n\n    fillGeomAttribs(gltf, tgeom, attribs, setGeom)\n    {\n        if (attribs.hasOwnProperty("POSITION")) tgeom.vertices = gltf.accBuffers[attribs.POSITION];\n        if (attribs.hasOwnProperty("NORMAL")) tgeom.vertexNormals = gltf.accBuffers[attribs.NORMAL];\n        if (attribs.hasOwnProperty("TANGENT")) tgeom.tangents = gltf.accBuffers[attribs.TANGENT];\n\n        if (attribs.hasOwnProperty("COLOR_0")) tgeom.vertexColors = this.calcVertexColors(gltf.accBuffers[attribs.COLOR_0]);\n        if (attribs.hasOwnProperty("COLOR_1")) tgeom.setAttribute("attrVertColor1", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_1]), 4);\n        if (attribs.hasOwnProperty("COLOR_2")) tgeom.setAttribute("attrVertColor2", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_2]), 4);\n        if (attribs.hasOwnProperty("COLOR_3")) tgeom.setAttribute("attrVertColor3", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_3]), 4);\n        if (attribs.hasOwnProperty("COLOR_4")) tgeom.setAttribute("attrVertColor4", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_4]), 4);\n\n        if (attribs.hasOwnProperty("TEXCOORD_0")) tgeom.texCoords = gltf.accBuffers[attribs.TEXCOORD_0];\n        if (attribs.hasOwnProperty("TEXCOORD_1")) tgeom.setAttribute("attrTexCoord1", gltf.accBuffers[attribs.TEXCOORD_1], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) tgeom.setAttribute("attrTexCoord2", gltf.accBuffers[attribs.TEXCOORD_2], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) tgeom.setAttribute("attrTexCoord3", gltf.accBuffers[attribs.TEXCOORD_3], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) tgeom.setAttribute("attrTexCoord4", gltf.accBuffers[attribs.TEXCOORD_4], 2);\n\n        if (attribs.hasOwnProperty("WEIGHTS_0"))\n        {\n            tgeom.setAttribute("attrWeights", gltf.accBuffers[attribs.WEIGHTS_0], 4);\n        }\n        if (attribs.hasOwnProperty("JOINTS_0"))\n        {\n            if (!gltf.accBuffers[attribs.JOINTS_0])console.log("no !gltf.accBuffers[attribs.JOINTS_0]");\n            tgeom.setAttribute("attrJoints", gltf.accBuffers[attribs.JOINTS_0], 4);\n        }\n\n        if (attribs.hasOwnProperty("POSITION")) gltf.accBuffersDelete.push(attribs.POSITION);\n        if (attribs.hasOwnProperty("NORMAL")) gltf.accBuffersDelete.push(attribs.NORMAL);\n        if (attribs.hasOwnProperty("TEXCOORD_0")) gltf.accBuffersDelete.push(attribs.TEXCOORD_0);\n        if (attribs.hasOwnProperty("TANGENT")) gltf.accBuffersDelete.push(attribs.TANGENT);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_1"))gltf.accBuffersDelete.push(attribs.COLOR_1);\n        if (attribs.hasOwnProperty("COLOR_2"))gltf.accBuffersDelete.push(attribs.COLOR_2);\n        if (attribs.hasOwnProperty("COLOR_3"))gltf.accBuffersDelete.push(attribs.COLOR_3);\n\n        if (attribs.hasOwnProperty("TEXCOORD_1")) gltf.accBuffersDelete.push(attribs.TEXCOORD_1);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) gltf.accBuffersDelete.push(attribs.TEXCOORD_2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) gltf.accBuffersDelete.push(attribs.TEXCOORD_3);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) gltf.accBuffersDelete.push(attribs.TEXCOORD_4);\n\n        if (setGeom !== false) if (tgeom && tgeom.verticesIndices) this.setGeom(tgeom);\n    }\n\n    setGeom(geom)\n    {\n        if (inNormFormat.get() == "X-ZY")\n        {\n            for (let i = 0; i < geom.vertexNormals.length; i += 3)\n            {\n                let t = geom.vertexNormals[i + 2];\n                geom.vertexNormals[i + 2] = geom.vertexNormals[i + 1];\n                geom.vertexNormals[i + 1] = -t;\n            }\n        }\n\n        if (inVertFormat.get() == "XZ-Y")\n        {\n            for (let i = 0; i < geom.vertices.length; i += 3)\n            {\n                let t = geom.vertices[i + 2];\n                geom.vertices[i + 2] = -geom.vertices[i + 1];\n                geom.vertices[i + 1] = t;\n            }\n        }\n\n        if (this.primitive == this.TRIANGLES)\n        {\n            if (inCalcNormals.get() == "Force Smooth" || inCalcNormals.get() == false) geom.calculateNormals();\n            else if (!geom.vertexNormals.length && inCalcNormals.get() == "Auto") geom.calculateNormals({ "smooth": false });\n\n            if ((!geom.biTangents || geom.biTangents.length == 0) && geom.tangents)\n            {\n                const bitan = vec3.create();\n                const tan = vec3.create();\n\n                const tangents = geom.tangents;\n                geom.tangents = new Float32Array(tangents.length / 4 * 3);\n                geom.biTangents = new Float32Array(tangents.length / 4 * 3);\n\n                for (let i = 0; i < tangents.length; i += 4)\n                {\n                    const idx = i / 4 * 3;\n\n                    vec3.cross(\n                        bitan,\n                        [geom.vertexNormals[idx], geom.vertexNormals[idx + 1], geom.vertexNormals[idx + 2]],\n                        [tangents[i], tangents[i + 1], tangents[i + 2]]\n                    );\n\n                    vec3.div(bitan, bitan, [tangents[i + 3], tangents[i + 3], tangents[i + 3]]);\n                    vec3.normalize(bitan, bitan);\n\n                    geom.biTangents[idx + 0] = bitan[0];\n                    geom.biTangents[idx + 1] = bitan[1];\n                    geom.biTangents[idx + 2] = bitan[2];\n\n                    geom.tangents[idx + 0] = tangents[i + 0];\n                    geom.tangents[idx + 1] = tangents[i + 1];\n                    geom.tangents[idx + 2] = tangents[i + 2];\n                }\n            }\n\n            if (geom.tangents.length === 0 || inCalcNormals.get() != "Never")\n            {\n                // console.log("[gltf ]no tangents... calculating tangents...");\n                geom.calcTangentsBitangents();\n            }\n        }\n\n        this.geom = geom;\n\n        this.bounds = geom.getBounds();\n    }\n\n    render(cgl, ignoreMaterial, skinRenderer)\n    {\n        if (!this.mesh && this.geom && this.geom.verticesIndices)\n        {\n            let g = this.geom;\n            if (this.geom.vertices.length / 3 > 64000)\n            {\n                g = this.geom.copy();\n                g.unIndex(false, true);\n            }\n\n            let glprim;\n            if (this.primitive == this.TRIANGLES)glprim = cgl.gl.TRIANGLES;\n            else if (this.primitive == this.LINES)glprim = cgl.gl.LINES;\n            else if (this.primitive == this.LINE_STRIP)glprim = cgl.gl.LINE_STRIP;\n            else if (this.primitive == this.POINTS)glprim = cgl.gl.POINTS;\n            else\n            {\n                op.logWarn("unknown primitive type", this);\n            }\n\n            this.mesh = op.patch.cg.createMesh(g, { "glPrimitive": glprim });\n        }\n\n        if (this.mesh)\n        {\n            // update morphTargets\n            if (this.geom && this.geom.morphTargets.length && !this.morphTargetsRenderMod)\n            {\n                this.mesh.addVertexNumbers = true;\n                this.morphTargetsRenderMod = new GltfTargetsRenderer(this);\n            }\n\n            let useMat = !ignoreMaterial && this.material != -1 && gltf.shaders[this.material];\n            if (skinRenderer)useMat = false;\n\n            if (useMat) cgl.pushShader(gltf.shaders[this.material]);\n\n            const currentShader = cgl.getShader() || {};\n            const uniDiff = currentShader.uniformColorDiffuse;\n\n            const uniPbrMetalness = currentShader.uniformPbrMetalness;\n            const uniPbrRoughness = currentShader.uniformPbrRoughness;\n\n            // if (gltf.shaders[this.material] && !inUseMatProps.get())\n            // {\n            //     gltf.shaders[this.material]=null;\n            // }\n\n            if (!gltf.shaders[this.material] && inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor)\n                {\n                    this._matDiffuseColorOrig = [uniDiff.getValue()[0], uniDiff.getValue()[1], uniDiff.getValue()[2], uniDiff.getValue()[3]];\n                    uniDiff.setValue(this._matDiffuseColor);\n                }\n\n                if (uniPbrMetalness)\n                    if (this._matPbrMetalness != null)\n                    {\n                        this._matPbrMetalnessOrig = uniPbrMetalness.getValue();\n                        uniPbrMetalness.setValue(this._matPbrMetalness);\n                    }\n                    else\n                        uniPbrMetalness.setValue(0);\n\n                if (uniPbrRoughness)\n                    if (this._matPbrRoughness != null)\n                    {\n                        this._matPbrRoughnessOrig = uniPbrRoughness.getValue();\n                        uniPbrRoughness.setValue(this._matPbrRoughness);\n                    }\n                    else\n                    {\n                        uniPbrRoughness.setValue(0);\n                    }\n            }\n\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderStart(cgl, 0);\n            if (this.mesh)\n            {\n                // console.log(this.mesh)\n                // this.mesh.lastMaterial=0;\n                this.mesh.render(cgl.getShader(), ignoreMaterial);\n            }\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderFinish(cgl);\n\n            if (inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor) uniDiff.setValue(this._matDiffuseColorOrig);\n                if (uniPbrMetalness && this._matPbrMetalnessOrig != undefined) uniPbrMetalness.setValue(this._matPbrMetalnessOrig);\n                if (uniPbrRoughness && this._matPbrRoughnessOrig != undefined) uniPbrRoughness.setValue(this._matPbrRoughnessOrig);\n            }\n\n            if (useMat) cgl.popShader();\n        }\n    }\n};\n', inc_meshGroup_js: "const gltfMeshGroup = class\n{\n    constructor(gltf, m)\n    {\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.meshes = [];\n        this.name = m.name;\n        const prims = m.primitives;\n\n        for (let i = 0; i < prims.length; i++)\n        {\n            const mesh = new gltfMesh(this.name, prims[i], gltf,\n                (mesh) =>\n                {\n                    mesh.extras = m.extras;\n                    this.bounds.apply(mesh.bounds);\n                });\n\n            mesh.submeshIndex = i;\n            this.meshes.push(mesh);\n        }\n    }\n\n    render(cgl, ignoreMat, skinRenderer, _time, weights)\n    {\n        for (let i = 0; i < this.meshes.length; i++)\n        {\n            const useMat = gltf.shaders[this.meshes[i].material];\n\n            if (!ignoreMat && useMat) cgl.pushShader(gltf.shaders[this.meshes[i].material]);\n            // console.log(gltf.shaders[this.meshes[i].material],this.meshes[i].material)\n            if (skinRenderer)skinRenderer.renderStart(cgl, _time);\n            if (weights) this.meshes[i].weights = weights;\n            this.meshes[i].render(cgl, ignoreMat, skinRenderer, _time);\n            if (skinRenderer)skinRenderer.renderFinish(cgl);\n            if (!ignoreMat && useMat) cgl.popShader();\n        }\n    }\n};\n", inc_node_js: 'const gltfNode = class\n{\n    constructor(node, gltf)\n    {\n        this.isChild = node.isChild || false;\n        this.name = node.name;\n        if (node.hasOwnProperty("camera")) this.camera = node.camera;\n        this.hidden = false;\n        this.mat = mat4.create();\n        this._animActions = {};\n        this.animWeights = [];\n        this._animMat = mat4.create();\n        this._tempMat = mat4.create();\n        this._tempQuat = quat.create();\n        this._tempRotmat = mat4.create();\n        this.mesh = null;\n        this.children = [];\n        this._node = node;\n        this._gltf = gltf;\n        this.absMat = mat4.create();\n        this.addTranslate = null;\n        this._tempAnimScale = null;\n        this.addMulMat = null;\n        this.updateMatrix();\n        this.skinRenderer = null;\n        this.copies = [];\n    }\n\n    get skin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._node.skin;\n        else return -1;\n    }\n\n    copy()\n    {\n        this.isCopy = true;\n        const n = new gltfNode(this._node, this._gltf);\n        n.copyOf = this;\n\n        n._animActions = this._animActions;\n        n.children = this.children;\n        if (this.skin) n.skinRenderer = new GltfSkin(this);\n\n        this.updateMatrix();\n        return n;\n    }\n\n    hasSkin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._gltf.json.skins[this._node.skin].name || "unknown";\n        return false;\n    }\n\n    initSkin()\n    {\n        if (this.skin > -1)\n        {\n            this.skinRenderer = new GltfSkin(this);\n        }\n    }\n\n    updateMatrix()\n    {\n        mat4.identity(this.mat);\n        if (this._node.translation) mat4.translate(this.mat, this.mat, this._node.translation);\n\n        if (this._node.rotation)\n        {\n            const rotmat = mat4.create();\n            this._rot = this._node.rotation;\n\n            mat4.fromQuat(rotmat, this._node.rotation);\n            mat4.mul(this.mat, this.mat, rotmat);\n        }\n\n        if (this._node.scale)\n        {\n            this._scale = this._node.scale;\n            mat4.scale(this.mat, this.mat, this._scale);\n        }\n\n        if (this._node.hasOwnProperty("mesh"))\n        {\n            this.mesh = this._gltf.meshes[this._node.mesh];\n            if (this.isCopy)\n            {\n                // console.log(this.mesh);\n            }\n        }\n\n        if (this._node.children)\n        {\n            for (let i = 0; i < this._node.children.length; i++)\n            {\n                this._gltf.json.nodes[i].isChild = true;\n                if (this._gltf.nodes[this._node.children[i]]) this._gltf.nodes[this._node.children[i]].isChild = true;\n                this.children.push(this._node.children[i]);\n            }\n        }\n    }\n\n    unHide()\n    {\n        this.hidden = false;\n        for (let i = 0; i < this.children.length; i++)\n            if (this.children[i].unHide) this.children[i].unHide();\n    }\n\n    calcBounds(gltf, mat, bounds)\n    {\n        const localMat = mat4.create();\n\n        if (mat) mat4.copy(localMat, mat);\n        if (this.mat) mat4.mul(localMat, localMat, this.mat);\n\n        if (this.mesh)\n        {\n            const bb = this.mesh.bounds.copy();\n            bb.mulMat4(localMat);\n            bounds.apply(bb);\n\n            if (bounds.changed)\n            {\n                boundingPoints.push(\n                    bb._min[0] || 0, bb._min[1] || 0, bb._min[2] || 0,\n                    bb._max[0] || 0, bb._max[1] || 0, bb._max[2] || 0);\n            }\n        }\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            if (gltf.nodes[this.children[i]] && gltf.nodes[this.children[i]].calcBounds)\n            {\n                const b = gltf.nodes[this.children[i]].calcBounds(gltf, localMat, bounds);\n\n                bounds.apply(b);\n            }\n        }\n\n        if (bounds.changed) return bounds;\n        else return null;\n    }\n\n    setAnimAction(name)\n    {\n        // console.log("setAnimAction:", name);\n        if (!name) return;\n\n        this._currentAnimaction = name;\n\n        if (name && !this._animActions[name])\n        {\n            // console.log("no action found:", name,this._animActions);\n            return null;\n        }\n\n        // else console.log("YES action found:", name);\n        // console.log(this._animActions);\n\n        for (let path in this._animActions[name])\n        {\n            if (path == "translation") this._animTrans = this._animActions[name][path];\n            else if (path == "rotation") this._animRot = this._animActions[name][path];\n            else if (path == "scale") this._animScale = this._animActions[name][path];\n            else if (path == "weights") this.animWeights = this._animActions[name][path];\n            else console.log("[gltfNode] unknown anim path", path, this._animActions[name][path]);\n        }\n    }\n\n    setAnim(path, name, anims)\n    {\n        if (!path || !name || !anims) return;\n\n        // console.log("setanim", this._node.name, path, name, anims);\n\n        this._animActions[name] = this._animActions[name] || {};\n\n        // console.log(this._animActions);\n        // debugger;\n\n        // for (let i = 0; i < this.copies.length; i++) this.copies[i]._animActions = this._animActions;\n\n        if (this._animActions[name][path]) op.log("[gltfNode] animation action path already exists", name, path, this._animActions[name][path]);\n\n        this._animActions[name][path] = anims;\n\n        if (path == "translation") this._animTrans = anims;\n        else if (path == "rotation") this._animRot = anims;\n        else if (path == "scale") this._animScale = anims;\n        else if (path == "weights")\n        {\n            // console.log("weights",name,path,anims)\n            this.animWeights = this._animActions[name][path];\n            // console.log(this.animWeights);\n        }\n        else console.warn("unknown anim path", path, anims);\n    }\n\n    modelMatLocal()\n    {\n        return this._animMat || this.mat;\n    }\n\n    modelMatAbs()\n    {\n        return this.absMat;\n    }\n\n    transform(cgl, _time)\n    {\n        if (!_time && _time != 0)_time = time;\n\n        this._lastTimeTrans = _time;\n\n        // console.log(this._rot)\n\n        gltfTransforms++;\n\n        if (!this._animTrans && !this._animRot && !this._animScale)\n        {\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this.mat);\n            this._animMat = null;\n        }\n        else\n        {\n            this._animMat = this._animMat || mat4.create();\n            mat4.identity(this._animMat);\n\n            const playAnims = true;\n\n            if (playAnims && this._animTrans)\n            {\n                mat4.translate(this._animMat, this._animMat, [\n                    this._animTrans[0].getValue(_time),\n                    this._animTrans[1].getValue(_time),\n                    this._animTrans[2].getValue(_time)]);\n            }\n            else\n            if (this._node.translation) mat4.translate(this._animMat, this._animMat, this._node.translation);\n\n            if (playAnims && this._animRot)\n            {\n                if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR) CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE)\n                {\n                    this._tempQuat[0] = this._animRot[0].getValue(_time);\n                    this._tempQuat[1] = this._animRot[1].getValue(_time);\n                    this._tempQuat[2] = this._animRot[2].getValue(_time);\n                    this._tempQuat[3] = this._animRot[3].getValue(_time);\n                }\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE)\n                {\n                    CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                }\n\n                mat4.fromQuat(this._tempMat, this._tempQuat);\n                mat4.mul(this._animMat, this._animMat, this._tempMat);\n            }\n            else if (this._rot)\n            {\n                mat4.fromQuat(this._tempRotmat, this._rot);\n                mat4.mul(this._animMat, this._animMat, this._tempRotmat);\n            }\n\n            if (playAnims && this._animScale)\n            {\n                if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];\n                this._tempAnimScale[0] = this._animScale[0].getValue(_time);\n                this._tempAnimScale[1] = this._animScale[1].getValue(_time);\n                this._tempAnimScale[2] = this._animScale[2].getValue(_time);\n                mat4.scale(this._animMat, this._animMat, this._tempAnimScale);\n            }\n            else if (this._scale) mat4.scale(this._animMat, this._animMat, this._scale);\n\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this._animMat);\n        }\n\n        if (this.animWeights)\n        {\n            this.weights = this.weights || [];\n\n            let str = "";\n            for (let i = 0; i < this.animWeights.length; i++)\n            {\n                this.weights[i] = this.animWeights[i].getValue(_time);\n                str += this.weights[i] + "/";\n            }\n\n            // console.log(str);\n            // this.mesh.weights=this.animWeights.get(_time);\n            // console.log(this.animWeights);\n        }\n\n        if (this.addTranslate) mat4.translate(cgl.mMatrix, cgl.mMatrix, this.addTranslate);\n\n        if (this.addMulMat) mat4.mul(cgl.mMatrix, cgl.mMatrix, this.addMulMat);\n\n        mat4.copy(this.absMat, cgl.mMatrix);\n    }\n\n    render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)\n    {\n        if (!dontTransform) cgl.pushModelMatrix();\n\n        if (_time === undefined) _time = gltf.time;\n\n        if (!dontTransform || this.skinRenderer) this.transform(cgl, _time);\n\n        if (this.hidden && !drawHidden)\n        {\n        }\n        else\n        {\n            if (this.skinRenderer)\n            {\n                this.skinRenderer.time = _time;\n                if (!dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, this.skinRenderer, _time, this.weights);\n            }\n            else\n            {\n                if (this.mesh && !dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, null, _time, this.weights);\n            }\n        }\n\n        if (!ignoreChilds && !this.hidden)\n            for (let i = 0; i < this.children.length; i++)\n                if (gltf.nodes[this.children[i]])\n                    gltf.nodes[this.children[i]].render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time);\n\n        if (!dontTransform)cgl.popModelMatrix();\n    }\n};\n', inc_print_js: `let tab = null;

function closeTab()
{
    if (tab)gui.mainTabs.closeTab(tab.id);
    tab = null;
}

function formatVec(arr)
{
    const nums = [];
    for (let i = 0; i < arr.length; i++)
    {
        nums.push(Math.round(arr[i] * 1000) / 1000);
    }

    return nums.join(",");
}

function printNode(html, node, level)
{
    if (!gltf) return;

    html += "<tr class=\\"row\\">";

    let ident = "";
    let identSpace = "";

    for (let i = 1; i < level; i++)
    {
        identSpace += "&nbsp;&nbsp;&nbsp;";
        let identClass = "identBg";
        if (i == 1)identClass = "identBgLevel0";
        ident += "<td class=\\"ident " + identClass + "\\" ><div style=\\"\\"></div></td>";
    }
    let id = CABLES.uuid();
    html += ident;
    html += "<td colspan=\\"" + (21 - level) + "\\">";

    if (node.mesh && node.mesh.meshes.length)html += "<span class=\\"icon icon-cube\\"></span>&nbsp;";
    else html += "<span class=\\"icon icon-box-select\\"></span> &nbsp;";

    html += node.name + "</td><td></td>";

    if (node.mesh)
    {
        html += "<td>";
        for (let i = 0; i < node.mesh.meshes.length; i++)
        {
            if (i > 0)html += ", ";
            html += node.mesh.meshes[i].name;
        }

        html += "</td>";

        html += "<td>";
        html += node.hasSkin() || "-";
        html += "</td>";

        html += "<td>";
        let countMats = 0;
        for (let i = 0; i < node.mesh.meshes.length; i++)
        {
            if (countMats > 0)html += ", ";
            if (gltf.json.materials && node.mesh.meshes[i].hasOwnProperty("material"))
            {
                if (gltf.json.materials[node.mesh.meshes[i].material])
                {
                    html += gltf.json.materials[node.mesh.meshes[i].material].name;
                    countMats++;
                }
            }
        }
        if (countMats == 0)html += "none";
        html += "</td>";
    }
    else
    {
        html += "<td>-</td><td>-</td><td>-</td>";
    }

    html += "<td>";

    if (node._node.translation || node._node.rotation || node._node.scale)
    {
        let info = "";

        if (node._node.translation)info += "Translate: \`" + formatVec(node._node.translation) + "\` || ";
        if (node._node.rotation)info += "Rotation: \`" + formatVec(node._node.rotation) + "\` || ";
        if (node._node.scale)info += "Scale: \`" + formatVec(node._node.scale) + "\` || ";

        html += "<span class=\\"icon icon-gizmo info\\" data-info=\\"" + info + "\\"></span> &nbsp;";
    }

    if (node._animRot || node._animScale || node._animTrans)
    {
        let info = "Animated: ";
        if (node._animRot) info += "Rot ";
        if (node._animScale) info += "Scale ";
        if (node._animTrans) info += "Trans ";

        html += "<span class=\\"icon icon-clock info\\" data-info=\\"" + info + "\\"></span>&nbsp;";
    }

    if (!node._node.translation && !node._node.rotation && !node._node.scale && !node._animRot && !node._animScale && !node._animTrans) html += "-";

    html += "</td>";

    html += "<td>";
    let hideclass = "";
    if (node.hidden)hideclass = "node-hidden";

    // html+='';
    html += "<a onclick=\\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "','transform')\\" class=\\"treebutton\\">Transform</a>";
    html += " <a onclick=\\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "','hierarchy')\\" class=\\"treebutton\\">Hierarchy</a>";
    html += " <a onclick=\\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "')\\" class=\\"treebutton\\">Node</a>";

    if (node.hasSkin())
        html += " <a onclick=\\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "',false,{skin:true});\\" class=\\"treebutton\\">Skin</a>";

    html += "</td><td>";
    html += "&nbsp;<span class=\\"icon iconhover icon-eye " + hideclass + "\\" onclick=\\"gui.corePatch().getOpById('" + op.id + "').toggleNodeVisibility('" + node.name + "');this.classList.toggle('node-hidden');\\"></span>";
    html += "</td>";

    html += "</tr>";

    if (node.children)
    {
        for (let i = 0; i < node.children.length; i++)
            html = printNode(html, gltf.nodes[node.children[i]], level + 1);
    }

    return html;
}

function printMaterial(mat, idx)
{
    let html = "<tr>";
    html += " <td>" + idx + "</td>";
    html += " <td>" + mat.name + "</td>";

    html += " <td>";

    const info = JSON.stringify(mat, null, 4).replaceAll("\\"", "").replaceAll("\\n", "<br/>");

    html += "<span class=\\"icon icon-info\\" onclick=\\"new CABLES.UI.ModalDialog({ 'html': '<pre>" + info + "</pre>', 'title': '" + mat.name + "' });\\"></span>&nbsp;";

    if (mat.pbrMetallicRoughness && mat.pbrMetallicRoughness.baseColorFactor)
    {
        let rgb = "";
        rgb += "" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[0] * 255);
        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[1] * 255);
        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[2] * 255);

        html += "<div style=\\"width:15px;height:15px;background-color:rgb(" + rgb + ");display:inline-block\\">&nbsp;</a>";
    }
    html += " <td style=\\"\\">" + (gltf.shaders[idx] ? "-" : "<a onclick=\\"gui.corePatch().getOpById('" + op.id + "').assignMaterial('" + mat.name + "')\\" class=\\"treebutton\\">Assign</a>") + "<td>";
    html += "<td>";

    html += "</tr>";
    return html;
}

function printInfo()
{
    if (!gltf) return;

    const startTime = performance.now();
    const sizes = {};
    let html = "<div style=\\"overflow:scroll;width:100%;height:100%\\">";

    html += "File: <a href=\\"" + CABLES.platform.getCablesUrl() + "/asset/patches/?filename=" + inFile.get() + "\\" target=\\"_blank\\">" + CABLES.basename(inFile.get()) + "</a><br/>";

    html += "Generator:" + gltf.json.asset.generator;

    let numNodes = 0;
    if (gltf.json.nodes)numNodes = gltf.json.nodes.length;
    html += "<div id=\\"groupNodes\\">Nodes (" + numNodes + ")</div>";

    html += "<table id=\\"sectionNodes\\" class=\\"table treetable\\">";

    html += "<tr>";
    html += " <th colspan=\\"21\\">Name</th>";
    html += " <th>Mesh</th>";
    html += " <th>Skin</th>";
    html += " <th>Material</th>";
    html += " <th>Transform</th>";
    html += " <th>Expose</th>";
    html += " <th></th>";
    html += "</tr>";

    for (let i = 0; i < gltf.nodes.length; i++)
    {
        if (!gltf.nodes[i].isChild)
            html = printNode(html, gltf.nodes[i], 1);
    }
    html += "</table>";

    // / //////////////////

    let numMaterials = 0;
    if (gltf.json.materials)numMaterials = gltf.json.materials.length;
    html += "<div id=\\"groupMaterials\\">Materials (" + numMaterials + ")</div>";

    if (!gltf.json.materials || gltf.json.materials.length == 0)
    {
    }
    else
    {
        html += "<table id=\\"materialtable\\"  class=\\"table treetable\\">";
        html += "<tr>";
        html += " <th>Index</th>";
        html += " <th>Name</th>";
        html += " <th>Color</th>";
        html += " <th>Function</th>";
        html += " <th></th>";
        html += "</tr>";
        for (let i = 0; i < gltf.json.materials.length; i++)
        {
            html += printMaterial(gltf.json.materials[i], i);
        }
        html += "</table>";
    }

    // / ///////////////////////

    html += "<div id=\\"groupMeshes\\">Meshes (" + gltf.json.meshes.length + ")</div>";

    html += "<table id=\\"meshestable\\"  class=\\"table treetable\\">";
    html += "<tr>";
    html += " <th>Name</th>";
    html += " <th>Node</th>";
    html += " <th>Material</th>";
    html += " <th>Vertices</th>";
    html += " <th>Attributes</th>";
    html += "</tr>";

    let sizeBufferViews = [];
    sizes.meshes = 0;
    sizes.meshTargets = 0;

    for (let i = 0; i < gltf.json.meshes.length; i++)
    {
        html += "<tr>";
        html += "<td>" + gltf.json.meshes[i].name + "</td>";

        html += "<td>";
        let count = 0;
        let nodename = "";
        for (let j = 0; j < gltf.json.nodes.length; j++)
        {
            if (gltf.json.nodes[j].mesh == i)
            {
                count++;
                if (count == 1)
                {
                    nodename = gltf.json.nodes[j].name;
                }
            }
        }
        if (count > 1) html += (count) + " nodes (" + nodename + " ...)";
        else html += nodename;
        html += "</td>";

        // -------

        html += "<td>";
        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            if (gltf.json.meshes[i].primitives[j].hasOwnProperty("material"))
            {
                if (gltf.json.materials[gltf.json.meshes[i]])
                {
                    html += gltf.json.materials[gltf.json.meshes[i].primitives[j].material].name + " ";
                }
            }
            else html += "None";
        }
        html += "</td>";

        html += "<td>";
        let numVerts = 0;
        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            if (gltf.json.meshes[i].primitives[j].attributes.POSITION != undefined)
            {
                let v = parseInt(gltf.json.accessors[gltf.json.meshes[i].primitives[j].attributes.POSITION].count);
                numVerts += v;
                html += "" + v + "<br/>";
            }
            else html += "-<br/>";
        }

        if (gltf.json.meshes[i].primitives.length > 1)
            html += "=" + numVerts;
        html += "</td>";

        html += "<td>";
        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            html += Object.keys(gltf.json.meshes[i].primitives[j].attributes);
            html += " <a onclick=\\"gui.corePatch().getOpById('" + op.id + "').exposeGeom('" + gltf.json.meshes[i].name + "'," + j + ")\\" class=\\"treebutton\\">Geometry</a>";
            html += "<br/>";

            if (gltf.json.meshes[i].primitives[j].targets)
            {
                html += gltf.json.meshes[i].primitives[j].targets.length + " targets<br/>";

                if (gltf.json.meshes[i].extras && gltf.json.meshes[i].extras.targetNames)
                    html += "Targetnames:<br/>" + gltf.json.meshes[i].extras.targetNames.join("<br/>");

                html += "<br/>";
            }
        }

        html += "</td>";
        html += "</tr>";

        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            const accessor = gltf.json.accessors[gltf.json.meshes[i].primitives[j].indices];
            if (accessor)
            {
                let bufView = accessor.bufferView;

                if (sizeBufferViews.indexOf(bufView) == -1)
                {
                    sizeBufferViews.push(bufView);
                    if (gltf.json.bufferViews[bufView])sizes.meshes += gltf.json.bufferViews[bufView].byteLength;
                }
            }

            for (let k in gltf.json.meshes[i].primitives[j].attributes)
            {
                const attr = gltf.json.meshes[i].primitives[j].attributes[k];
                const bufView2 = gltf.json.accessors[attr].bufferView;

                if (sizeBufferViews.indexOf(bufView2) == -1)
                {
                    sizeBufferViews.push(bufView2);
                    if (gltf.json.bufferViews[bufView2])sizes.meshes += gltf.json.bufferViews[bufView2].byteLength;
                }
            }

            if (gltf.json.meshes[i].primitives[j].targets)
                for (let k = 0; k < gltf.json.meshes[i].primitives[j].targets.length; k++)
                {
                    for (let l in gltf.json.meshes[i].primitives[j].targets[k])
                    {
                        const accessorIdx = gltf.json.meshes[i].primitives[j].targets[k][l];
                        const accessor = gltf.json.accessors[accessorIdx];
                        const bufView2 = accessor.bufferView;
                        console.log("accessor", accessor);
                        if (sizeBufferViews.indexOf(bufView2) == -1)
                            if (gltf.json.bufferViews[bufView2])
                            {
                                sizeBufferViews.push(bufView2);
                                sizes.meshTargets += gltf.json.bufferViews[bufView2].byteLength;
                            }
                    }
                }
        }
    }
    html += "</table>";

    // / //////////////////////////////////

    let numSamplers = 0;
    let numAnims = 0;
    let numKeyframes = 0;

    if (gltf.json.animations)
    {
        numAnims = gltf.json.animations.length;
        for (let i = 0; i < gltf.json.animations.length; i++)
        {
            numSamplers += gltf.json.animations[i].samplers.length;
        }
    }

    html += "<div id=\\"groupAnims\\">Animations (" + numAnims + "/" + numSamplers + ")</div>";

    if (gltf.json.animations)
    {
        html += "<table id=\\"sectionAnim\\" class=\\"table treetable\\">";
        html += "<tr>";
        html += "  <th>Name</th>";
        html += "  <th>Target node</th>";
        html += "  <th>Path</th>";
        html += "  <th>Interpolation</th>";
        html += "  <th>Keys</th>";
        html += "</tr>";


        sizes.animations = 0;

        for (let i = 0; i < gltf.json.animations.length; i++)
        {
            for (let j = 0; j < gltf.json.animations[i].samplers.length; j++)
            {
                let bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].input].bufferView;
                if (sizeBufferViews.indexOf(bufView) == -1)
                {
                    sizeBufferViews.push(bufView);
                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;
                }

                bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].output].bufferView;
                if (sizeBufferViews.indexOf(bufView) == -1)
                {
                    sizeBufferViews.push(bufView);
                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;
                }
            }

            for (let j = 0; j < gltf.json.animations[i].channels.length; j++)
            {
                html += "<tr>";
                html += "  <td> Anim " + i + ": " + gltf.json.animations[i].name + "</td>";

                html += "  <td>" + gltf.nodes[gltf.json.animations[i].channels[j].target.node].name + "</td>";
                html += "  <td>";
                html += gltf.json.animations[i].channels[j].target.path + " ";
                html += "  </td>";

                const smplidx = gltf.json.animations[i].channels[j].sampler;
                const smplr = gltf.json.animations[i].samplers[smplidx];

                html += "  <td>" + smplr.interpolation + "</td>";

                html += "  <td>" + gltf.json.accessors[smplr.output].count;
                numKeyframes += gltf.json.accessors[smplr.output].count;

                // html += "&nbsp;&nbsp;<a onclick=\\"gui.corePatch().getOpById('" + op.id + "').showAnim('" + i + "','" + j + "')\\" class=\\"icon icon-search\\"></a>";

                html += "</td>";

                html += "</tr>";
            }
        }

        html += "<tr>";
        html += "  <td></td>";
        html += "  <td></td>";
        html += "  <td></td>";
        html += "  <td></td>";
        html += "  <td>" + numKeyframes + " total</td>";
        html += "</tr>";
        html += "</table>";
    }
    else
    {

    }

    // / ///////////////////

    let numImages = 0;
    if (gltf.json.images)numImages = gltf.json.images.length;
    html += "<div id=\\"groupImages\\">Images (" + numImages + ")</div>";

    if (gltf.json.images)
    {
        html += "<table id=\\"sectionImages\\" class=\\"table treetable\\">";

        html += "<tr>";
        html += "  <th>name</th>";
        html += "  <th>type</th>";
        html += "  <th>func</th>";
        html += "</tr>";

        sizes.images = 0;

        for (let i = 0; i < gltf.json.images.length; i++)
        {
            if (gltf.json.images[i].hasOwnProperty("bufferView"))
            {
                // if (sizeBufferViews.indexOf(gltf.json.images[i].hasOwnProperty("bufferView")) == -1)console.log("image bufferview already there?!");
                // else
                sizes.images += gltf.json.bufferViews[gltf.json.images[i].bufferView].byteLength;
            }
            else console.log("image has no bufferview?!");

            html += "<tr>";
            html += "<td>" + gltf.json.images[i].name + "</td>";
            html += "<td>" + gltf.json.images[i].mimeType + "</td>";
            html += "<td>";

            let name = gltf.json.images[i].name;
            if (name === undefined)name = gltf.json.images[i].bufferView;

            html += "<a onclick=\\"gui.corePatch().getOpById('" + op.id + "').exposeTexture('" + name + "')\\" class=\\"treebutton\\">Expose</a>";
            html += "</td>";

            html += "<tr>";
        }
        html += "</table>";
    }

    // / ///////////////////////

    let numCameras = 0;
    if (gltf.json.cameras)numCameras = gltf.json.cameras.length;
    html += "<div id=\\"groupCameras\\">Cameras (" + numCameras + ")</div>";

    if (gltf.json.cameras)
    {
        html += "<table id=\\"sectionCameras\\" class=\\"table treetable\\">";

        html += "<tr>";
        html += "  <th>name</th>";
        html += "  <th>type</th>";
        html += "  <th>info</th>";
        html += "</tr>";

        for (let i = 0; i < gltf.json.cameras.length; i++)
        {
            html += "<tr>";
            html += "<td>" + gltf.json.cameras[i].name + "</td>";
            html += "<td>" + gltf.json.cameras[i].type + "</td>";
            html += "<td>";

            if (gltf.json.cameras[i].perspective)
            {
                html += "yfov: " + Math.round(gltf.json.cameras[i].perspective.yfov * 100) / 100;
                html += ", ";
                html += "zfar: " + Math.round(gltf.json.cameras[i].perspective.zfar * 100) / 100;
                html += ", ";
                html += "znear: " + Math.round(gltf.json.cameras[i].perspective.znear * 100) / 100;
            }
            html += "</td>";

            html += "<tr>";
        }
        html += "</table>";
    }

    // / ////////////////////////////////////

    let numSkins = 0;
    if (gltf.json.skins)numSkins = gltf.json.skins.length;
    html += "<div id=\\"groupSkins\\">Skins (" + numSkins + ")</div>";

    if (gltf.json.skins)
    {
        // html += "<h3>Skins (" + gltf.json.skins.length + ")</h3>";
        html += "<table id=\\"sectionSkins\\" class=\\"table treetable\\">";

        html += "<tr>";
        html += "  <th>name</th>";
        html += "  <th></th>";
        html += "  <th>total joints</th>";
        html += "</tr>";

        for (let i = 0; i < gltf.json.skins.length; i++)
        {
            html += "<tr>";
            html += "<td>" + gltf.json.skins[i].name + "</td>";
            html += "<td>" + "</td>";
            html += "<td>" + gltf.json.skins[i].joints.length + "</td>";
            html += "<td>";
            html += "</td>";
            html += "<tr>";
        }
        html += "</table>";
    }

    // / ////////////////////////////////////

    if (gltf.timing)
    {
        html += "<div id=\\"groupTiming\\">Debug Loading Timing </div>";

        html += "<table id=\\"sectionTiming\\" class=\\"table treetable\\">";

        html += "<tr>";
        html += "  <th>task</th>";
        html += "  <th>time used</th>";
        html += "</tr>";

        let lt = 0;
        for (let i = 0; i < gltf.timing.length - 1; i++)
        {
            html += "<tr>";
            html += "  <td>" + gltf.timing[i][0] + "</td>";
            html += "  <td>" + (gltf.timing[i + 1][1] - gltf.timing[i][1]) + " ms</td>";
            html += "</tr>";
            // lt = gltf.timing[i][1];
        }
        html += "</table>";
    }

    // / //////////////////////////

    let sizeBin = 0;
    if (gltf.json.buffers)
        sizeBin = gltf.json.buffers[0].byteLength;

    html += "<div id=\\"groupBinary\\">File Size Allocation (" + Math.round(sizeBin / 1024) + "k )</div>";

    html += "<table id=\\"sectionBinary\\" class=\\"table treetable\\">";
    html += "<tr>";
    html += "  <th>name</th>";
    html += "  <th>size</th>";
    html += "  <th>%</th>";
    html += "</tr>";
    let sizeUnknown = sizeBin;
    for (let i in sizes)
    {
        // html+=i+':'+Math.round(sizes[i]/1024);
        html += "<tr>";
        html += "<td>" + i + "</td>";
        html += "<td>" + readableSize(sizes[i]) + " </td>";
        html += "<td>" + Math.round(sizes[i] / sizeBin * 100) + "% </td>";
        html += "<tr>";
        sizeUnknown -= sizes[i];
    }

    if (sizeUnknown != 0)
    {
        html += "<tr>";
        html += "<td>unknown</td>";
        html += "<td>" + readableSize(sizeUnknown) + " </td>";
        html += "<td>" + Math.round(sizeUnknown / sizeBin * 100) + "% </td>";
        html += "<tr>";
    }

    html += "</table>";
    html += "</div>";

    tab = new CABLES.UI.Tab("GLTF " + CABLES.basename(inFile.get()), { "icon": "cube", "infotext": "tab_gltf", "padding": true, "singleton": true });
    gui.mainTabs.addTab(tab, true);

    tab.addEventListener("close", closeTab);
    tab.html(html);

    CABLES.UI.Collapsable.setup(ele.byId("groupNodes"), ele.byId("sectionNodes"), false);
    CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"), ele.byId("materialtable"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupAnims"), ele.byId("sectionAnim"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"), ele.byId("meshestable"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupCameras"), ele.byId("sectionCameras"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupImages"), ele.byId("sectionImages"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupSkins"), ele.byId("sectionSkins"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupBinary"), ele.byId("sectionBinary"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupTiming"), ele.byId("sectionTiming"), true);

    gui.maintabPanel.show(true);
}

function readableSize(n)
{
    if (n > 1024) return Math.round(n / 1024) + " kb";
    if (n > 1024 * 500) return Math.round(n / 1024) + " mb";
    else return n + " bytes";
}
`, inc_skin_js: 'const GltfSkin = class\n{\n    constructor(node)\n    {\n        this._mod = null;\n        this._node = node;\n        this._lastTime = 0;\n        this._matArr = [];\n        this._m = mat4.create();\n        this._invBindMatrix = mat4.create();\n        this.identity = true;\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, op.name + this._node.name);\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.skin_head_vert || "",\n                "srcBodyVert": attachments.skin_vert || ""\n            });\n\n            this._mod.addUniformVert("m4[]", "MOD_boneMats", []);// bohnenmatze\n            const tr = vec3.create();\n        }\n\n        const skinIdx = this._node.skin;\n        const arrLength = gltf.json.skins[skinIdx].joints.length * 16;\n\n        // if (this._lastTime != time || !time)\n        {\n            // this._lastTime=inTime.get();\n            if (this._matArr.length != arrLength) this._matArr.length = arrLength;\n\n            for (let i = 0; i < gltf.json.skins[skinIdx].joints.length; i++)\n            {\n                const i16 = i * 16;\n                const jointIdx = gltf.json.skins[skinIdx].joints[i];\n                const nodeJoint = gltf.nodes[jointIdx];\n\n                for (let j = 0; j < 16; j++)\n                    this._invBindMatrix[j] = gltf.accBuffers[gltf.json.skins[skinIdx].inverseBindMatrices][i16 + j];\n\n                mat4.mul(this._m, nodeJoint.modelMatAbs(), this._invBindMatrix);\n\n                for (let j = 0; j < this._m.length; j++) this._matArr[i16 + j] = this._m[j];\n            }\n\n            this._mod.setUniformValue("MOD_boneMats", this._matArr);\n            this._lastTime = time;\n        }\n\n        this._mod.define("SKIN_NUM_BONES", gltf.json.skins[skinIdx].joints.length);\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n};\n', inc_targets_js: 'const GltfTargetsRenderer = class\n{\n    constructor(mesh)\n    {\n        this.mesh = mesh;\n        this.tex = null;\n        this.numRowsPerTarget = 0;\n\n        this.makeTex(mesh.geom);\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, "gltftarget");\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.targets_head_vert || "",\n                "srcBodyVert": attachments.targets_vert || ""\n            });\n\n            this._mod.addUniformVert("4f", "MOD_targetTexInfo", [0, 0, 0, 0]);\n            this._mod.addUniformVert("t", "MOD_targetTex", 1);\n            this._mod.addUniformVert("f[]", "MOD_weights", []);\n\n            const tr = vec3.create();\n        }\n\n        this._mod.pushTexture("MOD_targetTex", this.tex);\n        if (this.tex && this.mesh.weights)\n        {\n            this._mod.setUniformValue("MOD_weights", this.mesh.weights);\n            this._mod.setUniformValue("MOD_targetTexInfo", [this.tex.width, this.tex.height, this.numRowsPerTarget, this.mesh.weights.length]);\n\n            this._mod.define("MOD_NUM_WEIGHTS", Math.max(1, this.mesh.weights.length));\n        }\n        else\n        {\n            this._mod.define("MOD_NUM_WEIGHTS", 1);\n        }\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n\n    makeTex(geom)\n    {\n        if (!geom.morphTargets || !geom.morphTargets.length) return;\n\n        let w = geom.morphTargets[0].vertices.length / 3;\n        let h = 0;\n        this.numRowsPerTarget = 0;\n\n        if (geom.morphTargets[0].vertices && geom.morphTargets[0].vertices.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].vertexNormals && geom.morphTargets[0].vertexNormals.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].tangents && geom.morphTargets[0].tangents.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].bitangents && geom.morphTargets[0].bitangents.length) this.numRowsPerTarget++;\n\n        h = geom.morphTargets.length * this.numRowsPerTarget;\n\n        // console.log("this.numRowsPerTarget", this.numRowsPerTarget);\n\n        const pixels = new Float32Array(w * h * 4);\n        let row = 0;\n\n        for (let i = 0; i < geom.morphTargets.length; i++)\n        {\n            if (geom.morphTargets[i].vertices && geom.morphTargets[i].vertices.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertices.length; j += 3)\n                {\n                    pixels[((row * w) + (j / 3)) * 4 + 0] = geom.morphTargets[i].vertices[j + 0];\n                    pixels[((row * w) + (j / 3)) * 4 + 1] = geom.morphTargets[i].vertices[j + 1];\n                    pixels[((row * w) + (j / 3)) * 4 + 2] = geom.morphTargets[i].vertices[j + 2];\n                    pixels[((row * w) + (j / 3)) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].vertexNormals && geom.morphTargets[i].vertexNormals.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertexNormals.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].vertexNormals[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].vertexNormals[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].vertexNormals[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n\n                row++;\n            }\n\n            if (geom.morphTargets[i].tangents && geom.morphTargets[i].tangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].tangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].tangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].tangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].tangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].bitangents && geom.morphTargets[i].bitangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].bitangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].bitangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].bitangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].bitangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n        }\n\n        this.tex = new CGL.Texture(cgl, { "isFloatingPointTexture": true, "name": "targetsTexture" });\n\n        this.tex.initFromData(pixels, w, h, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);\n\n        // console.log("morphTargets generated texture", w, h);\n    }\n};\n', skin_vert: "int index=int(attrJoints.x);\nvec4 newPos = (MOD_boneMats[index] * pos) * attrWeights.x;\nvec3 newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.x).xyz);\n\nindex=int(attrJoints.y);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.y;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.y).xyz)+newNorm;\n\nindex=int(attrJoints.z);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.z;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.z).xyz)+newNorm;\n\nindex=int(attrJoints.w);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.w ;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.w).xyz)+newNorm;\n\npos=newPos;\n\nnorm=normalize(newNorm.xyz);\n\n\n", skin_head_vert: "\nIN vec4 attrWeights;\nIN vec4 attrJoints;\nUNI mat4 MOD_boneMats[SKIN_NUM_BONES];\n", targets_vert: "\n\nfloat MOD_width=MOD_targetTexInfo.x;\nfloat MOD_height=MOD_targetTexInfo.y;\nfloat MOD_numTargets=MOD_targetTexInfo.w;\nfloat MOD_numLinesPerTarget=MOD_height/MOD_numTargets;\n\nfloat halfpix=(1.0/MOD_width)*0.5;\nfloat halfpixy=(1.0/MOD_height)*0.5;\n\nfloat x=(attrVertIndex)/MOD_width+halfpix;\n\nvec3 off=vec3(0.0);\n\nfor(float i=0.0;i<MOD_numTargets;i+=1.0)\n{\n    float y=1.0-((MOD_numLinesPerTarget*i)/MOD_height+halfpixy);\n    vec2 coord=vec2(x,y);\n    vec3 targetXYZ = texture(MOD_targetTex,coord).xyz;\n\n    off+=(targetXYZ*MOD_weights[int(i)]);\n\n\n\n    coord.y+=1.0/MOD_height; // normals are in next row\n    vec3 targetNormal = texture(MOD_targetTex,coord).xyz;\n    norm+=targetNormal*MOD_weights[int(i)];\n\n\n}\n\n// norm=normalize(norm);\npos.xyz+=off;\n", targets_head_vert: "\nUNI float MOD_weights[MOD_NUM_WEIGHTS];\n" };
  const v = class {
    constructor(A2, e2) {
      this.node = e2;
      this.name = e2.name;
      this.config = A2.json.cameras[e2.camera];
      this.pos = vec3.create();
      this.quat = quat.create();
      this.vCenter = vec3.create();
      this.vUp = vec3.create();
      this.vMat = mat4.create();
    }
    updateAnim(A2) {
      if (this.node && this.node._animTrans) {
        vec3.set(this.pos, this.node._animTrans[0].getValue(A2), this.node._animTrans[1].getValue(A2), this.node._animTrans[2].getValue(A2));
        quat.set(this.quat, this.node._animRot[0].getValue(A2), this.node._animRot[1].getValue(A2), this.node._animRot[2].getValue(A2), this.node._animRot[3].getValue(A2));
      }
    }
    start(A2) {
      if (E.frameStore.shadowPass)
        return;
      this.updateAnim(A2);
      const e2 = E.getViewPort()[2] / E.getViewPort()[3];
      E.pushPMatrix();
      E.pushViewMatrix();
      let t2 = mat4.create();
      mat4.invert(t2, this.node.modelMatAbs());
      this.vMat = t2;
      mat4.identity(E.vMatrix);
      mat4.mul(E.vMatrix, E.vMatrix, t2);
    }
    end() {
      if (E.frameStore.shadowPass)
        return;
      E.popPMatrix();
      E.popViewMatrix();
    }
  };
  const f = true;
  const O = class {
    constructor() {
      this.json = {};
      this.accBuffers = [];
      this.meshes = [];
      this.nodes = [];
      this.shaders = [];
      this.timing = [];
      this.cams = [];
      this.startTime = performance.now();
      this.bounds = new CABLES.CG.BoundingBox();
      this.loaded = Date.now();
      this.accBuffersDelete = [];
    }
    getNode(e2) {
      for (let A2 = 0; A2 < this.nodes.length; A2++) {
        if (this.nodes[A2].name == e2)
          return this.nodes[A2];
      }
    }
    unHideAll() {
      for (let A2 = 0; A2 < this.nodes.length; A2++) {
        this.nodes[A2].unHide();
      }
    }
  };
  function D(A2) {
    if (window.TextDecoder)
      return new TextDecoder("utf-8").decode(A2);
    let e2, t2, g2, i2;
    let I2, n2;
    e2 = "";
    g2 = A2.length;
    t2 = 0;
    while (t2 < g2) {
      i2 = A2[t2++];
      switch (i2 >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          e2 += String.fromCharCode(i2);
          break;
        case 12:
        case 13:
          I2 = A2[t2++];
          e2 += String.fromCharCode((i2 & 31) << 6 | I2 & 63);
          break;
        case 14:
          I2 = A2[t2++];
          n2 = A2[t2++];
          e2 += String.fromCharCode((i2 & 15) << 12 | (I2 & 63) << 6 | (n2 & 63) << 0);
          break;
      }
    }
    return e2;
  }
  function y(A2, e2, t2, g2) {
    const i2 = {};
    if (g2 >= A2.byteLength) {
      m.log("could not read chunk...");
      return;
    }
    i2.size = A2.getUint32(g2 + 0, f);
    i2.type = D(e2.subarray(g2 + 4, g2 + 4 + 4));
    if (i2.type == "BIN\0") {
      i2.dataView = new DataView(t2, g2 + 8, i2.size);
    } else if (i2.type == "JSON") {
      const I2 = D(e2.subarray(g2 + 8, g2 + 8 + i2.size));
      try {
        const n2 = JSON.parse(I2);
        i2.data = n2;
        nA.set(n2.asset.generator);
      } catch (A3) {
      }
    } else {
      m.warn("unknown type", i2.type);
    }
    return i2;
  }
  function k(e2) {
    const g2 = {};
    for (let A2 = 0; A2 < e2.json.animations.length; A2++) {
      const i2 = e2.json.animations[A2];
      i2.name = i2.name || "unknown";
      for (let A3 = 0; A3 < i2.channels.length; A3++) {
        const I2 = i2.channels[A3];
        const n2 = e2.nodes[I2.target.node];
        const o2 = i2.samplers[I2.sampler];
        const t2 = e2.json.accessors[o2.input];
        const C2 = e2.accBuffers[o2.input];
        const a2 = e2.json.accessors[o2.output];
        const r2 = e2.accBuffers[o2.output];
        e2.accBuffersDelete.push(o2.output, o2.input);
        if (C2 && r2) {
          let t3 = 1;
          if (a2.type === "VEC2")
            t3 = 2;
          else if (a2.type === "VEC3")
            t3 = 3;
          else if (a2.type === "VEC4")
            t3 = 4;
          else if (a2.type === "SCALAR") {
            t3 = r2.length / C2.length;
          } else
            m.log("[] UNKNOWN accOut.type", a2.type);
          const s2 = [];
          g2[i2.name] = true;
          for (let A4 = 0; A4 < t3; A4++) {
            const B2 = new CABLES.Anim();
            s2.push(B2);
          }
          if (o2.interpolation === "LINEAR") {
          } else if (o2.interpolation === "STEP")
            for (let A4 = 0; A4 < t3; A4++)
              s2[A4].defaultEasing = CABLES.EASING_ABSOLUTE;
          else if (o2.interpolation === "CUBICSPLINE")
            for (let A4 = 0; A4 < t3; A4++)
              s2[A4].defaultEasing = CABLES.EASING_CUBICSPLINE;
          else
            m.warn("unknown interpolation", o2.interpolation);
          if (C2[0] !== 0)
            for (let A4 = 0; A4 < t3; A4++)
              s2[A4].setValue(0, r2[0 * t3 + A4]);
          for (let e3 = 0; e3 < C2.length; e3++) {
            p = Math.max(C2[e3], p);
            for (let A4 = 0; A4 < t3; A4++) {
              if (s2[A4].defaultEasing === CABLES.EASING_CUBICSPLINE) {
                const Q2 = e3 * t3 * 3 + A4;
                const E2 = s2[A4].setValue(C2[e3], r2[Q2 + t3]);
                E2.bezTangIn = r2[Q2];
                E2.bezTangOut = r2[Q2 + t3 * 2];
              } else {
                s2[A4].setValue(C2[e3], r2[e3 * t3 + A4]);
              }
            }
          }
          n2.setAnim(I2.target.path, i2.name, s2);
        } else {
          m.warn("loadAmins bufferIn undefined ", C2 === void 0);
          m.warn("loadAmins bufferOut undefined ", r2 === void 0);
          m.warn("loadAmins ", o2, a2);
          m.warn("loadAmins num accBuffers", e2.accBuffers.length);
          m.warn("loadAmins num accessors", e2.json.accessors.length);
        }
      }
    }
    e2.uniqueAnimNames = g2;
    BA.setRef(Object.keys(g2));
  }
  function x(t2) {
    if (!t2 || !t2.json.cameras)
      return;
    t2.cameras = t2.cameras || [];
    for (let e2 = 0; e2 < t2.nodes.length; e2++) {
      if (t2.nodes[e2].hasOwnProperty("camera")) {
        const A2 = new v(t2, t2.nodes[e2]);
        t2.cameras.push(A2);
      }
    }
  }
  function T() {
    if (!window.DracoDecoder) {
      setTimeout(() => {
        T();
      }, 100);
    }
    M();
  }
  function J(A2) {
    const e2 = 8;
    let i2 = 0, t2 = 0;
    const I2 = new O();
    I2.timing.push(["Start parsing", Math.round(performance.now() - I2.startTime)]);
    if (!A2)
      return;
    const g2 = new Uint8Array(A2);
    let n2 = 0;
    const o2 = D(g2.subarray(n2, 4));
    n2 += 4;
    if (o2 != "glTF")
      return;
    I2.timing.push(["dataview", Math.round(performance.now() - I2.startTime)]);
    const C2 = new DataView(A2);
    const a2 = C2.getUint32(n2, f);
    n2 += 4;
    const r2 = C2.getUint32(n2, f);
    n2 += 4;
    oA.set(a2);
    const s2 = [];
    I2.chunks = s2;
    s2.push(y(C2, g2, A2, n2));
    n2 += s2[0].size + e2;
    I2.json = s2[0].data;
    I2.cables = { fileUrl: N.get(), shortFileName: CABLES.basename(N.get()) };
    sA.setRef(I2.json);
    CA.setRef(I2.json.extensionsUsed || []);
    let B2 = y(C2, g2, A2, n2);
    while (B2) {
      s2.push(B2);
      n2 += B2.size + e2;
      B2 = y(C2, g2, A2, n2);
    }
    I2.chunks = s2;
    const Q2 = s2[0].data.bufferViews;
    const E2 = s2[0].data.accessors;
    I2.timing.push(["Parse buffers", Math.round(performance.now() - I2.startTime)]);
    if (I2.json.extensionsUsed && I2.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1) {
      if (!window.DracoDecoder) {
        m.setUiError("gltfdraco", "GLTF draco compression lib not found / add draco op to your patch!");
        T();
        return I2;
      } else {
        I2.useDraco = true;
      }
    }
    m.setUiError("gltfdraco", null);
    if (Q2) {
      for (t2 = 0; t2 < E2.length; t2++) {
        const l2 = E2[t2];
        const u2 = Q2[l2.bufferView];
        let g3 = 0;
        if (l2.type == "SCALAR")
          g3 = 1;
        else if (l2.type == "VEC2")
          g3 = 2;
        else if (l2.type == "VEC3")
          g3 = 3;
        else if (l2.type == "VEC4")
          g3 = 4;
        else if (l2.type == "MAT4")
          g3 = 16;
        else
          console.error("unknown accessor type", l2.type);
        if (s2[1].dataView) {
          if (u2) {
            const c2 = l2.count * g3;
            let A3 = (u2.byteOffset || 0) + (l2.byteOffset || 0);
            let e3 = u2.byteStride || 0;
            let t3 = null;
            if (l2.componentType == 5126 || l2.componentType == 5125) {
              e3 = e3 || 4;
              const h2 = l2.componentType == 5125;
              if (h2)
                t3 = new Uint32Array(c2);
              else
                t3 = new Float32Array(c2);
              for (i2 = 0; i2 < c2; i2++) {
                if (h2)
                  t3[i2] = s2[1].dataView.getUint32(A3, f);
                else
                  t3[i2] = s2[1].dataView.getFloat32(A3, f);
                if (e3 != 4 && (i2 + 1) % g3 === 0)
                  A3 += e3 - g3 * 4;
                A3 += 4;
              }
            } else if (l2.componentType == 5123) {
              e3 = e3 || 2;
              t3 = new Uint16Array(c2);
              for (i2 = 0; i2 < c2; i2++) {
                t3[i2] = s2[1].dataView.getUint16(A3, f);
                if (e3 != 2 && (i2 + 1) % g3 === 0)
                  A3 += e3 - g3 * 2;
                A3 += 2;
              }
            } else if (l2.componentType == 5121) {
              e3 = e3 || 1;
              t3 = new Uint8Array(c2);
              for (i2 = 0; i2 < c2; i2++) {
                t3[i2] = s2[1].dataView.getUint8(A3, f);
                if (e3 != 1 && (i2 + 1) % g3 === 0)
                  A3 += e3 - g3 * 1;
                A3 += 1;
              }
            } else {
              console.error("unknown component type", l2.componentType);
            }
            I2.accBuffers.push(t3);
          } else {
          }
        }
      }
    }
    I2.timing.push(["Parse mesh groups", Math.round(performance.now() - I2.startTime)]);
    I2.json.meshes = I2.json.meshes || [];
    if (I2.json.meshes) {
      for (t2 = 0; t2 < I2.json.meshes.length; t2++) {
        const p2 = new K(I2, I2.json.meshes[t2]);
        I2.meshes.push(p2);
      }
    }
    I2.timing.push(["Parse nodes", Math.round(performance.now() - I2.startTime)]);
    for (t2 = 0; t2 < I2.json.nodes.length; t2++) {
      if (I2.json.nodes[t2].children)
        for (i2 = 0; i2 < I2.json.nodes[t2].children.length; i2++) {
          I2.json.nodes[I2.json.nodes[t2].children[i2]].isChild = true;
        }
    }
    for (t2 = 0; t2 < I2.json.nodes.length; t2++) {
      const d2 = new j(I2.json.nodes[t2], I2);
      I2.nodes.push(d2);
    }
    for (t2 = 0; t2 < I2.nodes.length; t2++) {
      const d2 = I2.nodes[t2];
      if (!d2.children)
        continue;
      for (let A3 = 0; A3 < d2.children.length; A3++) {
        I2.nodes[d2.children[A3]].parent = d2;
      }
    }
    for (t2 = 0; t2 < I2.nodes.length; t2++) {
      I2.nodes[t2].initSkin();
    }
    R = true;
    I2.timing.push(["load anims", Math.round(performance.now() - I2.startTime)]);
    if (I2.json.animations)
      k(I2);
    I2.timing.push(["load cameras", Math.round(performance.now() - I2.startTime)]);
    if (I2.json.cameras)
      x(I2);
    I2.timing.push(["finished", Math.round(performance.now() - I2.startTime)]);
    return I2;
  }
  let Y = class {
    constructor(A2, t2, I2, n2) {
      this.POINTS = 0;
      this.LINES = 1;
      this.LINE_LOOP = 2;
      this.LINE_STRIP = 3;
      this.TRIANGLES = 4;
      this.TRIANGLE_STRIP = 5;
      this.TRIANGLE_FAN = 6;
      this.test = 0;
      this.name = A2;
      this.submeshIndex = 0;
      this.material = t2.material;
      this.mesh = null;
      this.geom = new CGL.Geometry("gltf_" + this.name);
      this.geom.verticesIndices = [];
      this.bounds = null;
      this.primitive = 4;
      this.morphTargetsRenderMod = null;
      this.weights = t2.weights;
      if (t2.hasOwnProperty("mode"))
        this.primitive = t2.mode;
      if (t2.hasOwnProperty("indices"))
        this.geom.verticesIndices = I2.accBuffers[t2.indices];
      I2.loadingMeshes = I2.loadingMeshes || 0;
      I2.loadingMeshes++;
      this.materialJson = this._matPbrMetalness = this._matPbrRoughness = this._matDiffuseColor = null;
      if (I2.json.materials) {
        if (this.material != -1)
          this.materialJson = I2.json.materials[this.material];
        if (this.materialJson && this.materialJson.pbrMetallicRoughness) {
          if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor")) {
            this._matDiffuseColor = [1, 1, 1, 1];
          } else {
            this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;
          }
          this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;
          if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor")) {
            this._matPbrMetalness = 1;
          } else {
            this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null;
          }
          if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor")) {
            this._matPbrRoughness = 1;
          } else {
            this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null;
          }
        }
      }
      if (I2.useDraco && t2.extensions.KHR_draco_mesh_compression) {
        const g2 = I2.chunks[0].data.bufferViews[t2.extensions.KHR_draco_mesh_compression.bufferView];
        const i2 = g2.byteLength;
        const o2 = new Int8Array(i2);
        let e2 = g2.byteOffset || 0;
        for (let A3 = 0; A3 < i2; A3++) {
          o2[A3] = I2.chunks[1].dataView.getInt8(e2, f);
          e2++;
        }
        const C2 = window.DracoDecoder;
        C2.decodeGeometry(o2.buffer, (e3) => {
          const t3 = new CGL.Geometry("draco mesh " + A2);
          for (let A3 = 0; A3 < e3.attributes.length; A3++) {
            const g3 = e3.attributes[A3];
            if (g3.name === "position")
              t3.vertices = g3.array;
            else if (g3.name === "normal")
              t3.vertexNormals = g3.array;
            else if (g3.name === "uv")
              t3.texCoords = g3.array;
            else if (g3.name === "color")
              t3.vertexColors = this.calcVertexColors(g3.array);
            else if (g3.name === "joints")
              t3.setAttribute("attrJoints", Array.from(g3.array), 4);
            else if (g3.name === "weights") {
              const i3 = new Float32Array(g3.array.length / g3.itemSize * 4);
              for (let e4 = 0; e4 < g3.array.length / g3.itemSize; e4++) {
                i3[e4 * 4] = i3[e4 * 4 + 1] = i3[e4 * 4 + 2] = i3[e4 * 4 + 3] = 0;
                for (let A4 = 0; A4 < g3.itemSize; A4++)
                  i3[e4 * 4 + A4] = g3.array[e4 * g3.itemSize + A4];
              }
              t3.setAttribute("attrWeights", i3, 4);
            } else
              m.logWarn("unknown draco attrib", g3);
          }
          e3.attributes = null;
          t3.verticesIndices = e3.index.array;
          this.setGeom(t3);
          this.mesh = null;
          I2.loadingMeshes--;
          I2.timing.push(["draco decode", Math.round(performance.now() - I2.startTime)]);
          if (n2)
            n2(this);
        }, (A3) => {
          m.logError(A3);
        });
      } else {
        I2.loadingMeshes--;
        this.fillGeomAttribs(I2, this.geom, t2.attributes);
        if (t2.targets) {
          for (let A3 = 0; A3 < t2.targets.length; A3++) {
            const e2 = new CGL.Geometry("gltf_target_" + A3);
            this.fillGeomAttribs(I2, e2, t2.targets[A3], false);
            this.geom.morphTargets.push(e2);
          }
        }
        if (n2)
          n2(this);
      }
    }
    _linearToSrgb(A2) {
      if (A2 <= 0)
        return 0;
      else if (A2 >= 1)
        return 1;
      else if (A2 < 31308e-7)
        return A2 * 12.92;
      else
        return A2 ** (1 / 2.2) * 1.055 - 0.055;
    }
    calcVertexColors(t2) {
      let g2 = null;
      if (t2 instanceof Float32Array) {
        let e2 = false;
        for (let A2 = 0; A2 < t2.length; A2++) {
          if (t2[A2] > 1) {
            e2 = true;
            continue;
          }
        }
        if (e2)
          for (let A2 = 0; A2 < t2.length; A2++)
            t2[A2] /= 65535;
        g2 = t2;
      } else if (t2 instanceof Uint16Array) {
        const e2 = new Float32Array(t2.length);
        for (let A2 = 0; A2 < t2.length; A2++)
          e2[A2] = t2[A2] / 65535;
        g2 = e2;
      } else
        g2 = t2;
      for (let A2 = 0; A2 < g2.length; A2++) {
        g2[A2] = this._linearToSrgb(g2[A2]);
      }
      return g2;
    }
    fillGeomAttribs(A2, e2, t2, g2) {
      if (t2.hasOwnProperty("POSITION"))
        e2.vertices = A2.accBuffers[t2.POSITION];
      if (t2.hasOwnProperty("NORMAL"))
        e2.vertexNormals = A2.accBuffers[t2.NORMAL];
      if (t2.hasOwnProperty("TANGENT"))
        e2.tangents = A2.accBuffers[t2.TANGENT];
      if (t2.hasOwnProperty("COLOR_0"))
        e2.vertexColors = this.calcVertexColors(A2.accBuffers[t2.COLOR_0]);
      if (t2.hasOwnProperty("COLOR_1"))
        e2.setAttribute("attrVertColor1", this.calcVertexColors(A2.accBuffers[t2.COLOR_1]), 4);
      if (t2.hasOwnProperty("COLOR_2"))
        e2.setAttribute("attrVertColor2", this.calcVertexColors(A2.accBuffers[t2.COLOR_2]), 4);
      if (t2.hasOwnProperty("COLOR_3"))
        e2.setAttribute("attrVertColor3", this.calcVertexColors(A2.accBuffers[t2.COLOR_3]), 4);
      if (t2.hasOwnProperty("COLOR_4"))
        e2.setAttribute("attrVertColor4", this.calcVertexColors(A2.accBuffers[t2.COLOR_4]), 4);
      if (t2.hasOwnProperty("TEXCOORD_0"))
        e2.texCoords = A2.accBuffers[t2.TEXCOORD_0];
      if (t2.hasOwnProperty("TEXCOORD_1"))
        e2.setAttribute("attrTexCoord1", A2.accBuffers[t2.TEXCOORD_1], 2);
      if (t2.hasOwnProperty("TEXCOORD_2"))
        e2.setAttribute("attrTexCoord2", A2.accBuffers[t2.TEXCOORD_2], 2);
      if (t2.hasOwnProperty("TEXCOORD_3"))
        e2.setAttribute("attrTexCoord3", A2.accBuffers[t2.TEXCOORD_3], 2);
      if (t2.hasOwnProperty("TEXCOORD_4"))
        e2.setAttribute("attrTexCoord4", A2.accBuffers[t2.TEXCOORD_4], 2);
      if (t2.hasOwnProperty("WEIGHTS_0")) {
        e2.setAttribute("attrWeights", A2.accBuffers[t2.WEIGHTS_0], 4);
      }
      if (t2.hasOwnProperty("JOINTS_0")) {
        if (!A2.accBuffers[t2.JOINTS_0])
          console.log("no !gltf.accBuffers[attribs.JOINTS_0]");
        e2.setAttribute("attrJoints", A2.accBuffers[t2.JOINTS_0], 4);
      }
      if (t2.hasOwnProperty("POSITION"))
        A2.accBuffersDelete.push(t2.POSITION);
      if (t2.hasOwnProperty("NORMAL"))
        A2.accBuffersDelete.push(t2.NORMAL);
      if (t2.hasOwnProperty("TEXCOORD_0"))
        A2.accBuffersDelete.push(t2.TEXCOORD_0);
      if (t2.hasOwnProperty("TANGENT"))
        A2.accBuffersDelete.push(t2.TANGENT);
      if (t2.hasOwnProperty("COLOR_0"))
        A2.accBuffersDelete.push(t2.COLOR_0);
      if (t2.hasOwnProperty("COLOR_0"))
        A2.accBuffersDelete.push(t2.COLOR_0);
      if (t2.hasOwnProperty("COLOR_1"))
        A2.accBuffersDelete.push(t2.COLOR_1);
      if (t2.hasOwnProperty("COLOR_2"))
        A2.accBuffersDelete.push(t2.COLOR_2);
      if (t2.hasOwnProperty("COLOR_3"))
        A2.accBuffersDelete.push(t2.COLOR_3);
      if (t2.hasOwnProperty("TEXCOORD_1"))
        A2.accBuffersDelete.push(t2.TEXCOORD_1);
      if (t2.hasOwnProperty("TEXCOORD_2"))
        A2.accBuffersDelete.push(t2.TEXCOORD_2);
      if (t2.hasOwnProperty("TEXCOORD_3"))
        A2.accBuffersDelete.push(t2.TEXCOORD_3);
      if (t2.hasOwnProperty("TEXCOORD_4"))
        A2.accBuffersDelete.push(t2.TEXCOORD_4);
      if (g2 !== false) {
        if (e2 && e2.verticesIndices)
          this.setGeom(e2);
      }
    }
    setGeom(t2) {
      if (eA.get() == "X-ZY") {
        for (let e2 = 0; e2 < t2.vertexNormals.length; e2 += 3) {
          let A2 = t2.vertexNormals[e2 + 2];
          t2.vertexNormals[e2 + 2] = t2.vertexNormals[e2 + 1];
          t2.vertexNormals[e2 + 1] = -A2;
        }
      }
      if (tA.get() == "XZ-Y") {
        for (let e2 = 0; e2 < t2.vertices.length; e2 += 3) {
          let A2 = t2.vertices[e2 + 2];
          t2.vertices[e2 + 2] = -t2.vertices[e2 + 1];
          t2.vertices[e2 + 1] = A2;
        }
      }
      if (this.primitive == this.TRIANGLES) {
        if (r.get() == "Force Smooth" || r.get() == false)
          t2.calculateNormals();
        else if (!t2.vertexNormals.length && r.get() == "Auto")
          t2.calculateNormals({ smooth: false });
        if ((!t2.biTangents || t2.biTangents.length == 0) && t2.tangents) {
          const e2 = vec3.create();
          const A2 = vec3.create();
          const g2 = t2.tangents;
          t2.tangents = new Float32Array(g2.length / 4 * 3);
          t2.biTangents = new Float32Array(g2.length / 4 * 3);
          for (let A3 = 0; A3 < g2.length; A3 += 4) {
            const i2 = A3 / 4 * 3;
            vec3.cross(e2, [t2.vertexNormals[i2], t2.vertexNormals[i2 + 1], t2.vertexNormals[i2 + 2]], [g2[A3], g2[A3 + 1], g2[A3 + 2]]);
            vec3.div(e2, e2, [g2[A3 + 3], g2[A3 + 3], g2[A3 + 3]]);
            vec3.normalize(e2, e2);
            t2.biTangents[i2 + 0] = e2[0];
            t2.biTangents[i2 + 1] = e2[1];
            t2.biTangents[i2 + 2] = e2[2];
            t2.tangents[i2 + 0] = g2[A3 + 0];
            t2.tangents[i2 + 1] = g2[A3 + 1];
            t2.tangents[i2 + 2] = g2[A3 + 2];
          }
        }
        if (t2.tangents.length === 0 || r.get() != "Never") {
          t2.calcTangentsBitangents();
        }
      }
      this.geom = t2;
      this.bounds = t2.getBounds();
    }
    render(t2, e2, g2) {
      if (!this.mesh && this.geom && this.geom.verticesIndices) {
        let A2 = this.geom;
        if (this.geom.vertices.length / 3 > 64e3) {
          A2 = this.geom.copy();
          A2.unIndex(false, true);
        }
        let e3;
        if (this.primitive == this.TRIANGLES)
          e3 = t2.gl.TRIANGLES;
        else if (this.primitive == this.LINES)
          e3 = t2.gl.LINES;
        else if (this.primitive == this.LINE_STRIP)
          e3 = t2.gl.LINE_STRIP;
        else if (this.primitive == this.POINTS)
          e3 = t2.gl.POINTS;
        else {
          m.logWarn("unknown primitive type", this);
        }
        this.mesh = m.patch.cg.createMesh(A2, { glPrimitive: e3 });
      }
      if (this.mesh) {
        if (this.geom && this.geom.morphTargets.length && !this.morphTargetsRenderMod) {
          this.mesh.addVertexNumbers = true;
          this.morphTargetsRenderMod = new W(this);
        }
        let A2 = !e2 && this.material != -1 && S.shaders[this.material];
        if (g2)
          A2 = false;
        if (A2)
          t2.pushShader(S.shaders[this.material]);
        const i2 = t2.getShader() || {};
        const I2 = i2.uniformColorDiffuse;
        const n2 = i2.uniformPbrMetalness;
        const o2 = i2.uniformPbrRoughness;
        if (!S.shaders[this.material] && iA.get()) {
          if (I2 && this._matDiffuseColor) {
            this._matDiffuseColorOrig = [I2.getValue()[0], I2.getValue()[1], I2.getValue()[2], I2.getValue()[3]];
            I2.setValue(this._matDiffuseColor);
          }
          if (n2)
            if (this._matPbrMetalness != null) {
              this._matPbrMetalnessOrig = n2.getValue();
              n2.setValue(this._matPbrMetalness);
            } else
              n2.setValue(0);
          if (o2)
            if (this._matPbrRoughness != null) {
              this._matPbrRoughnessOrig = o2.getValue();
              o2.setValue(this._matPbrRoughness);
            } else {
              o2.setValue(0);
            }
        }
        if (this.morphTargetsRenderMod)
          this.morphTargetsRenderMod.renderStart(t2, 0);
        if (this.mesh) {
          this.mesh.render(t2.getShader(), e2);
        }
        if (this.morphTargetsRenderMod)
          this.morphTargetsRenderMod.renderFinish(t2);
        if (iA.get()) {
          if (I2 && this._matDiffuseColor)
            I2.setValue(this._matDiffuseColorOrig);
          if (n2 && this._matPbrMetalnessOrig != void 0)
            n2.setValue(this._matPbrMetalnessOrig);
          if (o2 && this._matPbrRoughnessOrig != void 0)
            o2.setValue(this._matPbrRoughnessOrig);
        }
        if (A2)
          t2.popShader();
      }
    }
  };
  const K = class {
    constructor(e2, t2) {
      this.bounds = new CABLES.CG.BoundingBox();
      this.meshes = [];
      this.name = t2.name;
      const g2 = t2.primitives;
      for (let A2 = 0; A2 < g2.length; A2++) {
        const i2 = new Y(this.name, g2[A2], e2, (A3) => {
          A3.extras = t2.extras;
          this.bounds.apply(A3.bounds);
        });
        i2.submeshIndex = A2;
        this.meshes.push(i2);
      }
    }
    render(e2, t2, g2, i2, I2) {
      for (let A2 = 0; A2 < this.meshes.length; A2++) {
        const n2 = S.shaders[this.meshes[A2].material];
        if (!t2 && n2)
          e2.pushShader(S.shaders[this.meshes[A2].material]);
        if (g2)
          g2.renderStart(e2, i2);
        if (I2)
          this.meshes[A2].weights = I2;
        this.meshes[A2].render(e2, t2, g2, i2);
        if (g2)
          g2.renderFinish(e2);
        if (!t2 && n2)
          e2.popShader();
      }
    }
  };
  const j = class {
    constructor(A2, e2) {
      this.isChild = A2.isChild || false;
      this.name = A2.name;
      if (A2.hasOwnProperty("camera"))
        this.camera = A2.camera;
      this.hidden = false;
      this.mat = mat4.create();
      this._animActions = {};
      this.animWeights = [];
      this._animMat = mat4.create();
      this._tempMat = mat4.create();
      this._tempQuat = quat.create();
      this._tempRotmat = mat4.create();
      this.mesh = null;
      this.children = [];
      this._node = A2;
      this._gltf = e2;
      this.absMat = mat4.create();
      this.addTranslate = null;
      this._tempAnimScale = null;
      this.addMulMat = null;
      this.updateMatrix();
      this.skinRenderer = null;
      this.copies = [];
    }
    get skin() {
      if (this._node.hasOwnProperty("skin"))
        return this._node.skin;
      else
        return -1;
    }
    copy() {
      this.isCopy = true;
      const A2 = new j(this._node, this._gltf);
      A2.copyOf = this;
      A2._animActions = this._animActions;
      A2.children = this.children;
      if (this.skin)
        A2.skinRenderer = new P(this);
      this.updateMatrix();
      return A2;
    }
    hasSkin() {
      if (this._node.hasOwnProperty("skin"))
        return this._gltf.json.skins[this._node.skin].name || "unknown";
      return false;
    }
    initSkin() {
      if (this.skin > -1) {
        this.skinRenderer = new P(this);
      }
    }
    updateMatrix() {
      mat4.identity(this.mat);
      if (this._node.translation)
        mat4.translate(this.mat, this.mat, this._node.translation);
      if (this._node.rotation) {
        const A2 = mat4.create();
        this._rot = this._node.rotation;
        mat4.fromQuat(A2, this._node.rotation);
        mat4.mul(this.mat, this.mat, A2);
      }
      if (this._node.scale) {
        this._scale = this._node.scale;
        mat4.scale(this.mat, this.mat, this._scale);
      }
      if (this._node.hasOwnProperty("mesh")) {
        this.mesh = this._gltf.meshes[this._node.mesh];
        if (this.isCopy) {
        }
      }
      if (this._node.children) {
        for (let A2 = 0; A2 < this._node.children.length; A2++) {
          this._gltf.json.nodes[A2].isChild = true;
          if (this._gltf.nodes[this._node.children[A2]])
            this._gltf.nodes[this._node.children[A2]].isChild = true;
          this.children.push(this._node.children[A2]);
        }
      }
    }
    unHide() {
      this.hidden = false;
      for (let A2 = 0; A2 < this.children.length; A2++)
        if (this.children[A2].unHide)
          this.children[A2].unHide();
    }
    calcBounds(e2, A2, t2) {
      const g2 = mat4.create();
      if (A2)
        mat4.copy(g2, A2);
      if (this.mat)
        mat4.mul(g2, g2, this.mat);
      if (this.mesh) {
        const i2 = this.mesh.bounds.copy();
        i2.mulMat4(g2);
        t2.apply(i2);
        if (t2.changed) {
          h.push(i2._min[0] || 0, i2._min[1] || 0, i2._min[2] || 0, i2._max[0] || 0, i2._max[1] || 0, i2._max[2] || 0);
        }
      }
      for (let A3 = 0; A3 < this.children.length; A3++) {
        if (e2.nodes[this.children[A3]] && e2.nodes[this.children[A3]].calcBounds) {
          const I2 = e2.nodes[this.children[A3]].calcBounds(e2, g2, t2);
          t2.apply(I2);
        }
      }
      if (t2.changed)
        return t2;
      else
        return null;
    }
    setAnimAction(e2) {
      if (!e2)
        return;
      this._currentAnimaction = e2;
      if (e2 && !this._animActions[e2]) {
        return null;
      }
      for (let A2 in this._animActions[e2]) {
        if (A2 == "translation")
          this._animTrans = this._animActions[e2][A2];
        else if (A2 == "rotation")
          this._animRot = this._animActions[e2][A2];
        else if (A2 == "scale")
          this._animScale = this._animActions[e2][A2];
        else if (A2 == "weights")
          this.animWeights = this._animActions[e2][A2];
        else
          console.log("[gltfNode] unknown anim path", A2, this._animActions[e2][A2]);
      }
    }
    setAnim(A2, e2, t2) {
      if (!A2 || !e2 || !t2)
        return;
      this._animActions[e2] = this._animActions[e2] || {};
      if (this._animActions[e2][A2])
        m.log("[gltfNode] animation action path already exists", e2, A2, this._animActions[e2][A2]);
      this._animActions[e2][A2] = t2;
      if (A2 == "translation")
        this._animTrans = t2;
      else if (A2 == "rotation")
        this._animRot = t2;
      else if (A2 == "scale")
        this._animScale = t2;
      else if (A2 == "weights") {
        this.animWeights = this._animActions[e2][A2];
      } else
        console.warn("unknown anim path", A2, t2);
    }
    modelMatLocal() {
      return this._animMat || this.mat;
    }
    modelMatAbs() {
      return this.absMat;
    }
    transform(A2, t2) {
      if (!t2 && t2 != 0)
        t2 = w;
      this._lastTimeTrans = t2;
      hA++;
      if (!this._animTrans && !this._animRot && !this._animScale) {
        mat4.mul(A2.mMatrix, A2.mMatrix, this.mat);
        this._animMat = null;
      } else {
        this._animMat = this._animMat || mat4.create();
        mat4.identity(this._animMat);
        const e2 = true;
        if (e2 && this._animTrans) {
          mat4.translate(this._animMat, this._animMat, [this._animTrans[0].getValue(t2), this._animTrans[1].getValue(t2), this._animTrans[2].getValue(t2)]);
        } else if (this._node.translation)
          mat4.translate(this._animMat, this._animMat, this._node.translation);
        if (e2 && this._animRot) {
          if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR)
            CABLES.Anim.slerpQuaternion(t2, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);
          else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE) {
            this._tempQuat[0] = this._animRot[0].getValue(t2);
            this._tempQuat[1] = this._animRot[1].getValue(t2);
            this._tempQuat[2] = this._animRot[2].getValue(t2);
            this._tempQuat[3] = this._animRot[3].getValue(t2);
          } else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE) {
            CABLES.Anim.slerpQuaternion(t2, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);
          }
          mat4.fromQuat(this._tempMat, this._tempQuat);
          mat4.mul(this._animMat, this._animMat, this._tempMat);
        } else if (this._rot) {
          mat4.fromQuat(this._tempRotmat, this._rot);
          mat4.mul(this._animMat, this._animMat, this._tempRotmat);
        }
        if (e2 && this._animScale) {
          if (!this._tempAnimScale)
            this._tempAnimScale = [1, 1, 1];
          this._tempAnimScale[0] = this._animScale[0].getValue(t2);
          this._tempAnimScale[1] = this._animScale[1].getValue(t2);
          this._tempAnimScale[2] = this._animScale[2].getValue(t2);
          mat4.scale(this._animMat, this._animMat, this._tempAnimScale);
        } else if (this._scale)
          mat4.scale(this._animMat, this._animMat, this._scale);
        mat4.mul(A2.mMatrix, A2.mMatrix, this._animMat);
      }
      if (this.animWeights) {
        this.weights = this.weights || [];
        let e2 = "";
        for (let A3 = 0; A3 < this.animWeights.length; A3++) {
          this.weights[A3] = this.animWeights[A3].getValue(t2);
          e2 += this.weights[A3] + "/";
        }
      }
      if (this.addTranslate)
        mat4.translate(A2.mMatrix, A2.mMatrix, this.addTranslate);
      if (this.addMulMat)
        mat4.mul(A2.mMatrix, A2.mMatrix, this.addMulMat);
      mat4.copy(this.absMat, A2.mMatrix);
    }
    render(e2, t2, g2, i2, I2, n2, o2) {
      if (!t2)
        e2.pushModelMatrix();
      if (o2 === void 0)
        o2 = S.time;
      if (!t2 || this.skinRenderer)
        this.transform(e2, o2);
      if (this.hidden && !n2) {
      } else {
        if (this.skinRenderer) {
          this.skinRenderer.time = o2;
          if (!g2)
            this.mesh.render(e2, i2, this.skinRenderer, o2, this.weights);
        } else {
          if (this.mesh && !g2)
            this.mesh.render(e2, i2, null, o2, this.weights);
        }
      }
      if (!I2 && !this.hidden) {
        for (let A2 = 0; A2 < this.children.length; A2++)
          if (S.nodes[this.children[A2]])
            S.nodes[this.children[A2]].render(e2, t2, g2, i2, I2, n2, o2);
      }
      if (!t2)
        e2.popModelMatrix();
    }
  };
  let d = null;
  function b() {
    if (d)
      gui.mainTabs.closeTab(d.id);
    d = null;
  }
  function o(e2) {
    const t2 = [];
    for (let A2 = 0; A2 < e2.length; A2++) {
      t2.push(Math.round(e2[A2] * 1e3) / 1e3);
    }
    return t2.join(",");
  }
  function V(t2, g2, i2) {
    if (!S)
      return;
    t2 += '<tr class="row">';
    let I2 = "";
    let n2 = "";
    for (let e3 = 1; e3 < i2; e3++) {
      n2 += "&nbsp;&nbsp;&nbsp;";
      let A3 = "identBg";
      if (e3 == 1)
        A3 = "identBgLevel0";
      I2 += '<td class="ident ' + A3 + '" ><div style=""></div></td>';
    }
    let A2 = CABLES.uuid();
    t2 += I2;
    t2 += '<td colspan="' + (21 - i2) + '">';
    if (g2.mesh && g2.mesh.meshes.length)
      t2 += '<span class="icon icon-cube"></span>&nbsp;';
    else
      t2 += '<span class="icon icon-box-select"></span> &nbsp;';
    t2 += g2.name + "</td><td></td>";
    if (g2.mesh) {
      t2 += "<td>";
      for (let A3 = 0; A3 < g2.mesh.meshes.length; A3++) {
        if (A3 > 0)
          t2 += ", ";
        t2 += g2.mesh.meshes[A3].name;
      }
      t2 += "</td>";
      t2 += "<td>";
      t2 += g2.hasSkin() || "-";
      t2 += "</td>";
      t2 += "<td>";
      let e3 = 0;
      for (let A3 = 0; A3 < g2.mesh.meshes.length; A3++) {
        if (e3 > 0)
          t2 += ", ";
        if (S.json.materials && g2.mesh.meshes[A3].hasOwnProperty("material")) {
          if (S.json.materials[g2.mesh.meshes[A3].material]) {
            t2 += S.json.materials[g2.mesh.meshes[A3].material].name;
            e3++;
          }
        }
      }
      if (e3 == 0)
        t2 += "none";
      t2 += "</td>";
    } else {
      t2 += "<td>-</td><td>-</td><td>-</td>";
    }
    t2 += "<td>";
    if (g2._node.translation || g2._node.rotation || g2._node.scale) {
      let A3 = "";
      if (g2._node.translation)
        A3 += "Translate: `" + o(g2._node.translation) + "` || ";
      if (g2._node.rotation)
        A3 += "Rotation: `" + o(g2._node.rotation) + "` || ";
      if (g2._node.scale)
        A3 += "Scale: `" + o(g2._node.scale) + "` || ";
      t2 += '<span class="icon icon-gizmo info" data-info="' + A3 + '"></span> &nbsp;';
    }
    if (g2._animRot || g2._animScale || g2._animTrans) {
      let A3 = "Animated: ";
      if (g2._animRot)
        A3 += "Rot ";
      if (g2._animScale)
        A3 += "Scale ";
      if (g2._animTrans)
        A3 += "Trans ";
      t2 += '<span class="icon icon-clock info" data-info="' + A3 + '"></span>&nbsp;';
    }
    if (!g2._node.translation && !g2._node.rotation && !g2._node.scale && !g2._animRot && !g2._animScale && !g2._animTrans)
      t2 += "-";
    t2 += "</td>";
    t2 += "<td>";
    let e2 = "";
    if (g2.hidden)
      e2 = "node-hidden";
    t2 += `<a onclick="gui.corePatch().getOpById('` + m.id + "').exposeNode('" + g2.name + `','transform')" class="treebutton">Transform</a>`;
    t2 += ` <a onclick="gui.corePatch().getOpById('` + m.id + "').exposeNode('" + g2.name + `','hierarchy')" class="treebutton">Hierarchy</a>`;
    t2 += ` <a onclick="gui.corePatch().getOpById('` + m.id + "').exposeNode('" + g2.name + `')" class="treebutton">Node</a>`;
    if (g2.hasSkin())
      t2 += ` <a onclick="gui.corePatch().getOpById('` + m.id + "').exposeNode('" + g2.name + `',false,{skin:true});" class="treebutton">Skin</a>`;
    t2 += "</td><td>";
    t2 += '&nbsp;<span class="icon iconhover icon-eye ' + e2 + `" onclick="gui.corePatch().getOpById('` + m.id + "').toggleNodeVisibility('" + g2.name + `');this.classList.toggle('node-hidden');"></span>`;
    t2 += "</td>";
    t2 += "</tr>";
    if (g2.children) {
      for (let A3 = 0; A3 < g2.children.length; A3++)
        t2 = V(t2, S.nodes[g2.children[A3]], i2 + 1);
    }
    return t2;
  }
  function H(e2, A2) {
    let t2 = "<tr>";
    t2 += " <td>" + A2 + "</td>";
    t2 += " <td>" + e2.name + "</td>";
    t2 += " <td>";
    const g2 = JSON.stringify(e2, null, 4).replaceAll('"', "").replaceAll("\n", "<br/>");
    t2 += `<span class="icon icon-info" onclick="new CABLES.UI.ModalDialog({ 'html': '<pre>` + g2 + "</pre>', 'title': '" + e2.name + `' });"></span>&nbsp;`;
    if (e2.pbrMetallicRoughness && e2.pbrMetallicRoughness.baseColorFactor) {
      let A3 = "";
      A3 += "" + Math.round(e2.pbrMetallicRoughness.baseColorFactor[0] * 255);
      A3 += "," + Math.round(e2.pbrMetallicRoughness.baseColorFactor[1] * 255);
      A3 += "," + Math.round(e2.pbrMetallicRoughness.baseColorFactor[2] * 255);
      t2 += '<div style="width:15px;height:15px;background-color:rgb(' + A3 + ');display:inline-block">&nbsp;</a>';
    }
    t2 += ' <td style="">' + (S.shaders[A2] ? "-" : `<a onclick="gui.corePatch().getOpById('` + m.id + "').assignMaterial('" + e2.name + `')" class="treebutton">Assign</a>`) + "<td>";
    t2 += "<td>";
    t2 += "</tr>";
    return t2;
  }
  function A() {
    if (!S)
      return;
    const A2 = performance.now();
    const I2 = {};
    let n2 = '<div style="overflow:scroll;width:100%;height:100%">';
    n2 += 'File: <a href="' + CABLES.platform.getCablesUrl() + "/asset/patches/?filename=" + N.get() + '" target="_blank">' + CABLES.basename(N.get()) + "</a><br/>";
    n2 += "Generator:" + S.json.asset.generator;
    let e2 = 0;
    if (S.json.nodes)
      e2 = S.json.nodes.length;
    n2 += '<div id="groupNodes">Nodes (' + e2 + ")</div>";
    n2 += '<table id="sectionNodes" class="table treetable">';
    n2 += "<tr>";
    n2 += ' <th colspan="21">Name</th>';
    n2 += " <th>Mesh</th>";
    n2 += " <th>Skin</th>";
    n2 += " <th>Material</th>";
    n2 += " <th>Transform</th>";
    n2 += " <th>Expose</th>";
    n2 += " <th></th>";
    n2 += "</tr>";
    for (let A3 = 0; A3 < S.nodes.length; A3++) {
      if (!S.nodes[A3].isChild)
        n2 = V(n2, S.nodes[A3], 1);
    }
    n2 += "</table>";
    let t2 = 0;
    if (S.json.materials)
      t2 = S.json.materials.length;
    n2 += '<div id="groupMaterials">Materials (' + t2 + ")</div>";
    if (!S.json.materials || S.json.materials.length == 0) {
    } else {
      n2 += '<table id="materialtable"  class="table treetable">';
      n2 += "<tr>";
      n2 += " <th>Index</th>";
      n2 += " <th>Name</th>";
      n2 += " <th>Color</th>";
      n2 += " <th>Function</th>";
      n2 += " <th></th>";
      n2 += "</tr>";
      for (let A3 = 0; A3 < S.json.materials.length; A3++) {
        n2 += H(S.json.materials[A3], A3);
      }
      n2 += "</table>";
    }
    n2 += '<div id="groupMeshes">Meshes (' + S.json.meshes.length + ")</div>";
    n2 += '<table id="meshestable"  class="table treetable">';
    n2 += "<tr>";
    n2 += " <th>Name</th>";
    n2 += " <th>Node</th>";
    n2 += " <th>Material</th>";
    n2 += " <th>Vertices</th>";
    n2 += " <th>Attributes</th>";
    n2 += "</tr>";
    let o2 = [];
    I2.meshes = 0;
    I2.meshTargets = 0;
    for (let i3 = 0; i3 < S.json.meshes.length; i3++) {
      n2 += "<tr>";
      n2 += "<td>" + S.json.meshes[i3].name + "</td>";
      n2 += "<td>";
      let e3 = 0;
      let t3 = "";
      for (let A3 = 0; A3 < S.json.nodes.length; A3++) {
        if (S.json.nodes[A3].mesh == i3) {
          e3++;
          if (e3 == 1) {
            t3 = S.json.nodes[A3].name;
          }
        }
      }
      if (e3 > 1)
        n2 += e3 + " nodes (" + t3 + " ...)";
      else
        n2 += t3;
      n2 += "</td>";
      n2 += "<td>";
      for (let A3 = 0; A3 < S.json.meshes[i3].primitives.length; A3++) {
        if (S.json.meshes[i3].primitives[A3].hasOwnProperty("material")) {
          if (S.json.materials[S.json.meshes[i3]]) {
            n2 += S.json.materials[S.json.meshes[i3].primitives[A3].material].name + " ";
          }
        } else
          n2 += "None";
      }
      n2 += "</td>";
      n2 += "<td>";
      let g3 = 0;
      for (let e4 = 0; e4 < S.json.meshes[i3].primitives.length; e4++) {
        if (S.json.meshes[i3].primitives[e4].attributes.POSITION != void 0) {
          let A3 = parseInt(S.json.accessors[S.json.meshes[i3].primitives[e4].attributes.POSITION].count);
          g3 += A3;
          n2 += "" + A3 + "<br/>";
        } else
          n2 += "-<br/>";
      }
      if (S.json.meshes[i3].primitives.length > 1)
        n2 += "=" + g3;
      n2 += "</td>";
      n2 += "<td>";
      for (let A3 = 0; A3 < S.json.meshes[i3].primitives.length; A3++) {
        n2 += Object.keys(S.json.meshes[i3].primitives[A3].attributes);
        n2 += ` <a onclick="gui.corePatch().getOpById('` + m.id + "').exposeGeom('" + S.json.meshes[i3].name + "'," + A3 + ')" class="treebutton">Geometry</a>';
        n2 += "<br/>";
        if (S.json.meshes[i3].primitives[A3].targets) {
          n2 += S.json.meshes[i3].primitives[A3].targets.length + " targets<br/>";
          if (S.json.meshes[i3].extras && S.json.meshes[i3].extras.targetNames)
            n2 += "Targetnames:<br/>" + S.json.meshes[i3].extras.targetNames.join("<br/>");
          n2 += "<br/>";
        }
      }
      n2 += "</td>";
      n2 += "</tr>";
      for (let t4 = 0; t4 < S.json.meshes[i3].primitives.length; t4++) {
        const E2 = S.json.accessors[S.json.meshes[i3].primitives[t4].indices];
        if (E2) {
          let A3 = E2.bufferView;
          if (o2.indexOf(A3) == -1) {
            o2.push(A3);
            if (S.json.bufferViews[A3])
              I2.meshes += S.json.bufferViews[A3].byteLength;
          }
        }
        for (let A3 in S.json.meshes[i3].primitives[t4].attributes) {
          const l2 = S.json.meshes[i3].primitives[t4].attributes[A3];
          const u2 = S.json.accessors[l2].bufferView;
          if (o2.indexOf(u2) == -1) {
            o2.push(u2);
            if (S.json.bufferViews[u2])
              I2.meshes += S.json.bufferViews[u2].byteLength;
          }
        }
        if (S.json.meshes[i3].primitives[t4].targets)
          for (let e4 = 0; e4 < S.json.meshes[i3].primitives[t4].targets.length; e4++) {
            for (let A3 in S.json.meshes[i3].primitives[t4].targets[e4]) {
              const c2 = S.json.meshes[i3].primitives[t4].targets[e4][A3];
              const E3 = S.json.accessors[c2];
              const u2 = E3.bufferView;
              console.log("accessor", E3);
              if (o2.indexOf(u2) == -1) {
                if (S.json.bufferViews[u2]) {
                  o2.push(u2);
                  I2.meshTargets += S.json.bufferViews[u2].byteLength;
                }
              }
            }
          }
      }
    }
    n2 += "</table>";
    let g2 = 0;
    let i2 = 0;
    let C2 = 0;
    if (S.json.animations) {
      i2 = S.json.animations.length;
      for (let A3 = 0; A3 < S.json.animations.length; A3++) {
        g2 += S.json.animations[A3].samplers.length;
      }
    }
    n2 += '<div id="groupAnims">Animations (' + i2 + "/" + g2 + ")</div>";
    if (S.json.animations) {
      n2 += '<table id="sectionAnim" class="table treetable">';
      n2 += "<tr>";
      n2 += "  <th>Name</th>";
      n2 += "  <th>Target node</th>";
      n2 += "  <th>Path</th>";
      n2 += "  <th>Interpolation</th>";
      n2 += "  <th>Keys</th>";
      n2 += "</tr>";
      I2.animations = 0;
      for (let t3 = 0; t3 < S.json.animations.length; t3++) {
        for (let e3 = 0; e3 < S.json.animations[t3].samplers.length; e3++) {
          let A3 = S.json.accessors[S.json.animations[t3].samplers[e3].input].bufferView;
          if (o2.indexOf(A3) == -1) {
            o2.push(A3);
            I2.animations += S.json.bufferViews[A3].byteLength;
          }
          A3 = S.json.accessors[S.json.animations[t3].samplers[e3].output].bufferView;
          if (o2.indexOf(A3) == -1) {
            o2.push(A3);
            I2.animations += S.json.bufferViews[A3].byteLength;
          }
        }
        for (let A3 = 0; A3 < S.json.animations[t3].channels.length; A3++) {
          n2 += "<tr>";
          n2 += "  <td> Anim " + t3 + ": " + S.json.animations[t3].name + "</td>";
          n2 += "  <td>" + S.nodes[S.json.animations[t3].channels[A3].target.node].name + "</td>";
          n2 += "  <td>";
          n2 += S.json.animations[t3].channels[A3].target.path + " ";
          n2 += "  </td>";
          const h2 = S.json.animations[t3].channels[A3].sampler;
          const p2 = S.json.animations[t3].samplers[h2];
          n2 += "  <td>" + p2.interpolation + "</td>";
          n2 += "  <td>" + S.json.accessors[p2.output].count;
          C2 += S.json.accessors[p2.output].count;
          n2 += "</td>";
          n2 += "</tr>";
        }
      }
      n2 += "<tr>";
      n2 += "  <td></td>";
      n2 += "  <td></td>";
      n2 += "  <td></td>";
      n2 += "  <td></td>";
      n2 += "  <td>" + C2 + " total</td>";
      n2 += "</tr>";
      n2 += "</table>";
    } else {
    }
    let a2 = 0;
    if (S.json.images)
      a2 = S.json.images.length;
    n2 += '<div id="groupImages">Images (' + a2 + ")</div>";
    if (S.json.images) {
      n2 += '<table id="sectionImages" class="table treetable">';
      n2 += "<tr>";
      n2 += "  <th>name</th>";
      n2 += "  <th>type</th>";
      n2 += "  <th>func</th>";
      n2 += "</tr>";
      I2.images = 0;
      for (let e3 = 0; e3 < S.json.images.length; e3++) {
        if (S.json.images[e3].hasOwnProperty("bufferView")) {
          I2.images += S.json.bufferViews[S.json.images[e3].bufferView].byteLength;
        } else
          console.log("image has no bufferview?!");
        n2 += "<tr>";
        n2 += "<td>" + S.json.images[e3].name + "</td>";
        n2 += "<td>" + S.json.images[e3].mimeType + "</td>";
        n2 += "<td>";
        let A3 = S.json.images[e3].name;
        if (A3 === void 0)
          A3 = S.json.images[e3].bufferView;
        n2 += `<a onclick="gui.corePatch().getOpById('` + m.id + "').exposeTexture('" + A3 + `')" class="treebutton">Expose</a>`;
        n2 += "</td>";
        n2 += "<tr>";
      }
      n2 += "</table>";
    }
    let r2 = 0;
    if (S.json.cameras)
      r2 = S.json.cameras.length;
    n2 += '<div id="groupCameras">Cameras (' + r2 + ")</div>";
    if (S.json.cameras) {
      n2 += '<table id="sectionCameras" class="table treetable">';
      n2 += "<tr>";
      n2 += "  <th>name</th>";
      n2 += "  <th>type</th>";
      n2 += "  <th>info</th>";
      n2 += "</tr>";
      for (let A3 = 0; A3 < S.json.cameras.length; A3++) {
        n2 += "<tr>";
        n2 += "<td>" + S.json.cameras[A3].name + "</td>";
        n2 += "<td>" + S.json.cameras[A3].type + "</td>";
        n2 += "<td>";
        if (S.json.cameras[A3].perspective) {
          n2 += "yfov: " + Math.round(S.json.cameras[A3].perspective.yfov * 100) / 100;
          n2 += ", ";
          n2 += "zfar: " + Math.round(S.json.cameras[A3].perspective.zfar * 100) / 100;
          n2 += ", ";
          n2 += "znear: " + Math.round(S.json.cameras[A3].perspective.znear * 100) / 100;
        }
        n2 += "</td>";
        n2 += "<tr>";
      }
      n2 += "</table>";
    }
    let s2 = 0;
    if (S.json.skins)
      s2 = S.json.skins.length;
    n2 += '<div id="groupSkins">Skins (' + s2 + ")</div>";
    if (S.json.skins) {
      n2 += '<table id="sectionSkins" class="table treetable">';
      n2 += "<tr>";
      n2 += "  <th>name</th>";
      n2 += "  <th></th>";
      n2 += "  <th>total joints</th>";
      n2 += "</tr>";
      for (let A3 = 0; A3 < S.json.skins.length; A3++) {
        n2 += "<tr>";
        n2 += "<td>" + S.json.skins[A3].name + "</td>";
        n2 += "<td></td>";
        n2 += "<td>" + S.json.skins[A3].joints.length + "</td>";
        n2 += "<td>";
        n2 += "</td>";
        n2 += "<tr>";
      }
      n2 += "</table>";
    }
    if (S.timing) {
      n2 += '<div id="groupTiming">Debug Loading Timing </div>';
      n2 += '<table id="sectionTiming" class="table treetable">';
      n2 += "<tr>";
      n2 += "  <th>task</th>";
      n2 += "  <th>time used</th>";
      n2 += "</tr>";
      let A3 = 0;
      for (let A4 = 0; A4 < S.timing.length - 1; A4++) {
        n2 += "<tr>";
        n2 += "  <td>" + S.timing[A4][0] + "</td>";
        n2 += "  <td>" + (S.timing[A4 + 1][1] - S.timing[A4][1]) + " ms</td>";
        n2 += "</tr>";
      }
      n2 += "</table>";
    }
    let B2 = 0;
    if (S.json.buffers)
      B2 = S.json.buffers[0].byteLength;
    n2 += '<div id="groupBinary">File Size Allocation (' + Math.round(B2 / 1024) + "k )</div>";
    n2 += '<table id="sectionBinary" class="table treetable">';
    n2 += "<tr>";
    n2 += "  <th>name</th>";
    n2 += "  <th>size</th>";
    n2 += "  <th>%</th>";
    n2 += "</tr>";
    let Q2 = B2;
    for (let A3 in I2) {
      n2 += "<tr>";
      n2 += "<td>" + A3 + "</td>";
      n2 += "<td>" + q(I2[A3]) + " </td>";
      n2 += "<td>" + Math.round(I2[A3] / B2 * 100) + "% </td>";
      n2 += "<tr>";
      Q2 -= I2[A3];
    }
    if (Q2 != 0) {
      n2 += "<tr>";
      n2 += "<td>unknown</td>";
      n2 += "<td>" + q(Q2) + " </td>";
      n2 += "<td>" + Math.round(Q2 / B2 * 100) + "% </td>";
      n2 += "<tr>";
    }
    n2 += "</table>";
    n2 += "</div>";
    d = new CABLES.UI.Tab("GLTF " + CABLES.basename(N.get()), { icon: "cube", infotext: "tab_gltf", padding: true, singleton: true });
    gui.mainTabs.addTab(d, true);
    d.addEventListener("close", b);
    d.html(n2);
    CABLES.UI.Collapsable.setup(ele.byId("groupNodes"), ele.byId("sectionNodes"), false);
    CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"), ele.byId("materialtable"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupAnims"), ele.byId("sectionAnim"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"), ele.byId("meshestable"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupCameras"), ele.byId("sectionCameras"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupImages"), ele.byId("sectionImages"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupSkins"), ele.byId("sectionSkins"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupBinary"), ele.byId("sectionBinary"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupTiming"), ele.byId("sectionTiming"), true);
    gui.maintabPanel.show(true);
  }
  function q(A2) {
    if (A2 > 1024)
      return Math.round(A2 / 1024) + " kb";
    if (A2 > 1024 * 500)
      return Math.round(A2 / 1024) + " mb";
    else
      return A2 + " bytes";
  }
  const P = class {
    constructor(A2) {
      this._mod = null;
      this._node = A2;
      this._lastTime = 0;
      this._matArr = [];
      this._m = mat4.create();
      this._invBindMatrix = mat4.create();
      this.identity = true;
    }
    renderFinish(A2) {
      A2.popModelMatrix();
      this._mod.unbind();
    }
    renderStart(A2, e2) {
      if (!this._mod) {
        this._mod = new CGL.ShaderModifier(A2, m.name + this._node.name);
        this._mod.addModule({ priority: -2, name: "MODULE_VERTEX_POSITION", srcHeadVert: C.skin_head_vert || "", srcBodyVert: C.skin_vert || "" });
        this._mod.addUniformVert("m4[]", "MOD_boneMats", []);
        const i2 = vec3.create();
      }
      const t2 = this._node.skin;
      const g2 = S.json.skins[t2].joints.length * 16;
      {
        if (this._matArr.length != g2)
          this._matArr.length = g2;
        for (let A3 = 0; A3 < S.json.skins[t2].joints.length; A3++) {
          const I2 = A3 * 16;
          const n2 = S.json.skins[t2].joints[A3];
          const o2 = S.nodes[n2];
          for (let A4 = 0; A4 < 16; A4++)
            this._invBindMatrix[A4] = S.accBuffers[S.json.skins[t2].inverseBindMatrices][I2 + A4];
          mat4.mul(this._m, o2.modelMatAbs(), this._invBindMatrix);
          for (let A4 = 0; A4 < this._m.length; A4++)
            this._matArr[I2 + A4] = this._m[A4];
        }
        this._mod.setUniformValue("MOD_boneMats", this._matArr);
        this._lastTime = e2;
      }
      this._mod.define("SKIN_NUM_BONES", S.json.skins[t2].joints.length);
      this._mod.bind();
      A2.pushModelMatrix();
      if (this.identity)
        mat4.identity(A2.mMatrix);
    }
  };
  const W = class {
    constructor(A2) {
      this.mesh = A2;
      this.tex = null;
      this.numRowsPerTarget = 0;
      this.makeTex(A2.geom);
    }
    renderFinish(A2) {
      A2.popModelMatrix();
      this._mod.unbind();
    }
    renderStart(A2, e2) {
      if (!this._mod) {
        this._mod = new CGL.ShaderModifier(A2, "gltftarget");
        this._mod.addModule({ priority: -2, name: "MODULE_VERTEX_POSITION", srcHeadVert: C.targets_head_vert || "", srcBodyVert: C.targets_vert || "" });
        this._mod.addUniformVert("4f", "MOD_targetTexInfo", [0, 0, 0, 0]);
        this._mod.addUniformVert("t", "MOD_targetTex", 1);
        this._mod.addUniformVert("f[]", "MOD_weights", []);
        const t2 = vec3.create();
      }
      this._mod.pushTexture("MOD_targetTex", this.tex);
      if (this.tex && this.mesh.weights) {
        this._mod.setUniformValue("MOD_weights", this.mesh.weights);
        this._mod.setUniformValue("MOD_targetTexInfo", [this.tex.width, this.tex.height, this.numRowsPerTarget, this.mesh.weights.length]);
        this._mod.define("MOD_NUM_WEIGHTS", Math.max(1, this.mesh.weights.length));
      } else {
        this._mod.define("MOD_NUM_WEIGHTS", 1);
      }
      this._mod.bind();
      A2.pushModelMatrix();
      if (this.identity)
        mat4.identity(A2.mMatrix);
    }
    makeTex(t2) {
      if (!t2.morphTargets || !t2.morphTargets.length)
        return;
      let g2 = t2.morphTargets[0].vertices.length / 3;
      let A2 = 0;
      this.numRowsPerTarget = 0;
      if (t2.morphTargets[0].vertices && t2.morphTargets[0].vertices.length)
        this.numRowsPerTarget++;
      if (t2.morphTargets[0].vertexNormals && t2.morphTargets[0].vertexNormals.length)
        this.numRowsPerTarget++;
      if (t2.morphTargets[0].tangents && t2.morphTargets[0].tangents.length)
        this.numRowsPerTarget++;
      if (t2.morphTargets[0].bitangents && t2.morphTargets[0].bitangents.length)
        this.numRowsPerTarget++;
      A2 = t2.morphTargets.length * this.numRowsPerTarget;
      const i2 = new Float32Array(g2 * A2 * 4);
      let I2 = 0;
      for (let e2 = 0; e2 < t2.morphTargets.length; e2++) {
        if (t2.morphTargets[e2].vertices && t2.morphTargets[e2].vertices.length) {
          for (let A3 = 0; A3 < t2.morphTargets[e2].vertices.length; A3 += 3) {
            i2[(I2 * g2 + A3 / 3) * 4 + 0] = t2.morphTargets[e2].vertices[A3 + 0];
            i2[(I2 * g2 + A3 / 3) * 4 + 1] = t2.morphTargets[e2].vertices[A3 + 1];
            i2[(I2 * g2 + A3 / 3) * 4 + 2] = t2.morphTargets[e2].vertices[A3 + 2];
            i2[(I2 * g2 + A3 / 3) * 4 + 3] = 1;
          }
          I2++;
        }
        if (t2.morphTargets[e2].vertexNormals && t2.morphTargets[e2].vertexNormals.length) {
          for (let A3 = 0; A3 < t2.morphTargets[e2].vertexNormals.length; A3 += 3) {
            i2[(I2 * g2 + A3 / 3) * 4 + 0] = t2.morphTargets[e2].vertexNormals[A3 + 0];
            i2[(I2 * g2 + A3 / 3) * 4 + 1] = t2.morphTargets[e2].vertexNormals[A3 + 1];
            i2[(I2 * g2 + A3 / 3) * 4 + 2] = t2.morphTargets[e2].vertexNormals[A3 + 2];
            i2[(I2 * g2 + A3 / 3) * 4 + 3] = 1;
          }
          I2++;
        }
        if (t2.morphTargets[e2].tangents && t2.morphTargets[e2].tangents.length) {
          for (let A3 = 0; A3 < t2.morphTargets[e2].tangents.length; A3 += 3) {
            i2[(I2 * g2 + A3 / 3) * 4 + 0] = t2.morphTargets[e2].tangents[A3 + 0];
            i2[(I2 * g2 + A3 / 3) * 4 + 1] = t2.morphTargets[e2].tangents[A3 + 1];
            i2[(I2 * g2 + A3 / 3) * 4 + 2] = t2.morphTargets[e2].tangents[A3 + 2];
            i2[(I2 * g2 + A3 / 3) * 4 + 3] = 1;
          }
          I2++;
        }
        if (t2.morphTargets[e2].bitangents && t2.morphTargets[e2].bitangents.length) {
          for (let A3 = 0; A3 < t2.morphTargets[e2].bitangents.length; A3 += 3) {
            i2[(I2 * g2 + A3 / 3) * 4 + 0] = t2.morphTargets[e2].bitangents[A3 + 0];
            i2[(I2 * g2 + A3 / 3) * 4 + 1] = t2.morphTargets[e2].bitangents[A3 + 1];
            i2[(I2 * g2 + A3 / 3) * 4 + 2] = t2.morphTargets[e2].bitangents[A3 + 2];
            i2[(I2 * g2 + A3 / 3) * 4 + 3] = 1;
          }
          I2++;
        }
      }
      this.tex = new CGL.Texture(E, { isFloatingPointTexture: true, name: "targetsTexture" });
      this.tex.initFromData(i2, g2, A2, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);
    }
  };
  const X = m.inTrigger("Render"), e = m.inString("data"), N = m.inUrl("glb File", [".glb"]), z = m.inBool("Draw", true), t = m.inDropDown("Camera", ["None"], "None"), Z = m.inString("Animation", ""), $ = m.inTriggerButton("Show Structure"), g = m.inSwitch("Center", ["None", "XYZ", "XZ"], "XYZ"), i = m.inBool("Rescale", true), I = m.inFloat("Rescale Size", 2.5), n = m.inFloat("Time"), a = m.inBool("Sync to timeline", false), AA = m.inBool("Loop", true), eA = m.inSwitch("Normals Format", ["XYZ", "X-ZY"], "XYZ"), tA = m.inSwitch("Vertices Format", ["XYZ", "XZ-Y"], "XYZ"), r = m.inSwitch("Calc Normals", ["Auto", "Force Smooth", "Never"], "Auto"), s = m.inObject("Materials"), gA = m.inArray("Hide Nodes"), iA = m.inBool("Use Material Properties", false), B = m.inBool("Active", true), IA = m.outTrigger("Render Before"), Q = m.outTrigger("Next"), nA = m.outString("Generator"), oA = m.outNumber("GLTF Version"), CA = m.outArray("GLTF Extensions Used"), aA = m.outNumber("Anim Length", 0), rA = m.outNumber("Anim Time", 0), sA = m.outObject("Json"), BA = m.outArray("Anims"), QA = m.outArray("BoundingPoints"), EA = m.outObject("Bounds"), lA = m.outTrigger("Finished"), uA = m.outBool("Loading");
  m.setPortGroup("Timing", [n, a, AA]);
  const E = m.patch.cgl;
  let l = null;
  let cA = false;
  let hA = 0;
  let u = false;
  let c = null;
  let h = [];
  let S = null;
  let p = 0;
  let w = 0;
  let R = true;
  let pA = null;
  let G = null;
  let _ = null;
  const dA = vec3.create();
  let mA = 0;
  let fA = false;
  const F = vec3.create();
  N.onChange = tA.onChange = r.onChange = eA.onChange = M;
  $.onTriggered = A;
  e.onChange = GA;
  gA.onChange = U;
  Z.onChange = FA;
  g.onChange = yA;
  m.toWorkPortsNeedToBeLinked(X);
  e.setUiAttribs({ hideParam: true, hidePort: true });
  m.setPortGroup("Transform", [i, I, g]);
  function DA() {
    const e2 = ["None"];
    if (S) {
      for (let A2 = 0; A2 < S.nodes.length; A2++) {
        if (S.nodes[A2].camera >= 0) {
          e2.push(S.nodes[A2].name);
        }
      }
    }
    t.uiAttribs.values = e2;
  }
  function yA() {
    fA = g.get() != "None";
    if (S && S.bounds) {
      F.set(S.bounds.center);
      F[0] = -F[0];
      F[1] = -F[1];
      F[2] = -F[2];
      if (g.get() == "XZ")
        F[1] = -S.bounds.minY;
    }
  }
  i.onChange = function() {
    I.setUiAttribs({ greyout: !i.get() });
  };
  s.onChange = function() {
    R = true;
  };
  m.onDelete = function() {
    b();
  };
  a.onChange = function() {
    n.setUiAttribs({ greyout: a.get() });
  };
  t.onChange = bA;
  function bA() {
    c = null;
    if (!S)
      return;
    for (let A2 = 0; A2 < S.nodes.length; A2++) {
      if (S.nodes[A2].name == t.get())
        c = new v(S, S.nodes[A2]);
    }
  }
  X.onTriggered = function() {
    if (!u)
      return;
    if (!B.get())
      return;
    if (cA) {
      if (!l)
        l = CGL.MESHES.getSimpleCube(E, "ErrorCube");
      l.render(E.getShader());
    }
    hA = 0;
    if (a.get())
      w = m.patch.timer.getTime();
    else
      w = Math.max(0, n.get());
    if (AA.get()) {
      w %= p;
      if (w < mA)
        lA.trigger();
    } else {
      if (p > 0 && w >= p)
        lA.trigger();
    }
    mA = w;
    E.pushModelMatrix();
    rA.set(w || 0);
    if (u && S && S.bounds) {
      if (i.get()) {
        let A3 = I.get() / S.bounds.maxAxis;
        S.scale = A3;
        vec3.set(dA, A3, A3, A3);
        mat4.scale(E.mMatrix, E.mMatrix, dA);
      }
      if (fA) {
        mat4.translate(E.mMatrix, E.mMatrix, F);
      }
    }
    let A2 = E.frameStore.currentScene || null;
    E.frameStore.currentScene = S;
    IA.trigger();
    if (u) {
      if (R)
        wA();
      if (c)
        c.start(w);
      if (S) {
        S.time = w;
        if (S.bounds && E.shouldDrawHelpers(m)) {
          if (m.isCurrentUiOp())
            E.pushShader(CABLES.GL_MARKER.getSelectedShader(E));
          else
            E.pushShader(CABLES.GL_MARKER.getDefaultShader(E));
          S.bounds.render(E, null, m);
          E.popShader();
        }
        if (z.get()) {
          for (let A3 = 0; A3 < S.nodes.length; A3++)
            if (!S.nodes[A3].isChild)
              S.nodes[A3].render(E);
        } else {
          for (let A3 = 0; A3 < S.nodes.length; A3++)
            if (!S.nodes[A3].isChild)
              S.nodes[A3].render(E, false, true);
        }
      }
    }
    Q.trigger();
    E.frameStore.currentScene = A2;
    E.popModelMatrix();
    if (c)
      c.end();
  };
  function NA() {
    if (!S) {
      u = true;
      cA = true;
      E.patch.loading.finished(G);
      m.setUiError("nogltf", "GLTF File not found");
      return;
    }
    m.setUiError("nogltf", null);
    if (S.loadingMeshes > 0) {
      setTimeout(NA, 100);
      return;
    }
    S.timing.push(["finishLoading()", Math.round(performance.now() - S.startTime)]);
    R = true;
    aA.set(p);
    S.bounds = new CABLES.CG.BoundingBox();
    S.timing.push(["start calc bounds", Math.round(performance.now() - S.startTime)]);
    for (let A2 = 0; A2 < S.nodes.length; A2++) {
      const e2 = S.nodes[A2];
      e2.updateMatrix();
      if (!e2.isChild)
        e2.calcBounds(S, null, S.bounds);
    }
    if (S.bounds)
      EA.set(S.bounds);
    S.timing.push(["calced bounds", Math.round(performance.now() - S.startTime)]);
    U();
    S.timing.push(["hideNodesFromData", Math.round(performance.now() - S.startTime)]);
    if (d)
      A();
    S.timing.push(["printinfo", Math.round(performance.now() - S.startTime)]);
    DA();
    bA();
    QA.set(h);
    if (S) {
      if (N.get() && !N.get().startsWith("data:")) {
        m.setUiAttrib({ extendTitle: CABLES.basename(N.get()) });
      }
      S.loaded = Date.now();
    }
    if (S) {
      for (let A2 = 0; A2 < S.nodes.length; A2++) {
        if (!S.nodes[A2].isChild) {
          S.nodes[A2].render(E, false, true, true, false, true, 0);
        }
      }
      for (let A2 = 0; A2 < S.nodes.length; A2++) {
        const e2 = S.nodes[A2];
        e2.children = UA(e2.children);
      }
    }
    yA();
    FA();
    uA.set(false);
    E.patch.loading.finished(G);
    G = null;
    if (S.accBuffersDelete) {
      for (let A2 = 0; A2 < S.accBuffersDelete.length; A2++) {
        S.accBuffers[S.accBuffersDelete[A2]] = null;
      }
    }
    if (!(S.json.images && S.json.images.length))
      S.chunks = null;
    u = true;
  }
  function SA(A2) {
    if (!B.get())
      return;
    if (!G)
      G = E.patch.loading.start("gltfScene", N.get(), m);
    let e2 = N.get();
    if (!e2 || e2 == "null")
      return;
    let t2 = m.patch.getFilePath(String(N.get()));
    if (!t2)
      return;
    if (N.get() && !N.get().startsWith("data:")) {
      if (A2 === true)
        t2 += "?rnd=" + CABLES.generateUUID();
    }
    R = true;
    uA.set(true);
    fetch(t2).then((A3) => {
      return A3.arrayBuffer();
    }).then((A3) => {
      if (N.get() != e2) {
        E.patch.loading.finished(G);
        G = null;
        return;
      }
      h = [];
      p = 0;
      S = J(A3);
      A3 = null;
      NA();
    });
    b();
    const g2 = new XMLHttpRequest();
    g2.open("GET", t2, true);
    g2.responseType = "arraybuffer";
    E.patch.loading.addAssetLoadingTask(() => {
    });
  }
  m.onFileChanged = function(A2) {
    if (N.get() && N.get().indexOf(A2) > -1) {
      M(true);
    }
  };
  B.onChange = () => {
    if (B.get())
      M();
    if (!B.get()) {
      S = null;
    }
  };
  function M(A2) {
    clearTimeout(pA);
    pA = setTimeout(function() {
      SA(A2);
    }, 30);
  }
  function wA() {
    if (!S)
      return;
    S.shaders = {};
    if (s.links.length == 1 && s.get()) {
      R = true;
      const t2 = s.links[0].portOut.op;
      const g2 = t2.getPort("Shader");
      const i2 = t2.getPort("Material Name");
      if (!g2 && !i2) {
        const I2 = s.get();
        for (let e2 in I2) {
          if (I2[e2] && S.json.materials)
            for (let A2 = 0; A2 < S.json.materials.length; A2++) {
              if (S.json.materials[A2].name == e2) {
                if (S.shaders[A2]) {
                  t2.warn("double material assignment:", name);
                }
                S.shaders[A2] = I2[e2];
              }
            }
        }
      }
    }
    if (s.get()) {
      for (let A2 = 0; A2 < s.links.length; A2++) {
        const e2 = s.links[A2].portOut.op;
        const g2 = e2.getPort("Shader");
        const i2 = e2.getPort("Material Name");
        if (g2 && i2 && g2.get()) {
          const name2 = i2.get();
          if (S.json.materials) {
            for (let A3 = 0; A3 < S.json.materials.length; A3++)
              if (S.json.materials[A3].name == name2) {
                if (S.shaders[A3]) {
                  e2.warn("double material assignment:", name2);
                }
                S.shaders[A3] = g2.get();
              }
          }
        }
      }
    }
    R = false;
    if (d)
      A();
  }
  function RA() {
    const e2 = gA.get();
    if (!S || !_ || !_.hiddenNodes)
      return;
    if (!e2) {
      return;
    }
    for (let A2 = 0; A2 < e2.length; A2++) {
      const t2 = S.getNode(e2[A2]);
      if (t2)
        t2.hidden = true;
    }
  }
  function U() {
    if (!_)
      GA();
    if (!S)
      return;
    S.unHideAll();
    if (_ && _.hiddenNodes) {
      for (const A2 in _.hiddenNodes) {
        const e2 = S.getNode(A2);
        if (e2)
          e2.hidden = true;
        else
          m.verbose("node to be hidden not found", A2, e2);
      }
    }
    RA();
  }
  function GA() {
    _ = e.get();
    if (!_ || _ === "")
      _ = {};
    else
      _ = JSON.parse(_);
    if (S)
      U();
    return _;
  }
  function _A() {
    e.set(JSON.stringify(_));
  }
  function FA() {
    if (S && S.nodes) {
      for (let A2 = 0; A2 < S.nodes.length; A2++) {
        S.nodes[A2].setAnimAction(Z.get());
      }
    }
  }
  function MA(e2, t2) {
    for (let A2 = 0; A2 < S.nodes.length; A2++) {
      if (S.nodes[A2].children.indexOf(t2) >= 0) {
        e2.push(S.nodes[A2]);
        if (S.nodes[A2].isChild)
          MA(e2, A2);
      }
    }
  }
  m.exposeTexture = function(A2) {
    const e2 = gui.corePatch().addOp("Ops.Gl.GLTF.GltfTexture");
    e2.getPort("Name").set(A2);
    L(e2, 1);
    m.patch.link(m, Q.name, e2, "Render");
    gui.patchView.testCollision(e2);
    gui.patchView.centerSelectOp(e2.id, true);
  };
  m.exposeGeom = function(A2, e2) {
    const t2 = gui.corePatch().addOp("Ops.Gl.GLTF.GltfGeometry");
    t2.getPort("Name").set(A2);
    t2.getPort("Submesh").set(e2);
    L(t2, 1);
    m.patch.link(m, Q.name, t2, "Update");
    gui.patchView.testCollision(t2);
    gui.patchView.centerSelectOp(t2.id, true);
  };
  function L(A2, e2) {
    e2 = e2 || 1;
    A2.setUiAttrib({ subPatch: m.uiAttribs.subPatch, translate: { x: m.uiAttribs.translate.x, y: m.uiAttribs.translate.y + e2 * CABLES.GLUI.glUiConfig.newOpDistanceY } });
  }
  m.exposeNode = function(t2, A2, g2) {
    let e2 = A2 == "hierarchy";
    if (e2) {
      let i2 = [];
      for (let A3 = 0; A3 < S.nodes.length; A3++) {
        if (S.nodes[A3].name == t2) {
          let e3 = [];
          const I2 = S.nodes[A3];
          MA(e3, A3);
          e3 = e3.reverse();
          e3.push(I2, I2);
          let t3 = Q.name;
          let g3 = m;
          for (let A4 = 0; A4 < e3.length; A4++) {
            const n2 = gui.corePatch().addOp("Ops.Gl.GLTF.GltfNode_v2");
            n2.getPort("Node Name").set(e3[A4].name);
            m.patch.link(g3, t3, n2, "Render");
            L(n2, A4);
            if (A4 == e3.length - 1) {
              n2.getPort("Transformation").set(false);
            } else {
              n2.getPort("Draw Mesh").set(false);
              n2.getPort("Draw Childs").set(false);
            }
            t3 = "Next";
            g3 = n2;
            i2.push(n2);
            gui.patchView.testCollision(n2);
          }
        }
      }
      for (let A3 = 0; A3 < i2.length; A3++) {
        i2[A3].selectChilds();
      }
    } else {
      let e3 = "Ops.Gl.GLTF.GltfNode_v2";
      if (g2 && g2.skin)
        e3 = "Ops.Gl.GLTF.GltfSkin";
      if (A2 == "transform")
        e3 = "Ops.Gl.GLTF.GltfNodeTransform_v2";
      gui.serverOps.loadOpLibs(e3, () => {
        let A3 = gui.corePatch().addOp(e3);
        A3.getPort("Node Name").set(t2);
        L(A3);
        m.patch.link(m, Q.name, A3, "Render");
        gui.patchView.testCollision(A3);
        gui.patchView.centerSelectOp(A3.id, true);
      });
    }
    gui.closeModal();
  };
  m.assignMaterial = function(A2) {
    const e2 = gui.corePatch().addOp("Ops.Gl.GLTF.GltfSetMaterial");
    e2.getPort("Material Name").set(A2);
    m.patch.link(m, s.name, e2, "Material");
    L(e2);
    gui.patchView.testCollision(e2);
    gui.patchView.centerSelectOp(e2.id, true);
    gui.closeModal();
  };
  m.toggleNodeVisibility = function(A2) {
    const e2 = S.getNode(A2);
    e2.hidden = !e2.hidden;
    _.hiddenNodes = _.hiddenNodes || {};
    if (e2)
      if (e2.hidden)
        _.hiddenNodes[A2] = true;
      else
        delete _.hiddenNodes[A2];
    _A();
  };
  function UA(t2) {
    const g2 = {}, i2 = [];
    for (let A2 = 0, e2 = t2.length; A2 < e2; ++A2) {
      if (!g2.hasOwnProperty(t2[A2])) {
        i2.push(t2[A2]);
        g2[t2[A2]] = 1;
      }
    }
    return i2;
  }
};
Ops.Gl.GLTF.GltfScene_v4.prototype = new CABLES.Op();
CABLES.OPS["c9cbb226-46f7-4ca6-8dab-a9d0bdca4331"] = { f: Ops.Gl.GLTF.GltfScene_v4, objName: "Ops.Gl.GLTF.GltfScene_v4" };
Ops.Gl.GLTF.GltfSetMaterial = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("Shader", null, "shader"), g = A.inString("Material Name", "none"), i = A.outObject("Material");
  g.onChange = t.onChange = function() {
    A.setUiAttrib({ extendTitle: g.get() });
    i.setRef(t.get() || A.patch.cgl.getDefaultShader());
  };
};
Ops.Gl.GLTF.GltfSetMaterial.prototype = new CABLES.Op();
CABLES.OPS["baf968ea-e4df-4fca-9cda-e6ddd38a4200"] = { f: Ops.Gl.GLTF.GltfSetMaterial, objName: "Ops.Gl.GLTF.GltfSetMaterial" };
Ops.Vars.VarSetObject_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("Value", null);
  A.varName = A.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(A, "object", t, A.varName);
};
Ops.Vars.VarSetObject_v2.prototype = new CABLES.Op();
CABLES.OPS["c7608375-5b45-4bca-87ef-d0c5e970779a"] = { f: Ops.Vars.VarSetObject_v2, objName: "Ops.Vars.VarSetObject_v2" };
Ops.Vars.VarGetObject_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.outObject("Value");
  A.varName = A.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(A, "object", A.varName, t);
};
Ops.Vars.VarGetObject_v2.prototype = new CABLES.Op();
CABLES.OPS["321419d9-69c7-4310-a327-93d310bc2b8e"] = { f: Ops.Vars.VarGetObject_v2, objName: "Ops.Vars.VarGetObject_v2" };
Ops.Gl.Phong.LambertMaterial_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { lambert_frag: "{{MODULES_HEAD}}\n\n#define AMBIENT 0\n#define POINT 1\n#define DIRECTIONAL 2\n#define SPOT 3\n\nIN vec3 norm;\nIN vec4 modelPos;\n\n// UNI mat4 normalMatrix;\nIN mat3 normalMatrix; // when instancing...\n\nIN vec2 texCoord;\n\nIN vec3 mvNormal;\nIN vec3 mvTangent;\nIN vec3 mvBiTangent;\n\nUNI vec4 materialColor;//r,g,b,a;\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    // * SPOT LIGHT * //\n    #ifdef HAS_SPOT\n        vec3 conePointAt;\n        #define COSCONEANGLE x\n        #define COSCONEANGLEINNER y\n        #define SPOTEXPONENT z\n        vec3 spotProperties;\n    #endif\n\n    #define INTENSITY x\n    #define ATTENUATION y\n    #define FALLOFF z\n    #define RADIUS w\n    vec4 lightProperties;\n\n    int type;\n    int castLight;\n    #define CASTLIGHT x\n    #define TYPE y\n    ivec2 castLightType;\n};\n#ifdef HAS_TEXTURES\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D texDiffuse;\n    #endif\n#endif\n\nUNI Light lights[NUM_LIGHTS];\n\n// * UTILITY FUNCTIONS */\nfloat when_gt(float x, float y) { return max(sign(x - y), 0.0); } // comparator function\nfloat when_eq(float x, float y) { return 1. - abs(sign(x - y)); } // comparator function\nfloat when_neq(float x, float y) { return abs(sign(x - y)); } // comparator function\n\n\n// * LIGHT CALCULATIONS */\nfloat CalculateFalloff(float radius, float falloff, float distLight)\n{\n    float denom = distLight / radius + 1.0;\n    float attenuation = 1.0 / (denom*denom);\n    float t = (attenuation - 0.1) / (1.0 - 0.1);\n\n    t = t * (20.0 * (1. - falloff) * 20.0 * (1. - falloff));\n\n    return min(1.0,max(t, 0.0));\n}\n\nfloat Falloff2(vec3 lightDirection, float falloff) {\n    float distanceSquared = dot(lightDirection, lightDirection);\n    float factor = distanceSquared * falloff;\n    float smoothFactor = clamp(1. - factor * factor, 0., 1.);\n    float attenuation = smoothFactor * smoothFactor;\n\n    return attenuation * 1. / max(distanceSquared, 0.00001);\n}\n\n#ifdef HAS_SPOT\n    float CalculateSpotLightEffect(vec3 lightPosition, vec3 conePointAt, float cosConeAngle, float cosConeAngleInner, float spotExponent, vec3 lightDirection) {\n        vec3 spotLightDirection = normalize(lightPosition-conePointAt);\n        float spotAngle = dot(-lightDirection, spotLightDirection);\n        float epsilon = cosConeAngle - cosConeAngleInner;\n\n        float spotIntensity = clamp((spotAngle - cosConeAngle)/epsilon, 0.0, 1.0);\n        spotIntensity = pow(spotIntensity, max(0.01, spotExponent));\n\n        return max(0., spotIntensity);\n    }\n#endif\nvec3 CalculateDiffuseColor(vec3 lightDirection, vec3 normal, vec3 lightColor, vec3 materialColor, inout float lambert) {\n    lambert = clamp(dot(lightDirection, normal), 0., 1.);\n    vec3 diffuseColor = lambert * lightColor * materialColor;\n    return diffuseColor;\n}\n\n\n// MAIN\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n\n    vec4 col=vec4(0.0);\n    vec3 normal = normalize(mat3(normalMatrix)*norm);\n\n    #ifdef DOUBLE_SIDED\n        if(!gl_FrontFacing) normal = normal*-1.0;\n    #endif\n\n    vec3 matColor = materialColor.rgb;\n\n    #ifdef HAS_TEXTURES\n        #ifdef HAS_TEXTURE_DIFFUSE\n            matColor = texture(texDiffuse, texCoord).rgb;\n            #ifdef COLORIZE_TEXTURE\n                matColor *= materialColor.rgb;\n            #endif\n        #endif\n    #endif\n\n    for(int l=0;l<NUM_LIGHTS;l++) {\n        if (lights[l].castLightType.TYPE == AMBIENT) {\n            col.rgb += lights[l].lightProperties.INTENSITY * lights[l].color;\n        } else {\n            if (lights[l].castLightType.CASTLIGHT == 0) continue;\n\n            vec3 lightModelDiff= lights[l].position - modelPos.xyz;\n            vec3 lightDirection = normalize(lightModelDiff);\n\n            if (lights[l].castLightType.TYPE == DIRECTIONAL) lightDirection = lights[l].position;\n\n            float lambert = 1.; // inout variable\n            vec3 diffuseColor = CalculateDiffuseColor(lightDirection, normal, lights[l].color, matColor, lambert);\n\n            if (lights[l].castLightType.TYPE != DIRECTIONAL) diffuseColor *= Falloff2(lightDirection, lights[l].lightProperties.FALLOFF);\n\n            #ifdef HAS_SPOT\n                if (lights[l].castLightType.TYPE == SPOT) diffuseColor *= CalculateSpotLightEffect(\n                    lights[l].position, lights[l].conePointAt, lights[l].spotProperties.COSCONEANGLE,\n                    lights[l].spotProperties.COSCONEANGLEINNER, lights[l].spotProperties.SPOTEXPONENT,\n                    lightDirection\n                );\n            #endif\n\n            diffuseColor *= lights[l].lightProperties.INTENSITY;\n            col.rgb += diffuseColor;\n        }\n    }\n\n\n    col.a = materialColor.a;\n\n    {{MODULE_COLOR}}\n\n    // col.rgb=norm.rgb;\n\n    outColor = col;\n}\n", lambert_vert: "#define TEX_REPEAT_X x;\n#define TEX_REPEAT_Y y;\n#define TEX_OFFSET_X z;\n#define TEX_OFFSET_Y w;\n\nIN vec3 vPosition;\nIN vec3 attrVertNormal;\nIN vec2 attrTexCoord;\n\nIN vec3 attrTangent;\nIN vec3 attrBiTangent;\nIN float attrVertIndex;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nOUT vec3 norm;\nOUT mat4 mvMatrix;\nOUT mat3 normalMatrix;\nOUT vec4 modelPos;\nOUT vec2 texCoord;\n{{MODULES_HEAD}}\n\nmat3 transposeMat3(mat3 m)\n{\n    return mat3(\n        m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\nmat3 inverseMat3(mat3 m)\n{\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mMatrix=modelMatrix;\n    vec3 tangent=attrTangent,\n        bitangent=attrBiTangent;\n\n    texCoord=attrTexCoord;\n    texCoord.y = 1. - texCoord.y;\n\n    norm=attrVertNormal;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mMatrix)));\n\n\n    // this needs only to be done when instancing....\n\n    mat4 modelViewMatrix=viewMatrix*mMatrix;\n    {{MODULE_VERTEX_MOVELVIEW}}\n    mvMatrix=modelViewMatrix;\n\n\n    modelPos=mMatrix*pos;\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n}\n" };
  const g = { ambient: 0, point: 1, directional: 2, spot: 3 };
  const t = A.inTrigger("Execute"), i = A.inValueSlider("Diffuse R", Math.random()), I = A.inValueSlider("Diffuse G", Math.random()), n = A.inValueSlider("Diffuse B", Math.random()), o = A.inValueSlider("Diffuse A", 1);
  i.setUiAttribs({ colorPick: true });
  A.setPortGroup("Diffuse Color", [i, I, n, o]);
  const C = A.inBool("Double Sided", false);
  C.setUiAttribs({ hidePort: true });
  C.onChange = function() {
    u.toggleDefine("DOUBLE_SIDED", C.get());
  };
  A.setPortGroup("Material Properties", [C]);
  A.toWorkPortsNeedToBeLinked(t);
  A.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);
  const a = A.inTexture("Diffuse Texture");
  let r = null;
  const s = null;
  a.onChange = Q;
  const B = A.inBool("Colorize Texture", false);
  B.onChange = function() {
    u.toggleDefine("COLORIZE_TEXTURE", B.get());
  };
  A.setPortGroup("Texture", [a, B]);
  function Q() {
    if (a.get()) {
      if (!u.hasDefine("HAS_TEXTURE_DIFFUSE")) {
        u.define("HAS_TEXTURE_DIFFUSE");
        if (!r)
          r = new CGL.Uniform(u, "t", "texDiffuse", 0);
      }
    } else {
      u.removeUniform("texDiffuse");
      u.removeDefine("HAS_TEXTURE_DIFFUSE");
      r = null;
    }
  }
  const E = A.outTrigger("next");
  const l = A.patch.cgl;
  const u = new CGL.Shader(l, "LambertMaterial");
  u.define("NUM_LIGHTS", "1");
  const c = new CGL.Uniform(u, "4f", "materialColor", i, I, n, o);
  u.uniformColorDiffuse = c;
  const h = A.outObject("Shader");
  h.set(u);
  const p = l.maxUniformsFrag;
  const d = p === 64 ? 6 : 16;
  u.setSource(e.lambert_vert, e.lambert_frag);
  const m = [{ type: "point", position: [0, 2, 1], intensity: 1, attenuation: 0, falloff: 0.5, radius: 80, castLight: 1 }];
  u.define("MAX_LIGHTS", d.toString());
  let f = null;
  function D() {
    f = { color: new CGL.Uniform(u, "3f", "lights[0].color", [1, 1, 1]), position: new CGL.Uniform(u, "3f", "lights[0].position", [0, 11, 0]), lightProperties: new CGL.Uniform(u, "4f", "lights[0].lightProperties", [1, 1, 1, 1]), conePointAt: new CGL.Uniform(u, "3f", "lights[0].conePointAt", vec3.create()), spotProperties: new CGL.Uniform(u, "3f", "lights[0].spotProperties", [0, 0, 0, 0]), castLightType: new CGL.Uniform(u, "2i", "lights[0].castLightType", [0, 0]) };
  }
  function y(A2) {
    u.define("NUM_LIGHTS", "1");
    if (u.hasDefine("HAS_SPOT")) {
      u.removeDefine("HAS_SPOT");
    }
    if (u.hasDefine("HAS_DIRECTIONAL")) {
      u.removeDefine("HAS_DIRECTIONAL");
    }
    if (u.hasDefine("HAS_AMBIENT")) {
      u.removeDefine("HAS_AMBIENT");
    }
    if (!u.hasDefine("HAS_POINT"))
      u.define("HAS_POINT");
    f.position.setValue(A2.position);
    f.color.setValue(A2.color);
    f.lightProperties.setValue([A2.intensity, A2.attenuation, A2.falloff, A2.radius]);
    f.castLightType.setValue([1, g[A2.type]]);
    f.conePointAt.setValue(A2.conePointAt);
    f.spotProperties.setValue([A2.cosConeAngle, A2.cosConeAngleInner, A2.spotExponent]);
  }
  const b = [];
  const N = { directional: false, spot: false, ambient: false, point: false };
  function S(e2) {
    for (let A2 = 0; A2 < b.length; A2 += 1) {
      b[A2] = null;
    }
    N.directional = false;
    N.spot = false;
    N.ambient = false;
    N.point = false;
    for (let A2 = 0; A2 < e2.length; A2 += 1) {
      if (A2 === d)
        return;
      b[A2] = null;
      const t2 = e2[A2];
      const g2 = t2.type;
      if (!N[g2])
        N[g2] = true;
      if (!b[A2]) {
        b[A2] = { color: new CGL.Uniform(u, "3f", "lights[" + A2 + "].color", [1, 1, 1]), position: new CGL.Uniform(u, "3f", "lights[" + A2 + "].position", [0, 11, 0]), lightProperties: new CGL.Uniform(u, "4f", "lights[" + A2 + "].lightProperties", [1, 1, 1, 1]), conePointAt: new CGL.Uniform(u, "3f", "lights[" + A2 + "].conePointAt", vec3.create()), spotProperties: new CGL.Uniform(u, "3f", "lights[" + A2 + "].spotProperties", [0, 0, 0, 0]), castLightType: new CGL.Uniform(u, "2i", "lights[" + A2 + "].castLightType", [0, 0]) };
      }
    }
    for (let A2 = 0, e3 = Object.keys(N); A2 < e3.length; A2 += 1) {
      const i2 = e3[A2];
      u.toggleDefine("HAS_" + i2.toUpperCase(), N[i2]);
    }
  }
  function w(e2) {
    for (let A2 = 0; A2 < e2.length; A2 += 1) {
      const t2 = e2[A2];
      t2.isUsed = true;
      b[A2].position.setValue(t2.position);
      b[A2].color.setValue(t2.color);
      b[A2].lightProperties.setValue([t2.intensity, t2.attenuation, t2.falloff, t2.radius]);
      b[A2].conePointAt.setValue(t2.conePointAt);
      b[A2].spotProperties.setValue([t2.cosConeAngle, t2.cosConeAngleInner, t2.spotExponent]);
      b[A2].castLightType.setValue([Number(t2.castLight), g[t2.type]]);
    }
  }
  let R = 0;
  function G(A2) {
    if (A2.length !== R) {
      S(A2);
      R = A2.length;
      u.define("NUM_LIGHTS", "" + Math.max(R, 1));
      w(A2);
    } else {
      w(A2);
    }
  }
  const _ = mat4.create();
  function F() {
    if (!l.frameStore.lightStack || !l.frameStore.lightStack.length) {
      if (!f)
        D();
      mat4.invert(_, l.vMatrix);
      m[0].position = [_[12], _[13], _[14]];
      y(m[0]);
      R = -1;
    } else {
      if (u) {
        if (l.frameStore.lightStack) {
          if (l.frameStore.lightStack.length) {
            f = null;
            G(l.frameStore.lightStack);
          }
        }
      }
    }
  }
  t.onTriggered = function() {
    if (!u) {
      A.log("lambert has no shader...");
      return;
    }
    if (l.frameStore.lightStack) {
      if (l.frameStore.lightStack.length === 0)
        A.setUiError("deflight", "Default light is enabled. Please add lights to your patch to make this warning disappear.", 1);
      else
        A.setUiError("deflight", null);
    }
    l.pushShader(u);
    u.popTextures();
    F();
    if (a.get())
      u.pushTexture(r, a.get().tex);
    E.trigger();
    l.popShader();
  };
  Q();
};
Ops.Gl.Phong.LambertMaterial_v2.prototype = new CABLES.Op();
CABLES.OPS["d69316f1-bde9-4645-8280-c635a8982e0d"] = { f: Ops.Gl.Phong.LambertMaterial_v2, objName: "Ops.Gl.Phong.LambertMaterial_v2" };
Ops.Math.OneMinus = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("Value"), g = A.outNumber("Result");
  t.onChange = i;
  i();
  function i() {
    g.set(1 - t.get());
  }
};
Ops.Math.OneMinus.prototype = new CABLES.Op();
CABLES.OPS["f34d019d-59ae-40d6-a55d-a7691bbc40e0"] = { f: Ops.Math.OneMinus, objName: "Ops.Math.OneMinus" };
Ops.Gl.GLTF.GltfTransformNode = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Render"), g = A.inString("Node Name"), i = A.inFloat("Translate X", 0), I = A.inFloat("Translate Y", 0), n = A.inFloat("Translate Z", 0), o = A.inFloat("Rotation X", 0), C = A.inFloat("Rotation Y", 0), a = A.inFloat("Rotation Z", 0), r = A.outTrigger("Next"), s = A.outBool("Found");
  const B = A.patch.cgl;
  let Q = quat.create();
  let E = mat4.create();
  let l = mat4.create();
  let u = null;
  let c = null;
  g.onChange = function() {
    u = null;
    s.set(false);
    A.setUiAttrib({ extendTitle: g.get() });
  };
  A.onDelete = function() {
  };
  t.onTriggered = function() {
    if (!B.frameStore.currentScene)
      return;
    if (c != B.frameStore.currentScene.loaded)
      u = null;
    if (!u) {
      const e2 = g.get();
      if (!B.frameStore || !B.frameStore.currentScene || !B.frameStore.currentScene.nodes)
        return;
      c = B.frameStore.currentScene.loaded;
      for (let A2 = 0; A2 < B.frameStore.currentScene.nodes.length; A2++) {
        if (B.frameStore.currentScene.nodes[A2].name == e2) {
          u = B.frameStore.currentScene.nodes[A2];
          s.set(true);
        }
      }
    }
    if (u) {
      mat4.identity(E);
      mat4.translate(E, E, [i.get(), I.get(), n.get()]);
      mat4.rotateX(E, E, o.get());
      mat4.rotateY(E, E, C.get());
      mat4.rotateZ(E, E, a.get());
      u.addMulMat = E;
    }
    r.trigger();
  };
};
Ops.Gl.GLTF.GltfTransformNode.prototype = new CABLES.Op();
CABLES.OPS["bccdb19d-6786-4656-90d7-e798346ea644"] = { f: Ops.Gl.GLTF.GltfTransformNode, objName: "Ops.Gl.GLTF.GltfTransformNode" };
Ops.Array.GateArray_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inArray("Array in"), g = A.inValueBool("Pass Through", true), i = A.inSwitch("When False", ["keep last array", "null"], "keep last array"), I = A.outArray("Array Out");
  let n = null;
  function o(e2) {
    if (!e2)
      return null;
    const t2 = [];
    t2.length = e2.length;
    for (let A2 = 0; A2 < e2.length; A2++)
      t2[A2] = e2[A2];
    return t2;
  }
  i.onChange = t.onChange = g.onChange = function() {
    if (g.get()) {
      n = o(t.get());
      I.setRef(n);
    } else {
      if (i.get() == "null")
        I.setRef(null);
    }
  };
};
Ops.Array.GateArray_v2.prototype = new CABLES.Op();
CABLES.OPS["e28a489c-46b6-4279-928c-6b0cbaaaae2a"] = { f: Ops.Array.GateArray_v2, objName: "Ops.Array.GateArray_v2" };
Ops.Math.MathExpression = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inFloat("A", 0);
  const g = A.inFloat("B", 1);
  const i = A.inFloat("C", 2);
  const I = A.inFloat("D", 3);
  A.setPortGroup("Parameters", [t, g, i, I]);
  const n = A.inString("Expression", "a*(b+c+d)");
  A.setPortGroup("Expression", [n]);
  const o = A.outNumber("Result");
  const C = A.outBool("Expression Valid");
  let a = n.get();
  let r = false;
  const s = () => {
    try {
      a = new Function("m", "a", "b", "c", "d", `with(m) { return ${n.get()} }`);
      r = true;
      B();
      C.set(r);
    } catch (A2) {
      r = false;
      C.set(r);
      if (A2 instanceof ReferenceError || A2 instanceof SyntaxError)
        return;
    }
  };
  const B = () => {
    if (r) {
      o.set(a(Math, t.get(), g.get(), i.get(), I.get()));
      if (!n.get())
        o.set(0);
    }
    C.set(r);
  };
  t.onChange = g.onChange = i.onChange = I.onChange = B;
  n.onChange = s;
  s();
};
Ops.Math.MathExpression.prototype = new CABLES.Op();
CABLES.OPS["d2343a1e-64ea-45b2-99ed-46e167bbdcd3"] = { f: Ops.Math.MathExpression, objName: "Ops.Math.MathExpression" };
Ops.Trigger.TriggerCounter = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTriggerButton("exe"), g = A.inTriggerButton("reset"), i = A.outTrigger("trigger"), I = A.outNumber("timesTriggered");
  A.toWorkPortsNeedToBeLinked(t);
  A.setUiAttrib({ extendTitle: 0 });
  let n = 0;
  g.onTriggered = A.onLoaded = o;
  t.onTriggered = function() {
    n++;
    I.set(n);
    A.setUiAttrib({ extendTitle: n });
    i.trigger();
  };
  function o() {
    n = 0;
    A.setUiAttrib({ extendTitle: n });
    I.set(n);
  }
};
Ops.Trigger.TriggerCounter.prototype = new CABLES.Op();
CABLES.OPS["e640619f-235c-4543-bbf8-b358e0283180"] = { f: Ops.Trigger.TriggerCounter, objName: "Ops.Trigger.TriggerCounter" };
Ops.Gl.Matrix.Scale = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("render"), g = e.inValueFloat("scale", 1), i = e.inValueFloat("x", 1), I = e.inValueFloat("y", 1), n = e.inValueFloat("z", 1), o = e.outTrigger("trigger");
  e.setPortGroup("Axis", [i, I, n]);
  const C = vec3.create();
  i.onChange = I.onChange = n.onChange = g.onChange = a;
  a();
  t.onTriggered = function() {
    const A2 = e.patch.cgl;
    A2.pushModelMatrix();
    mat4.scale(A2.mMatrix, A2.mMatrix, C);
    o.trigger();
    A2.popModelMatrix();
  };
  function a() {
    const A2 = g.get();
    vec3.set(C, A2 * i.get(), A2 * I.get(), A2 * n.get());
  }
};
Ops.Gl.Matrix.Scale.prototype = new CABLES.Op();
CABLES.OPS["50e7f565-0cdb-47ca-912b-87c04e2f00e3"] = { f: Ops.Gl.Matrix.Scale, objName: "Ops.Gl.Matrix.Scale" };
Ops.Gl.Meshes.Rectangle_v4 = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("render"), g = e.inValueBool("Render Mesh", true), S = e.inValue("width", 1), w = e.inValue("height", 1), R = e.inSwitch("pivot x", ["left", "center", "right"], "center"), G = e.inSwitch("pivot y", ["top", "center", "bottom"], "center"), _ = e.inSwitch("axis", ["xy", "xz"], "xy"), F = e.inBool("Flip TexCoord X", false), M = e.inBool("Flip TexCoord Y", true), U = e.inValueInt("num columns", 1), L = e.inValueInt("num rows", 1), i = e.outTrigger("trigger"), v = e.outObject("geometry", null, "geometry");
  v.ignoreValueSerialize = true;
  const I = e.patch.cgl;
  const O = new CGL.Geometry("rectangle");
  g.setUiAttribs({ title: "Render" });
  t.setUiAttribs({ title: "Trigger" });
  i.setUiAttribs({ title: "Next" });
  e.setPortGroup("Pivot", [R, G, _]);
  e.setPortGroup("Size", [S, w]);
  e.setPortGroup("Structure", [U, L]);
  e.toWorkPortsNeedToBeLinked(t);
  e.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_TRIGGER);
  const k = 0;
  const x = 1;
  let T = k;
  let J = null;
  let Y = true;
  let K = true;
  const n = vec3.create();
  vec3.set(n, 1, 1, 1);
  _.onChange = R.onChange = G.onChange = F.onChange = M.onChange = L.onChange = U.onChange = o;
  j();
  S.onChange = w.onChange = () => {
    if (K)
      j();
    else
      Y = true;
  };
  function j() {
    if (T === k)
      vec3.set(n, S.get(), w.get(), 1);
    if (T === x)
      vec3.set(n, S.get(), 1, w.get());
  }
  v.onLinkChanged = () => {
    K = !v.isLinked();
    j();
    Y = true;
  };
  function o() {
    Y = true;
  }
  t.onTriggered = () => {
    if (Y)
      C();
    const A2 = e.patch.cg;
    if (A2 && J && g.get()) {
      if (K) {
        A2.pushModelMatrix();
        mat4.scale(A2.mMatrix, A2.mMatrix, n);
      }
      J.render(A2.getShader());
      if (K)
        A2.popModelMatrix();
    }
    i.trigger();
  };
  e.onDelete = () => {
    if (J)
      J.dispose();
    o();
  };
  function C() {
    if (_.get() == "xy")
      T = k;
    if (_.get() == "xz")
      T = x;
    j();
    let t2 = S.get();
    let g2 = w.get();
    if (K)
      t2 = g2 = 1;
    let i2 = 0;
    let I2 = 0;
    if (R.get() == "center")
      i2 = 0;
    else if (R.get() == "right")
      i2 = -t2 / 2;
    else if (R.get() == "left")
      i2 = +t2 / 2;
    if (G.get() == "center")
      I2 = 0;
    else if (G.get() == "top")
      I2 = -g2 / 2;
    else if (G.get() == "bottom")
      I2 = +g2 / 2;
    const n2 = Math.max(1, Math.round(L.get()));
    const o2 = Math.max(1, Math.round(U.get()));
    const C2 = t2 / o2;
    const a = g2 / n2;
    const r = [];
    const s = new Float32Array((o2 + 1) * (n2 + 1) * 2);
    const B = new Float32Array((o2 + 1) * (n2 + 1) * 3);
    const Q = new Float32Array((o2 + 1) * (n2 + 1) * 3);
    const E = new Float32Array((o2 + 1) * (n2 + 1) * 3);
    const l = new Float32Array((o2 + 1) * (n2 + 1) * 3);
    let u = 0;
    let c = 0;
    let h = 0;
    let p = 0;
    let d = 0;
    for (let e2 = 0; e2 <= n2; e2++) {
      for (let A2 = 0; A2 <= o2; A2++) {
        B[c++] = A2 * C2 - t2 / 2 + i2;
        if (T == x)
          B[c++] = 0;
        B[c++] = e2 * a - g2 / 2 + I2;
        if (T == k)
          B[c++] = 0;
        s[u++] = A2 / o2;
        s[u++] = e2 / n2;
        if (T == k) {
          Q[h++] = 0;
          Q[h++] = 0;
          Q[h++] = 1;
          E[p++] = 1;
          E[p++] = 0;
          E[p++] = 0;
          l[d++] = 0;
          l[d++] = 1;
          l[d++] = 0;
        } else if (T == x) {
          Q[h++] = 0;
          Q[h++] = 1;
          Q[h++] = 0;
          l[d++] = 0;
          l[d++] = 0;
          l[d++] = 1;
        }
      }
    }
    r.length = o2 * n2 * 6;
    let m = 0;
    for (let e2 = 0; e2 < o2; e2++) {
      for (let A2 = 0; A2 < n2; A2++) {
        const f = e2 + (o2 + 1) * A2;
        const D = f;
        const y = f + 1;
        const b = f + o2 + 1;
        const N = f + 1 + o2 + 1;
        if (T == k) {
          r[m++] = D;
          r[m++] = y;
          r[m++] = b;
          r[m++] = b;
          r[m++] = y;
          r[m++] = N;
        } else if (T == x) {
          r[m++] = D;
          r[m++] = b;
          r[m++] = y;
          r[m++] = y;
          r[m++] = b;
          r[m++] = N;
        }
      }
    }
    if (M.get())
      for (let A2 = 0; A2 < s.length; A2 += 2)
        s[A2 + 1] = 1 - s[A2 + 1];
    if (F.get())
      for (let A2 = 0; A2 < s.length; A2 += 2)
        s[A2] = 1 - s[A2];
    O.clear();
    O.vertices = B;
    O.texCoords = s;
    O.verticesIndices = r;
    O.vertexNormals = Q;
    O.tangents = E;
    O.biTangents = l;
    if (e.patch.cg)
      if (!J)
        J = e.patch.cg.createMesh(O, { opId: e.id });
      else
        J.setGeom(O);
    v.setRef(O);
    Y = false;
  }
};
Ops.Gl.Meshes.Rectangle_v4.prototype = new CABLES.Op();
CABLES.OPS["cc8c3ede-7103-410b-849f-a645793cab39"] = { f: Ops.Gl.Meshes.Rectangle_v4, objName: "Ops.Gl.Meshes.Rectangle_v4" };
Ops.Gl.Matrix.Billboard = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Exec");
  const g = A.outTrigger("Next");
  const i = A.patch.cgl;
  let I = mat4.create();
  let n = mat4.create();
  let o = mat4.create();
  let C = mat4.create();
  t.onTriggered = function() {
    mat4.invert(I, i.mMatrix);
    mat4.invert(n, i.vMatrix);
    mat4.mul(I, I, n);
    I[12] = 0;
    I[13] = 0;
    I[14] = 0;
    i.pushModelMatrix();
    i.pushViewMatrix();
    mat4.mul(i.mMatrix, i.mMatrix, I);
    g.trigger();
    i.popViewMatrix();
    i.popModelMatrix();
  };
};
Ops.Gl.Matrix.Billboard.prototype = new CABLES.Op();
CABLES.OPS["d41e676e-d8a7-4a1e-8abf-f1bddfc982d5"] = { f: Ops.Gl.Matrix.Billboard, objName: "Ops.Gl.Matrix.Billboard" };
Ops.Gl.Matrix.TranslateView = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("render"), g = A.inValueFloat("x"), i = A.inValueFloat("y"), I = A.inValueFloat("z"), n = A.outTrigger("trigger");
  const o = A.patch.cgl;
  const C = vec3.create();
  t.onTriggered = function() {
    vec3.set(C, g.get(), i.get(), I.get());
    o.pushViewMatrix();
    mat4.translate(o.vMatrix, o.vMatrix, C);
    n.trigger();
    o.popViewMatrix();
  };
};
Ops.Gl.Matrix.TranslateView.prototype = new CABLES.Op();
CABLES.OPS["b15472e2-b895-4dde-95c3-239fa5e08afc"] = { f: Ops.Gl.Matrix.TranslateView, objName: "Ops.Gl.Matrix.TranslateView" };
Ops.Data.Compose.Object.CompObject = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("Update"), g = e.outTrigger("Next"), i = e.outObject("Result");
  t.onTriggered = () => {
    e.patch.frameStore.compObject = e.patch.frameStore.compObject || [];
    let A2 = {};
    e.patch.frameStore.compObject.push(A2);
    g.trigger();
    i.setRef(e.patch.frameStore.compObject.pop());
  };
};
Ops.Data.Compose.Object.CompObject.prototype = new CABLES.Op();
CABLES.OPS["c85b449b-fb4e-40b3-928e-5eea6a5d0ebc"] = { f: Ops.Data.Compose.Object.CompObject, objName: "Ops.Data.Compose.Object.CompObject" };
Ops.Data.Compose.Object.CompObjectSetNumber = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("Update"), g = e.inString("Key", ""), i = e.inFloat("Number", 0), I = e.outTrigger("Next");
  e.setUiAttrib({ extendTitlePort: g.name });
  g.setUiAttribs({ stringTrim: true, minLength: 1 });
  t.onTriggered = () => {
    if (e.patch.frameStore.compObject && e.patch.frameStore.compObject.length > 0) {
      let A2 = e.patch.frameStore.compObject[e.patch.frameStore.compObject.length - 1];
      A2[g.get()] = i.get();
    }
    I.trigger();
  };
};
Ops.Data.Compose.Object.CompObjectSetNumber.prototype = new CABLES.Op();
CABLES.OPS["58a75bf7-6828-4190-a205-3b8037bc24d4"] = { f: Ops.Data.Compose.Object.CompObjectSetNumber, objName: "Ops.Data.Compose.Object.CompObjectSetNumber" };
Ops.Ui.VizObject = function() {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const A = i.attachments = {};
  const I = i.inObject("Object"), e = i.inTriggerButton("console log"), g = i.inBool("ZoomText", false), n = i.inBool("Line Numbers", true), o = i.inFloat("Font Size", 10), C = i.inFloatSlider("Scroll", 0);
  let a = [];
  e.setUiAttribs({ hidePort: true });
  i.setUiAttrib({ height: 200, width: 400, resizable: true, vizLayerMaxZoom: 2500 });
  I.onChange = () => {
    let A2 = I.get();
    let e2 = "???";
    if (A2 && A2.getInfo)
      A2 = A2.getInfo();
    if (A2 && A2.constructor && A2.constructor.name != "Object")
      i.setUiAttribs({ extendTitle: A2.constructor.name });
    if (A2 === void 0)
      e2 = "undefined";
    else if (A2 == null)
      e2 = "null";
    else
      try {
        e2 = JSON.stringify(A2, false, 4);
        if (A2.hasOwnProperty("isTrusted") && Object.keys(A2).length == 1 || e2 == "{}" && A2 && A2.constructor && A2.constructor.name != "Object") {
          e2 = "could not stringify object: " + A2.constructor.name + "\n";
          const t = {};
          for (const g2 in A2) {
            if (!A2[g2])
              continue;
            if (A2[g2].constructor) {
              if (A2[g2].constructor.name == "Number" || A2[g2].constructor.name == "String" || A2[g2].constructor.name == "Boolean")
                t[g2] = A2[g2];
            } else
              t[g2] = "{???}";
          }
          A2 = t;
          e2 = JSON.stringify(A2, false, 4);
        }
      } catch (A3) {
        e2 = "object can not be displayed as string", A3.msg;
      }
    e2 = String(e2);
    a = e2.split("\n");
  };
  I.onLinkChanged = () => {
    if (I.isLinked()) {
      const A2 = I.links[0].getOtherPort(I);
      i.setUiAttrib({ extendTitle: A2.uiAttribs.objType });
    }
  };
  e.onTriggered = () => {
    console.info(I.get());
  };
  i.renderVizLayer = (A2, e2, t) => {
    t.clear(A2, e2);
    A2.save();
    A2.scale(e2.scale, e2.scale);
    t.renderText(A2, e2, a, { zoomText: g.get(), showLineNum: n.get(), syntax: "js", fontSize: o.get(), scroll: C.get() });
    A2.restore();
  };
};
Ops.Ui.VizObject.prototype = new CABLES.Op();
CABLES.OPS["d09bc53e-9f52-4872-94c7-4ef777512222"] = { f: Ops.Ui.VizObject, objName: "Ops.Ui.VizObject" };
Ops.Json.ObjectValuesAsArray = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("Object"), g = A.outArray("Values"), i = A.outNumber("Num values");
  t.onChange = () => {
    const A2 = t.get();
    if (!A2) {
      i.set(0);
      g.set([]);
      return;
    }
    const e2 = Object.values(A2);
    i.set(e2.length);
    g.set(e2);
  };
};
Ops.Json.ObjectValuesAsArray.prototype = new CABLES.Op();
CABLES.OPS["32ff73f5-7947-42b0-83fa-e079af7beb5c"] = { f: Ops.Json.ObjectValuesAsArray, objName: "Ops.Json.ObjectValuesAsArray" };
Ops.Ui.VizArrayTable = function() {
  CABLES.Op.apply(this, arguments);
  const E = this;
  const A = E.attachments = {};
  const l = E.inArray("Array"), u = E.inInt("Start Row", 0);
  E.setUiAttrib({ height: 200, width: 400, resizable: true, vizLayerMaxZoom: 2500 });
  function c(e) {
    let t = "";
    if (typeof e == "string") {
      t = '"' + e + '"';
    } else if (CABLES.UTILS.isNumeric(e))
      t = String(Math.round(e * 1e4) / 1e4);
    else if (Array.isArray(e)) {
      let A2 = "...";
      if (e.length == 0)
        A2 = "";
      t = "[" + A2 + "] (" + e.length + ")";
    } else if (typeof e == "object") {
      try {
        t = JSON.stringify(e, true, 1);
      } catch (A2) {
        t = "{???}";
      }
    } else if (e != e || e === void 0) {
      t += String(e);
    } else {
      t += String(e);
    }
    return t;
  }
  E.renderVizLayer = (g, i) => {
    g.fillStyle = "#222";
    g.fillRect(i.x, i.y, i.width, i.height);
    g.save();
    g.scale(i.scale, i.scale);
    g.font = "normal 10px sourceCodePro";
    g.fillStyle = "#ccc";
    const I = l.get() || [];
    let n = 1;
    if (l.get() === null)
      E.setUiAttrib({ extendTitle: "null" });
    else if (l.get() === void 0)
      E.setUiAttrib({ extendTitle: "undefined" });
    else
      E.setUiAttrib({ extendTitle: "length: " + I.length });
    if (l.links.length > 0 && l.links[0].getOtherPort(l))
      n = l.links[0].getOtherPort(l).uiAttribs.stride || 1;
    let A2 = Math.floor(i.height / i.scale / 10 - 1);
    let o = 4;
    let C = u.get() * n;
    let t = [];
    for (let A3 = 0; A3 < n; A3++)
      t[A3] = 0;
    for (let e2 = C; e2 < C + A2 * n; e2 += n) {
      for (let A3 = 0; A3 < n; A3++) {
        const s = I[e2 + A3];
        t[A3] = Math.max(t[A3], c(s).length);
      }
    }
    let a = [];
    let e = 30;
    for (let A3 = 0; A3 < n; A3++) {
      a[A3] = e;
      e += (t[A3] + 1) * 7;
    }
    for (let t2 = C; t2 < C + A2 * n; t2 += n) {
      if (t2 < 0)
        continue;
      if (t2 + n > I.length)
        continue;
      g.fillStyle = "#666";
      const B = t2 / n;
      if (B >= 0)
        g.fillText(B, i.x / i.scale + o, i.y / i.scale + 10 + (t2 - C) / n * 10 + o);
      for (let e2 = 0; e2 < n; e2++) {
        const s = I[t2 + e2];
        let A3 = c(s);
        g.fillStyle = "#ccc";
        if (typeof s == "string") {
        } else if (CABLES.UTILS.isNumeric(s))
          A3 = String(Math.round(s * 1e4) / 1e4);
        else if (Array.isArray(s)) {
        } else if (typeof s == "object") {
        } else if (s != s || s === void 0) {
          g.fillStyle = "#f00";
        }
        g.fillText(A3, i.x / i.scale + a[e2], i.y / i.scale + 10 + (t2 - C) / n * 10 + o);
      }
    }
    if (l.get() === null)
      g.fillText("null", i.x / i.scale + 10, i.y / i.scale + 10 + o);
    else if (l.get() === void 0)
      g.fillText("undefined", i.x / i.scale + 10, i.y / i.scale + 10 + o);
    const r = 30;
    if (i.scale <= 0)
      return;
    if (C > 0) {
      const Q = g.createLinearGradient(0, i.y / i.scale + 5, 0, i.y / i.scale + r);
      Q.addColorStop(0, "#222");
      Q.addColorStop(1, "rgba(34,34,34,0.0)");
      g.fillStyle = Q;
      g.fillRect(i.x / i.scale, i.y / i.scale, 2e5, r);
    }
    if (C + A2 * n < I.length) {
      const Q = g.createLinearGradient(0, i.y / i.scale + i.height / i.scale - r + 5, 0, i.y / i.scale + i.height / i.scale - r + r);
      Q.addColorStop(1, "#222");
      Q.addColorStop(0, "rgba(34,34,34,0.0)");
      g.fillStyle = Q;
      g.fillRect(i.x / i.scale, i.y / i.scale + i.height / i.scale - r, 2e5, r);
    }
    g.restore();
  };
};
Ops.Ui.VizArrayTable.prototype = new CABLES.Op();
CABLES.OPS["af2eeaaf-ff86-4bfb-9a27-42f05160a5d8"] = { f: Ops.Ui.VizArrayTable, objName: "Ops.Ui.VizArrayTable" };
Ops.String.GateString = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("String In", "hello"), g = A.inValueBool("Pass Through", false), i = A.inSwitch("When False", ["keep last string", "custom"], "keep last string"), I = A.inString("Custom Value"), n = A.outString("String Out", "");
  t.onChange = g.onChange = C;
  i.onChange = o;
  function o() {
    I.setUiAttribs({ greyout: i.get() != "custom" });
    C();
  }
  function C() {
    if (g.get()) {
      n.set("");
      n.set(t.get());
    } else {
      if (i.get() == "custom")
        n.set(I.get());
    }
  }
};
Ops.String.GateString.prototype = new CABLES.Op();
CABLES.OPS["0ce14933-2d91-4381-9d82-2304aae22c0e"] = { f: Ops.String.GateString, objName: "Ops.String.GateString" };
Ops.Data.Compose.Object.CompObjectSetString = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("Update"), g = e.inString("Key", ""), i = e.inString("String", ""), I = e.outTrigger("Next");
  e.setUiAttrib({ extendTitlePort: g.name });
  g.setUiAttribs({ stringTrim: true, minLength: 1 });
  t.onTriggered = () => {
    if (e.patch.frameStore.compObject && e.patch.frameStore.compObject.length > 0) {
      let A2 = e.patch.frameStore.compObject[e.patch.frameStore.compObject.length - 1];
      A2[g.get()] = i.get();
    }
    I.trigger();
  };
};
Ops.Data.Compose.Object.CompObjectSetString.prototype = new CABLES.Op();
CABLES.OPS["b5a24d4c-4b1d-44c7-b6ef-a38cc71b9ad1"] = { f: Ops.Data.Compose.Object.CompObjectSetString, objName: "Ops.Data.Compose.Object.CompObjectSetString" };
Ops.Json.ObjectGetString = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("data"), g = A.inString("Key"), i = A.outString("Result");
  i.ignoreValueSerialize = true;
  t.ignoreValueSerialize = true;
  A.setUiAttrib({ extendTitlePort: g.name });
  g.setUiAttribs({ stringTrim: true });
  g.onChange = t.onChange = I;
  function I() {
    if (t.get()) {
      const A2 = t.get()[g.get()];
      const e2 = A2 === void 0 || A2 === null;
      if (e2) {
        i.setRef(null);
      } else {
        i.set(String(A2));
      }
    } else {
      i.setRef(null);
    }
  }
};
Ops.Json.ObjectGetString.prototype = new CABLES.Op();
CABLES.OPS["7d86cd28-f7d8-44a1-a4da-466c4782aaec"] = { f: Ops.Json.ObjectGetString, objName: "Ops.Json.ObjectGetString" };
Ops.Json.TriggerObjectSetNumber = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTriggerButton("Trigger"), g = A.inObject("Object"), i = A.inString("Key"), I = A.inFloat("Number"), n = A.outTrigger("Next"), o = A.outObject("Result");
  i.setUiAttribs({ stringTrim: true, minLength: 1 });
  t.onTriggered = () => {
    const A2 = g.get();
    if (A2 && i.get()) {
      A2[i.get()] = I.get();
    }
    o.setRef(A2);
    n.trigger();
  };
};
Ops.Json.TriggerObjectSetNumber.prototype = new CABLES.Op();
CABLES.OPS["ecc96e87-c51f-49bf-ad90-25f283c73e87"] = { f: Ops.Json.TriggerObjectSetNumber, objName: "Ops.Json.TriggerObjectSetNumber" };
Ops.Trigger.TriggerOnce = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTriggerButton("Exec"), g = A.inTriggerButton("Reset"), i = A.outTrigger("Next"), I = A.outBoolNum("Was Triggered");
  let n = false;
  A.toWorkPortsNeedToBeLinked(t);
  g.onTriggered = function() {
    n = false;
    I.set(n);
  };
  t.onTriggered = function() {
    if (n)
      return;
    n = true;
    i.trigger();
    I.set(n);
  };
};
Ops.Trigger.TriggerOnce.prototype = new CABLES.Op();
CABLES.OPS["cf3544e4-e392-432b-89fd-fcfb5c974388"] = { f: Ops.Trigger.TriggerOnce, objName: "Ops.Trigger.TriggerOnce" };
Ops.Json.GateObject = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("Object In"), g = A.inValueBool("Pass Through", true), i = A.inSwitch("When False", ["keep last object", "null"], "keep last object"), I = A.inValueBool("Only Valid Objects", false), n = A.outObject("Object Out");
  t.onChange = i.onChange = g.onChange = o;
  t.changeAlways = true;
  function o() {
    if (!t.get() && I.get())
      return;
    if (g.get())
      n.setRef(t.get());
    else {
      if (i.get() == "null")
        n.setRef(null);
    }
  }
};
Ops.Json.GateObject.prototype = new CABLES.Op();
CABLES.OPS["95e04331-49d6-42da-81d8-5a75261ab22f"] = { f: Ops.Json.GateObject, objName: "Ops.Json.GateObject" };
Ops.Boolean.MonoFlop = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTriggerButton("Trigger"), g = A.inValue("Duration", 1), i = A.inValue("Value True", 1), I = A.inValue("Value False", 0), n = A.inTriggerButton("Reset"), o = A.outTrigger("Activated"), C = A.outTrigger("Ended"), a = A.outBoolNum("Result", false);
  let r = -1;
  n.onTriggered = function() {
    a.set(I.get());
    clearTimeout(r);
  };
  t.onTriggered = function() {
    if (a.get() == I.get())
      o.trigger();
    a.set(i.get());
    clearTimeout(r);
    r = setTimeout(function() {
      a.set(I.get());
      C.trigger();
    }, g.get() * 1e3);
  };
};
Ops.Boolean.MonoFlop.prototype = new CABLES.Op();
CABLES.OPS["3a4b0a78-4172-41c7-8248-95cb0856ecc8"] = { f: Ops.Boolean.MonoFlop, objName: "Ops.Boolean.MonoFlop" };
Ops.Devices.Keyboard.KeyPressLearn = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = {};
  const g = t.inValueInt("key code");
  const e = t.inValueBool("canvas only", true);
  const i = t.inValueSelect("Mod Key", ["none", "alt"], "none");
  const I = t.inValueBool("Enabled", true);
  const n = t.inValueBool("Prevent Default");
  const o = t.inTriggerButton("learn");
  const C = t.outTrigger("on press");
  const a = t.outTrigger("on release");
  const r = t.outBoolNum("Pressed", false);
  const s = t.outString("Key");
  const B = t.patch.cgl;
  let Q = false;
  i.onChange = g.onChange = d;
  function E(A2) {
    if (Q) {
      g.set(A2.keyCode);
      if (CABLES.UI) {
        t.refreshParams();
      }
      Q = false;
      c();
      u();
      if (CABLES.UI)
        gui.emitEvent("portValueEdited", t, g, g.get());
    } else {
      if (A2.keyCode == g.get()) {
        if (i.get() == "alt") {
          if (A2.altKey === true) {
            C.trigger();
            r.set(true);
            if (n.get())
              A2.preventDefault();
          }
        } else {
          C.trigger();
          r.set(true);
          if (n.get())
            A2.preventDefault();
        }
      }
    }
  }
  function l(e2) {
    if (e2.keyCode == g.get()) {
      let A2 = true;
      if (i.get() == "alt" && e2.altKey != true)
        A2 = false;
      if (A2) {
        a.trigger();
        r.set(false);
      }
    }
  }
  t.onDelete = function() {
    B.canvas.removeEventListener("keyup", l, false);
    B.canvas.removeEventListener("keydown", E, false);
    document.removeEventListener("keyup", l, false);
    document.removeEventListener("keydown", E, false);
  };
  o.onTriggered = function() {
    Q = true;
    p();
    setTimeout(function() {
      Q = false;
      c();
      u();
    }, 3e3);
  };
  function u() {
    if (e.get())
      h();
    else
      p();
  }
  function c() {
    document.removeEventListener("keydown", E, false);
    document.removeEventListener("keyup", l, false);
    B.canvas.removeEventListener("keydown", E, false);
    B.canvas.removeEventListener("keyup", l, false);
    r.set(false);
  }
  function h() {
    if (!CABLES.UTILS.isNumeric(B.canvas.getAttribute("tabindex")))
      B.canvas.setAttribute("tabindex", 1);
    B.canvas.addEventListener("keydown", E, false);
    B.canvas.addEventListener("keyup", l, false);
  }
  function p() {
    document.addEventListener("keydown", E, false);
    document.addEventListener("keyup", l, false);
  }
  I.onChange = function() {
    if (!I.get()) {
      c();
    } else {
      u();
    }
  };
  e.onChange = function() {
    c();
    u();
  };
  function d() {
    let A2 = CABLES.keyCodeToName(g.get());
    const e2 = i.get();
    if (e2 && e2 !== "none") {
      A2 = e2.charAt(0).toUpperCase() + e2.slice(1) + "-" + A2;
    }
    t.setUiAttribs({ extendTitle: A2 });
    s.set(A2);
  }
  h();
};
Ops.Devices.Keyboard.KeyPressLearn.prototype = new CABLES.Op();
CABLES.OPS["f069c0db-4051-4eae-989e-6ef7953787fd"] = { f: Ops.Devices.Keyboard.KeyPressLearn, objName: "Ops.Devices.Keyboard.KeyPressLearn" };
Ops.Number.SwitchNumberOnTrigger = function() {
  CABLES.Op.apply(this, arguments);
  const g = this;
  const A = g.attachments = {};
  const e = g.outNumber("Value"), t = g.outNumber("Last Value"), i = g.outTrigger("Triggered");
  let I = [];
  let n = [];
  let o = [];
  function C() {
    t.set(e.get());
    e.set(n[this.slot].get());
    i.trigger();
  }
  let a = 8;
  for (let t2 = 0; t2 < a; t2++) {
    let A2 = g.addInPort(new CABLES.Port(g, "Trigger " + t2, CABLES.OP_PORT_TYPE_FUNCTION));
    A2.slot = t2;
    A2.onTriggered = C.bind(A2);
    let e2 = g.addInPort(new CABLES.Port(g, "Value " + t2, CABLES.OP_PORT_TYPE_VALUE));
    n.push(e2);
  }
  let r = g.inValueString("Default Value");
  e.set(r.get());
  t.set(r.get());
  r.onChange = function() {
    t.set(e.get());
    e.set(r.get());
  };
};
Ops.Number.SwitchNumberOnTrigger.prototype = new CABLES.Op();
CABLES.OPS["338032c5-bf47-454b-8ae1-cd91f17e5c5b"] = { f: Ops.Number.SwitchNumberOnTrigger, objName: "Ops.Number.SwitchNumberOnTrigger" };
Ops.Gl.ImageCompose.ImageCompose_v4 = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = { imgcomp_frag: "IN vec2 texCoord;\nUNI vec4 bgColor;\nUNI sampler2D tex;\n#ifdef USE_UVTEX\nUNI sampler2D UVTex;\n#endif\n\nvoid main()\n{\n\n    #ifndef USE_TEX\n        outColor=bgColor;\n    #endif\n    #ifdef USE_TEX\n        #ifndef USE_UVTEX\n        outColor=texture(tex,texCoord);\n        #else\n        outColor=texture(tex,texture(UVTex,texCoord).xy);\n        #endif\n    #endif\n\n\n\n}\n" };
  const e = t.patch.cgl, g = t.inTrigger("Render"), i = t.inTexture("Base Texture"), I = t.inTexture("UV Texture"), n = t.inSwitch("Size", ["Auto", "Canvas", "Manual"], "Auto"), o = t.inValueInt("Width", 640), C = t.inValueInt("Height", 480), a = t.inSwitch("Filter", ["nearest", "linear", "mipmap"], "linear"), r = t.inValueSelect("Wrap", ["clamp to edge", "repeat", "mirrored repeat"], "repeat"), s = t.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"), B = t.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB), Q = t.inValueSlider("R", 0), E = t.inValueSlider("G", 0), l = t.inValueSlider("B", 0), u = t.inValueSlider("A", 0), c = t.outTrigger("Next"), h = t.outTexture("texture_out", CGL.Texture.getEmptyTexture(e)), p = t.outNumber("Aspect Ratio"), d = t.outNumber("Texture Width"), L = t.outNumber("Texture Height");
  t.setPortGroup("Texture Size", [n, o, C]);
  t.setPortGroup("Texture Parameters", [r, s, a, B]);
  Q.setUiAttribs({ colorPick: true });
  t.setPortGroup("Color", [Q, E, l, u]);
  t.toWorkPortsNeedToBeLinked(g);
  const v = [0, 0, 0, 0];
  let m = null;
  let f = null;
  let D = true;
  let O = false;
  let y = null;
  let k = null;
  let x = null;
  let T = null;
  r.onChange = a.onChange = s.onChange = B.onChange = J;
  i.onLinkChanged = n.onChange = I.onChange = F;
  g.onTriggered = t.preRender = U;
  F();
  function b() {
    if (m)
      m.delete();
    if (f)
      f.delete();
    f = null;
    m = new CGL.TextureEffect(e, { isFloatingPointTexture: CGL.Texture.isPixelFormatFloat(B.get()), name: t.name });
    const A2 = Math.min(e.maxAnisotropic, parseFloat(s.get()));
    f = new CGL.Texture(e, { anisotropic: A2, name: "image_compose_v2_" + t.id, pixelFormat: B.get(), filter: N(), wrap: S(), width: w(), height: R() });
    m.setSourceTexture(f);
    d.set(w());
    L.set(R());
    p.set(w() / R());
    h.set(CGL.Texture.getEmptyTexture(e));
    D = false;
    F();
  }
  function N() {
    if (a.get() == "nearest")
      return CGL.Texture.FILTER_NEAREST;
    else if (a.get() == "linear")
      return CGL.Texture.FILTER_LINEAR;
    else if (a.get() == "mipmap")
      return CGL.Texture.FILTER_MIPMAP;
  }
  function S() {
    if (r.get() == "repeat")
      return CGL.Texture.WRAP_REPEAT;
    else if (r.get() == "mirrored repeat")
      return CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (r.get() == "clamp to edge")
      return CGL.Texture.WRAP_CLAMP_TO_EDGE;
  }
  function w() {
    let A2 = 0;
    if (i.get() && n.get() == "Auto")
      A2 = i.get().width;
    else if (n.get() == "Auto" || n.get() == "Canvas")
      A2 = e.canvasWidth;
    else if (n.get() == "ViewPort")
      A2 = e.getViewPort()[2];
    else
      A2 = Math.ceil(o.get());
    return t.patch.cgl.checkTextureSize(A2);
  }
  function R() {
    let A2 = 0;
    if (i.get() && n.get() == "Auto")
      A2 = i.get().height;
    else if (n.get() == "Auto" || n.get() == "Canvas")
      A2 = e.canvasHeight;
    else if (n.get() == "ViewPort")
      A2 = e.getViewPort()[3];
    else
      A2 = Math.ceil(C.get());
    return t.patch.cgl.checkTextureSize(A2);
  }
  function J() {
    D = true;
  }
  function Y() {
    if ((w() != f.width || R() != f.height || f.pixelFormat != B.get() || f.filter != N() || f.wrap != S()) && (w() !== 0 && R() !== 0)) {
      b();
      m.setSourceTexture(f);
      h.set(CGL.Texture.getEmptyTexture(e));
      h.set(f);
      G();
      M();
    }
  }
  function G() {
    let A2 = null;
    if (n.get() == "Manual") {
      A2 = null;
    } else if (n.get() == "Auto") {
      if (i.get())
        A2 = "Input Texture";
      else
        A2 = "Canvas Size";
      A2 += ": " + w() + " x " + R();
    }
    let e2 = false;
    e2 = n.uiAttribs.info != A2;
    n.setUiAttribs({ info: A2 });
    if (e2)
      t.refreshParams();
  }
  function _() {
    if (y)
      y.toggleDefine("USE_TEX", i.isLinked());
    if (y)
      y.toggleDefine("USE_UVTEX", I.isLinked());
  }
  function F() {
    s.setUiAttribs({ greyout: N() != CGL.Texture.FILTER_MIPMAP });
    Q.setUiAttribs({ greyout: i.isLinked() });
    l.setUiAttribs({ greyout: i.isLinked() });
    E.setUiAttribs({ greyout: i.isLinked() });
    u.setUiAttribs({ greyout: i.isLinked() });
    o.setUiAttribs({ greyout: n.get() != "Manual" });
    C.setUiAttribs({ greyout: n.get() != "Manual" });
    if (f)
      if (CGL.Texture.isPixelFormatFloat(B.get()) && N() == CGL.Texture.FILTER_MIPMAP)
        t.setUiError("fpmipmap", "Don't use mipmap and 32bit at the same time, many systems do not support this.");
      else
        t.setUiError("fpmipmap", null);
    G();
    _();
    M();
  }
  function M() {
    if (f)
      if (i.isLinked() && i.get() && f.isFloatingPoint() != i.get().isFloatingPoint())
        t.setUiError("textypediff", "Warning: Mixing floating point and non floating point texture can result in data/precision loss", 1);
      else
        t.setUiError("textypediff", null);
  }
  t.preRender = () => {
    U();
  };
  function K() {
    if (!y) {
      y = new CGL.Shader(e, "copytextureshader");
      y.setSource(y.getDefaultVertexShader(), A.imgcomp_frag);
      k = new CGL.Uniform(y, "t", "tex", 0);
      x = new CGL.Uniform(y, "t", "UVTex", 1);
      T = new CGL.Uniform(y, "4f", "bgColor", Q, E, l, u);
      _();
    }
    e.pushShader(y);
    e.currentTextureEffect.bind();
    if (i.get())
      e.setTexture(0, i.get().tex);
    if (I.get())
      e.setTexture(1, I.get().tex);
    e.currentTextureEffect.finish();
    e.popShader();
  }
  function U() {
    if (!m || D)
      b();
    e.pushBlend(false);
    Y();
    const A2 = e.currentTextureEffect;
    e.currentTextureEffect = m;
    e.currentTextureEffect.imgCompVer = 3;
    e.currentTextureEffect.width = o.get();
    e.currentTextureEffect.height = C.get();
    m.setSourceTexture(f);
    m.startEffect(i.get() || CGL.Texture.getEmptyTexture(e, O), true);
    K();
    c.trigger();
    e.pushViewPort(0, 0, o.get(), C.get());
    m.endEffect();
    h.setRef(m.getCurrentSourceTexture());
    e.popViewPort();
    e.popBlend();
    e.currentTextureEffect = A2;
  }
};
Ops.Gl.ImageCompose.ImageCompose_v4.prototype = new CABLES.Op();
CABLES.OPS["17212e2b-d692-464c-8f8d-2d511dd3410a"] = { f: Ops.Gl.ImageCompose.ImageCompose_v4, objName: "Ops.Gl.ImageCompose.ImageCompose_v4" };
Ops.Gl.Matrix.ScaleXYZViewMatrix = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("render"), g = A.inValueFloat("x", 1), i = A.inValueFloat("y", 1), I = A.inValueFloat("z", 1), n = A.outTrigger("trigger");
  const o = A.patch.cgl;
  let C = vec3.create();
  let a = mat4.create();
  mat4.identity(a);
  g.onChange = i.onChange = I.onChange = s;
  s();
  t.onTriggered = r;
  function r() {
    o.pushViewMatrix();
    mat4.multiply(o.vMatrix, o.vMatrix, a);
    n.trigger();
    o.popViewMatrix();
  }
  function s() {
    vec3.set(C, g.get(), i.get(), I.get());
    mat4.identity(a);
    mat4.scale(a, a, C);
  }
};
Ops.Gl.Matrix.ScaleXYZViewMatrix.prototype = new CABLES.Op();
CABLES.OPS["8b1fa9c9-0c4d-41b6-9c4f-8f4b633a9d7f"] = { f: Ops.Gl.Matrix.ScaleXYZViewMatrix, objName: "Ops.Gl.Matrix.ScaleXYZViewMatrix" };
Ops.Gl.Meshes.HeightMap = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = {};
  const e = t.inTrigger("render"), g = t.inUrl("file"), D = t.inValueFloat("extrude", 1), y = t.inValueFloat("width", 3), b = t.inValueFloat("height", 3), N = t.inValueInt("rows", 20), S = t.inValueInt("columns", 20), w = t.inValueBool("texCoords slice"), R = t.inValueBool("flat"), i = t.outTrigger("trigger");
  let G = t.outObject("geometry");
  G.ignoreValueSerialize = true;
  t.toWorkPortsNeedToBeLinked(e);
  let _ = new CGL.Geometry(t.name);
  let F = null;
  let M = t.patch.cgl;
  let U = new Image();
  e.onTriggered = function() {
    if (!F)
      I();
    if (F)
      F.render(M.getShader());
    i.trigger();
  };
  D.onChange = b.onChange = y.onChange = N.onChange = S.onChange = R.onChange = () => {
    F = null;
  };
  g.onChange = n;
  function I() {
    _.clear();
    let e2 = [];
    let t2 = [];
    let I2 = [];
    let A2 = U.width;
    let g2 = U.height;
    let i2 = document.createElement("canvas");
    let n2 = i2.getContext("2d");
    i2.width = A2;
    i2.height = g2;
    n2.drawImage(U, 0, 0);
    let o = y.get();
    let C = b.get();
    let a = 0;
    let r = o / A2;
    let s = C / g2;
    let B = parseFloat(N.get());
    let Q = parseFloat(S.get());
    let E = Q ? A2 / Q : A2;
    let l = B ? g2 / B : g2;
    let u = D.get() * 1e-3;
    let c = B ? o / B : o;
    let h = Q ? C / Q : C;
    let p = 0;
    let d = 0;
    for (var m = 0; m <= B; m++) {
      for (var f = 0; f <= Q; f++) {
        let A3 = n2.getImageData(Math.round(f * E), Math.round(m * l), 1, 1).data[1] * u;
        e2.push(f * h);
        e2.push(m * c);
        e2.push(A3);
        if (w.get()) {
          if (A3 != d) {
            if (f % 2 == 0)
              t2.push(0.5);
            else
              t2.push(1);
            t2.push(1 - m / B);
          } else {
            t2.push(1);
            t2.push(0);
          }
          d = A3;
        } else {
          t2.push(f / Q);
          t2.push(1 - m / B);
        }
      }
    }
    for (f = 0; f < Q; f++) {
      for (m = 0; m < B; m++) {
        let A3 = f + (Q + 1) * m;
        let e3 = A3;
        let t3 = A3 + 1;
        let g3 = A3 + Q + 1;
        let i3 = A3 + 1 + Q + 1;
        I2.push(e3);
        I2.push(t3);
        I2.push(g3);
        I2.push(t3);
        I2.push(g3);
        I2.push(i3);
      }
    }
    _.vertices = e2;
    _.texCoords = t2;
    _.verticesIndices = I2;
    if (R.get())
      _.unIndex();
    _.calculateNormals({ forceZUp: true });
    if (!F)
      F = new CGL.Mesh(M, _);
    F.setGeom(_);
    G.set(null);
    G.set(_);
  }
  function n() {
    U.crossOrigin = "";
    let A2 = t.patch.getFilePath(g.get());
    let e2 = t.patch.loading.start("heightmapImage", A2, t);
    U.onabort = U.onerror = function(A3) {
      t.patch.loading.finished(e2);
      t.log("error loading heightmap image...");
    };
    U.onload = function(A3) {
      I();
      t.patch.loading.finished(e2);
    };
    U.src = A2;
  }
};
Ops.Gl.Meshes.HeightMap.prototype = new CABLES.Op();
CABLES.OPS["81264799-d92b-4b71-a3f1-ad1da8331e62"] = { f: Ops.Gl.Meshes.HeightMap, objName: "Ops.Gl.Meshes.HeightMap" };
Ops.Ui.VizTexture = function() {
  CABLES.Op.apply(this, arguments);
  const v = this;
  const t = v.attachments = { viztex_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\nUNI samplerCube cubeMap;\nUNI float width;\nUNI float height;\nUNI float type;\nUNI float time;\n\nfloat LinearizeDepth(float d,float zNear,float zFar)\n{\n    float z_n = 2.0 * d - 1.0;\n    return 2.0 * zNear / (zFar + zNear - z_n * (zFar - zNear));\n}\n\nvoid main()\n{\n    vec4 col=vec4(vec3(0.),0.0);\n\n    vec4 colTex=texture(tex,texCoord);\n\n\n\n    if(type==1.0)\n    {\n        vec4 depth=vec4(0.);\n        vec2 localST=texCoord;\n        localST.y = 1. - localST.y;\n\n        localST.t = mod(localST.t*3.,1.);\n        localST.s = mod(localST.s*4.,1.);\n\n        #ifdef WEBGL2\n            #define texCube texture\n        #endif\n        #ifdef WEBGL1\n            #define texCube textureCube\n        #endif\n\n//         //Due to the way my depth-cubeMap is rendered, objects to the -x,y,z side is projected to the positive x,y,z side\n//         //Inside where top/bottom is to be drawn?\n        if (texCoord.s*4.> 1. && texCoord.s*4.<2.)\n        {\n            //Bottom (-y) quad\n            if (texCoord.t*3. < 1.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-1.,-localST.t*2.+1.);//Due to the (arbitrary) way I choose as up in my depth-viewmatrix, i her emultiply the latter coordinate with -1\n                depth = texCube(cubeMap, dir);\n            }\n            //top (+y) quad\n            else if (texCoord.t*3. > 2.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,1.,localST.t*2.-1.);//Get lower y texture, which is projected to the +y part of my cubeMap\n                depth = texCube(cubeMap, dir);\n            }\n            else//Front (-z) quad\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-localST.t*2.+1.,1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n//         //If not, only these ranges should be drawn\n        else if (texCoord.t*3. > 1. && texCoord.t*3. < 2.)\n        {\n            if (texCoord.x*4. < 1.)//left (-x) quad\n            {\n                vec3 dir=vec3(-1.,-localST.t*2.+1.,localST.s*2.-1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else if (texCoord.x*4. < 3.)//right (+x) quad (front was done above)\n            {\n                vec3 dir=vec3(1,-localST.t*2.+1.,-localST.s*2.+1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else //back (+z) quad\n            {\n                vec3 dir=vec3(-localST.s*2.+1.,-localST.t*2.+1.,-1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n        // colTex = vec4(vec3(depth),1.);\n        colTex = vec4(depth);\n    }\n\n    if(type==2.0)\n    {\n       float near = 0.1;\n       float far = 50.;\n       float depth = LinearizeDepth(colTex.r, near, far);\n       colTex.rgb = vec3(depth);\n    }\n\n\n\n\n    #ifdef ANIM_RANGE\n\n        if(colTex.r>1.0 || colTex.r<0.0)\n            colTex.r=mod(colTex.r,1.0)*0.5+(sin(colTex.r+mod(colTex.r*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n        if(colTex.g>1.0 || colTex.g<0.0)\n            colTex.g=mod(colTex.g,1.0)*0.5+(sin(colTex.g+mod(colTex.g*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n        if(colTex.b>1.0 || colTex.b<0.0)\n            colTex.b=mod(colTex.b,1.0)*0.5+(sin(colTex.b+mod(colTex.b*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n\n    #endif\n\n\n    // #ifdef ANIM_RANGE\n    //     if(colTex.r>1.0 || colTex.r<0.0)\n    //     {\n    //         float r=mod( time+colTex.r,1.0)*0.5+0.5;\n    //         colTex.r=r;\n    //     }\n    //     if(colTex.g>1.0 || colTex.g<0.0)\n    //     {\n    //         float r=mod( time+colTex.g,1.0)*0.5+0.5;\n    //         colTex.g=r;\n    //     }\n    //     if(colTex.b>1.0 || colTex.b<0.0)\n    //     {\n    //         float r=mod( time+colTex.b,1.0)*0.5+0.5;\n    //         colTex.b=r;\n    //     }\n    // #endif\n\n    #ifdef MOD_RANGE\n        colTex.r=mod(colTex.r,1.0001);\n        colTex.g=mod(colTex.g,1.0001);\n        colTex.b=mod(colTex.b,1.0001);\n\n    #endif\n\n    #ifdef ALPHA_ONE\n        colTex.a=1.0;\n    #endif\n    #ifdef ALPHA_INV\n        colTex.a=1.0-colTex.a;\n    #endif\n\n    outColor = mix(col,colTex,colTex.a);\n}\n\n", viztex_vert: "IN vec3 vPosition;\nIN vec2 attrTexCoord;\nOUT vec2 texCoord;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nvoid main()\n{\n    texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mvMatrix=viewMatrix * modelMatrix;\n    gl_Position = projMatrix * mvMatrix * pos;\n}" };
  const O = v.inTexture("Texture In"), k = v.inBool("Show Info", false), A = v.inSwitch("Visualize outside 0-1", ["Off", "Anim", "Modulo"], "Anim"), e = v.inSwitch("Alpha", ["A", "1", "1-A"], "A"), x = v.inBool("Show Color", false), T = v.inFloatSlider("X", 0.5), J = v.inFloatSlider("Y", 0.5), g = v.outTexture("Texture Out"), Y = v.outString("Info");
  v.setUiAttrib({ height: 150, resizable: true });
  const K = new CABLES.Timer();
  let i = null;
  let j = null;
  let V = null;
  let H = "";
  e.onChange = A.onChange = n;
  x.onChange = I;
  I();
  if (CABLES.UI) {
    K.play();
    v.checkMainloopExists();
  }
  function I() {
    T.setUiAttribs({ greyout: !x.get() });
    J.setUiAttribs({ greyout: !x.get() });
  }
  O.onChange = () => {
    const A2 = O.get();
    g.setRef(A2);
    let e2 = "";
    if (O.get() && O.isLinked())
      e2 = O.links[0].getOtherPort(O).name;
    v.setUiAttrib({ extendTitle: e2 });
  };
  function n() {
    if (!i)
      return;
    i.toggleDefine("MOD_RANGE", A.get() == "Modulo");
    i.toggleDefine("ANIM_RANGE", A.get() == "Anim");
    i.toggleDefine("ALPHA_INV", e.get() == "1-A");
    i.toggleDefine("ALPHA_ONE", e.get() == "1");
    v.checkMainloopExists();
  }
  v.renderVizLayerGl = (r, s) => {
    if (!O.isLinked())
      return;
    if (!s.useGl)
      return;
    const B = O;
    const Q = 5;
    const E = Q + 1;
    const A2 = CABLES.UI.uiProfiler.start("previewlayer texture");
    const l = B.op.patch.cgl;
    if (!this._emptyCubemap)
      this._emptyCubemap = CGL.Texture.getEmptyCubemapTexture(l);
    B.op.patch.cgl.profileData.profileTexPreviews++;
    const u = B.get() || CGL.Texture.getEmptyTexture(l);
    if (!this._mesh) {
      const e2 = new CGL.Geometry("vizTexture rect");
      e2.vertices = [1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0];
      e2.texCoords = [1, 1, 0, 1, 1, 0, 0, 0];
      e2.verticesIndices = [0, 1, 2, 3, 1, 2];
      this._mesh = new CGL.Mesh(l, e2);
    }
    if (!this._shader) {
      this._shader = new CGL.Shader(l, "glpreviewtex");
      this._shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
      this._shader.setSource(t.viztex_vert, t.viztex_frag);
      this._shaderTexUniform = new CGL.Uniform(this._shader, "t", "tex", Q);
      this._shaderTexCubemapUniform = new CGL.Uniform(this._shader, "tc", "cubeMap", E);
      i = this._shader;
      n();
      this._shaderTexUniformW = new CGL.Uniform(this._shader, "f", "width", u.width);
      this._shaderTexUniformH = new CGL.Uniform(this._shader, "f", "height", u.height);
      this._shaderTypeUniform = new CGL.Uniform(this._shader, "f", "type", 0);
      this._shaderTimeUniform = new CGL.Uniform(this._shader, "f", "time", 0);
    }
    l.pushPMatrix();
    const c = [u.width, u.height];
    const h = B.op.patch.cgl.canvasWidth > c[0] && B.op.patch.cgl.canvasHeight > c[1];
    if (h) {
      mat4.ortho(l.pMatrix, 0, B.op.patch.cgl.canvasWidth, B.op.patch.cgl.canvasHeight, 0, 1e-3, 11);
    } else
      mat4.ortho(l.pMatrix, -1, 1, 1, -1, 1e-3, 11);
    const p = l.getTexture(Q);
    const d = l.getTexture(E);
    let m = 0;
    if (u) {
      if (u.cubemap)
        m = 1;
      if (u.textureType == CGL.Texture.TYPE_DEPTH)
        m = 2;
      if (m == 0 || m == 2) {
        l.setTexture(Q, u.tex);
        l.setTexture(E, this._emptyCubemap.cubemap, l.gl.TEXTURE_CUBE_MAP);
      } else if (m == 1) {
        l.setTexture(E, u.cubemap, l.gl.TEXTURE_CUBE_MAP);
      }
      K.update();
      this._shaderTimeUniform.setValue(K.get());
      this._shaderTypeUniform.setValue(m);
      let e2 = [B.op.patch.cgl.canvasWidth, B.op.patch.cgl.canvasHeight];
      l.gl.clearColor(0, 0, 0, 0);
      l.gl.clear(l.gl.COLOR_BUFFER_BIT | l.gl.DEPTH_BUFFER_BIT);
      l.pushModelMatrix();
      if (h) {
        e2 = c;
        mat4.translate(l.mMatrix, l.mMatrix, [c[0] / 2, c[1] / 2, 0]);
        mat4.scale(l.mMatrix, l.mMatrix, [c[0] / 2, c[1] / 2, 0]);
      }
      this._mesh.render(this._shader);
      l.popModelMatrix();
      if (m == 0)
        l.setTexture(Q, p);
      if (m == 1)
        l.setTexture(E, d);
      l.popPMatrix();
      l.resetViewPort();
      const f = [s.width, s.height];
      const D = false;
      if (u.width > u.height)
        f[1] = s.width * c[1] / c[0];
      else {
        f[1] = s.width * (c[1] / c[0]);
        if (f[1] > s.height) {
          const S = s.height / f[1];
          f[0] *= S;
          f[1] *= S;
        }
      }
      const y = f[0] > c[0] && f[1] > c[1];
      r.imageSmoothingEnabled = true;
      r.fillStyle = "#ffffff";
      r.fillRect(s.x, s.y - 10, 10, 10);
      r.fillStyle = "#000000";
      r.fillRect(s.x, s.y - 10, 5, 5);
      r.fillRect(s.x + 5, s.y - 10 + 5, 5, 5);
      let A3 = s.height;
      let t2 = 10 * s.width / A3;
      let g2 = A3 / 10;
      let i2 = s.width / t2;
      for (let e3 = 0; e3 < t2; e3++)
        for (let A4 = 0; A4 < 10; A4++) {
          if ((e3 + A4) % 2 == 0)
            r.fillStyle = "#333333";
          else
            r.fillStyle = "#393939";
          r.fillRect(s.x + i2 * e3, s.y + g2 * A4, i2, g2);
        }
      r.fillStyle = "#222";
      const b = (s.width - f[0]) / 2;
      const N = (A3 - f[1]) / 2;
      let I2 = s.x + (s.width - f[0]) / 2;
      let n2 = s.y + (A3 - f[1]) / 2;
      let o = f[0];
      let C = f[1];
      if (A3 - f[1] < 0) {
        I2 = s.x + (s.width - f[0] * A3 / f[1]) / 2;
        n2 = s.y;
        o = f[0] * A3 / f[1];
        C = A3;
      }
      r.fillRect(s.x, s.y, I2 - s.x, A3);
      r.fillRect(s.x + o + I2 - s.x, s.y, o, A3);
      r.fillRect(s.x, s.y, s.width, N);
      r.fillRect(s.x, s.y + f[1] + N, s.width, N);
      if (l.canvas && l.canvasWidth > 0 && l.canvasHeight > 0 && l.canvas.width > 0 && l.canvas.height > 0) {
        try {
          const w = o / e2[0] > 3 || C / e2[1] > 3;
          const R = o / e2[0] > 10 || C / e2[1] > 10;
          if (c[1] == 1) {
            r.imageSmoothingEnabled = false;
            r.drawImage(l.canvas, 0, 0, e2[0], e2[1], s.x, s.y, s.width, A3);
            r.imageSmoothingEnabled = true;
          } else if (c[0] == 1) {
            r.imageSmoothingEnabled = false;
            r.drawImage(l.canvas, 0, 0, e2[0], e2[1], s.x, s.y, s.width, A3);
            r.imageSmoothingEnabled = true;
          } else if (f[0] != 0 && f[1] != 0 && s.width != 0 && A3 != 0 && o != 0 && C != 0) {
            r.imageSmoothingEnabled = !w;
            r.drawImage(l.canvas, 0, 0, e2[0], e2[1], I2, n2, o, C);
          }
          if (R) {
            const G = o / e2[0];
            const _ = C / e2[1];
            r.imageSmoothingEnabled = true;
            r.lineWidth = 1;
            r.globalAlpha = 0.5;
            r.beginPath();
            for (let A4 = 0; A4 <= e2[0]; A4++) {
              r.moveTo(I2 + A4 * G, n2);
              r.lineTo(I2 + A4 * G, n2 + C);
            }
            for (let A4 = 0; A4 <= e2[1]; A4++) {
              r.moveTo(I2, n2 + A4 * _);
              r.lineTo(I2 + o, n2 + A4 * _);
            }
            r.strokeStyle = "#555";
            r.stroke();
            r.globalAlpha = 1;
          }
        } catch (A4) {
          console.error("canvas drawimage exception...", A4);
        }
      }
      let a = "";
      if (k.get()) {
        if (B.get() && B.get().getInfoOneLine)
          a += B.get().getInfoOneLine() + "\n";
      }
      if (x.get()) {
        a += H + "\n";
        const F = I2 + o * T.get();
        const M = n2 + C * J.get();
        r.fillStyle = "#000";
        r.fillRect(F - 1, M - 10, 3, 20);
        r.fillRect(F, M - 1, 20, 3);
        r.fillStyle = "#fff";
        r.fillRect(F - 1, M - 10, 1, 20);
        r.fillRect(F - 10, M - 1, 20, 1);
      }
      v.setUiAttrib({ comment: a });
      Y.set(a);
      if (x.get()) {
        const U = l.gl;
        const L = O.get();
        if (!L) {
          H = "";
          return;
        }
        if (!j)
          j = U.createFramebuffer();
        if (!V)
          V = new CGL.PixelReader();
        U.bindFramebuffer(U.FRAMEBUFFER, j);
        U.framebufferTexture2D(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_2D, L.tex, 0);
        U.bindFramebuffer(U.FRAMEBUFFER, null);
        V.read(l, j, L.pixelFormat, T.get() * L.width, L.height - J.get() * L.height, 1, 1, (A4) => {
          if (!CGL.Texture.isPixelFormatFloat(L.pixelFormat)) {
            H = "Pixel Float: " + Math.floor(A4[0] / 255 * 100) / 100;
            if (!isNaN(A4[1]))
              H += ", " + Math.floor(A4[1] / 255 * 100) / 100;
            if (!isNaN(A4[2]))
              H += ", " + Math.floor(A4[2] / 255 * 100) / 100;
            if (!isNaN(A4[3]))
              H += ", " + Math.floor(A4[3] / 255 * 100) / 100;
            H += "\n";
            if (L.pixelFormat.indexOf("ubyte") > 0) {
              H += "Pixel UByte: ";
              H += Math.round(A4[0]);
              if (!isNaN(A4[1]))
                H += ", " + Math.round(A4[1]);
              if (!isNaN(A4[2]))
                H += ", " + Math.round(A4[2]);
              if (!isNaN(A4[3]))
                H += ", " + Math.round(A4[3]);
              H += "\n";
            }
          } else {
            H = "Pixel Float: " + Math.round(A4[0] * 100) / 100 + ", " + Math.round(A4[1] * 100) / 100 + ", " + Math.round(A4[2] * 100) / 100 + ", " + Math.round(A4[3] * 100) / 100;
            H += "\n";
          }
        });
      }
    }
    l.gl.clearColor(0, 0, 0, 0);
    l.gl.clear(l.gl.COLOR_BUFFER_BIT | l.gl.DEPTH_BUFFER_BIT);
    A2.finish();
  };
};
Ops.Ui.VizTexture.prototype = new CABLES.Op();
CABLES.OPS["4ea2d7b0-ca74-45db-962b-4d1965ac20c0"] = { f: Ops.Ui.VizTexture, objName: "Ops.Ui.VizTexture" };
Ops.Json.ObjectFunnel = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("Object1"), g = A.inObject("Object2"), i = A.inObject("Object3"), I = A.inObject("Object4"), n = A.inObject("Object5");
  let o = A.outObject("Out Object");
  t.onChange = function() {
    o.setRef(t.get());
  };
  g.onChange = function() {
    o.setRef(g.get());
  };
  i.onChange = function() {
    o.setRef(i.get());
  };
  I.onChange = function() {
    o.setRef(I.get());
  };
  n.onChange = function() {
    o.setRef(n.get());
  };
};
Ops.Json.ObjectFunnel.prototype = new CABLES.Op();
CABLES.OPS["ff67d867-098e-4eb1-8b37-00ec0863ce5e"] = { f: Ops.Json.ObjectFunnel, objName: "Ops.Json.ObjectFunnel" };
Ops.Vars.VarGetTexture_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.outTexture("Value");
  A.varName = A.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(A, "object", A.varName, t);
};
Ops.Vars.VarGetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["5f8ce5fc-9787-45c9-9a83-0eebd2c6de15"] = { f: Ops.Vars.VarGetTexture_v2, objName: "Ops.Vars.VarGetTexture_v2" };
Ops.Trigger.NthTrigger_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  let t = 5;
  let g = A.inTriggerButton("Execute");
  let i = A.inValue("Nth", t);
  let I = A.outTrigger("Next");
  let n = 0;
  let o = t;
  g.onTriggered = C;
  i.onChange = a;
  function C() {
    n++;
    if (n % o === 0) {
      n = 0;
      I.trigger();
    }
  }
  function a() {
    o = i.get();
    n = 0;
  }
};
Ops.Trigger.NthTrigger_v2.prototype = new CABLES.Op();
CABLES.OPS["ea43c184-5842-4aa1-b298-5db4515cbed0"] = { f: Ops.Trigger.NthTrigger_v2, objName: "Ops.Trigger.NthTrigger_v2" };
Ops.String.StringLength_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("String"), g = A.outNumber("Result");
  t.onChange = function() {
    if (!t.get())
      g.set(0);
    else
      g.set(String(t.get()).length);
  };
};
Ops.String.StringLength_v2.prototype = new CABLES.Op();
CABLES.OPS["aa47bb8b-d5d7-4175-b217-ab0157d3365d"] = { f: Ops.String.StringLength_v2, objName: "Ops.String.StringLength_v2" };
Ops.Number.TriggerOnChangeNumber = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inFloat("Value"), g = A.outTrigger("Next"), i = A.outNumber("Number");
  t.onChange = function() {
    i.set(t.get());
    g.trigger();
  };
};
Ops.Number.TriggerOnChangeNumber.prototype = new CABLES.Op();
CABLES.OPS["f5c8c433-ce13-49c4-9a33-74e98f110ed0"] = { f: Ops.Number.TriggerOnChangeNumber, objName: "Ops.Number.TriggerOnChangeNumber" };
Ops.Math.Min_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("Value 1", 1), g = A.inValue("Value 2", 2), i = A.outNumber("result");
  t.onChange = g.onChange = I;
  I();
  function I() {
    let A2 = Math.min(t.get(), g.get());
    i.set(A2);
  }
};
Ops.Math.Min_v3.prototype = new CABLES.Op();
CABLES.OPS["24a9062d-380c-4690-8fe7-6703787fa94c"] = { f: Ops.Math.Min_v3, objName: "Ops.Math.Min_v3" };
Ops.Gl.Matrix.TransformMul = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("render");
  const g = A.inValueFloat("mul");
  const i = A.outTrigger("trigger");
  const I = A.patch.cgl;
  t.onTriggered = function() {
    var A2 = [0, 0, 0];
    vec3.transformMat4(A2, [0, 0, 0], I.mMatrix);
    I.pushModelMatrix();
    vec3.mul(A2, A2, [g.get(), g.get(), g.get()]);
    mat4.translate(I.mMatrix, I.mMatrix, A2);
    i.trigger();
    I.popModelMatrix();
  };
};
Ops.Gl.Matrix.TransformMul.prototype = new CABLES.Op();
CABLES.OPS["2a83f565-7c5c-4cce-862f-d38481eb3726"] = { f: Ops.Gl.Matrix.TransformMul, objName: "Ops.Gl.Matrix.TransformMul" };
Ops.Number.DelayedNumber = function() {
  CABLES.Op.apply(this, arguments);
  const g = this;
  const A = g.attachments = {};
  const e = g.inTrigger("Update"), i = g.inValue("Value", 0), I = g.inValue("Delay", 0.5), t = g.outNumber("Result", 0), n = g.inValueBool("Clear on Change", false);
  const o = new CABLES.Anim();
  o.createPort(g, "easing", function() {
  }).set("absolute");
  e.onTriggered = function() {
    t.set(o.getValue(g.patch.freeTimer.get()) || 0);
  };
  i.onChange = function() {
    const A2 = o.getValue(g.patch.freeTimer.get());
    const e2 = g.patch.freeTimer.get();
    if (n.get())
      o.clear(e2);
    o.setValue(e2 + I.get(), i.get());
    let t2 = 0;
    for (let A3 = 0; A3 < o.keys.length; A3++)
      if (o.keys[A3] && o.keys[A3].time < e2)
        t2 = A3;
    if (t2 > 2)
      o.keys.splice(0, t2);
  };
};
Ops.Number.DelayedNumber.prototype = new CABLES.Op();
CABLES.OPS["8e7741e0-0b1b-40f3-a62c-ac8a8828dffb"] = { f: Ops.Number.DelayedNumber, objName: "Ops.Number.DelayedNumber" };
Ops.Math.Max = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("value", 1), g = A.inValueFloat("Maximum", 1), i = A.outNumber("result");
  g.onChange = t.onChange = I;
  I();
  function I() {
    let A2 = Math.max(t.get(), g.get());
    if (A2 == A2)
      i.set(A2);
  }
};
Ops.Math.Max.prototype = new CABLES.Op();
CABLES.OPS["07f0be49-c226-4029-8039-3b620145dc2a"] = { f: Ops.Math.Max, objName: "Ops.Math.Max" };
Ops.User.cristianvogel.LofiSmoothArray = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Execute"), i = A.inArray("Array In"), g = A.inBool("Separate inc/dec", false), I = A.inValue("Inc factor", 4), n = A.inValue("Dec factor", 4), o = A.outTrigger("Next"), C = A.outArray("Array Out");
  let a = [];
  let r = false;
  let s = 0;
  let B = [];
  C.set(B);
  let Q;
  let E;
  let l = false;
  u();
  c();
  function u() {
    l = g.get();
    if (!l) {
      n.setUiAttribs({ greyout: true });
      I.setUiAttribs({ title: "Inc/Dec factor" });
    } else {
      n.setUiAttribs({ greyout: false });
      I.setUiAttribs({ title: "Inc factor" });
    }
    c();
    p();
  }
  function c() {
    Q = I.get();
    if (l == false)
      E = I.get();
    else
      E = n.get();
    if (Q <= 0 || Q != Q)
      Q = 1e-4;
    if (E <= 0 || E != E)
      E = 1e-4;
    if (Q <= 1)
      Q = 1;
    if (E <= 1)
      E = 1;
  }
  i.onLinkChanged = () => {
    if (i)
      i.copyLinkedUiAttrib("stride", C);
  };
  i.onChange = function() {
    let e2 = i.get();
    if (!e2)
      return;
    for (let A2 = 0; A2 < e2.length; A2++) {
      a[A2] = e2[A2] || 0;
    }
  };
  let h = 0;
  function p() {
    let A2 = i.get();
    if (!A2)
      return;
    if (B.length != A2.length) {
      B.length = A2.length || 0;
      r = true;
    }
    let t2 = 1;
    if (CABLES.now() - s > 500 || s === 0)
      r = true;
    else
      t2 = (CABLES.now() - s) / 17;
    s = CABLES.now();
    if (r) {
      for (var g2 = 0; g2 < A2.length; g2++) {
        B[g2] = A2[g2];
      }
      r = false;
    }
    for (var g2 = 0; g2 < A2.length; g2++) {
      let A3 = B[g2];
      let e2 = a[g2] - A3;
      if (e2 >= 0)
        A3 += e2 / (E * t2);
      else
        A3 += e2 / (Q * t2);
      A3 = parseFloat(A3.toFixed(5));
      if (A3 > 0 && A3 < 1e-5)
        A3 = 0;
      if (!A3)
        A3 = 0;
      if (B[g2] != A3) {
        B[g2] = A3;
        h = A3;
      }
    }
    C.setRef(B);
    o.trigger();
  }
  t.onTriggered = function() {
    p();
  };
  I.onChange = n.onChange = c;
  g.onChange = u;
  p();
};
Ops.User.cristianvogel.LofiSmoothArray.prototype = new CABLES.Op();
CABLES.OPS["1823f416-5296-44c1-8caa-2f435da23cd6"] = { f: Ops.User.cristianvogel.LofiSmoothArray, objName: "Ops.User.cristianvogel.LofiSmoothArray" };
Ops.String.String_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inString("value", ""), g = A.outString("String");
  t.onChange = function() {
    if (!t.isLinked())
      A.setUiAttrib({ extendTitle: t.get() });
    g.set(t.get());
  };
};
Ops.String.String_v2.prototype = new CABLES.Op();
CABLES.OPS["d697ff82-74fd-4f31-8f54-295bc64e713d"] = { f: Ops.String.String_v2, objName: "Ops.String.String_v2" };
Ops.Trigger.Repeat_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Execute"), g = A.inValueInt("Repeats", 5), i = A.inSwitch("Direction", ["Forward", "Backward"], "Forward"), I = A.outTrigger("Next"), n = A.addOutPort(new CABLES.Port(A, "index"));
  i.onChange = o;
  o();
  function o() {
    if (i.get() == "Forward")
      t.onTriggered = C;
    else
      t.onTriggered = a;
  }
  function C() {
    const A2 = Math.floor(g.get());
    for (var e2 = 0; e2 < A2; e2++) {
      n.set(e2);
      I.trigger();
    }
  }
  function a() {
    const A2 = Math.floor(g.get());
    for (var e2 = A2 - 1; e2 > -1; e2--) {
      n.set(e2);
      I.trigger();
    }
  }
};
Ops.Trigger.Repeat_v2.prototype = new CABLES.Op();
CABLES.OPS["a4deea80-db97-478f-ad1a-5ee30f2f47cc"] = { f: Ops.Trigger.Repeat_v2, objName: "Ops.Trigger.Repeat_v2" };
Ops.String.SwitchString = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueInt("Index"), g = A.outString("Result");
  const i = [];
  t.onChange = o;
  for (var I = 0; I < 10; I++) {
    var n = A.inString("String " + I);
    i.push(n);
    n.onChange = o;
  }
  function o() {
    if (t.get() >= 0 && i[t.get()]) {
      g.set(i[t.get()].get());
    }
  }
};
Ops.String.SwitchString.prototype = new CABLES.Op();
CABLES.OPS["2a7a0c68-f7c9-4249-b19a-d2de5cb4862c"] = { f: Ops.String.SwitchString, objName: "Ops.String.SwitchString" };
Ops.Math.Sum = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("number1", 0), g = A.inValueFloat("number2", 0), i = A.outNumber("result");
  A.setUiAttribs({ mathTitle: true });
  t.onChange = g.onChange = I;
  I();
  function I() {
    const A2 = t.get() + g.get();
    if (!isNaN(A2))
      i.set(A2);
  }
};
Ops.Math.Sum.prototype = new CABLES.Op();
CABLES.OPS["c8fb181e-0b03-4b41-9e55-06b6267bc634"] = { f: Ops.Math.Sum, objName: "Ops.Math.Sum" };
Ops.Gl.Meshes.LinesArray = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = {};
  const e = t.inTrigger("render"), N = t.inValueFloat("width", 10), S = t.inValueFloat("height", 1), w = t.inValueBool("Logarithmic", false), g = t.inValueSelect("pivot x", ["center", "left", "right"], "center"), i = t.inValueSelect("pivot y", ["center", "top", "bottom"], "center"), I = t.inValueInt("num columns", 10), R = t.inValueInt("num rows", 10), G = t.inValueSelect("axis", ["xy", "xz"], "xy"), n = t.outTrigger("trigger"), _ = t.outArray("Point Arrays");
  const F = t.patch.cgl;
  let M = [];
  t.setPortGroup("Size", [N, S]);
  t.setPortGroup("Alignment", [g, i]);
  G.onChange = g.onChange = i.onChange = N.onChange = S.onChange = R.onChange = I.onChange = w.onChange = C;
  a();
  e.onTriggered = function() {
    for (let A2 = 0; A2 < M.length; A2++)
      M[A2].render(F.getShader());
    n.trigger();
  };
  let o = 0;
  function C() {
    clearTimeout(o);
    o = setTimeout(a, 60);
  }
  function a() {
    let n2 = 0;
    let o2 = 0;
    if (g.get() == "center")
      n2 = 0;
    if (g.get() == "right")
      n2 = -N.get() / 2;
    if (g.get() == "left")
      n2 = +N.get() / 2;
    if (i.get() == "center")
      o2 = 0;
    if (i.get() == "top")
      o2 = -S.get() / 2;
    if (i.get() == "bottom")
      o2 = +S.get() / 2;
    let C2 = parseInt(R.get(), 10);
    let a2 = parseInt(I.get(), 10);
    let r = N.get() / a2;
    let s = S.get() / C2;
    let B, Q;
    M.length = 0;
    let E, l, u;
    let c = [];
    let h = [];
    let p = [];
    let d = 0;
    function m() {
      let A3 = new CGL.Geometry(t.name);
      A3.vertices = c;
      A3.texCoords = h;
      A3.verticesIndices = p;
      let e3 = new CGL.Mesh(F, A3, { glPrimitive: F.gl.LINES });
      e3.setGeom(A3);
      M.push(e3);
      c.length = 0;
      h.length = 0;
      p.length = 0;
      d = 0;
      D = null;
    }
    let f = Math.log(1 / C2);
    let A2 = Math.log(1);
    let e2 = [];
    for (Q = C2; Q >= 0; Q--) {
      var D = null, y = null, b = null;
      let t2 = null, g2 = null;
      let A3 = 0;
      let i2 = w.get();
      let I2 = [];
      e2.push(I2);
      for (B = a2; B >= 0; B--) {
        E = B * r - N.get() / 2 + n2;
        if (i2)
          l = Math.log(Q / C2) / f * S.get() - S.get() / 2 + o2;
        else
          l = Q * s - S.get() / 2 + o2;
        let A4 = B / a2;
        let e3 = 1 - Q / C2;
        if (i2)
          e3 = Math.log(Q / C2) / f;
        u = 0;
        if (G.get() == "xz") {
          u = l;
          l = 0;
        }
        if (G.get() == "xy")
          u = 0;
        if (D !== null) {
          c.push(D);
          c.push(y);
          c.push(b);
          I2.push(D, y, b);
          c.push(E);
          c.push(l);
          c.push(u);
          h.push(t2);
          h.push(g2);
          h.push(A4);
          h.push(e3);
          p.push(d);
          d++;
          p.push(d);
          d++;
        }
        if (d > 64e3) {
          m();
        }
        t2 = A4;
        g2 = e3;
        D = E;
        y = l;
        b = u;
      }
    }
    _.set(e2);
    m();
  }
};
Ops.Gl.Meshes.LinesArray.prototype = new CABLES.Op();
CABLES.OPS["a75265c2-957b-4719-9d03-7bbf00ace364"] = { f: Ops.Gl.Meshes.LinesArray, objName: "Ops.Gl.Meshes.LinesArray" };
Ops.Gl.Meshes.SplineMesh_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Render"), n = A.inArray("Points"), o = A.inBool("Tesselate Edges", false), g = A.inBool("Render Mesh", true), i = A.outTrigger("Next");
  const I = new CGL.Geometry("splinemesh_2");
  I.vertices = [];
  I.clear();
  let C = [];
  const a = A.patch.cgl;
  let r = new Float32Array();
  let s = new Float32Array();
  let B = new Float32Array();
  let Q = new Float32Array();
  let E = null;
  let l = new Float32Array();
  const u = new Float32Array();
  const c = [];
  const h = [0, 0, 0];
  let p = new CGL.Mesh(a, I);
  p.addVertexNumbers = true;
  let d = true;
  o.onChange = n.onChange = () => {
    d = true;
  };
  t.onTriggered = f;
  let m = null;
  function f() {
    if (d)
      y();
    if (p && g.get()) {
      if (m != a.getShader()) {
        m = a.getShader();
        if (!m)
          return;
        if (m.getName() != "splinemesh_material")
          A.setUiError("nosplinemat", "Splinemesh needs a SplineMeshMaterial!");
        else
          A.setUiError("nosplinemat");
        m = a.getShader();
      }
      if (h.length > 0)
        p.render(m);
    }
    i.trigger();
  }
  function D() {
    h.length = 0;
    const e2 = 1;
    const t2 = -e2;
    for (let A2 = 0; A2 < C.length / 3; A2++) {
      h.push(e2, t2, 0, 0, t2, 0, e2, e2, 0, 0, t2, 0, 0, e2, 0, e2, e2, 0);
    }
    I.vertices = h;
    if (!p)
      p = new CGL.Mesh(a, I);
    p.addVertexNumbers = true;
    p.setGeom(I);
    p.addVertexNumbers = true;
  }
  function y() {
    const g2 = n.get();
    if (!g2 || g2.length === 0) {
      p = null;
      return;
    }
    if (g2[0].length) {
      const I2 = [];
      E = [];
      let t3 = 0;
      for (let e3 = 0; e3 < g2.length; e3++) {
        for (let A3 = 0; A3 < g2[e3].length / 3; A3++) {
          E[(t3 - 3) / 3] = e3;
          I2[t3++] = g2[e3][A3 * 3 + 0];
          I2[t3++] = g2[e3][A3 * 3 + 1];
          I2[t3++] = g2[e3][A3 * 3 + 2];
        }
      }
      C = I2;
    } else {
      E = null;
      C = g2;
    }
    if (o.get())
      C = N(C);
    D();
    const e2 = C.length * 6;
    let t2 = 0;
    let A2 = 0;
    let i2 = 0;
    if (r.length != e2) {
      r = new Float32Array(e2);
      s = new Float32Array(e2);
      B = new Float32Array(e2);
      Q = new Float32Array(e2 / 3);
      l = new Float32Array(e2 / 3);
      for (let A3 = 0; A3 < e2 / 3; A3++)
        l[A3] = A3 / (e2 / 3);
    }
    for (let e3 = 0; e3 < C.length / 3; e3++) {
      if (E) {
        if (e3 > 1 && A2 != E[e3])
          i2 = 0;
        else
          i2 = 1;
        A2 = E[e3];
      } else
        i2 = 1;
      for (let A3 = 0; A3 < 6; A3++) {
        Q[t2 / 3] = i2;
        for (let A4 = 0; A4 < 3; A4++) {
          r[t2] = C[Math.max(0, e3 - 1) * 3 + A4];
          s[t2] = C[(e3 + 0) * 3 + A4];
          B[t2] = C[(e3 + 1) * 3 + A4];
          t2++;
        }
      }
    }
    p.setAttribute("spline", r, 3);
    p.setAttribute("spline2", s, 3);
    p.setAttribute("spline3", B, 3);
    p.setAttribute("splineDoDraw", Q, 1);
    p.setAttribute("splineProgress", l, 1);
    d = false;
  }
  function b(A2, e2, t2) {
    return A2 + t2 * (e2 - A2);
  }
  function N(e2) {
    let t2 = 0;
    const g2 = 1e-3;
    const i2 = 1 - g2;
    const A2 = e2.length * 3 - 3;
    c.length = A2;
    const I2 = [];
    if (E)
      I2[0] = E[1];
    for (let A3 = 0; A3 < e2.length - 3; A3 += 3) {
      c[t2++] = e2[A3 + 0];
      c[t2++] = e2[A3 + 1];
      c[t2++] = e2[A3 + 2];
      if (E)
        I2[t2 / 3] = E[A3 / 3];
      c[t2++] = b(e2[A3 + 0], e2[A3 + 3], g2);
      c[t2++] = b(e2[A3 + 1], e2[A3 + 4], g2);
      c[t2++] = b(e2[A3 + 2], e2[A3 + 5], g2);
      if (E)
        I2[t2 / 3] = E[A3 / 3];
      c[t2++] = b(e2[A3 + 0], e2[A3 + 3], i2);
      c[t2++] = b(e2[A3 + 1], e2[A3 + 4], i2);
      c[t2++] = b(e2[A3 + 2], e2[A3 + 5], i2);
      if (E)
        I2[t2 / 3] = E[A3 / 3];
    }
    if (E)
      E = I2;
    return c;
  }
};
Ops.Gl.Meshes.SplineMesh_v2.prototype = new CABLES.Op();
CABLES.OPS["287abf6c-5501-4bc9-a627-70ec3c3766d2"] = { f: Ops.Gl.Meshes.SplineMesh_v2, objName: "Ops.Gl.Meshes.SplineMesh_v2" };
Ops.Gl.Meshes.SplineMeshMaterial_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = { splinemat_frag: "IN vec2 texCoord;\nIN float splineDoDrawFrag;\nUNI vec4 color;\nUNI sampler2D tex;\nUNI sampler2D texMask;\n\n{{MODULES_HEAD}}\n\nvoid main()\n{\n    vec4 col=color;\n\n    #ifdef USE_TEXTURE\n        #ifdef TEX_COLORIZE\n            col*=texture(tex,texCoord);\n        #endif\n        #ifndef TEX_COLORIZE\n            col=texture(tex,texCoord);\n        #endif\n    #endif\n\n    col.a=color.a;\n\n    #ifdef USE_TEXMASK\n        col.a*=texture(texMask,texCoord).r;\n        if(col.a==0.0) discard;\n    #endif\n\n    {{MODULE_COLOR}}\n\n    // if(splineDoDrawFrag==0.0) col.rgb=vec3(1.0,0.0,0.0);\n    if(splineDoDrawFrag==0.0) discard;\n\n    outColor = col;\n}", splinemat_vert: "{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nIN float attrVertIndex;\nIN float splineProgress;\nIN vec3 spline,spline2,spline3;\nIN float splineDoDraw;\n\nOUT float splineDoDrawFrag;\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nUNI float width;\nUNI float texOffset;\nUNI float aspect;\n\n#define PI 3.1415926538\n\nvec2 rotate(vec2 v, float a)\n{\n	float s = sin(a);\n	float c = cos(a);\n	mat2 m = mat2(c, -s, s, c);\n	return m * v;\n}\n\nvec2 fix( vec4 i )\n{\n    vec2 res = i.xy / i.w;\n    return res;\n}\n\nvoid main()\n{\n    texCoord=vPosition.xy;\n    texCoord.y=texCoord.y*0.5+0.5;\n    #ifdef TEX_MAP_FULL\n        texCoord.x=splineProgress;\n    #endif\n    texCoord.x+=texOffset;\n\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix=viewMatrix * mMatrix;\n\n    splineDoDrawFrag=splineDoDraw;\n\n    // vec4 pos=vec4((spline2+spline3+spline)/3.0*vPosition,1.0);\n    vec4 pos=vec4(spline2,1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    vec4 finalPosition  = projMatrix * mvMatrix * (vec4(spline2,1.0));\n    vec4 finalPosition2 = projMatrix * mvMatrix * (vec4(spline3,1.0));\n\n    vec2 screenPos =fix(projMatrix * mvMatrix * vec4(spline,1.0));\n    vec2 screenPos2=fix(projMatrix * mvMatrix * vec4(spline2,1.0));\n    vec2 screenPos3=fix(projMatrix * mvMatrix * vec4(spline3,1.0));\n\n    float wid=width/10.0;\n\n    #ifndef PERSPWIDTH\n        wid=width*finalPosition.w*0.0025;\n    #endif\n\n    vec2 dir1 = normalize( screenPos2 - screenPos );\n    vec2 dir2 = normalize( screenPos3 - screenPos2 );\n\n	if( screenPos2 == screenPos ) dir1 = normalize( screenPos3 - screenPos2 );\n\n    vec2 normal = vec2( -dir1.y/aspect, dir1.x ) * 0.5 * wid;\n    vec2 normal2 = vec2( -dir2.y/aspect, dir2.x ) * 0.5 * wid;\n\n    vec4 offset = vec4( mix(normal,normal2,vPosition.x) * vPosition.y, 0.0, 1.0 );\n\n    finalPosition = mix(finalPosition,finalPosition2,vPosition.x);\n	finalPosition.xy += offset.xy;\n\n    gl_Position = finalPosition;\n}\n" };
  const e = t.inTrigger("Render"), g = t.inFloat("Width", 0.2), i = t.inBool("Width Perspective", true), I = t.inTexture("Texture"), n = t.inTexture("Texture Mask"), o = t.inSwitch("Mapping", ["Full", "Face"], "Full"), C = t.inBool("Colorize Texture", false), a = t.inFloat("Offset", 0), r = t.inValueSlider("r", Math.random()), s = t.inValueSlider("g", Math.random()), B = t.inValueSlider("b", Math.random()), Q = t.inValueSlider("a", 1), E = t.outTrigger("Trigger"), l = t.outObject("Shader");
  r.setUiAttribs({ colorPick: true });
  l.ignoreValueSerialize = true;
  const u = t.patch.cgl;
  t.toWorkPortsNeedToBeLinked(e);
  t.setPortGroup("Color", [r, s, B, Q]);
  t.setPortGroup("Texture", [I, o, C]);
  const c = new CGL.Shader(u, "splinemesh_material", this);
  c.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
  c.setSource(A.splinemat_vert, A.splinemat_frag);
  l.set(c);
  const h = c.addUniformFrag("t", "tex");
  const p = c.addUniformFrag("t", "texMask");
  let d = 1.7777;
  c.addUniformFrag("4f", "color", r, s, B, Q);
  c.addUniformFrag("f", "width", g);
  c.addUniformFrag("f", "texOffset", a);
  c.addUniformFrag("f", "aspect", d);
  c.toggleDefine("PERSPWIDTH", i);
  c.toggleDefine("USE_TEXTURE", I);
  c.toggleDefine("TEX_COLORIZE", C);
  c.toggleDefine("USE_TEXMASK", n);
  o.on("change", f);
  e.onTriggered = m;
  f();
  function m() {
    if (!c)
      return;
    const A2 = t.patch.cgl.getViewPort();
    const e2 = A2[2] / A2[3];
    if (e2 != d) {
      d = e2;
      c.addUniformFrag("f", "aspect", d);
    }
    u.pushShader(c);
    c.popTextures();
    if (h && I.get())
      c.pushTexture(h, I.get().tex);
    if (p && n.get())
      c.pushTexture(p, n.get().tex);
    E.trigger();
    u.popShader();
  }
  function f() {
    c.toggleDefine("TEX_MAP_FULL", o.get() === "Full");
  }
};
Ops.Gl.Meshes.SplineMeshMaterial_v2.prototype = new CABLES.Op();
CABLES.OPS["5ff7c643-cbea-44cc-9f34-fb18a44bcfff"] = { f: Ops.Gl.Meshes.SplineMeshMaterial_v2, objName: "Ops.Gl.Meshes.SplineMeshMaterial_v2" };
Ops.Gl.Meshes.Circle_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("render"), G = A.inValue("radius", 0.5), _ = A.inValueSlider("innerRadius", 0), F = A.inValueInt("segments", 40), M = A.inValueSlider("percent", 1), U = A.inValue("steps", 0), L = A.inValueBool("invertSteps", false), v = A.inSwitch("mapping", ["flat", "round"]), O = A.inValueBool("Spline", false), g = A.inValueBool("Draw", true), i = A.outTrigger("trigger"), k = A.outObject("geometry", null, "geometry");
  A.setPortGroup("Size", [G, _]);
  A.setPortGroup("Display", [M, U, L]);
  A.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);
  g.setUiAttribs({ title: "Render mesh" });
  v.set("flat");
  v.onChange = F.onChange = G.onChange = _.onChange = M.onChange = U.onChange = L.onChange = O.onChange = s;
  k.ignoreValueSerialize = true;
  const I = A.patch.cgl;
  let x = new CGL.Geometry("circle");
  let T = null;
  const n = -1;
  let o = 0;
  let C = null;
  let J = true;
  t.onTriggered = a;
  A.preRender = () => {
    a();
  };
  t.onLinkChanged = function() {
    if (!t.isLinked())
      k.set(null);
    else
      k.setRef(x);
  };
  function a() {
    if (!A.patch.cg)
      return;
    if (J)
      r();
    if (!CGL.TextureEffect.checkOpNotInTextureEffect(A))
      return;
    C = A.patch.cg.getShader();
    if (!C)
      return;
    o = C.glPrimitive;
    if (O.get())
      C.glPrimitive = I.gl.LINE_STRIP;
    if (g.get() && T)
      T.render(C);
    i.trigger();
    C.glPrimitive = o;
  }
  function r() {
    const t2 = Math.max(3, Math.floor(F.get()));
    x.clear();
    const e2 = [];
    const g2 = [];
    const i2 = [];
    const I2 = [];
    const n2 = [];
    let o2 = 0, C2 = 0;
    let a2 = 0, r2 = 0;
    let s2 = 0, B = 0;
    let Q = 0, E = 0;
    let l = 0, u = 0;
    let c = 0, h = 0;
    let p = 0, d = 0;
    let m = 0, f = 0;
    const D = Math.max(0, M.get());
    const y = [];
    if (O.get()) {
      let A2 = 0;
      let e3 = 0;
      const b = [];
      for (o2 = 0; o2 <= t2 * D; o2++) {
        C2 = 360 / t2 * o2 * CGL.DEG2RAD;
        m = Math.cos(C2) * G.get();
        f = Math.sin(C2) * G.get();
        d = 0.5;
        if (o2 > 0) {
          y.push(A2);
          y.push(e3);
          y.push(0);
          p = 1 - (o2 - 1) / t2;
          b.push(p, d);
        }
        y.push(m);
        y.push(f);
        y.push(0);
        A2 = m;
        e3 = f;
      }
      x.setPointVertices(y);
    } else if (_.get() <= 0) {
      for (o2 = 0; o2 <= t2 * D; o2++) {
        C2 = 360 / t2 * o2 * CGL.DEG2RAD;
        m = Math.cos(C2) * G.get();
        f = Math.sin(C2) * G.get();
        if (v.get() == "flat") {
          p = (Math.cos(C2) + 1) / 2;
          d = 1 - (Math.sin(C2) + 1) / 2;
          c = 0.5;
          h = 0.5;
        } else if (v.get() == "round") {
          p = 1 - o2 / t2;
          d = 0;
          c = p;
          h = 1;
        }
        e2.push([0, 0, 0], [a2, r2, 0], [m, f, 0]);
        g2.push(c, h, s2, B, p, d);
        i2.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
        I2.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
        n2.push(0, -1, 0, 0, -1, 0, 0, -1, 0);
        s2 = p;
        B = d;
        a2 = m;
        r2 = f;
      }
      x = CGL.Geometry.buildFromFaces(e2, "circle");
      x.vertexNormals = i2;
      x.tangents = I2;
      x.biTangents = n2;
      x.texCoords = g2;
    } else {
      let A2 = 0;
      const N = t2 * D;
      const S = 0;
      for (o2 = 0; o2 <= N; o2++) {
        A2++;
        C2 = 360 / t2 * o2 * CGL.DEG2RAD;
        m = Math.cos(C2) * G.get();
        f = Math.sin(C2) * G.get();
        const w = Math.cos(C2) * _.get() * G.get();
        const R = Math.sin(C2) * _.get() * G.get();
        if (v.get() == "round") {
          p = 1 - o2 / t2;
          d = 0;
          c = p;
          h = 1;
        }
        if (U.get() === 0 || A2 % parseInt(U.get(), 10) === 0 && !L.get() || A2 % parseInt(U.get(), 10) !== 0 && L.get()) {
          e2.push([w, R, 0], [a2, r2, 0], [m, f, 0]);
          e2.push([Q, E, 0], [a2, r2, 0], [w, R, 0]);
          g2.push(p, 0, s2, 0, c, 1, p, 1, s2, 0, l, 1);
          i2.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);
          I2.push(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0);
          n2.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
        }
        l = c;
        u = h;
        s2 = p;
        B = d;
        a2 = m;
        r2 = f;
        Q = w;
        E = R;
      }
      x = CGL.Geometry.buildFromFaces(e2, "circle");
      x.vertexNormals = i2;
      x.tangents = I2;
      x.biTangents = n2;
      if (v.get() == "flat")
        x.mapTexCoords2d();
      else
        x.texCoords = g2;
    }
    k.setRef(x);
    if (x.vertices.length == 0)
      return;
    if (T)
      T.dispose();
    T = null;
    if (A.patch.cg)
      T = A.patch.cg.createMesh(x, { opId: A.id });
    J = false;
  }
  function s() {
    J = true;
  }
  A.onDelete = function() {
    if (T)
      T.dispose();
  };
};
Ops.Gl.Meshes.Circle_v3.prototype = new CABLES.Op();
CABLES.OPS["ae07830b-91c3-4cbe-a7d6-d3b737392c16"] = { f: Ops.Gl.Meshes.Circle_v3, objName: "Ops.Gl.Meshes.Circle_v3" };
Ops.Gl.ImageCompose.FastBlur_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { blur_frag: "\nUNI sampler2D tex;\n#ifdef USE_MASK\n    UNI sampler2D texMask;\n#endif\nUNI float amount;\nUNI float pass;\n\nIN vec2 texCoord;\n\nUNI float dirX;\nUNI float dirY;\nUNI float width;\nUNI float height;\n\nIN vec2 coord0;\nIN vec2 coord1;\nIN vec2 coord2;\nIN vec2 coord3;\nIN vec2 coord4;\nIN vec2 coord5;\nIN vec2 coord6;\n\n#ifdef HAS_MASK\n    UNI sampler2D imageMask;\n#endif\n\nvoid main()\n{\n    vec4 color = vec4(0.0);\n\n    #ifdef USE_MASK\n        #ifdef MASK_INVERT\n            if(texture(texMask,texCoord).r<0.5)\n            {\n                outColor= texture(tex, texCoord);\n                return;\n            }\n        #endif\n\n        #ifndef MASK_INVERT\n            if(texture(texMask,texCoord).r>0.5)\n            {\n                outColor= texture(tex, texCoord);\n                return;\n            }\n        #endif\n    #endif\n\n    color += texture(tex, coord0) * 0.06927096443792478;\n    color += texture(tex, coord1) * 0.1383328848652136;\n    color += texture(tex, coord2) * 0.21920904690397863;\n    color += texture(tex, coord3) * 0.14637421;\n    color += texture(tex, coord4) * 0.21920904690397863;\n    color += texture(tex, coord5) * 0.1383328848652136;\n    color += texture(tex, coord6) * 0.06927096443795711;\n\n    outColor= color;\n}", blur_vert: "\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\nUNI mat4 modelMatrix;\n\nUNI float pass;\nUNI float dirX;\nUNI float dirY;\nUNI float width;\nUNI float height;\n\nOUT vec2 coord0;\nOUT vec2 coord1;\nOUT vec2 coord2;\nOUT vec2 coord3;\nOUT vec2 coord4;\nOUT vec2 coord5;\nOUT vec2 coord6;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    {{MODULE_VERTEX_POSITION}}\n\n    vec2 dir=vec2(dirX,dirY);\n    vec2 res=vec2( (1.) / width , (1.) / height )*dir;\n\n    coord3= attrTexCoord;\n\n    coord0= attrTexCoord + (-3.0368997744118595 * res);\n    coord1= attrTexCoord + (-2.089778445362373 * res);\n    coord2= attrTexCoord + (-1.2004366090034069 * res);\n    coord4= attrTexCoord + (1.2004366090034069 * res);\n    coord5= attrTexCoord + (2.089778445362373* res);\n    coord6= attrTexCoord + (3.0368997744118595 * res);\n\n    #ifdef CLAMP\n        coord0=clamp(coord0,0.0,1.0);\n        coord1=clamp(coord1,0.0,1.0);\n        coord2=clamp(coord2,0.0,1.0);\n        coord3=clamp(coord3,0.0,1.0);\n        coord4=clamp(coord4,0.0,1.0);\n        coord5=clamp(coord5,0.0,1.0);\n        coord6=clamp(coord6,0.0,1.0);\n    #endif\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n" };
  const t = A.inTrigger("render"), g = A.outTrigger("trigger"), i = A.inFloat("Passes", 3), I = A.inBool("Clamp", false), n = A.inDropDown("direction", ["both", "vertical", "horizontal"], "both"), o = A.inTexture("Mask"), C = A.inBool("Mask Invert", false);
  const a = A.patch.cgl;
  const r = new CGL.Shader(a, "fastblur");
  A.setPortGroup("Mask", [o, C]);
  r.setSource(e.blur_vert, e.blur_frag);
  const s = new CGL.Uniform(r, "t", "tex", 0), B = new CGL.Uniform(r, "f", "dirX", 0), Q = new CGL.Uniform(r, "f", "dirY", 0), E = new CGL.Uniform(r, "f", "width", 0), l = new CGL.Uniform(r, "f", "height", 0), u = new CGL.Uniform(r, "f", "pass", 0), c = new CGL.Uniform(r, "f", "amount", i.get()), h = new CGL.Uniform(r, "t", "texMask", 1);
  i.onChange = () => {
    c.setValue(i.get());
  };
  let p = 0;
  n.onChange = () => {
    if (n.get() == "both")
      p = 0;
    if (n.get() == "horizontal")
      p = 1;
    if (n.get() == "vertical")
      p = 2;
  };
  I.onChange = () => {
    r.toggleDefine("CLAMP", I.get());
  };
  C.onChange = o.onChange = d;
  d();
  function d() {
    r.toggleDefine("USE_MASK", o.isLinked());
    r.toggleDefine("MASK_INVERT", C.get());
    C.setUiAttribs({ greyout: !o.isLinked() });
  }
  t.onTriggered = function() {
    if (!CGL.TextureEffect.checkOpInEffect(A, 3))
      return;
    E.setValue(a.currentTextureEffect.getCurrentSourceTexture().width);
    l.setValue(a.currentTextureEffect.getCurrentSourceTexture().height);
    const e2 = i.get();
    if (o.get())
      a.setTexture(1, o.get().tex);
    for (let A2 = 0; A2 < e2; A2++) {
      a.pushShader(r);
      u.setValue(A2 / e2);
      if (p === 0 || p == 2) {
        a.currentTextureEffect.bind();
        a.setTexture(0, a.currentTextureEffect.getCurrentSourceTexture().tex);
        B.setValue(0);
        Q.setValue(1 + A2 * A2);
        a.currentTextureEffect.finish();
      }
      if (p === 0 || p == 1) {
        a.currentTextureEffect.bind();
        a.setTexture(0, a.currentTextureEffect.getCurrentSourceTexture().tex);
        B.setValue(1 + A2 * A2);
        Q.setValue(0);
        a.currentTextureEffect.finish();
      }
      a.popShader();
    }
    g.trigger();
  };
};
Ops.Gl.ImageCompose.FastBlur_v2.prototype = new CABLES.Op();
CABLES.OPS["61ed277f-d096-43b2-9de8-dc87fb3a9169"] = { f: Ops.Gl.ImageCompose.FastBlur_v2, objName: "Ops.Gl.ImageCompose.FastBlur_v2" };
Ops.Math.Interpolate = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inFloat("Value 1"), g = A.inFloat("Value 2"), i = A.inFloatSlider("Percentage"), I = A.outNumber("Result");
  t.onChange = g.onChange = i.onChange = n;
  function n() {
    I.set((g.get() - t.get()) * i.get() + t.get());
  }
};
Ops.Math.Interpolate.prototype = new CABLES.Op();
CABLES.OPS["d126e2c8-221e-428f-8ff4-8b8c5f6b8905"] = { f: Ops.Math.Interpolate, objName: "Ops.Math.Interpolate" };
Ops.Math.Ceil = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValue("Number");
  const g = A.outNumber("Result");
  function i() {
    g.set(Math.ceil(t.get()));
  }
  t.onChange = i;
};
Ops.Math.Ceil.prototype = new CABLES.Op();
CABLES.OPS["15ba7aa9-b1c3-4b20-b6bf-b52a3ba8c8c5"] = { f: Ops.Math.Ceil, objName: "Ops.Math.Ceil" };
Ops.Number.Number = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("value"), g = A.outNumber("result");
  t.onChange = i;
  function i() {
    g.set(Number(t.get()));
  }
};
Ops.Number.Number.prototype = new CABLES.Op();
CABLES.OPS["8fb2bb5d-665a-4d0a-8079-12710ae453be"] = { f: Ops.Number.Number, objName: "Ops.Number.Number" };
Ops.Graphics.Geometry.TransformGeometry = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const g = A.inObject("Geometry"), i = A.inValue("Translate X"), I = A.inValue("Translate Y"), n = A.inValue("Translate Z"), o = A.inValueSlider("Scale X", 1), C = A.inValueSlider("Scale Y", 1), a = A.inValueSlider("Scale Z", 1), r = A.inValue("Rotation X"), s = A.inValue("Rotation Y"), B = A.inValue("Rotation Z"), Q = A.outObject("Result", null, "geometry");
  i.onChange = I.onChange = n.onChange = o.onChange = C.onChange = a.onChange = r.onChange = s.onChange = B.onChange = g.onChange = c;
  const E = vec3.create();
  const t = vec3.create();
  const l = vec3.create();
  const u = vec3.create();
  function c() {
    const A2 = g.get();
    const e2 = 0;
    if (A2 && A2.copy) {
      const t2 = A2.copy();
      for (let A3 = 0; A3 < t2.vertices.length; A3 += 3) {
        t2.vertices[A3 + 0] *= o.get();
        t2.vertices[A3 + 1] *= C.get();
        t2.vertices[A3 + 2] *= a.get();
        t2.vertices[A3 + 0] += i.get();
        t2.vertices[A3 + 1] += I.get();
        t2.vertices[A3 + 2] += n.get();
      }
      for (let A3 = 0; A3 < t2.vertices.length; A3 += 3) {
        vec3.set(E, t2.vertices[A3 + 0], t2.vertices[A3 + 1], t2.vertices[A3 + 2]);
        vec3.rotateX(E, E, l, r.get() * CGL.DEG2RAD);
        vec3.rotateY(E, E, l, s.get() * CGL.DEG2RAD);
        vec3.rotateZ(E, E, l, B.get() * CGL.DEG2RAD);
        t2.vertices[A3 + 0] = E[0];
        t2.vertices[A3 + 1] = E[1];
        t2.vertices[A3 + 2] = E[2];
      }
      Q.setRef(t2);
    } else {
      Q.setRef(null);
    }
  }
};
Ops.Graphics.Geometry.TransformGeometry.prototype = new CABLES.Op();
CABLES.OPS["9678fee2-5436-499c-b94d-2603cdbeb380"] = { f: Ops.Graphics.Geometry.TransformGeometry, objName: "Ops.Graphics.Geometry.TransformGeometry" };
Ops.Gl.RenderGeometry_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("render"), g = e.inObject("Geometry", null, "geometry"), i = e.inBool("Render Mesh", true), I = e.inBool("Add Vertex Numbers", true), n = e.outTrigger("trigger");
  e.toWorkPortsNeedToBeLinked(g, t);
  g.ignoreValueSerialize = true;
  let o = null;
  let C = true;
  g.onLinkChanged = I.onChange = g.onChange = () => {
    C = true;
  };
  t.onTriggered = function() {
    if (C)
      a();
    if (o && i.get())
      o.render(e.patch.cgl.getShader());
    n.trigger();
  };
  function a() {
    C = false;
    const A2 = g.get();
    if (A2 && A2.isGeometry) {
      if (o) {
        o.dispose();
        o = null;
      }
      if (!o) {
        o = new CGL.Mesh(e.patch.cgl, A2);
        o.addVertexNumbers = I.get();
        o.setGeom(A2);
      }
    } else {
      o = null;
    }
  }
};
Ops.Gl.RenderGeometry_v2.prototype = new CABLES.Op();
CABLES.OPS["0a9bdb39-8250-460e-8d99-50fe6825d956"] = { f: Ops.Gl.RenderGeometry_v2, objName: "Ops.Gl.RenderGeometry_v2" };
Ops.Trigger.GateTrigger = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("Execute"), g = A.inValueBool("Pass Through", true), i = A.outTrigger("Trigger out");
  t.onTriggered = function() {
    if (g.get())
      i.trigger();
  };
};
Ops.Trigger.GateTrigger.prototype = new CABLES.Op();
CABLES.OPS["65e8b8a2-ba13-485f-883a-2bcf377989da"] = { f: Ops.Trigger.GateTrigger, objName: "Ops.Trigger.GateTrigger" };
Ops.Boolean.Not = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueBool("Boolean"), g = A.outBoolNum("Result");
  t.changeAlways = true;
  t.onChange = function() {
    g.set(!t.get());
  };
};
Ops.Boolean.Not.prototype = new CABLES.Op();
CABLES.OPS["6d123c9f-7485-4fd9-a5c2-76e59dcbeb34"] = { f: Ops.Boolean.Not, objName: "Ops.Boolean.Not" };
Ops.Anim.Bang = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTrigger("update"), g = A.inTriggerButton("Bang"), i = A.inValue("Duration", 0.1), I = A.inBool("Invert", false), n = A.outTrigger("Trigger Out"), o = A.outNumber("Value");
  const C = new CABLES.Anim();
  let a = CABLES.now();
  A.toWorkPortsNeedToBeLinked(t);
  let r = false;
  g.onTriggered = function() {
    r = true;
  };
  t.onTriggered = function() {
    if (r) {
      a = CABLES.now();
      C.clear();
      C.setValue(0, 1);
      C.setValue(i.get(), 0);
      r = false;
    }
    const A2 = (CABLES.now() - a) / 1e3;
    if (A2 <= i.get()) {
      const e2 = C.getValue(A2);
      if (I.get())
        o.set(1 - e2);
      else
        o.set(e2);
    } else {
      if (I.get()) {
        o.set(1);
      } else {
        o.set(0);
      }
    }
    n.trigger();
  };
};
Ops.Anim.Bang.prototype = new CABLES.Op();
CABLES.OPS["92ca45a7-5b4b-4238-956e-23d79bdc659f"] = { f: Ops.Anim.Bang, objName: "Ops.Anim.Bang" };
Ops.Vars.VarSetTexture_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inTexture("Value", null);
  A.varName = A.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(A, "object", t, A.varName);
};
Ops.Vars.VarSetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["4fbfc71e-1429-439f-8591-ad35961252ed"] = { f: Ops.Vars.VarSetTexture_v2, objName: "Ops.Vars.VarSetTexture_v2" };
Ops.Trigger.TriggerCounterLoop = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = {};
  const e = t.inTriggerButton("trigger in"), g = t.inTriggerButton("reset"), i = t.outTrigger("trigger out"), I = t.outNumber("current count"), n = t.inValueInt("Loop min", 0), o = t.inValueInt("Loop max", 4);
  let C = Math.floor(n.get());
  e.onTriggered = function() {
    let A2 = Math.floor(n.get());
    let e2 = Math.floor(o.get());
    if (A2 < e2) {
      if (C < A2) {
        C = n.get();
      } else if (C >= e2) {
        C = n.get();
      } else {
        C++;
      }
    } else if (A2 > e2) {
      if (C < e2) {
        C = A2;
      } else if (C > A2) {
        A2;
      } else if (C <= e2) {
        C = A2;
      } else {
        C--;
      }
    }
    I.set(C);
    t.setUiAttrib({ extendTitle: C });
    i.trigger();
  };
  g.onTriggered = function() {
    let A2 = Math.floor(n.get());
    let e2 = Math.floor(o.get());
    if (A2 < e2) {
      C = A2;
    } else if (e2 < A2) {
      C = A2;
    } else {
      C = 0;
    }
    t.setUiAttrib({ extendTitle: C });
    I.set(C);
  };
};
Ops.Trigger.TriggerCounterLoop.prototype = new CABLES.Op();
CABLES.OPS["d3356c53-e278-433f-af0b-d8327cd99a2d"] = { f: Ops.Trigger.TriggerCounterLoop, objName: "Ops.Trigger.TriggerCounterLoop" };
Ops.Array.RandomNumbersArray_v4 = function() {
  CABLES.Op.apply(this, arguments);
  const r = this;
  const A = r.attachments = {};
  const s = r.inValueInt("Num Values", 100), B = r.inSwitch("Mode", ["A", "AB", "ABC", "ABCD"], "A"), Q = r.inValueFloat("Random Seed ", 0), E = r.inBool("Integer", false), l = r.inValueBool("Last == First"), u = r.outArray("Array Out"), c = r.outNumber("Chunks Amount"), h = r.outNumber("Array length");
  const e = ["A", "B", "C", "D"];
  const p = [];
  const d = e.map(function(A2) {
    return { min: r.inValueFloat("Min " + A2, -1), max: r.inValueFloat("Max " + A2, 1) };
  });
  for (let A2 = 0; A2 < d.length; A2 += 1) {
    const t = d[A2];
    const i = Object.keys(t);
    r.setPortGroup("Value Range " + e[A2], i.map(function(A3) {
      return t[A3];
    }));
    if (A2 > 0)
      i.forEach(function(A3) {
        t[A3].setUiAttribs({ greyout: true });
      });
  }
  B.onChange = function() {
    const A2 = B.get();
    const e2 = B.uiAttribs.values;
    u.setUiAttribs({ stride: B.get().length });
    const i = e2.indexOf(A2);
    d.forEach(function(t, g2) {
      const A3 = Object.keys(t);
      A3.forEach(function(A4, e3) {
        if (g2 <= i)
          t[A4].setUiAttribs({ greyout: false });
        else
          t[A4].setUiAttribs({ greyout: true });
      });
    });
    g();
  };
  u.ignoreValueSerialize = true;
  l.onChange = s.onChange = Q.onChange = E.onChange = g;
  const m = [];
  g();
  function g() {
    const A2 = B.get();
    const e2 = B.uiAttribs.values;
    const t = e2.indexOf(A2);
    const g2 = Math.floor(Math.abs(s.get()));
    Math.randomSeed = Q.get();
    r.setUiAttrib({ extendTitle: g2 + "*" + A2.length });
    const i = t + 1;
    const I = g2 * i;
    p.length = I;
    const n = I / i;
    const o = E.get();
    for (let e3 = 0; e3 < i; e3 += 1) {
      const A3 = d[e3];
      const C = A3.max.get();
      const a = A3.min.get();
      m[e3] = [a, C];
    }
    for (let e3 = 0; e3 < n; e3 += 1) {
      for (let A3 = 0; A3 < i; A3 += 1) {
        const a = m[A3][0];
        const C = m[A3][1];
        const t2 = e3 * i + A3;
        if (o)
          p[t2] = Math.floor(Math.seededRandom() * (C + 1 - a) + a);
        else
          p[t2] = Math.seededRandom() * (C - a) + a;
      }
    }
    if (l.get() && p.length > i) {
      for (let A3 = 0; A3 < i; A3++)
        p[p.length - 3 + A3] = p[A3];
    }
    u.setRef(p);
    c.set(p.length / i);
    h.set(p.length);
  }
  d.forEach(function(t) {
    Object.keys(t).forEach(function(A2) {
      const e2 = t[A2];
      e2.onChange = g;
    });
  });
};
Ops.Array.RandomNumbersArray_v4.prototype = new CABLES.Op();
CABLES.OPS["8a9fa2c6-c229-49a9-9dc8-247001539217"] = { f: Ops.Array.RandomNumbersArray_v4, objName: "Ops.Array.RandomNumbersArray_v4" };
Ops.Data.Compose.Array.CompArray = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("Update"), g = e.inBool("Active", true), i = e.inTrigger("Reset"), I = e.outTrigger("Next"), n = e.outArray("Result");
  i.onTriggered = () => {
    n.setRef([]);
  };
  t.onTriggered = () => {
    if (!g.get())
      return I.trigger();
    e.patch.frameStore.compArray = e.patch.frameStore.compArray || [];
    let A2 = [];
    e.patch.frameStore.compArray.push(A2);
    I.trigger();
    n.setRef(e.patch.frameStore.compArray.pop());
  };
};
Ops.Data.Compose.Array.CompArray.prototype = new CABLES.Op();
CABLES.OPS["16f1ce37-9e0d-4632-a9ba-dfd42c4eb254"] = { f: Ops.Data.Compose.Array.CompArray, objName: "Ops.Data.Compose.Array.CompArray" };
Ops.Data.Compose.Array.CompArrayPushArray = function() {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const A = e.attachments = {};
  const t = e.inTrigger("Update"), g = e.inArray("Array"), i = e.outTrigger("Next");
  t.onTriggered = () => {
    if (e.patch.frameStore.compArray && e.patch.frameStore.compArray.length > 0) {
      let A2 = e.patch.frameStore.compArray[e.patch.frameStore.compArray.length - 1];
      try {
        A2.push(JSON.parse(JSON.stringify(g.get())));
      } catch (A3) {
        e.log("error comparraupusharray");
      }
    }
    i.trigger();
  };
};
Ops.Data.Compose.Array.CompArrayPushArray.prototype = new CABLES.Op();
CABLES.OPS["7f9724de-4d81-4aeb-ae5e-8d566a3abf3e"] = { f: Ops.Data.Compose.Array.CompArrayPushArray, objName: "Ops.Data.Compose.Array.CompArrayPushArray" };
Ops.Gl.GlInfo_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.patch.cgl.gl;
  let g = 0;
  if (t.MAX_SAMPLES !== void 0)
    g = t.getParameter(t.MAX_SAMPLES);
  const i = A.outNumber("WebGl Version Short", A.patch.cgl.glVersion), I = A.outString("WebGl Version", t.getParameter(t.VERSION)), n = A.outString("GLSL Version", t.getParameter(t.SHADING_LANGUAGE_VERSION)), o = A.outNumber("Max Frag uniforms", t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)), C = A.outNumber("Max Vert uniforms", t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)), a = A.outNumber("Max Texture Size", t.getParameter(t.MAX_TEXTURE_SIZE)), r = A.outNumber("Max Texture Units", t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)), s = A.outNumber("Max Varying Vectors", t.getParameter(t.MAX_VARYING_VECTORS)), B = A.outNumber("Max MSAA Samples", g), Q = A.outArray("Extensions", t.getSupportedExtensions()), E = A.outString("Vendor"), l = A.outString("Renderer"), u = t.getExtension("WEBGL_debug_renderer_info");
  if (u) {
    E.set(t.getParameter(u.UNMASKED_VENDOR_WEBGL));
    l.set(t.getParameter(u.UNMASKED_RENDERER_WEBGL));
  }
};
Ops.Gl.GlInfo_v2.prototype = new CABLES.Op();
CABLES.OPS["6097ff94-9553-4920-b16f-113b9329eac0"] = { f: Ops.Gl.GlInfo_v2, objName: "Ops.Gl.GlInfo_v2" };
Ops.Sidebar.SidebarText_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("link");
  const g = A.inString("Text", "Value");
  const i = A.inValueString("Id", "");
  const I = A.outObject("childs");
  const n = document.createElement("div");
  n.dataset.op = A.id;
  n.classList.add("cablesEle");
  n.classList.add("sidebar__item");
  n.classList.add("sidebar__text");
  const o = document.createElement("div");
  o.classList.add("sidebar__item-label");
  const C = document.createElement("div");
  o.appendChild(C);
  n.appendChild(o);
  t.onChange = s;
  g.onChange = r;
  i.onChange = a;
  A.onDelete = E;
  A.toWorkNeedsParent("Ops.Sidebar.Sidebar");
  function a() {
    n.id = i.get();
  }
  function r() {
    const A2 = g.get();
    o.innerHTML = A2;
  }
  function s() {
    I.set(null);
    const A2 = t.get();
    if (A2 && A2.parentElement) {
      A2.parentElement.appendChild(n);
      I.set(A2);
    } else {
      if (n.parentElement) {
        n.parentElement.removeChild(n);
      }
    }
  }
  function B(A2) {
    if (A2) {
      A2.style.display = "block";
    }
  }
  function Q(A2) {
    if (A2) {
      A2.style.display = "none";
    }
  }
  function E() {
    l(n);
  }
  function l(A2) {
    if (A2 && A2.parentNode && A2.parentNode.removeChild) {
      A2.parentNode.removeChild(A2);
    }
  }
};
Ops.Sidebar.SidebarText_v2.prototype = new CABLES.Op();
CABLES.OPS["cc591cc3-ff23-4817-907c-e5be7d5c059d"] = { f: Ops.Sidebar.SidebarText_v2, objName: "Ops.Sidebar.SidebarText_v2" };
Ops.Sidebar.Sidebar = function() {
  CABLES.Op.apply(this, arguments);
  const n = this;
  const t = n.attachments = { style_css: ` /*
 * SIDEBAR
  http://danielstern.ca/range.css/#/
  https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-progress-value
 */

.sidebar-icon-undo
{
    width:10px;
    height:10px;
    background-image: url("data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 7v6h6'/%3E%3Cpath d='M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13'/%3E%3C/svg%3E");
    background-size: 19px;
    background-repeat: no-repeat;
    top: -19px;
    margin-top: -7px;
}

.icon-chevron-down {
    top: 2px;
    right: 9px;
}

.iconsidebar-chevron-up,.sidebar__close-button {
	background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);
}

.iconsidebar-minimizebutton {
    background-position: 98% center;
    background-repeat: no-repeat;
}

.sidebar-cables-right
{
    right: 15px;
    left: initial !important;
}

.sidebar-cables *
{
    color: #BBBBBB !important;
    font-family: Arial;
}

.sidebar-cables {
    --sidebar-color: #07f78c;
    --sidebar-width: 220px;
    --sidebar-border-radius: 10px;
    --sidebar-monospace-font-stack: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
    --sidebar-hover-transition-time: .2s;

    position: absolute;
    top: 15px;
    left: 15px;
    border-radius: var(--sidebar-border-radius);
    z-index: 100000;
    width: var(--sidebar-width);
    max-height: 100%;
    box-sizing: border-box;
    overflow-y: auto;
    overflow-x: hidden;
    font-size: 13px;
    line-height: 1em; /* prevent emojis from breaking height of the title */
}

.sidebar-cables::selection {
    background-color: var(--sidebar-color);
    color: #EEEEEE;
}

.sidebar-cables::-webkit-scrollbar {
    background-color: transparent;
    --cables-scrollbar-width: 8px;
    width: var(--cables-scrollbar-width);
}

.sidebar-cables::-webkit-scrollbar-track {
    background-color: transparent;
    width: var(--cables-scrollbar-width);
}

.sidebar-cables::-webkit-scrollbar-thumb {
    background-color: #333333;
    border-radius: 4px;
    width: var(--cables-scrollbar-width);
}

.sidebar-cables--closed {
    width: auto;
}

.sidebar__close-button {
    background-color: #222;
    /*-webkit-user-select: none;  */
    /*-moz-user-select: none;     */
    /*-ms-user-select: none;      */
    /*user-select: none;          */
    /*transition: background-color var(--sidebar-hover-transition-time);*/
    /*color: #CCCCCC;*/
    height: 2px;
    /*border-bottom:20px solid #222;*/

    /*box-sizing: border-box;*/
    /*padding-top: 2px;*/
    /*text-align: center;*/
    /*cursor: pointer;*/
    /*border-radius: 0 0 var(--sidebar-border-radius) var(--sidebar-border-radius);*/
    /*opacity: 1.0;*/
    /*transition: opacity 0.3s;*/
    /*overflow: hidden;*/
}

.sidebar__close-button-icon {
    display: inline-block;
    /*opacity: 0;*/
    width: 20px;
    height: 20px;
    /*position: relative;*/
    /*top: -1px;*/


}

.sidebar--closed {
    width: auto;
    margin-right: 20px;
}

.sidebar--closed .sidebar__close-button {
    margin-top: 8px;
    margin-left: 8px;
    padding:10px;

    height: 25px;
    width:25px;
    border-radius: 50%;
    cursor: pointer;
    opacity: 0.3;
    background-repeat: no-repeat;
    background-position: center center;
    transform:rotate(180deg);
}

.sidebar--closed .sidebar__group
{
    display:none;

}
.sidebar--closed .sidebar__close-button-icon {
    background-position: 0px 0px;
}

.sidebar__close-button:hover {
    background-color: #111111;
    opacity: 1.0 !important;
}

/*
 * SIDEBAR ITEMS
 */

.sidebar__items {
    /* max-height: 1000px; */
    /* transition: max-height 0.5;*/
    background-color: #222;
    padding-bottom: 20px;
}

.sidebar--closed .sidebar__items {
    /* max-height: 0; */
    height: 0;
    display: none;
    pointer-interactions: none;
}

.sidebar__item__right {
    float: right;
}

/*
 * SIDEBAR GROUP
 */

.sidebar__group {
    /*background-color: #1A1A1A;*/
    overflow: hidden;
    box-sizing: border-box;
    animate: height;
    /*background-color: #151515;*/
    /* max-height: 1000px; */
    /* transition: max-height 0.5s; */
--sidebar-group-header-height: 33px;
}

.sidebar__group-items
{
    padding-top: 15px;
    padding-bottom: 15px;
}

.sidebar__group--closed {
    /* max-height: 13px; */
    height: var(--sidebar-group-header-height);
}

.sidebar__group-header {
    box-sizing: border-box;
    color: #EEEEEE;
    background-color: #151515;
    -webkit-user-select: none;  /* Chrome all / Safari all */
    -moz-user-select: none;     /* Firefox all */
    -ms-user-select: none;      /* IE 10+ */
    user-select: none;          /* Likely future */

    /*height: 100%;//var(--sidebar-group-header-height);*/

    padding-top: 7px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    cursor: pointer;
    /*transition: background-color var(--sidebar-hover-transition-time);*/
    position: relative;
}

.sidebar__group-header:hover {
  background-color: #111111;
}

.sidebar__group-header-title {
  /*float: left;*/
  overflow: hidden;
  padding: 0 15px;
  padding-top:5px;
  padding-bottom:10px;
  font-weight:bold;
}

.sidebar__group-header-undo {
    float: right;
    overflow: hidden;
    padding-right: 15px;
    padding-top:5px;
    font-weight:bold;
  }

.sidebar__group-header-icon {
    width: 17px;
    height: 14px;
    background-repeat: no-repeat;
    display: inline-block;
    position: absolute;
    background-size: cover;

    /* icon open */
    /* feather icon: chevron up */
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);
    top: 4px;
    right: 5px;
    opacity: 0.0;
    transition: opacity 0.3;
}

.sidebar__group-header:hover .sidebar__group-header-icon {
    opacity: 1.0;
}

/* icon closed */
.sidebar__group--closed .sidebar__group-header-icon {
    /* feather icon: chevron down */
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);
    top: 4px;
    right: 5px;
}

/*
 * SIDEBAR ITEM
 */

.sidebar__item
{
    box-sizing: border-box;
    padding: 7px;
    padding-left:15px;
    padding-right:15px;

    overflow: hidden;
    position: relative;
}

.sidebar__item-label {
    display: inline-block;
    -webkit-user-select: none;  /* Chrome all / Safari all */
    -moz-user-select: none;     /* Firefox all */
    -ms-user-select: none;      /* IE 10+ */
    user-select: none;          /* Likely future */
    width: calc(50% - 7px);
    margin-right: 7px;
    margin-top: 2px;
    text-overflow: ellipsis;
    /* overflow: hidden; */
}

.sidebar__item-value-label {
    font-family: var(--sidebar-monospace-font-stack);
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    max-width: 60%;
}

.sidebar__item-value-label::selection {
    background-color: var(--sidebar-color);
    color: #EEEEEE;
}

.sidebar__item + .sidebar__item,
.sidebar__item + .sidebar__group,
.sidebar__group + .sidebar__item,
.sidebar__group + .sidebar__group {
    /*border-top: 1px solid #272727;*/
}

/*
 * SIDEBAR ITEM TOGGLE
 */

/*.sidebar__toggle */
.icon_toggle{
    cursor: pointer;
}

.sidebar__toggle-input {
    --sidebar-toggle-input-color: #CCCCCC;
    --sidebar-toggle-input-color-hover: #EEEEEE;
    --sidebar-toggle-input-border-size: 2px;
    display: inline;
    float: right;
    box-sizing: border-box;
    border-radius: 50%;
    cursor: pointer;
    --toggle-size: 11px;
    margin-top: 2px;
    background-color: transparent !important;
    border: var(--sidebar-toggle-input-border-size) solid var(--sidebar-toggle-input-color);
    width: var(--toggle-size);
    height: var(--toggle-size);
    transition: background-color var(--sidebar-hover-transition-time);
    transition: border-color var(--sidebar-hover-transition-time);
}
.sidebar__toggle:hover .sidebar__toggle-input {
    border-color: var(--sidebar-toggle-input-color-hover);
}

.sidebar__toggle .sidebar__item-value-label {
    -webkit-user-select: none;  /* Chrome all / Safari all */
    -moz-user-select: none;     /* Firefox all */
    -ms-user-select: none;      /* IE 10+ */
    user-select: none;          /* Likely future */
    max-width: calc(50% - 12px);
}
.sidebar__toggle-input::after { clear: both; }

.sidebar__toggle--active .icon_toggle
{

    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjMDZmNzhiIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzA2Zjc4YiIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjMDZmNzhiIiBzdHJva2U9IiMwNmY3OGIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNmY3OGIiIHN0cm9rZT0iIzA2Zjc4YiIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);
    opacity: 1;
    transform: rotate(0deg);
}


.icon_toggle
{
    float: right;
    width:40px;
    height:18px;
    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjYWFhYWFhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI2FhYWFhYSIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjYWFhYWFhIiBzdHJva2U9IiNhYWFhYWEiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNhYWFhYWEiIHN0cm9rZT0iI2FhYWFhYSIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);
    background-size: 50px 37px;
    background-position: -6px -10px;
    transform: rotate(180deg);
    opacity: 0.4;
}



/*.sidebar__toggle--active .sidebar__toggle-input {*/
/*    transition: background-color var(--sidebar-hover-transition-time);*/
/*    background-color: var(--sidebar-toggle-input-color);*/
/*}*/
/*.sidebar__toggle--active .sidebar__toggle-input:hover*/
/*{*/
/*    background-color: var(--sidebar-toggle-input-color-hover);*/
/*    border-color: var(--sidebar-toggle-input-color-hover);*/
/*    transition: background-color var(--sidebar-hover-transition-time);*/
/*    transition: border-color var(--sidebar-hover-transition-time);*/
/*}*/

/*
 * SIDEBAR ITEM BUTTON
 */

.sidebar__button {}

.sidebar__button-input:active
{
    background-color: #555 !important;
}

.sidebar__button-input {
    -webkit-user-select: none;  /* Chrome all / Safari all */
    -moz-user-select: none;     /* Firefox all */
    -ms-user-select: none;      /* IE 10+ */
    user-select: none;          /* Likely future */
    min-height: 24px;
    background-color: transparent;
    color: #CCCCCC;
    box-sizing: border-box;
    padding-top: 3px;
    text-align: center;
    border-radius: 125px;
    border:2px solid #555;
    cursor: pointer;
    padding-bottom: 3px;
}

.sidebar__button-input.plus, .sidebar__button-input.minus {
    display: inline-block;
    min-width: 20px;
}

.sidebar__button-input:hover {
  background-color: #333;
  border:2px solid var(--sidebar-color);
}

/*
 * VALUE DISPLAY (shows a value)
 */

.sidebar__value-display {}

/*
 * SLIDER
 */

.sidebar__slider {
    --sidebar-slider-input-height: 3px;
}

.sidebar__slider-input-wrapper {
    width: 100%;

    margin-top: 8px;
    position: relative;
}

.sidebar__slider-input {
    -webkit-appearance: none;
    appearance: none;
    margin: 0;
    width: 100%;
    height: var(--sidebar-slider-input-height);
    background: #555;
    cursor: pointer;
    outline: 0;

    -webkit-transition: .2s;
    transition: background-color .2s;
    border: none;
}

.sidebar__slider-input:focus, .sidebar__slider-input:hover {
    border: none;
}

.sidebar__slider-input-active-track {
    user-select: none;
    position: absolute;
    z-index: 11;
    top: 0;
    left: 0;
    background-color: var(--sidebar-color);
    pointer-events: none;
    height: var(--sidebar-slider-input-height);
    max-width: 100%;
}

/* Mouse-over effects */
.sidebar__slider-input:hover {
    /*background-color: #444444;*/
}

/*.sidebar__slider-input::-webkit-progress-value {*/
/*    background-color: green;*/
/*    color:green;*/

/*    }*/

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */

.sidebar__slider-input::-moz-range-thumb
{
    position: absolute;
    height: 15px;
    width: 15px;
    z-index: 900 !important;
    border-radius: 20px !important;
    cursor: pointer;
    background: var(--sidebar-color) !important;
    user-select: none;

}

.sidebar__slider-input::-webkit-slider-thumb
{
    position: relative;
    appearance: none;
    -webkit-appearance: none;
    user-select: none;
    height: 15px;
    width: 15px;
    display: block;
    z-index: 900 !important;
    border: 0;
    border-radius: 20px !important;
    cursor: pointer;
    background: #777 !important;
}

.sidebar__slider-input:hover ::-webkit-slider-thumb {
    background-color: #EEEEEE !important;
}

/*.sidebar__slider-input::-moz-range-thumb {*/

/*    width: 0 !important;*/
/*    height: var(--sidebar-slider-input-height);*/
/*    background: #EEEEEE;*/
/*    cursor: pointer;*/
/*    border-radius: 0 !important;*/
/*    border: none;*/
/*    outline: 0;*/
/*    z-index: 100 !important;*/
/*}*/

.sidebar__slider-input::-moz-range-track {
    background-color: transparent;
    z-index: 11;
}

/*.sidebar__slider-input::-moz-range-thumb:hover {*/
  /* background-color: #EEEEEE; */
/*}*/


/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input-active-track {*/
/*    background-color: #EEEEEE;*/
/*}*/

/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-moz-range-thumb {*/
/*    background-color: #fff !important;*/
/*}*/

/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-webkit-slider-thumb {*/
/*    background-color: #EEEEEE;*/
/*}*/

.sidebar__slider input[type=text],
.sidebar__slider input[type=paddword]
{
    box-sizing: border-box;
    /*background-color: #333333;*/
    text-align: right;
    color: #BBBBBB;
    display: inline-block;
    background-color: transparent !important;

    width: 40%;
    height: 18px;
    outline: none;
    border: none;
    border-radius: 0;
    padding: 0 0 0 4px !important;
    margin: 0;
}

.sidebar__slider input[type=text]:active,
.sidebar__slider input[type=text]:focus,
.sidebar__slider input[type=text]:hover
.sidebar__slider input[type=password]:active,
.sidebar__slider input[type=password]:focus,
.sidebar__slider input[type=password]:hover
{

    color: #EEEEEE;
}

/*
 * TEXT / DESCRIPTION
 */

.sidebar__text .sidebar__item-label {
    width: auto;
    display: block;
    max-height: none;
    margin-right: 0;
    line-height: 1.1em;
}

/*
 * SIDEBAR INPUT
 */
.sidebar__text-input textarea,
.sidebar__text-input input[type=date],
.sidebar__text-input input[type=datetime-local],
.sidebar__text-input input[type=text],
.sidebar__text-input input[type=password] {
    box-sizing: border-box;
    background-color: #333333;
    color: #BBBBBB;
    display: inline-block;
    width: 50%;
    height: 18px;
    outline: none;
    border: none;
    border-radius: 0;
    border:1px solid #666;
    padding: 0 0 0 4px !important;
    margin: 0;
    color-scheme: dark;
}

.sidebar__text-input textarea:focus::placeholder {
  color: transparent;
}

.sidebar__color-picker .sidebar__item-label
{
    width:45%;
}

.sidebar__text-input textarea,
.sidebar__text-input input[type=text]:active,
.sidebar__text-input input[type=text]:focus,
.sidebar__text-input input[type=text]:hover,
.sidebar__text-input input[type=password]:active,
.sidebar__text-input input[type=password]:focus,
.sidebar__text-input input[type=password]:hover {
    background-color: transparent;
    color: #EEEEEE;
}

.sidebar__text-input textarea
{
    margin-top:10px;
    height:60px;
    width:100%;
}

/*
 * SIDEBAR SELECT
 */



 .sidebar__select {}
 .sidebar__select-select {
    color: #BBBBBB;
    /*-webkit-appearance: none;*/
    /*-moz-appearance: none;*/
    appearance: none;
    /*box-sizing: border-box;*/
    width: 50%;
    /*height: 20px;*/
    background-color: #333333;
    /*background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);*/
    background-repeat: no-repeat;
    background-position: right center;
    background-size: 16px 16px;
    margin: 0;
    /*padding: 0 2 2 6px;*/
    border-radius: 5px;
    border: 1px solid #777;
    background-color: #444;
    cursor: pointer;
    outline: none;
    padding-left: 5px;

 }

.sidebar__select-select:hover,
.sidebar__select-select:active,
.sidebar__select-select:inactive {
    background-color: #444444;
    color: #EEEEEE;
}

/*.sidebar__select-select option*/
/*{*/
/*    background-color: #444444;*/
/*    color: #bbb;*/
/*}*/

.sidebar__select-select option:checked
{
    background-color: #000;
    color: #FFF;
}


/*
 * COLOR PICKER
 */


 .sidebar__color-picker input[type=text] {
    box-sizing: border-box;
    background-color: #333333;
    color: #BBBBBB;
    display: inline-block;
    width: calc(50% - 21px); /* 50% minus space of picker circle */
    height: 18px;
    outline: none;
    border: none;
    border-radius: 0;
    padding: 0 0 0 4px !important;
    margin: 0;
    margin-right: 7px;
}

.sidebar__color-picker input[type=text]:active,
.sidebar__color-picker input[type=text]:focus,
.sidebar__color-picker input[type=text]:hover {
    background-color: #444444;
    color: #EEEEEE;
}

div.sidebar__color-picker-color-input,
.sidebar__color-picker input[type=color],
.sidebar__palette-picker input[type=color] {
    display: inline-block;
    border-radius: 100%;
    height: 14px;
    width: 14px;

    padding: 0;
    border: none;
    /*border:2px solid red;*/
    border-color: transparent;
    outline: none;
    background: none;
    appearance: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    cursor: pointer;
    position: relative;
    top: 3px;
}
.sidebar__color-picker input[type=color]:focus,
.sidebar__palette-picker input[type=color]:focus {
    outline: none;
}
.sidebar__color-picker input[type=color]::-moz-color-swatch,
.sidebar__palette-picker input[type=color]::-moz-color-swatch {
    border: none;
}
.sidebar__color-picker input[type=color]::-webkit-color-swatch-wrapper,
.sidebar__palette-picker input[type=color]::-webkit-color-swatch-wrapper {
    padding: 0;
}
.sidebar__color-picker input[type=color]::-webkit-color-swatch,
.sidebar__palette-picker input[type=color]::-webkit-color-swatch {
    border: none;
    border-radius: 100%;
}

/*
 * Palette Picker
 */
.sidebar__palette-picker .sidebar__palette-picker-color-input.first {
    margin-left: 0;
}
.sidebar__palette-picker .sidebar__palette-picker-color-input.last {
    margin-right: 0;
}
.sidebar__palette-picker .sidebar__palette-picker-color-input {
    margin: 0 4px;
}

.sidebar__palette-picker .circlebutton {
    width: 14px;
    height: 14px;
    border-radius: 1em;
    display: inline-block;
    top: 3px;
    position: relative;
}

/*
 * Preset
 */
.sidebar__item-presets-preset
{
    padding:4px;
    cursor:pointer;
    padding-left:8px;
    padding-right:8px;
    margin-right:4px;
    background-color:#444;
}

.sidebar__item-presets-preset:hover
{
    background-color:#666;
}

.sidebar__greyout
{
    background: #222;
    opacity: 0.8;
    width: 100%;
    height: 100%;
    position: absolute;
    z-index: 1000;
    right: 0;
    top: 0;
}

.sidebar_tabs
{
    background-color: #151515;
    padding-bottom: 0px;
}

.sidebar_switchs
{
    float: right;
}

.sidebar_tab
{
    float:left;
    background-color: #151515;
    border-bottom:1px solid transparent;
    padding-right:7px;
    padding-left:7px;
    padding-bottom: 5px;
    padding-top: 5px;
    cursor:pointer;
}

.sidebar_tab_active
{
    background-color: #272727;
    color:white;
}

.sidebar_tab:hover
{
    border-bottom:1px solid #777;
    color:white;
}


.sidebar_switch
{
    float:left;
    background-color: #444;
    padding-right:7px;
    padding-left:7px;
    padding-bottom: 5px;
    padding-top: 5px;
    cursor:pointer;
}

.sidebar_switch:last-child
{
    border-top-right-radius: 7px;
    border-bottom-right-radius: 7px;
}

.sidebar_switch:first-child
{
    border-top-left-radius: 7px;
    border-bottom-left-radius: 7px;
}


.sidebar_switch_active
{
    background-color: #999;
    color:white;
}

.sidebar_switch:hover
{
    color:white;
}

` };
  const g = "cables-sidebar-style";
  const i = "cables-sidebar-dynamic-style";
  const o = "sidebar-cables";
  const C = "sidebar" + CABLES.uuid();
  const a = "sidebar__items";
  const r = "sidebar__close-button";
  const I = "";
  const s = "";
  let B = null;
  let L = null;
  let Q = null;
  const A = n.inValueBool("Visible", true);
  const e = n.inValueSlider("Opacity", 1);
  const E = n.inValueBool("Default Minimized");
  const l = n.inValueSlider("Minimized Opacity", 0.5);
  const u = n.inValueBool("Show undo button", false);
  const c = n.inValueBool("Show Minimize", false);
  const h = n.inString("Title", "");
  const p = n.inValueBool("Side");
  const d = n.inValueBool("Default CSS", true);
  let m = n.patch.cgl.canvas.ownerDocument;
  const f = n.outObject("childs");
  f.setUiAttribs({ title: "Children" });
  const D = n.outBool("Opfened");
  D.setUiAttribs({ title: "Opened" });
  let y = m.querySelector("." + C);
  if (!y)
    y = O();
  const b = y.querySelector("." + a);
  f.set({ parentElement: b, parentOp: n });
  G();
  U();
  F();
  d.onChange = () => {
    U();
    F();
  };
  A.onChange = v;
  e.onChange = _;
  E.onChange = G;
  l.onChange = N;
  u.onChange = w;
  n.onDelete = x;
  function N() {
    F();
  }
  c.onChange = S;
  function S(A2) {
    if (!A2 || A2.uiAttribs)
      A2 = m.querySelector(".sidebar-cables .sidebar__group-header");
    if (!A2)
      return;
    const e2 = m.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");
    if (c.get()) {
      A2.classList.add("iconsidebar-chevron-up");
      A2.classList.add("iconsidebar-minimizebutton");
      if (e2)
        e2.style.marginRight = "20px";
    } else {
      A2.classList.remove("iconsidebar-chevron-up");
      A2.classList.remove("iconsidebar-minimizebutton");
      if (e2)
        e2.style.marginRight = "initial";
    }
  }
  p.onChange = function() {
    if (!y)
      return;
    if (p.get())
      y.classList.add("sidebar-cables-right");
    else
      y.classList.remove("sidebar-cables-right");
  };
  function w() {
    const A2 = m.querySelector(".sidebar-cables .sidebar__group-header");
    if (A2) {
      R(A2);
    }
  }
  function R(A2) {
    if (A2) {
      const e2 = m.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");
      if (e2) {
        if (!u.get()) {
          e2.remove();
        }
      } else {
        if (u.get()) {
          const t2 = m.createElement("span");
          t2.classList.add("sidebar__group-header-undo");
          t2.classList.add("sidebar-icon-undo");
          t2.addEventListener("click", function(A3) {
            A3.stopPropagation();
            const e3 = m.querySelectorAll(".sidebar-cables .sidebar__reloadable");
            const t3 = m.createEvent("MouseEvents");
            t3.initEvent("dblclick", true, true);
            e3.forEach((A4) => {
              A4.dispatchEvent(t3);
            });
          });
          A2.appendChild(t2);
        }
      }
    }
    S(A2);
  }
  function G() {
    if (!B) {
      return;
    }
    if (E.get()) {
      y.classList.add("sidebar--closed");
      if (A.get())
        D.set(false);
    } else {
      y.classList.remove("sidebar--closed");
      if (A.get())
        D.set(true);
    }
  }
  function _() {
    const A2 = e.get();
    y.style.opacity = A2;
  }
  function v() {
    if (!y)
      return;
    if (A.get()) {
      y.style.display = "block";
      if (!y.classList.contains("sidebar--closed"))
        D.set(true);
    } else {
      y.style.display = "none";
      D.set(false);
    }
  }
  p.onChanged = function() {
  };
  function F() {
    const A2 = m.querySelectorAll("." + i);
    if (A2) {
      A2.forEach(function(A3) {
        A3.parentNode.removeChild(A3);
      });
    }
    if (!d.get())
      return;
    const e2 = m.createElement("style");
    e2.classList.add("cablesEle");
    e2.classList.add(i);
    let t2 = ".sidebar--closed .sidebar__close-button { ";
    t2 += "opacity: " + l.get();
    t2 += "}";
    const g2 = m.createTextNode(t2);
    e2.appendChild(g2);
    m.body.appendChild(e2);
  }
  function O() {
    const A2 = m.createElement("div");
    A2.classList.add(o);
    A2.classList.add(C);
    const e2 = n.patch.cgl.canvas.parentElement;
    const t2 = m.createElement("div");
    t2.classList.add("sidebar__group");
    A2.appendChild(t2);
    const g2 = m.createElement("div");
    g2.classList.add("sidebar__group-header");
    A2.appendChild(g2);
    const i2 = m.createElement("span");
    i2.classList.add("sidebar__group-header-title");
    Q = m.createElement("span");
    Q.classList.add("sidebar__group-header-title-text");
    Q.innerHTML = h.get();
    i2.appendChild(Q);
    g2.appendChild(i2);
    R(g2);
    S(g2);
    t2.appendChild(g2);
    A2.appendChild(t2);
    t2.addEventListener("click", M);
    if (!e2) {
      n.warn("[sidebar] no canvas parentelement found...");
      return;
    }
    e2.appendChild(A2);
    const I2 = m.createElement("div");
    I2.classList.add(a);
    A2.appendChild(I2);
    B = m.createElement("div");
    B.classList.add(r);
    B.addEventListener("click", M);
    A2.appendChild(B);
    return A2;
  }
  h.onChange = function() {
    if (Q)
      Q.innerHTML = h.get();
  };
  function k(A2) {
  }
  function M(A2) {
    A2.stopPropagation();
    if (!y) {
      n.logError("Sidebar could not be closed...");
      return;
    }
    y.classList.toggle("sidebar--closed");
    const e2 = A2.target;
    let t2 = I;
    if (y.classList.contains("sidebar--closed")) {
      t2 = s;
      D.set(false);
    } else {
      D.set(true);
    }
  }
  function U() {
    const A2 = m.querySelectorAll("." + g);
    if (A2) {
      A2.forEach((A3) => {
        A3.parentNode.removeChild(A3);
      });
    }
    if (!d.get())
      return;
    const e2 = m.createElement("style");
    e2.innerHTML = t.style_css;
    e2.classList.add(g);
    e2.classList.add("cablesEle");
    m.body.appendChild(e2);
  }
  function x() {
    T(y);
  }
  function T(A2) {
    if (A2 && A2.parentNode && A2.parentNode.removeChild)
      A2.parentNode.removeChild(A2);
  }
};
Ops.Sidebar.Sidebar.prototype = new CABLES.Op();
CABLES.OPS["5a681c35-78ce-4cb3-9858-bc79c34c6819"] = { f: Ops.Sidebar.Sidebar, objName: "Ops.Sidebar.Sidebar" };
Ops.Sidebar.SideBarStyle = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("link"), g = A.inInt("Width", 220), i = A.inFloat("Round Corners", 10), I = A.inString("Special Color", "#07f78c"), n = A.outObject("childs");
  I.onChange = i.onChange = g.onChange = C;
  t.onChange = a;
  A.onDelete = B;
  A.toWorkNeedsParent("Ops.Sidebar.Sidebar");
  let o = null;
  function C() {
    if (!o)
      return;
    o.style.setProperty("--sidebar-width", g.get() + "px");
    o.style.setProperty("--sidebar-color", I.get());
    o.style.setProperty("--sidebar-border-radius", Math.round(i.get()) + "px");
    A.patch.emitEvent("sidebarStylesChanged");
  }
  function a() {
    n.set(null);
    const A2 = t.get();
    if (A2 && A2.parentElement) {
      n.set(A2);
      o = A2.parentElement.parentElement;
      C();
    } else {
      o = null;
    }
  }
  function r(A2) {
    if (!A2)
      return;
    A2.style.display = "block";
  }
  function s(A2) {
    if (!A2)
      return;
    A2.style.display = "none";
  }
  function B() {
  }
};
Ops.Sidebar.SideBarStyle.prototype = new CABLES.Op();
CABLES.OPS["87d78a59-c8d4-4269-a3f8-af273741aae4"] = { f: Ops.Sidebar.SideBarStyle, objName: "Ops.Sidebar.SideBarStyle" };
Ops.Cables.FPS_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.outNumber("FPS"), g = A.outNumber("MS");
  const i = A.patch.cgl.fpsCounter.addEventListener("performance", I);
  A.onDelete = function() {
    A.patch.removeEventListener(i);
  };
  function I(A2) {
    t.set(A2.fps);
    g.set(A2.ms);
  }
};
Ops.Cables.FPS_v2.prototype = new CABLES.Op();
CABLES.OPS["6dbb866c-b57a-4875-9f1d-22172162eaa8"] = { f: Ops.Cables.FPS_v2, objName: "Ops.Cables.FPS_v2" };
Ops.Math.Modulo = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("number1", 1), g = A.inValueFloat("number2", 2), i = A.inValueBool("pingpong"), I = A.outNumber("result");
  let n = C;
  t.onChange = g.onChange = o;
  i.onChange = r;
  o();
  function o() {
    let A2 = g.get();
    let e2 = t.get();
    I.set(n(e2, A2));
  }
  function C(A2, e2) {
    let t2 = (A2 % e2 + e2) % e2;
    if (t2 != t2)
      t2 = 0;
    return t2;
  }
  function a(A2, e2) {
    let t2 = 2 * e2;
    A2 %= t2;
    if (A2 >= e2)
      return t2 - A2;
    else
      return A2;
  }
  function r() {
    if (i.get())
      n = a;
    else
      n = C;
  }
};
Ops.Math.Modulo.prototype = new CABLES.Op();
CABLES.OPS["ebc13b25-3705-4265-8f06-5f985b6a7bb1"] = { f: Ops.Math.Modulo, objName: "Ops.Math.Modulo" };
Ops.Graphics.GeometryMergeSimple = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inObject("Geometry"), g = A.inObject("Geometry 2"), i = A.outObject("Geometry Result");
  A.toWorkPortsNeedToBeLinked(t);
  let I = new CGL.Geometry(A.name);
  i.set(I);
  t.onChange = g.onChange = function() {
    if (t.get() || g.get()) {
      I = new CGL.Geometry(A.name);
      if (t.get()) {
        I = t.get().copy();
      }
      if (g.get())
        I.merge(g.get());
      i.set(null);
      i.set(I);
    }
  };
};
Ops.Graphics.GeometryMergeSimple.prototype = new CABLES.Op();
CABLES.OPS["e9a6c398-b6f2-4c53-a7ea-47aa835c6938"] = { f: Ops.Graphics.GeometryMergeSimple, objName: "Ops.Graphics.GeometryMergeSimple" };
Ops.Gl.ImageCompose.Waveform_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { wave_v2_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D tex1;\nUNI float amount;\n\nUNI float r;\nUNI float g;\nUNI float b;\n\nUNI float uAmp;\nUNI float uFreq;\nUNI float uWidth;\nUNI float uGlow;\nUNI float uWaveSelect;\nUNI bool uInvert;\nUNI bool uSolid;\n\nUNI float uOffSetX;\nUNI float uOffSetY;\nUNI float uRotate;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265359\n#define TAU (2.0*PI)\n\nfloat vmax(vec2 v)\n{\n	return max(v.x, v.y);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n    float s = sin(a),c=cos(a); p *= mat2(c,s,-s,c);\n}\n\nfloat pMod1(inout float p, float size)\n{\n	float halfsize = size * 0.5;\n	float c = floor((p + halfsize) / size);\n	p = mod(p + halfsize, size) - halfsize;\n	return c;\n}\n\nfloat pModMirror1(inout float p, float size)\n{\n	float halfsize = size * 0.5;\n	float c = floor((p + halfsize) / size);\n	p = mod(p + halfsize,size) - halfsize;\n	p *= mod(c, 2.0) * 2.0 - 1.0;\n	return c;\n}\n\nfloat fCapsule2D(vec2 p, float r, float c)\n{\n	return mix(abs(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat SineWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float v = sin(p.x * frequency * PI);\n    v *= amplitude;\n\n    float d = 0.0;\n\n    if (solid == false)\n    {\n        d = abs(v * amplitude - p.y * 0.5);\n        d -= line_width;\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n    {\n        d = v * amplitude - p.y * 0.5;\n        d -= -line_width;\n        return smoothstep(0.0, line_glow, -d);\n    }\n}\n\nfloat SawWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float inverse_frequency = 2.0 / frequency;\n    vec2 p1 = p;\n    pMod1(p1.x, inverse_frequency);\n\n    float d1 = fCapsule2D(p1, 0.0, amplitude);\n    p.x += inverse_frequency * 0.5;\n    pMod1(p.x, inverse_frequency);\n    pR(p, atan(inverse_frequency, amplitude * 2.0));\n\n    float d = fCapsule2D(p, 0.0, 0.5 * length(vec2(inverse_frequency, 2.0 * amplitude)));\n	d = min(d, d1);\n    d -= line_width;\n\n    if(solid == false)\n    {\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n        return smoothstep(0.0, line_glow, min(d,p.x));\n}\n\nfloat TriangleWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float inverse_frequency = 1.0 / frequency;\n    p.x -= inverse_frequency;\n    pModMirror1(p.x, inverse_frequency);\n    pR(p, atan(inverse_frequency, amplitude * 2.0));\n\n    float d = fCapsule2D(p, 0.0, 0.5 * length(vec2(inverse_frequency, 2.0 * amplitude)));\n    d -= line_width;\n\n    if (solid == false)\n    {\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n        return smoothstep(0.0, line_glow, min(d,p.x));\n}\n\nfloat SquareWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float inverse_frequency = 0.5 / frequency;\n    vec2 p1 = p;\n    pMod1(p1.x, 2.0 * inverse_frequency);\n\n    float d1 = fCapsule2D(p1, 0.0, abs(amplitude));\n    p.x -= inverse_frequency * 0.5;\n    float cell = pMod1(p.x, inverse_frequency);\n\n    if(cell < 0.0) cell = -cell + 1.0;\n    if(int(cell * 0.5) % 2 == 1) p.y -= amplitude;\n        else p.y += amplitude;\n\n    float d = fCapsule2D(p.yx, 0.0, abs(inverse_frequency));\n    d = min(d, d1);\n    d -= line_width;\n\n    if (solid == false)\n    {\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n        return smoothstep(0.0, line_glow, p.y);\n}\n\nvoid main()\n{\n    vec4 rgb = vec4(r,g,b,1.0);\n	vec2 uv = texCoord;\n\n    uv -= 0.5;\n    pR(uv.xy,uRotate * TAU);\n    uv += 0.5;\n\n    float wave = 0.0;\n    #ifdef SINE\n        wave = 1.0 - SineWave     (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq , uWidth, uGlow, uSolid);\n    #endif\n    #ifdef SAWTOOTH\n        wave = 1.0 - SawWave      (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq, uWidth, uGlow, uSolid);\n    #endif\n    #ifdef TRIANGLE\n        wave = 1.0 - TriangleWave (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq, uWidth, uGlow, uSolid);\n    #endif\n    #ifdef SQUARE\n        wave = 1.0 - SquareWave   (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq, uWidth, uGlow, uSolid);\n    #endif\n\n    #ifdef INVERT\n        wave = 1.0-wave;\n    #endif\n\n    vec4 col = vec4(r,g,b,1.0);\n\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,col,wave*amount);\n}\n" };
  const t = A.inTrigger("render"), g = CGL.TextureEffect.AddBlendSelect(A, "Blend Mode", "normal"), i = A.inValueSlider("Amount", 1), I = CGL.TextureEffect.AddBlendAlphaMask(A), n = A.inValueSelect("Waveform", ["Sine", "Sawtooth", "Triangle", "Square"], "Sine"), o = A.inValueSlider("Amplitude", 0.5), C = A.inFloat("Frequency", 2), a = A.inValueSlider("Line Width", 0.1), r = A.inValueSlider("Line Glow", 0.1), s = A.inValueBool("invert color", false), B = A.inValueBool("Solid fill", false), Q = A.inValueSlider("Offset X", 0), E = A.inValueSlider("Offset Y", 0.5), l = A.inValueSlider("Rotate", 0), u = A.inValueSlider("r", 1), c = A.inValueSlider("g", 1), h = A.inValueSlider("b", 1);
  const p = A.outTrigger("trigger");
  u.setUiAttribs({ colorPick: true });
  const d = A.patch.cgl;
  const m = new CGL.Shader(d, A.name, A);
  m.setSource(m.getDefaultVertexShader(), e.wave_v2_frag);
  const f = new CGL.Uniform(m, "t", "tex", 0), D = new CGL.Uniform(m, "f", "amount", i), y = new CGL.Uniform(m, "f", "r", u), b = new CGL.Uniform(m, "f", "g", c), N = new CGL.Uniform(m, "f", "b", h), S = new CGL.Uniform(m, "f", "uAmp", o), w = new CGL.Uniform(m, "f", "uFreq", C), R = new CGL.Uniform(m, "f", "uWidth", a), G = new CGL.Uniform(m, "f", "uGlow", r), _ = new CGL.Uniform(m, "f", "uWaveSelect", 1), F = new CGL.Uniform(m, "b", "uInvert", s), M = new CGL.Uniform(m, "b", "uSolid", B), L = new CGL.Uniform(m, "f", "uOffSetX", Q), v = new CGL.Uniform(m, "f", "uOffSetY", E), O = new CGL.Uniform(m, "f", "uRotate", l);
  n.onChange = s.onChange = U;
  U();
  function U() {
    m.toggleDefine("SINE", n.get() == "Sine");
    m.toggleDefine("SAWTOOTH", n.get() == "Sawtooth");
    m.toggleDefine("TRIANGLE", n.get() == "Triangle");
    m.toggleDefine("SQUARE", n.get() == "Square");
    m.toggleDefine("INVERT", s.get());
  }
  CGL.TextureEffect.setupBlending(A, m, g, i, I);
  t.onTriggered = function() {
    if (!CGL.TextureEffect.checkOpInEffect(A, 3))
      return;
    d.pushShader(m);
    d.currentTextureEffect.bind();
    d.setTexture(0, d.currentTextureEffect.getCurrentSourceTexture().tex);
    d.currentTextureEffect.finish();
    d.popShader();
    p.trigger();
  };
};
Ops.Gl.ImageCompose.Waveform_v3.prototype = new CABLES.Op();
CABLES.OPS["fce7d8bc-5a2e-49b8-8f55-8ab8784493d5"] = { f: Ops.Gl.ImageCompose.Waveform_v3, objName: "Ops.Gl.ImageCompose.Waveform_v3" };
Ops.Gl.GradientTexture = function() {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const A = t.attachments = {};
  const N = t.inGradient("Gradient"), S = t.inValueSelect("Direction", ["X", "Y", "XY", "YX", "Radial"], "X"), w = t.inValueBool("Smoothstep", false), R = t.inBool("Step", false), G = t.inBool("Flip", false), _ = t.inBool("sRGB", false), F = t.inBool("Oklab", false), M = t.inValueInt("Size", 256), U = t.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"), L = t.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"), g = t.inArray("Gradient Array"), e = t.inTriggerButton("Randomize Colors"), v = t.outTexture("Texture"), O = t.outArray("Colors", null, 3), k = t.outArray("Colors Pos", null, 1);
  const x = t.patch.cgl;
  let i = null;
  N.setUiAttribs({ editShortcut: true });
  L.onChange = U.onChange = R.onChange = G.onChange = _.onChange = F.onChange = M.onChange = N.onChange = w.onChange = S.onChange = g.onChange = I;
  N.set('{"keys" : [{"pos":0,"r":0,"g":0,"b":0},{"pos":1,"r":1,"g":1,"b":1}]}');
  t.onLoaded = I;
  e.onTriggered = () => {
    const A2 = o();
    if (A2) {
      A2.forEach((A3) => {
        A3.r = Math.random();
        A3.g = Math.random();
        A3.b = Math.random();
      });
      const e2 = JSON.stringify({ keys: A2 });
      N.set(e2);
    }
  };
  function T(A2, e2, t2) {
    let g2 = 0.4122214708 * A2 + 0.5363325363 * e2 + 0.0514459929 * t2;
    let i2 = 0.2119034982 * A2 + 0.6806995451 * e2 + 0.1073969566 * t2;
    let I2 = 0.0883024619 * A2 + 0.2817188376 * e2 + 0.6299787005 * t2;
    g2 = Math.cbrt(g2);
    i2 = Math.cbrt(i2);
    I2 = Math.cbrt(I2);
    return [g2 * 0.2104542553 + i2 * 0.793617785 + I2 * -0.0040720468, g2 * 1.9779984951 + i2 * -2.428592205 + I2 * 0.4505937099, g2 * 0.0259040371 + i2 * 0.7827717662 + I2 * -0.808675766];
  }
  function J(A2, e2, t2) {
    let g2 = A2 + e2 * 0.3963377774 + t2 * 0.2158037573;
    let i2 = A2 + e2 * -0.1055613458 + t2 * -0.0638541728;
    let I2 = A2 + e2 * -0.0894841775 + t2 * -1.291485548;
    g2 **= 3;
    i2 **= 3;
    I2 **= 3;
    let n2 = g2 * 4.0767416621 + i2 * -3.3077115913 + I2 * 0.2309699292;
    let o2 = g2 * -1.2684380046 + i2 * 2.6097574011 + I2 * -0.3413193965;
    let C2 = g2 * -0.0041960863 + i2 * -0.7034186147 + I2 * 1.707614701;
    n2 = CABLES.clamp(n2, 0, 1);
    o2 = CABLES.clamp(o2, 0, 1);
    C2 = CABLES.clamp(C2, 0, 1);
    return [n2, o2, C2];
  }
  function Y(A2, e2, t2) {
    A2 /= 255;
    const g2 = 31308e-7;
    let i2 = 12.92 * A2;
    let I2 = 1.055 * Math.pow(A2, 0.41666) - 0.055;
    return (A2 < g2 ? i2 : I2) * 255;
  }
  function I() {
    x.addNextFrameOnceCallback(n);
  }
  function n() {
    const A2 = o();
    if (A2)
      C(A2);
  }
  function o() {
    let e2 = null;
    t.setUiError("nodata", null);
    t.setUiError("parse", null);
    if (Array.isArray(g.get())) {
      e2 = g.get();
    } else {
      let A2 = null;
      if (!N.get() || N.get() === "") {
        return null;
      }
      try {
        A2 = JSON.parse(N.get());
      } catch (A3) {
        t.setUiError("parse", "could not parse gradient data");
      }
      if (!A2 || !A2.keys) {
        t.setUiError("nodata", "gradient no data");
        return null;
      }
      e2 = A2.keys;
    }
    return e2;
  }
  function C(e2) {
    let i2 = Math.round(M.get());
    if (i2 < 4)
      i2 = 4;
    N.setUiAttribs({ editShortcut: true, gradEditSmoothstep: w.get(), gradEditStep: R.get(), gradOklab: F.get() });
    let A2 = 0;
    let t2 = 0;
    if (L.get() == "repeat")
      A2 = CGL.Texture.WRAP_REPEAT;
    else if (L.get() == "mirrored repeat")
      A2 = CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (L.get() == "clamp to edge")
      A2 = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    if (U.get() == "nearest")
      t2 = CGL.Texture.FILTER_NEAREST;
    else if (U.get() == "linear")
      t2 = CGL.Texture.FILTER_LINEAR;
    else if (U.get() == "mipmap")
      t2 = CGL.Texture.FILTER_MIPMAP;
    const g2 = new CGL.Texture(x);
    let I2 = new Uint8Array(i2 * 4);
    for (let A3 = 0; A3 < e2.length - 1; A3++) {
      const C2 = e2[A3];
      const a = e2[A3 + 1];
      for (let t3 = C2.pos * i2; t3 < a.pos * i2; t3++) {
        let A4 = CABLES.map(t3, C2.pos * i2, a.pos * i2, 0, 1);
        if (R.get())
          A4 = Math.round(A4);
        if (w.get())
          A4 = CABLES.smoothStep(A4);
        t3 = Math.round(t3);
        let e3 = t3;
        if (G.get())
          e3 = i2 - t3 - 1;
        if (F.get()) {
          const r = T(C2.r, C2.g, C2.b);
          const s = r[0];
          const B = r[1];
          const Q = r[2];
          const E = T(a.r, a.g, a.b);
          const l = E[0];
          const u = E[1];
          const c = E[2];
          const h = A4 * l + (1 - A4) * s;
          const p = A4 * u + (1 - A4) * B;
          const d = A4 * c + (1 - A4) * Q;
          const m = J(h, p, d);
          I2[e3 * 4 + 0] = Math.round(m[0] * 255);
          I2[e3 * 4 + 1] = Math.round(m[1] * 255);
          I2[e3 * 4 + 2] = Math.round(m[2] * 255);
        } else {
          I2[e3 * 4 + 0] = Math.round((A4 * a.r + (1 - A4) * C2.r) * 255);
          I2[e3 * 4 + 1] = Math.round((A4 * a.g + (1 - A4) * C2.g) * 255);
          I2[e3 * 4 + 2] = Math.round((A4 * a.b + (1 - A4) * C2.b) * 255);
        }
        if (typeof C2.a !== "undefined" && typeof a.a !== "undefined") {
          const f = Math.round((A4 * a.a + (1 - A4) * C2.a) * 255);
          I2[e3 * 4 + 3] = f;
        } else {
          I2[e3 * 4 + 3] = Math.round(255);
        }
      }
    }
    if (_.get())
      for (let A3 = 0; A3 < I2.length; A3 += 4) {
        I2[A3 + 0] = Y(I2[A3 + 0]);
        I2[A3 + 1] = Y(I2[A3 + 1]);
        I2[A3 + 2] = Y(I2[A3 + 2]);
      }
    if (S.get() == "X")
      g2.initFromData(I2, i2, 1, t2, A2);
    if (S.get() == "Y")
      g2.initFromData(I2, 1, i2, t2, A2);
    if (S.get() == "Radial") {
      const D = new Uint8Array(i2 * i2 * 4);
      for (let g3 = 0; g3 < i2; g3++) {
        for (let t3 = 0; t3 < i2; t3++) {
          const y = g3 - (i2 - 1) / 2;
          const b = t3 - (i2 - 1) / 2;
          let A3 = Math.sqrt(y * y + b * b) / i2 * 2;
          if (w.get())
            A3 = CABLES.smoothStep(A3);
          let e3 = Math.round(A3 * i2) * 4;
          if (e3 >= i2 * 4)
            e3 = i2 * 4 - 4;
          D[g3 * 4 + t3 * 4 * i2 + 0] = I2[e3 + 0];
          D[g3 * 4 + t3 * 4 * i2 + 1] = I2[e3 + 1];
          D[g3 * 4 + t3 * 4 * i2 + 2] = I2[e3 + 2];
          D[g3 * 4 + t3 * 4 * i2 + 3] = Math.round(255);
        }
      }
      I2 = D;
      g2.initFromData(I2, i2, i2, t2, A2);
    }
    if (S.get() == "XY" || S.get() == "YX") {
      const D = new Uint8Array(i2 * i2 * 4);
      for (let g3 = 0; g3 < i2; g3++) {
        let t3 = g3;
        if (S.get() == "YX")
          t3 = i2 - g3 - 1;
        for (let e3 = 0; e3 < i2; e3++) {
          let A3 = Math.round((t3 + e3) / 2) * 4;
          D[g3 * 4 + e3 * 4 * i2 + 0] = I2[A3 + 0];
          D[g3 * 4 + e3 * 4 * i2 + 1] = I2[A3 + 1];
          D[g3 * 4 + e3 * 4 * i2 + 2] = I2[A3 + 2];
          D[g3 * 4 + e3 * 4 * i2 + 3] = Math.round(255);
        }
      }
      I2 = D;
      g2.initFromData(I2, i2, i2, t2, A2);
    }
    const n2 = [];
    for (let A3 = 0; A3 < e2.length - 1; A3++) {
      n2.push(e2[A3].r, e2[A3].g, e2[A3].b);
    }
    const o2 = [];
    for (let A3 = 0; A3 < e2.length - 1; A3++) {
      o2.push(e2[A3].pos);
    }
    O.set(n2);
    k.set(o2);
    v.setRef(g2);
  }
};
Ops.Gl.GradientTexture.prototype = new CABLES.Op();
CABLES.OPS["01380a50-2dbb-4465-ae80-86349b0b717a"] = { f: Ops.Gl.GradientTexture, objName: "Ops.Gl.GradientTexture" };
Ops.Math.SmoothStep_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.outNumber("result"), g = A.inValueFloat("number", 0), i = A.inValueFloat("min", 0), I = A.inValueFloat("max", 1);
  g.onChange = I.onChange = i.onChange = n;
  n();
  function n() {
    let A2 = Math.max(0, Math.min(1, (g.get() - i.get()) / (I.get() - i.get())));
    t.set(A2 * A2 * (3 - 2) * (I.get() - i.get()));
  }
};
Ops.Math.SmoothStep_v2.prototype = new CABLES.Op();
CABLES.OPS["b5c41eea-ac30-4ac7-9481-eefe42e8199c"] = { f: Ops.Math.SmoothStep_v2, objName: "Ops.Math.SmoothStep_v2" };
Ops.Gl.ImageCompose.RotateTexture_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { rotate_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D multiplierTex;\nUNI float amount;\nUNI float resX;\nUNI float resY;\nUNI float rotate;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n\nvoid pR(inout vec2 p, float a)\n{\n	p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid main()\n{\n    float multiplier = 0.0;\n\n    #ifdef ROTATE_TEXTURE\n        multiplier = dot(vec3(0.2126,0.7152,0.0722), texture(multiplierTex,texCoord).rgb);\n    #endif\n\n    vec2 uv = texCoord;\n    vec2 res = vec2(resX,resY);\n    uv -= 0.5;\n    pR(uv.xy,(rotate + multiplier) * (TAU)  );\n    uv += 0.5;\n\n\n\n    vec4 col=texture(tex,uv);\n    vec4 base=texture(tex,texCoord);\n\n    #ifdef CLEAR\n        base.a=0.0;\n    #endif\n\n\n    #ifdef CROP_IMAGE\n    if(uv.x>1.0 ||uv.x<0.0  || uv.y>1.0 ||uv.y<0.0 )\n    {\n        base.a=0.0;\n        col.a=0.0;\n        // discard;\n        // return;\n    }\n    #endif\n\n    outColor=cgl_blendPixel(base,col,amount);\n}" };
  const t = A.inTrigger("render"), g = A.inTexture("Multiplier"), i = CGL.TextureEffect.AddBlendSelect(A, "Blend Mode", "normal"), I = A.inValueSlider("Amount", 1), n = A.inValueSlider("Rotate", 0.125), o = A.inValueBool("Crop", true), C = A.inBool("Clear", true), a = A.outTrigger("trigger");
  const r = A.patch.cgl;
  const s = new CGL.Shader(r, A.name, A);
  s.setSource(s.getDefaultVertexShader(), e.rotate_frag);
  const B = new CGL.Uniform(s, "t", "tex", 0), Q = new CGL.Uniform(s, "t", "multiplierTex", 1), E = new CGL.Uniform(s, "f", "amount", I), l = new CGL.Uniform(s, "f", "rotate", n);
  CGL.TextureEffect.setupBlending(A, s, i, I);
  o.onChange = g.onChange = u;
  u();
  function u() {
    s.toggleDefine("CLEAR", C.get());
    s.toggleDefine("CROP_IMAGE", o.get());
    s.toggleDefine("ROTATE_TEXTURE", g.isLinked());
  }
  t.onTriggered = function() {
    if (!CGL.TextureEffect.checkOpInEffect(A, 3))
      return;
    r.pushShader(s);
    r.currentTextureEffect.bind();
    r.setTexture(0, r.currentTextureEffect.getCurrentSourceTexture().tex);
    if (g.get())
      r.setTexture(1, g.get().tex);
    r.currentTextureEffect.finish();
    r.popShader();
    a.trigger();
  };
};
Ops.Gl.ImageCompose.RotateTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["20b8a2e6-2419-474b-98a4-71a5e3178631"] = { f: Ops.Gl.ImageCompose.RotateTexture_v2, objName: "Ops.Gl.ImageCompose.RotateTexture_v2" };
Ops.Gl.ImageCompose.SkewStretchImage_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { invert_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float stretchTopX;\nUNI float stretchBotX;\nUNI float stretchLeft;\nUNI float stretchRight;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n\n    vec2 tc=texCoord;\n\n    #ifdef SMOOTHSTEP\n        tc.y=smoothstep(0.,1.,tc.y);\n        tc.x=smoothstep(0.,1.,tc.x);\n    #endif\n\n    vec2 tcnorm=texCoord;\n\n    tcnorm-=0.5;\n    tcnorm*=2.0;\n\n    tcnorm.x=mix(tcnorm.x*stretchBotX,tcnorm.x,tc.y);\n    tcnorm.x=mix(tcnorm.x*stretchTopX,tcnorm.x,1.0-tc.y);\n\n    tcnorm.y=mix(tcnorm.y*stretchLeft,tcnorm.y,tc.x);\n    tcnorm.y=mix(tcnorm.y*stretchRight,tcnorm.y,1.0-tc.x);\n\n    tc=tcnorm/2.0+0.5;\n\n    col=texture(tex,tc);\n\n    #ifdef CLAMP\n        if(tc.x<0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0) col=vec4(0.0,0.0,0.0,0.0);\n    #endif\n\n    vec4 base=texture(tex,texCoord);\n    base.a=0.0;\n\n    outColor=cgl_blendPixel(base,col,amount);\n}\n" };
  const t = A.inTrigger("render"), g = CGL.TextureEffect.AddBlendSelect(A, "Blend Mode", "normal"), i = A.inValueSlider("Amount", 1), I = A.inBool("Clamp", true), n = A.outTrigger("trigger");
  const o = A.patch.cgl;
  const C = new CGL.Shader(o, "skewstrechimage");
  C.setSource(C.getDefaultVertexShader(), e.invert_frag);
  const a = new CGL.Uniform(C, "t", "tex", 0);
  const r = new CGL.Uniform(C, "f", "amount", i);
  C.addUniformFrag("f", "stretchTopX", A.inFloat("Stretch Top", 1));
  C.addUniformFrag("f", "stretchBotX", A.inFloat("Stretch Bottom", 1));
  C.addUniformFrag("f", "stretchLeft", A.inFloat("Stretch Left", 1));
  C.addUniformFrag("f", "stretchRight", A.inFloat("Stretch Right", 1));
  CGL.TextureEffect.setupBlending(A, C, g, i);
  I.onChange = s;
  s();
  function s() {
    C.toggleDefine("CLAMP", I.get());
  }
  t.onTriggered = function() {
    if (!CGL.TextureEffect.checkOpInEffect(A, 3))
      return;
    o.pushShader(C);
    o.currentTextureEffect.bind();
    o.setTexture(0, o.currentTextureEffect.getCurrentSourceTexture().tex);
    o.currentTextureEffect.finish();
    o.popShader();
    n.trigger();
  };
};
Ops.Gl.ImageCompose.SkewStretchImage_v2.prototype = new CABLES.Op();
CABLES.OPS["665bbc0c-2fd7-4683-a1df-e57d8f17da93"] = { f: Ops.Gl.ImageCompose.SkewStretchImage_v2, objName: "Ops.Gl.ImageCompose.SkewStretchImage_v2" };
Ops.Gl.ImageCompose.Mix = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { mix_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D tex1;\nUNI sampler2D tex2;\nUNI float fade;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n    vec4 col1=texture(tex1,texCoord);\n    vec4 col2=texture(tex2,texCoord);\n\n    col=mix(col1,col2,fade);\n\n    outColor= col;\n}\n" };
  const t = A.inTrigger("Render"), g = A.inTexture("Texture 1"), i = A.inFloatSlider("Fade", 0), I = A.inTexture("Texture 2"), n = A.outTrigger("trigger");
  const o = A.patch.cgl;
  const C = new CGL.Shader(o, A.name, A);
  C.setSource(C.getDefaultVertexShader(), e.mix_frag);
  const a = new CGL.Uniform(C, "t", "tex1", 0), r = new CGL.Uniform(C, "t", "tex1", 1), s = new CGL.Uniform(C, "t", "tex2", 2), B = new CGL.Uniform(C, "f", "fade", i);
  I.onLinkChanged = g.onLinkChanged = Q;
  Q();
  function Q() {
  }
  t.onTriggered = function() {
    if (!CGL.TextureEffect.checkOpInEffect(A))
      return;
    o.pushShader(C);
    o.currentTextureEffect.bind();
    o.setTexture(0, o.currentTextureEffect.getCurrentSourceTexture().tex);
    if (I.get())
      o.setTexture(1, I.get().tex);
    if (g.get())
      o.setTexture(2, g.get().tex);
    o.currentTextureEffect.finish();
    o.popShader();
    n.trigger();
  };
};
Ops.Gl.ImageCompose.Mix.prototype = new CABLES.Op();
CABLES.OPS["dbd68d4d-60ff-427f-8a76-c931fb8bb59b"] = { f: Ops.Gl.ImageCompose.Mix, objName: "Ops.Gl.ImageCompose.Mix" };
Ops.Gl.ImageCompose.LensDirt_v2 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { lensDirt_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float uOffsetX;\nUNI float uOffsetY;\nUNI float uZoom;\n// UNI int uIterations;\nUNI int uRandomSeed;\nUNI float uSpotEdge;\nUNI float uGamma;\nUNI float uAspect;\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n\n// https://www.shadertoy.com/view/MdfBRX\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n///  2 out, 2 in... from https://www.shadertoy.com/view/4djSRW\n//stable\nvec2 hash22(vec2 p)\n{\n	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy)*2.0-1.0;\n\n}\nvec3 dirt(vec2 uv, float n,float density,float hardness)\n{\n    n *= density;\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash22(st);\n    float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2,\n                    abs(rnd.y * 0.35) + 0.3, 0.25 + rnd.x * rnd.y * hardness);\n\n    return vec3(c) * exp(rnd.x * 4.0);\n}\n\nvoid main()\n{\n	vec3 di = vec3(1.0);\n    float edgeHardness = 0.1;\n    edgeHardness = clamp(uSpotEdge*0.25,0.0,0.2);\n\n    vec2 uv = (texCoord-0.5);\n\n    uv.y/=uAspect;\n    uv *= uZoom;\n    uv -= vec2(uOffsetX,uOffsetY);\n\n    float q = 0.0;\n    for (int i = 1; i < ITERATIONS ; i++)\n    {\n        q = float(i);\n        vec2 h=hash22(vec2(q)+vec2(uRandomSeed));\n        di += dirt(uv-h, h.x, 1.0, edgeHardness);\n    }\n\n    di = pow(di* 0.01,vec3(uGamma));\n    vec4 col = vec4(di,1.0);\n    vec4 base = texture(tex,texCoord);\n\n    outColor = cgl_blendPixel(base,col,amount);\n}" };
  const t = A.inTrigger("render"), g = CGL.TextureEffect.AddBlendSelect(A, "Blend Mode", "normal"), i = A.inValueSlider("Amount", 1), I = CGL.TextureEffect.AddBlendAlphaMask(A), n = A.inFloat("Offset X", 0), o = A.inFloat("Offset Y", 0), C = A.inFloat("Zoom", 5), a = A.inInt("Iterations", 50), r = A.inInt("Seed", 1), s = A.inFloatSlider("Spot edge", 0.5), B = A.inFloat("Gamma", 0.75), Q = A.outTrigger("trigger");
  const E = A.patch.cgl;
  const l = new CGL.Shader(E, A.name, A);
  l.setSource(l.getDefaultVertexShader(), e.lensDirt_frag);
  const u = new CGL.Uniform(l, "t", "tex", 0), c = new CGL.Uniform(l, "f", "uOffsetX", n), h = new CGL.Uniform(l, "f", "uOffsetY", o), p = new CGL.Uniform(l, "f", "uZoom", C), d = new CGL.Uniform(l, "i", "uRandomSeed", r), m = new CGL.Uniform(l, "f", "uSpotEdge", s), f = new CGL.Uniform(l, "f", "uGamma", B), D = new CGL.Uniform(l, "f", "uAspect", 1), y = new CGL.Uniform(l, "f", "amount", i);
  CGL.TextureEffect.setupBlending(A, l, g, i, I);
  a.onChange = b;
  b();
  function b() {
    let A2 = a.get();
    A2 = Math.min(300, Math.max(1, A2));
    l.define("ITERATIONS", A2);
  }
  t.onTriggered = function() {
    if (!CGL.TextureEffect.checkOpInEffect(A, 3))
      return;
    E.pushShader(l);
    E.currentTextureEffect.bind();
    D.setValue(E.currentTextureEffect.getCurrentSourceTexture().width / E.currentTextureEffect.getCurrentSourceTexture().height);
    E.setTexture(0, E.currentTextureEffect.getCurrentSourceTexture().tex);
    E.currentTextureEffect.finish();
    E.popShader();
    Q.trigger();
  };
};
Ops.Gl.ImageCompose.LensDirt_v2.prototype = new CABLES.Op();
CABLES.OPS["a04156f6-f636-430f-810e-9cb27199ceeb"] = { f: Ops.Gl.ImageCompose.LensDirt_v2, objName: "Ops.Gl.ImageCompose.LensDirt_v2" };
Ops.Gl.ImageCompose.Vignette_v3 = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = { vignette_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float lensRadius1;\nUNI float aspect;\nUNI float amount;\nUNI float strength;\nUNI float sharp;\n\nUNI vec3 vcol;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    vec4 vvcol=vec4(vcol,1.0);\n    vec4 col=texture(tex,texCoord);\n    vec2 tcPos=vec2(texCoord.x,(texCoord.y-0.5)*aspect+0.5);\n    float dist = distance(tcPos, vec2(0.5,0.5));\n    float am = (1.0-smoothstep( (lensRadius1+0.5), (lensRadius1*0.99+0.5)*sharp, dist));\n\n    col=mix(col,vvcol,am*strength);\n\n    #ifndef ALPHA\n        outColor=cgl_blendPixel(base,col,amount);\n    #endif\n\n    #ifdef ALPHA\n        outColor=vec4(base.rgb,base.a*(1.0-am*strength));\n    #endif\n}\n" };
  const t = A.inTrigger("Render"), g = CGL.TextureEffect.AddBlendSelect(A, "Blend Mode", "normal"), i = CGL.TextureEffect.AddBlendAlphaMask(A), I = A.inValueSlider("Amount", 1), n = A.outTrigger("Trigger"), o = A.inValueSlider("Strength", 1), C = A.inValueSlider("Radius", 0.3), a = A.inValueSlider("Sharp", 0.25), r = A.inValue("Aspect", 1), s = A.inValueSlider("r", 0), B = A.inValueSlider("g", 0), Q = A.inValueSlider("b", 0), E = A.inBool("Alpha", false);
  s.setUiAttribs({ colorPick: true });
  const l = A.patch.cgl;
  const u = new CGL.Shader(l, "vignette");
  u.setSource(u.getDefaultVertexShader(), e.vignette_frag);
  const c = new CGL.Uniform(u, "t", "tex", 0), h = new CGL.Uniform(u, "f", "amount", I), p = new CGL.Uniform(u, "f", "lensRadius1", C), d = new CGL.Uniform(u, "f", "aspect", r), m = new CGL.Uniform(u, "f", "strength", o), f = new CGL.Uniform(u, "f", "sharp", a), D = new CGL.Uniform(u, "3f", "vcol", s, B, Q);
  CGL.TextureEffect.setupBlending(A, u, g, I, i);
  E.onChange = y;
  y();
  function y() {
    u.toggleDefine("ALPHA", E.get());
    s.setUiAttribs({ greyout: E.get() });
    B.setUiAttribs({ greyout: E.get() });
    Q.setUiAttribs({ greyout: E.get() });
  }
  t.onTriggered = function() {
    if (!CGL.TextureEffect.checkOpInEffect(A, 3))
      return;
    l.pushShader(u);
    l.currentTextureEffect.bind();
    l.setTexture(0, l.currentTextureEffect.getCurrentSourceTexture().tex);
    l.currentTextureEffect.finish();
    l.popShader();
    n.trigger();
  };
};
Ops.Gl.ImageCompose.Vignette_v3.prototype = new CABLES.Op();
CABLES.OPS["588302cb-f5a7-4129-90d2-ba66212d69e5"] = { f: Ops.Gl.ImageCompose.Vignette_v3, objName: "Ops.Gl.ImageCompose.Vignette_v3" };
Ops.Ui.Routing.RouteNumber = function() {
  CABLES.Op.apply(this, arguments);
  const A = this;
  const e = A.attachments = {};
  const t = A.inValueFloat("value"), g = A.outNumber("result");
  t.onChange = I;
  let i = false;
  A.setUiAttribs({ display: "reroute" });
  function I() {
    g.set(t.get());
  }
};
Ops.Ui.Routing.RouteNumber.prototype = new CABLES.Op();
CABLES.OPS["afff634a-b581-4449-b6f7-9ec7863c5d4d"] = { f: Ops.Ui.Routing.RouteNumber, objName: "Ops.Ui.Routing.RouteNumber" };
window.addEventListener("load", function(A) {
  CABLES.jsLoaded = new Event("CABLES.jsLoaded");
  document.dispatchEvent(CABLES.jsLoaded);
});
DracoWASMWrapperCode = `var $jscomp = $jscomp || {}; $jscomp.scope = {}, $jscomp.arrayIteratorImpl = function (t) { let e = 0; return function () { return e < t.length ? { "done": !1, "value": t[e++] } : { "done": !0 }; }; }, $jscomp.arrayIterator = function (t) { return { "next": $jscomp.arrayIteratorImpl(t) }; }, $jscomp.makeIterator = function (t) { let e = typeof Symbol != "undefined" && Symbol.iterator && t[Symbol.iterator]; return e ? e.call(t) : $jscomp.arrayIterator(t); }, $jscomp.ASSUME_ES5 = !1, $jscomp.ASSUME_NO_NATIVE_MAP = !1, $jscomp.ASSUME_NO_NATIVE_SET = !1, $jscomp.SIMPLE_FROUND_POLYFILL = !1, $jscomp.ISOLATE_POLYFILLS = !1, $jscomp.FORCE_POLYFILL_PROMISE = !1, $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1, $jscomp.getGlobal = function (t) { t = [typeof globalThis == "object" && globalThis, t, typeof window == "object" && window, typeof self == "object" && self, typeof global == "object" && global]; for (let e = 0; e < t.length; ++e) { let r = t[e]; if (r && r.Math == Math) return r; } throw Error("Cannot find global object"); }, $jscomp.global = $jscomp.getGlobal(this), $jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function (t, e, r) { return t == Array.prototype || t == Object.prototype ? t : (t[e] = r.value, t); }, $jscomp.IS_SYMBOL_NATIVE = typeof Symbol == "function" && typeof Symbol("x") == "symbol", $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE, $jscomp.polyfills = {}, $jscomp.propertyToPolyfillSymbol = {}, $jscomp.POLYFILL_PREFIX = "$jscp$"; let $jscomp$lookupPolyfilledValue = function (t, e) { let r = $jscomp.propertyToPolyfillSymbol[e]; return r == null ? t[e] : void 0 !== (r = t[r]) ? r : t[e]; }; $jscomp.polyfill = function (t, e, r, n) { e && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(t, e, r, n) : $jscomp.polyfillUnisolated(t, e, r, n)); }, $jscomp.polyfillUnisolated = function (t, e, r, n) { for (r = $jscomp.global, t = t.split("."), n = 0; n < t.length - 1; n++) { let e = t[n]; if (!(e in r)) return; r = r[e]; }(e = e(n = r[t = t[t.length - 1]])) != n && e != null && $jscomp.defineProperty(r, t, { "configurable": !0, "writable": !0, "value": e }); }, $jscomp.polyfillIsolated = function (t, e, r, n) { let o = t.split("."); t = o.length === 1, n = o[0], n = !t && n in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global; for (let t = 0; t < o.length - 1; t++) { let e = o[t]; if (!(e in n)) return; n = n[e]; }o = o[o.length - 1], (e = e(r = $jscomp.IS_SYMBOL_NATIVE && r === "es6" ? n[o] : null)) != null && (t ? $jscomp.defineProperty($jscomp.polyfills, o, { "configurable": !0, "writable": !0, "value": e }) : e !== r && (void 0 === $jscomp.propertyToPolyfillSymbol[o] && (r = 1e9 * Math.random() >>> 0, $jscomp.propertyToPolyfillSymbol[o] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(o) : $jscomp.POLYFILL_PREFIX + r + "$" + o), $jscomp.defineProperty(n, $jscomp.propertyToPolyfillSymbol[o], { "configurable": !0, "writable": !0, "value": e }))); }, $jscomp.polyfill("Promise", function (t)
{
    function e() { this.batch_ = null; }

    function r(t) { return t instanceof o ? t : new o(function (e, r) { e(t); }); }

    if (t && (!($jscomp.FORCE_POLYFILL_PROMISE || $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && void 0 === $jscomp.global.PromiseRejectionEvent) || !$jscomp.global.Promise || $jscomp.global.Promise.toString().indexOf("[native code]") === -1)) return t; e.prototype.asyncExecute = function (t) { if (this.batch_ == null) { this.batch_ = []; let t = this; this.asyncExecuteFunction(function () { t.executeBatch_(); }); } this.batch_.push(t); }; let n = $jscomp.global.setTimeout; e.prototype.asyncExecuteFunction = function (t) { n(t, 0); }, e.prototype.executeBatch_ = function ()
    {
        for (;this.batch_ && this.batch_.length;)
        {
            let t = this.batch_; this.batch_ = []; for (let e = 0; e < t.length; ++e)
            {
                let r = t[e]; t[e] = null; try { r(); }
                catch (t) { this.asyncThrow_(t); }
            }
        } this.batch_ = null;
    }, e.prototype.asyncThrow_ = function (t) { this.asyncExecuteFunction(function () { throw t; }); }; var o = function (t)
    {
        this.state_ = 0, this.result_ = void 0, this.onSettledCallbacks_ = [], this.isRejectionHandled_ = !1; let e = this.createResolveAndReject_(); try { t(e.resolve, e.reject); }
        catch (t) { e.reject(t); }
    }; o.prototype.createResolveAndReject_ = function ()
    {
        function t(t) { return function (n) { r || (r = !0, t.call(e, n)); }; }

        var e = this, r = !1; return { "resolve": t(this.resolveTo_), "reject": t(this.reject_) };
    }, o.prototype.resolveTo_ = function (t) { if (t === this) this.reject_(new TypeError("A Promise cannot resolve to itself")); else if (t instanceof o) this.settleSameAsPromise_(t); else { switch (typeof t) { case "object": var e = t != null; break; case "function": e = !0; break; default: e = !1; }e ? this.resolveToNonPromiseObj_(t) : this.fulfill_(t); } }, o.prototype.resolveToNonPromiseObj_ = function (t)
    {
        let e = void 0; try { e = t.then; }
        catch (t) { return void this.reject_(t); } typeof e == "function" ? this.settleSameAsThenable_(e, t) : this.fulfill_(t);
    }, o.prototype.reject_ = function (t) { this.settle_(2, t); }, o.prototype.fulfill_ = function (t) { this.settle_(1, t); }, o.prototype.settle_ = function (t, e) { if (this.state_ != 0) throw Error("Cannot settle(" + t + ", " + e + "): Promise already settled in state" + this.state_); this.state_ = t, this.result_ = e, this.state_ === 2 && this.scheduleUnhandledRejectionCheck_(), this.executeOnSettledCallbacks_(); }, o.prototype.scheduleUnhandledRejectionCheck_ = function () { let t = this; n(function () { if (t.notifyUnhandledRejection_()) { let e = $jscomp.global.console; void 0 !== e && e.error(t.result_); } }, 1); }, o.prototype.notifyUnhandledRejection_ = function () { if (this.isRejectionHandled_) return !1; let t = $jscomp.global.CustomEvent, e = $jscomp.global.Event, r = $jscomp.global.dispatchEvent; return void 0 === r || (typeof t == "function" ? t = new t("unhandledrejection", { "cancelable": !0 }) : typeof e == "function" ? t = new e("unhandledrejection", { "cancelable": !0 }) : (t = $jscomp.global.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection", !1, !0, t), t.promise = this, t.reason = this.result_, r(t)); }, o.prototype.executeOnSettledCallbacks_ = function () { if (this.onSettledCallbacks_ != null) { for (let t = 0; t < this.onSettledCallbacks_.length; ++t)_.asyncExecute(this.onSettledCallbacks_[t]); this.onSettledCallbacks_ = null; } }; var _ = new e(); return o.prototype.settleSameAsPromise_ = function (t) { let e = this.createResolveAndReject_(); t.callWhenSettled_(e.resolve, e.reject); }, o.prototype.settleSameAsThenable_ = function (t, e)
    {
        let r = this.createResolveAndReject_(); try { t.call(e, r.resolve, r.reject); }
        catch (t) { r.reject(t); }
    }, o.prototype.then = function (t, e)
    {
        function r(t, e)
        {
            return typeof t == "function" ? function (e)
            {
                try { n(t(e)); }
                catch (t) { _(t); }
            } : e;
        }

        let n, _, i = new o(function (t, e) { n = t, _ = e; }); return this.callWhenSettled_(r(t, n), r(e, _)), i;
    }, o.prototype.catch = function (t) { return this.then(void 0, t); }, o.prototype.callWhenSettled_ = function (t, e)
    {
        function r() { switch (n.state_) { case 1: t(n.result_); break; case 2: e(n.result_); break; default: throw Error("Unexpected state: " + n.state_); } }

        var n = this; this.onSettledCallbacks_ == null ? _.asyncExecute(r) : this.onSettledCallbacks_.push(r), this.isRejectionHandled_ = !0;
    }, o.resolve = r, o.reject = function (t) { return new o(function (e, r) { r(t); }); }, o.race = function (t) { return new o(function (e, n) { for (let o = $jscomp.makeIterator(t), _ = o.next(); !_.done; _ = o.next())r(_.value).callWhenSettled_(e, n); }); }, o.all = function (t)
    {
        let e = $jscomp.makeIterator(t), n = e.next(); return n.done ? r([]) : new o(function (t, o)
        {
            function _(e) { return function (r) { i[e] = r, --p == 0 && t(i); }; }

            var i = [], p = 0; do { i.push(void 0), p++, r(n.value).callWhenSettled_(_(i.length - 1), o), n = e.next(); } while (!n.done);
        });
    }, o;
}, "es6", "es3"), $jscomp.polyfill("Array.prototype.copyWithin", function (t)
{
    function e(t) { return 1 / 0 === (t = Number(t)) || -1 / 0 === t ? t : 0 | t; }

    return t || function (t, r, n) { let o = this.length; if (t = e(t), r = e(r), n = void 0 === n ? o : e(n), t = t < 0 ? Math.max(o + t, 0) : Math.min(t, o), r = r < 0 ? Math.max(o + r, 0) : Math.min(r, o), n = n < 0 ? Math.max(o + n, 0) : Math.min(n, o), t < r) for (;r < n;)r in this ? this[t++] = this[r++] : (delete this[t++], r++); else for (t += (n = Math.min(n, o + r - t)) - r; n > r;)--n in this ? this[--t] = this[n] : delete this[--t]; return this; };
}, "es6", "es3"), $jscomp.typedArrayCopyWithin = function (t) { return t || Array.prototype.copyWithin; }, $jscomp.polyfill("Int8Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Uint8Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Uint8ClampedArray.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Int16Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Uint16Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Int32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Uint32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Float32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"), $jscomp.polyfill("Float64Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5"); let DracoDecoderModule = (function ()
{
    let t = typeof document != "undefined" && document.currentScript ? document.currentScript.src : void 0; return typeof __filename != "undefined" && (t = t || __filename), function (e)
    {
        function r(t, e) { t || i("Assertion failed: " + e); }

        function n(t, e, r)
        {
            let n = e + r; for (r = e; t[r] && !(r >= n);)++r; if (r - e > 16 && t.subarray && st) return st.decode(t.subarray(e, r)); for (n = ""; e < r;)
            {
                let r = t[e++]; if (128 & r) { let o = 63 & t[e++]; if ((224 & r) == 192)n += String.fromCharCode((31 & r) << 6 | o); else { let _ = 63 & t[e++]; (r = (240 & r) == 224 ? (15 & r) << 12 | o << 6 | _ : (7 & r) << 18 | o << 12 | _ << 6 | 63 & t[e++]) < 65536 ? n += String.fromCharCode(r) : (r -= 65536, n += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)); } }
                else n += String.fromCharCode(r);
            } return n;
        }

        function o(t, e) { return t ? n(it, t, e) : ""; }

        function _(t) { ot = t, w.HEAP8 = _t = new Int8Array(t), w.HEAP16 = new Int16Array(t), w.HEAP32 = pt = new Int32Array(t), w.HEAPU8 = it = new Uint8Array(t), w.HEAPU16 = new Uint16Array(t), w.HEAPU32 = new Uint32Array(t), w.HEAPF32 = new Float32Array(t), w.HEAPF64 = new Float64Array(t); }

        function i(t) { throw w.onAbort && w.onAbort(t), et(t += ""), at = !0, t = new WebAssembly.RuntimeError("abort(" + t + "). Build with -s ASSERTIONS=1 for more info."), $(t), t; }

        function p(t, e) { return String.prototype.startsWith ? t.startsWith(e) : t.indexOf(e) === 0; }

        function c(t)
        {
            try { if (t == Tt && rt) return new Uint8Array(rt); if (Z) return Z(t); throw "both async and sync fetching of the wasm failed"; }
            catch (t) { i(t); }
        }

        function a(t) { for (;t.length > 0;) { let e = t.shift(); if (typeof e == "function")e(w); else { let t = e.func; typeof t == "number" ? void 0 === e.arg ? ct.get(t)() : ct.get(t)(e.arg) : t(void 0 === e.arg ? null : e.arg); } } }

        function s(t) { this.excPtr = t, this.ptr = t - Dt.SIZE, this.set_type = function (t) { pt[this.ptr + Dt.TYPE_OFFSET >> 2] = t; }, this.get_type = function () { return pt[this.ptr + Dt.TYPE_OFFSET >> 2]; }, this.set_destructor = function (t) { pt[this.ptr + Dt.DESTRUCTOR_OFFSET >> 2] = t; }, this.get_destructor = function () { return pt[this.ptr + Dt.DESTRUCTOR_OFFSET >> 2]; }, this.set_refcount = function (t) { pt[this.ptr + Dt.REFCOUNT_OFFSET >> 2] = t; }, this.set_caught = function (t) { _t[this.ptr + Dt.CAUGHT_OFFSET >> 0] = t ? 1 : 0; }, this.get_caught = function () { return _t[this.ptr + Dt.CAUGHT_OFFSET >> 0] != 0; }, this.set_rethrown = function (t) { _t[this.ptr + Dt.RETHROWN_OFFSET >> 0] = t ? 1 : 0; }, this.get_rethrown = function () { return _t[this.ptr + Dt.RETHROWN_OFFSET >> 0] != 0; }, this.init = function (t, e) { this.set_type(t), this.set_destructor(e), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1); }, this.add_ref = function () { pt[this.ptr + Dt.REFCOUNT_OFFSET >> 2] += 1; }, this.release_ref = function () { let t = pt[this.ptr + Dt.REFCOUNT_OFFSET >> 2]; return pt[this.ptr + Dt.REFCOUNT_OFFSET >> 2] = t - 1, t === 1; }; }

        function u(t)
        {
            function e() { if (!pn && (pn = !0, w.calledRun = !0, !at)) { if (mt = !0, a(lt), a(yt), v(w), w.onRuntimeInitialized && w.onRuntimeInitialized(), w.postRun) for (typeof w.postRun == "function" && (w.postRun = [w.postRun]); w.postRun.length;)ft.unshift(w.postRun.shift()); a(ft); } }

            if (!(dt > 0)) { if (w.preRun) for (typeof w.preRun == "function" && (w.preRun = [w.preRun]); w.preRun.length;)ut.unshift(w.preRun.shift()); a(ut), dt > 0 || (w.setStatus ? (w.setStatus("Running..."), setTimeout(function () { setTimeout(function () { w.setStatus(""); }, 1), e(); }, 1)) : e()); }
        }

        function l() {}

        function y(t) { return (t || l).__cache__; }

        function f(t, e) { let r = y(e), n = r[t]; return n || ((n = Object.create((e || l).prototype)).ptr = t, r[t] = n); }

        function m(t)
        {
            if (typeof t == "string")
            {
                for (var e = 0, r = 0; r < t.length; ++r) { var n = t.charCodeAt(r); n >= 55296 && n <= 57343 && (n = 65536 + ((1023 & n) << 10) | 1023 & t.charCodeAt(++r)), n <= 127 ? ++e : e = n <= 2047 ? e + 2 : n <= 65535 ? e + 3 : e + 4; } if (r = 0, (n = (e = Array(e + 1)).length) > 0)
                {
                    n = r + n - 1; for (let o = 0; o < t.length; ++o)
                    {
                        let _ = t.charCodeAt(o); if (_ >= 55296 && _ <= 57343) { _ = 65536 + ((1023 & _) << 10) | 1023 & t.charCodeAt(++o); } if (_ <= 127) { if (r >= n) break; e[r++] = _; }
                        else
                        {
                            if (_ <= 2047) { if (r + 1 >= n) break; e[r++] = 192 | _ >> 6; }
                            else
                            {
                                if (_ <= 65535) { if (r + 2 >= n) break; e[r++] = 224 | _ >> 12; }
                                else { if (r + 3 >= n) break; e[r++] = 240 | _ >> 18, e[r++] = 128 | _ >> 12 & 63; }e[r++] = 128 | _ >> 6 & 63;
                            }e[r++] = 128 | 63 & _;
                        }
                    }e[r] = 0;
                } return t = cn.alloc(e, _t), cn.copy(e, _t, t), t;
            } return t;
        }

        function d(t) { if (typeof t == "object") { let e = cn.alloc(t, _t); return cn.copy(t, _t, e), e; } return t; }

        function b() { throw "cannot construct a VoidPtr, no constructor in IDL"; }

        function h() { this.ptr = Ot(), y(h)[this.ptr] = this; }

        function A() { this.ptr = St(), y(A)[this.ptr] = this; }

        function T() { this.ptr = Nt(), y(T)[this.ptr] = this; }

        function D() { this.ptr = Mt(), y(D)[this.ptr] = this; }

        function I() { this.ptr = kt(), y(I)[this.ptr] = this; }

        function j() { this.ptr = Xt(), y(j)[this.ptr] = this; }

        function E() { this.ptr = te(), y(E)[this.ptr] = this; }

        function O() { this.ptr = oe(), y(O)[this.ptr] = this; }

        function G() { this.ptr = ae(), y(G)[this.ptr] = this; }

        function R() { throw "cannot construct a Status, no constructor in IDL"; }

        function S() { this.ptr = me(), y(S)[this.ptr] = this; }

        function P() { this.ptr = Ae(), y(P)[this.ptr] = this; }

        function F() { this.ptr = je(), y(F)[this.ptr] = this; }

        function N() { this.ptr = Re(), y(N)[this.ptr] = this; }

        function U() { this.ptr = Ne(), y(U)[this.ptr] = this; }

        function M() { this.ptr = Ce(), y(M)[this.ptr] = this; }

        function g() { this.ptr = we(), y(g)[this.ptr] = this; }

        function C() { this.ptr = We(), y(C)[this.ptr] = this; }

        function L() { this.ptr = Ze(), y(L)[this.ptr] = this; }

        var v, $, w = void 0 !== (e = e || {}) ? e : {}; w.ready = new Promise(function (t, e) { v = t, $ = e; }); let z = !1, V = !1; w.onRuntimeInitialized = function () { z = !0, w.callRuntimeCallbacks(w.mainCallbacks), V && typeof w.onModuleLoaded == "function" && w.onModuleLoaded(w); }, w.onModuleParsed = function () { V = !0, z && typeof w.onModuleLoaded == "function" && w.onModuleLoaded(w); }, w.isVersionSupported = function (t) { return typeof t == "string" && (!((t = t.split(".")).length < 2 || t.length > 3) && (t[0] == 1 && t[1] >= 0 && t[1] <= 4 || !(t[0] != 0 || t[1] > 10))); }; let B, W = {}; for (B in w)w.hasOwnProperty(B) && (W[B] = w[B]); let k, Q, H = !1, x = !1; H = typeof window == "object", x = typeof importScripts == "function", k = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", Q = !H && !k && !x; let Y, q, X = ""; if (k) { X = x ? require("path").dirname(X) + "/" : __dirname + "/"; var K = function (t, e) { return Y || (Y = require("fs")), q || (q = require("path")), t = q.normalize(t), Y.readFileSync(t, e ? null : "utf8"); }, Z = function (t) { return (t = K(t, !0)).buffer || (t = new Uint8Array(t)), r(t.buffer), t; }; process.argv.length > 1 && process.argv[1].replace(/\\\\/g, "/"), process.argv.slice(2), w.inspect = function () { return "[Emscripten Module object]"; }; }
        else if (Q) typeof read != "undefined" && (K = function (t) { return read(t); }), Z = function (t) { return typeof readbuffer == "function" ? new Uint8Array(readbuffer(t)) : (r(typeof (t = read(t, "binary")) == "object"), t); }, typeof print != "undefined" && (typeof console == "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr != "undefined" ? printErr : print); else if (H || x) { x ? X = self.location.href : typeof document != "undefined" && document.currentScript && (X = document.currentScript.src), t && (X = t), X = X.indexOf("blob:") !== 0 ? X.substr(0, X.lastIndexOf("/") + 1) : "", K = function (t) { let e = new XMLHttpRequest(); return e.open("GET", t, !1), e.send(null), e.responseText; }, x && (Z = function (t) { let e = new XMLHttpRequest(); return e.open("GET", t, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response); }); var J = function (t, e, r) { let n = new XMLHttpRequest(); n.open("GET", t, !0), n.responseType = "arraybuffer", n.onload = function () { n.status == 200 || n.status == 0 && n.response ? e(n.response) : r(); }, n.onerror = r, n.send(null); }; } var tt = w.print || console.log.bind(console), et = w.printErr || console.warn.bind(console); for (B in W)W.hasOwnProperty(B) && (w[B] = W[B]); let rt; W = null, w.wasmBinary && (rt = w.wasmBinary), typeof WebAssembly != "object" && i("no native wasm support detected"); var nt, ot, _t, it, pt, ct, at = !1, st = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0, ut = [], lt = [], yt = [], ft = [], mt = !1, dt = 0, bt = null, ht = null; w.preloadedImages = {}, w.preloadedAudios = {}; var At, Tt = "draco_decoder.wasm"; p(Tt, "data:application/octet-stream;base64,") || (At = Tt, Tt = w.locateFile ? w.locateFile(At, X) : X + At); var Dt = { "DESTRUCTOR_OFFSET": 0, "REFCOUNT_OFFSET": 4, "TYPE_OFFSET": 8, "CAUGHT_OFFSET": 12, "RETHROWN_OFFSET": 13, "SIZE": 16 }, It = { "mappings": {}, "buffers": [null, [], []], "printChar": function (t, e) { let r = It.buffers[t]; e === 0 || e === 10 ? ((t === 1 ? tt : et)(n(r, 0)), r.length = 0) : r.push(e); }, "varargs": void 0, "get": function () { return It.varargs += 4, pt[It.varargs - 4 >> 2]; }, "getStr": function (t) { return o(t); }, "get64": function (t, e) { return t; } }, jt = { "h": function (t) { return _n(t + Dt.SIZE) + Dt.SIZE; },
            "g": function (t, e, r) { throw new s(t).init(e, r), 0, t; },
            "a": function () { i(); },
            "d": function (t, e, r) { it.copyWithin(t, e, e + r); },
            "e": function (t)
            {
                let e = it.length; if ((t >>>= 0) > 2147483648) return !1; for (let n = 1; n <= 4; n *= 2)
                {
                    let o = e * (1 + 0.2 / n); o = Math.min(o, t + 100663296); let i = Math, p = i.min; (o = Math.max(t, o)) % 65536 > 0 && (o += 65536 - o % 65536), i = p.call(i, 2147483648, o); t:
                    {
                        try { nt.grow(i - ot.byteLength + 65535 >>> 16), _(nt.buffer); var r = 1; break t; }
                        catch (t) {}r = void 0;
                    } if (r) return !0;
                } return !1;
            },
            "f": function (t) { return 0; },
            "c": function (t, e, r, n, o) {},
            "b": function (t, e, r, n) { for (var o = 0, _ = 0; _ < r; _++) { for (var i = pt[e + 8 * _ >> 2], p = pt[e + (8 * _ + 4) >> 2], c = 0; c < p; c++)It.printChar(t, it[i + c]); o += p; } return pt[n >> 2] = o, 0; } }; !(function ()
        {
            function t(t, e) { w.asm = t.exports, _((nt = w.asm.i).buffer), ct = w.asm.k, lt.unshift(w.asm.j), dt--, w.monitorRunDependencies && w.monitorRunDependencies(dt), dt == 0 && (bt !== null && (clearInterval(bt), bt = null), ht && (t = ht, ht = null, t())); }

            function e(e) { t(e.instance); }

            function r(t) { return (function () { if (!rt && (H || x)) { if (typeof fetch == "function" && !p(Tt, "file://")) return fetch(Tt, { "credentials": "same-origin" }).then(function (t) { if (!t.ok) throw "failed to load wasm binary file at '" + Tt + "'"; return t.arrayBuffer(); }).catch(function () { return c(Tt); }); if (J) return new Promise(function (t, e) { J(Tt, function (e) { t(new Uint8Array(e)); }, e); }); } return Promise.resolve().then(function () { return c(Tt); }); }()).then(function (t) { return WebAssembly.instantiate(t, n); }).then(t, function (t) { et("failed to asynchronously prepare wasm: " + t), i(t); }); }

            var n = { "a": jt }; if (dt++, w.monitorRunDependencies && w.monitorRunDependencies(dt), w.instantiateWasm) try { return w.instantiateWasm(n, t); }
            catch (t) { return et("Module.instantiateWasm callback failed with error: " + t), !1; }(rt || typeof WebAssembly.instantiateStreaming != "function" || p(Tt, "data:application/octet-stream;base64,") || p(Tt, "file://") || typeof fetch != "function" ? r(e) : fetch(Tt, { "credentials": "same-origin" }).then(function (t) { return WebAssembly.instantiateStreaming(t, n).then(e, function (t) { return et("wasm streaming compile failed: " + t), et("falling back to ArrayBuffer instantiation"), r(e); }); })).catch($);
        }()), w.___wasm_call_ctors = function () { return (w.___wasm_call_ctors = w.asm.j).apply(null, arguments); }; var Et = w._emscripten_bind_VoidPtr___destroy___0 = function () { return (Et = w._emscripten_bind_VoidPtr___destroy___0 = w.asm.l).apply(null, arguments); }, Ot = w._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = function () { return (Ot = w._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = w.asm.m).apply(null, arguments); }, Gt = w._emscripten_bind_DecoderBuffer_Init_2 = function () { return (Gt = w._emscripten_bind_DecoderBuffer_Init_2 = w.asm.n).apply(null, arguments); }, Rt = w._emscripten_bind_DecoderBuffer___destroy___0 = function () { return (Rt = w._emscripten_bind_DecoderBuffer___destroy___0 = w.asm.o).apply(null, arguments); }, St = w._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = function () { return (St = w._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = w.asm.p).apply(null, arguments); }, Pt = w._emscripten_bind_AttributeTransformData_transform_type_0 = function () { return (Pt = w._emscripten_bind_AttributeTransformData_transform_type_0 = w.asm.q).apply(null, arguments); }, Ft = w._emscripten_bind_AttributeTransformData___destroy___0 = function () { return (Ft = w._emscripten_bind_AttributeTransformData___destroy___0 = w.asm.r).apply(null, arguments); }, Nt = w._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = function () { return (Nt = w._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = w.asm.s).apply(null, arguments); }, Ut = w._emscripten_bind_GeometryAttribute___destroy___0 = function () { return (Ut = w._emscripten_bind_GeometryAttribute___destroy___0 = w.asm.t).apply(null, arguments); }, Mt = w._emscripten_bind_PointAttribute_PointAttribute_0 = function () { return (Mt = w._emscripten_bind_PointAttribute_PointAttribute_0 = w.asm.u).apply(null, arguments); }, gt = w._emscripten_bind_PointAttribute_size_0 = function () { return (gt = w._emscripten_bind_PointAttribute_size_0 = w.asm.v).apply(null, arguments); }, Ct = w._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = function () { return (Ct = w._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = w.asm.w).apply(null, arguments); }, Lt = w._emscripten_bind_PointAttribute_attribute_type_0 = function () { return (Lt = w._emscripten_bind_PointAttribute_attribute_type_0 = w.asm.x).apply(null, arguments); }, vt = w._emscripten_bind_PointAttribute_data_type_0 = function () { return (vt = w._emscripten_bind_PointAttribute_data_type_0 = w.asm.y).apply(null, arguments); }, $t = w._emscripten_bind_PointAttribute_num_components_0 = function () { return ($t = w._emscripten_bind_PointAttribute_num_components_0 = w.asm.z).apply(null, arguments); }, wt = w._emscripten_bind_PointAttribute_normalized_0 = function () { return (wt = w._emscripten_bind_PointAttribute_normalized_0 = w.asm.A).apply(null, arguments); }, zt = w._emscripten_bind_PointAttribute_byte_stride_0 = function () { return (zt = w._emscripten_bind_PointAttribute_byte_stride_0 = w.asm.B).apply(null, arguments); }, Vt = w._emscripten_bind_PointAttribute_byte_offset_0 = function () { return (Vt = w._emscripten_bind_PointAttribute_byte_offset_0 = w.asm.C).apply(null, arguments); }, Bt = w._emscripten_bind_PointAttribute_unique_id_0 = function () { return (Bt = w._emscripten_bind_PointAttribute_unique_id_0 = w.asm.D).apply(null, arguments); }, Wt = w._emscripten_bind_PointAttribute___destroy___0 = function () { return (Wt = w._emscripten_bind_PointAttribute___destroy___0 = w.asm.E).apply(null, arguments); }, kt = w._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = function () { return (kt = w._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = w.asm.F).apply(null, arguments); }, Qt = w._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = function () { return (Qt = w._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = w.asm.G).apply(null, arguments); }, Ht = w._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = function () { return (Ht = w._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = w.asm.H).apply(null, arguments); }, xt = w._emscripten_bind_AttributeQuantizationTransform_min_value_1 = function () { return (xt = w._emscripten_bind_AttributeQuantizationTransform_min_value_1 = w.asm.I).apply(null, arguments); }, Yt = w._emscripten_bind_AttributeQuantizationTransform_range_0 = function () { return (Yt = w._emscripten_bind_AttributeQuantizationTransform_range_0 = w.asm.J).apply(null, arguments); }, qt = w._emscripten_bind_AttributeQuantizationTransform___destroy___0 = function () { return (qt = w._emscripten_bind_AttributeQuantizationTransform___destroy___0 = w.asm.K).apply(null, arguments); }, Xt = w._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = function () { return (Xt = w._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = w.asm.L).apply(null, arguments); }, Kt = w._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = function () { return (Kt = w._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = w.asm.M).apply(null, arguments); }, Zt = w._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = function () { return (Zt = w._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = w.asm.N).apply(null, arguments); }, Jt = w._emscripten_bind_AttributeOctahedronTransform___destroy___0 = function () { return (Jt = w._emscripten_bind_AttributeOctahedronTransform___destroy___0 = w.asm.O).apply(null, arguments); }, te = w._emscripten_bind_PointCloud_PointCloud_0 = function () { return (te = w._emscripten_bind_PointCloud_PointCloud_0 = w.asm.P).apply(null, arguments); }, ee = w._emscripten_bind_PointCloud_num_attributes_0 = function () { return (ee = w._emscripten_bind_PointCloud_num_attributes_0 = w.asm.Q).apply(null, arguments); }, re = w._emscripten_bind_PointCloud_num_points_0 = function () { return (re = w._emscripten_bind_PointCloud_num_points_0 = w.asm.R).apply(null, arguments); }, ne = w._emscripten_bind_PointCloud___destroy___0 = function () { return (ne = w._emscripten_bind_PointCloud___destroy___0 = w.asm.S).apply(null, arguments); }, oe = w._emscripten_bind_Mesh_Mesh_0 = function () { return (oe = w._emscripten_bind_Mesh_Mesh_0 = w.asm.T).apply(null, arguments); }, _e = w._emscripten_bind_Mesh_num_faces_0 = function () { return (_e = w._emscripten_bind_Mesh_num_faces_0 = w.asm.U).apply(null, arguments); }, ie = w._emscripten_bind_Mesh_num_attributes_0 = function () { return (ie = w._emscripten_bind_Mesh_num_attributes_0 = w.asm.V).apply(null, arguments); }, pe = w._emscripten_bind_Mesh_num_points_0 = function () { return (pe = w._emscripten_bind_Mesh_num_points_0 = w.asm.W).apply(null, arguments); }, ce = w._emscripten_bind_Mesh___destroy___0 = function () { return (ce = w._emscripten_bind_Mesh___destroy___0 = w.asm.X).apply(null, arguments); }, ae = w._emscripten_bind_Metadata_Metadata_0 = function () { return (ae = w._emscripten_bind_Metadata_Metadata_0 = w.asm.Y).apply(null, arguments); }, se = w._emscripten_bind_Metadata___destroy___0 = function () { return (se = w._emscripten_bind_Metadata___destroy___0 = w.asm.Z).apply(null, arguments); }, ue = w._emscripten_bind_Status_code_0 = function () { return (ue = w._emscripten_bind_Status_code_0 = w.asm._).apply(null, arguments); }, le = w._emscripten_bind_Status_ok_0 = function () { return (le = w._emscripten_bind_Status_ok_0 = w.asm.$).apply(null, arguments); }, ye = w._emscripten_bind_Status_error_msg_0 = function () { return (ye = w._emscripten_bind_Status_error_msg_0 = w.asm.aa).apply(null, arguments); }, fe = w._emscripten_bind_Status___destroy___0 = function () { return (fe = w._emscripten_bind_Status___destroy___0 = w.asm.ba).apply(null, arguments); }, me = w._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = function () { return (me = w._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = w.asm.ca).apply(null, arguments); }, de = w._emscripten_bind_DracoFloat32Array_GetValue_1 = function () { return (de = w._emscripten_bind_DracoFloat32Array_GetValue_1 = w.asm.da).apply(null, arguments); }, be = w._emscripten_bind_DracoFloat32Array_size_0 = function () { return (be = w._emscripten_bind_DracoFloat32Array_size_0 = w.asm.ea).apply(null, arguments); }, he = w._emscripten_bind_DracoFloat32Array___destroy___0 = function () { return (he = w._emscripten_bind_DracoFloat32Array___destroy___0 = w.asm.fa).apply(null, arguments); }, Ae = w._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = function () { return (Ae = w._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = w.asm.ga).apply(null, arguments); }, Te = w._emscripten_bind_DracoInt8Array_GetValue_1 = function () { return (Te = w._emscripten_bind_DracoInt8Array_GetValue_1 = w.asm.ha).apply(null, arguments); }, De = w._emscripten_bind_DracoInt8Array_size_0 = function () { return (De = w._emscripten_bind_DracoInt8Array_size_0 = w.asm.ia).apply(null, arguments); }, Ie = w._emscripten_bind_DracoInt8Array___destroy___0 = function () { return (Ie = w._emscripten_bind_DracoInt8Array___destroy___0 = w.asm.ja).apply(null, arguments); }, je = w._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = function () { return (je = w._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = w.asm.ka).apply(null, arguments); }, Ee = w._emscripten_bind_DracoUInt8Array_GetValue_1 = function () { return (Ee = w._emscripten_bind_DracoUInt8Array_GetValue_1 = w.asm.la).apply(null, arguments); }, Oe = w._emscripten_bind_DracoUInt8Array_size_0 = function () { return (Oe = w._emscripten_bind_DracoUInt8Array_size_0 = w.asm.ma).apply(null, arguments); }, Ge = w._emscripten_bind_DracoUInt8Array___destroy___0 = function () { return (Ge = w._emscripten_bind_DracoUInt8Array___destroy___0 = w.asm.na).apply(null, arguments); }, Re = w._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = function () { return (Re = w._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = w.asm.oa).apply(null, arguments); }, Se = w._emscripten_bind_DracoInt16Array_GetValue_1 = function () { return (Se = w._emscripten_bind_DracoInt16Array_GetValue_1 = w.asm.pa).apply(null, arguments); }, Pe = w._emscripten_bind_DracoInt16Array_size_0 = function () { return (Pe = w._emscripten_bind_DracoInt16Array_size_0 = w.asm.qa).apply(null, arguments); }, Fe = w._emscripten_bind_DracoInt16Array___destroy___0 = function () { return (Fe = w._emscripten_bind_DracoInt16Array___destroy___0 = w.asm.ra).apply(null, arguments); }, Ne = w._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = function () { return (Ne = w._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = w.asm.sa).apply(null, arguments); }, Ue = w._emscripten_bind_DracoUInt16Array_GetValue_1 = function () { return (Ue = w._emscripten_bind_DracoUInt16Array_GetValue_1 = w.asm.ta).apply(null, arguments); }, Me = w._emscripten_bind_DracoUInt16Array_size_0 = function () { return (Me = w._emscripten_bind_DracoUInt16Array_size_0 = w.asm.ua).apply(null, arguments); }, ge = w._emscripten_bind_DracoUInt16Array___destroy___0 = function () { return (ge = w._emscripten_bind_DracoUInt16Array___destroy___0 = w.asm.va).apply(null, arguments); }, Ce = w._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = function () { return (Ce = w._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = w.asm.wa).apply(null, arguments); }, Le = w._emscripten_bind_DracoInt32Array_GetValue_1 = function () { return (Le = w._emscripten_bind_DracoInt32Array_GetValue_1 = w.asm.xa).apply(null, arguments); }, ve = w._emscripten_bind_DracoInt32Array_size_0 = function () { return (ve = w._emscripten_bind_DracoInt32Array_size_0 = w.asm.ya).apply(null, arguments); }, $e = w._emscripten_bind_DracoInt32Array___destroy___0 = function () { return ($e = w._emscripten_bind_DracoInt32Array___destroy___0 = w.asm.za).apply(null, arguments); }, we = w._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = function () { return (we = w._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = w.asm.Aa).apply(null, arguments); }, ze = w._emscripten_bind_DracoUInt32Array_GetValue_1 = function () { return (ze = w._emscripten_bind_DracoUInt32Array_GetValue_1 = w.asm.Ba).apply(null, arguments); }, Ve = w._emscripten_bind_DracoUInt32Array_size_0 = function () { return (Ve = w._emscripten_bind_DracoUInt32Array_size_0 = w.asm.Ca).apply(null, arguments); }, Be = w._emscripten_bind_DracoUInt32Array___destroy___0 = function () { return (Be = w._emscripten_bind_DracoUInt32Array___destroy___0 = w.asm.Da).apply(null, arguments); }, We = w._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = function () { return (We = w._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = w.asm.Ea).apply(null, arguments); }, ke = w._emscripten_bind_MetadataQuerier_HasEntry_2 = function () { return (ke = w._emscripten_bind_MetadataQuerier_HasEntry_2 = w.asm.Fa).apply(null, arguments); }, Qe = w._emscripten_bind_MetadataQuerier_GetIntEntry_2 = function () { return (Qe = w._emscripten_bind_MetadataQuerier_GetIntEntry_2 = w.asm.Ga).apply(null, arguments); }, He = w._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = function () { return (He = w._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = w.asm.Ha).apply(null, arguments); }, xe = w._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = function () { return (xe = w._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = w.asm.Ia).apply(null, arguments); }, Ye = w._emscripten_bind_MetadataQuerier_GetStringEntry_2 = function () { return (Ye = w._emscripten_bind_MetadataQuerier_GetStringEntry_2 = w.asm.Ja).apply(null, arguments); }, qe = w._emscripten_bind_MetadataQuerier_NumEntries_1 = function () { return (qe = w._emscripten_bind_MetadataQuerier_NumEntries_1 = w.asm.Ka).apply(null, arguments); }, Xe = w._emscripten_bind_MetadataQuerier_GetEntryName_2 = function () { return (Xe = w._emscripten_bind_MetadataQuerier_GetEntryName_2 = w.asm.La).apply(null, arguments); }, Ke = w._emscripten_bind_MetadataQuerier___destroy___0 = function () { return (Ke = w._emscripten_bind_MetadataQuerier___destroy___0 = w.asm.Ma).apply(null, arguments); }, Ze = w._emscripten_bind_Decoder_Decoder_0 = function () { return (Ze = w._emscripten_bind_Decoder_Decoder_0 = w.asm.Na).apply(null, arguments); }, Je = w._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = function () { return (Je = w._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = w.asm.Oa).apply(null, arguments); }, tr = w._emscripten_bind_Decoder_DecodeArrayToMesh_3 = function () { return (tr = w._emscripten_bind_Decoder_DecodeArrayToMesh_3 = w.asm.Pa).apply(null, arguments); }, er = w._emscripten_bind_Decoder_GetAttributeId_2 = function () { return (er = w._emscripten_bind_Decoder_GetAttributeId_2 = w.asm.Qa).apply(null, arguments); }, rr = w._emscripten_bind_Decoder_GetAttributeIdByName_2 = function () { return (rr = w._emscripten_bind_Decoder_GetAttributeIdByName_2 = w.asm.Ra).apply(null, arguments); }, nr = w._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = function () { return (nr = w._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = w.asm.Sa).apply(null, arguments); }, or = w._emscripten_bind_Decoder_GetAttribute_2 = function () { return (or = w._emscripten_bind_Decoder_GetAttribute_2 = w.asm.Ta).apply(null, arguments); }, _r = w._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = function () { return (_r = w._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = w.asm.Ua).apply(null, arguments); }, ir = w._emscripten_bind_Decoder_GetMetadata_1 = function () { return (ir = w._emscripten_bind_Decoder_GetMetadata_1 = w.asm.Va).apply(null, arguments); }, pr = w._emscripten_bind_Decoder_GetAttributeMetadata_2 = function () { return (pr = w._emscripten_bind_Decoder_GetAttributeMetadata_2 = w.asm.Wa).apply(null, arguments); }, cr = w._emscripten_bind_Decoder_GetFaceFromMesh_3 = function () { return (cr = w._emscripten_bind_Decoder_GetFaceFromMesh_3 = w.asm.Xa).apply(null, arguments); }, ar = w._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = function () { return (ar = w._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = w.asm.Ya).apply(null, arguments); }, sr = w._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = function () { return (sr = w._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = w.asm.Za).apply(null, arguments); }, ur = w._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = function () { return (ur = w._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = w.asm._a).apply(null, arguments); }, lr = w._emscripten_bind_Decoder_GetAttributeFloat_3 = function () { return (lr = w._emscripten_bind_Decoder_GetAttributeFloat_3 = w.asm.$a).apply(null, arguments); }, yr = w._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = function () { return (yr = w._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = w.asm.ab).apply(null, arguments); }, fr = w._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = function () { return (fr = w._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = w.asm.bb).apply(null, arguments); }, mr = w._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = function () { return (mr = w._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = w.asm.cb).apply(null, arguments); }, dr = w._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = function () { return (dr = w._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = w.asm.db).apply(null, arguments); }, br = w._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = function () { return (br = w._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = w.asm.eb).apply(null, arguments); }, hr = w._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = function () { return (hr = w._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = w.asm.fb).apply(null, arguments); }, Ar = w._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = function () { return (Ar = w._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = w.asm.gb).apply(null, arguments); }, Tr = w._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = function () { return (Tr = w._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = w.asm.hb).apply(null, arguments); }, Dr = w._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = function () { return (Dr = w._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = w.asm.ib).apply(null, arguments); }, Ir = w._emscripten_bind_Decoder_SkipAttributeTransform_1 = function () { return (Ir = w._emscripten_bind_Decoder_SkipAttributeTransform_1 = w.asm.jb).apply(null, arguments); }, jr = w._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = function () { return (jr = w._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = w.asm.kb).apply(null, arguments); }, Er = w._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = function () { return (Er = w._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = w.asm.lb).apply(null, arguments); }, Or = w._emscripten_bind_Decoder_DecodeBufferToMesh_2 = function () { return (Or = w._emscripten_bind_Decoder_DecodeBufferToMesh_2 = w.asm.mb).apply(null, arguments); }, Gr = w._emscripten_bind_Decoder___destroy___0 = function () { return (Gr = w._emscripten_bind_Decoder___destroy___0 = w.asm.nb).apply(null, arguments); }, Rr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = function () { return (Rr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = w.asm.ob).apply(null, arguments); }, Sr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = function () { return (Sr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = w.asm.pb).apply(null, arguments); }, Pr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = function () { return (Pr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = w.asm.qb).apply(null, arguments); }, Fr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = function () { return (Fr = w._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = w.asm.rb).apply(null, arguments); }, Nr = w._emscripten_enum_draco_GeometryAttribute_Type_INVALID = function () { return (Nr = w._emscripten_enum_draco_GeometryAttribute_Type_INVALID = w.asm.sb).apply(null, arguments); }, Ur = w._emscripten_enum_draco_GeometryAttribute_Type_POSITION = function () { return (Ur = w._emscripten_enum_draco_GeometryAttribute_Type_POSITION = w.asm.tb).apply(null, arguments); }, Mr = w._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = function () { return (Mr = w._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = w.asm.ub).apply(null, arguments); }, gr = w._emscripten_enum_draco_GeometryAttribute_Type_COLOR = function () { return (gr = w._emscripten_enum_draco_GeometryAttribute_Type_COLOR = w.asm.vb).apply(null, arguments); }, Cr = w._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = function () { return (Cr = w._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = w.asm.wb).apply(null, arguments); }, Lr = w._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = function () { return (Lr = w._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = w.asm.xb).apply(null, arguments); }, vr = w._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = function () { return (vr = w._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = w.asm.yb).apply(null, arguments); }, $r = w._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = function () { return ($r = w._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = w.asm.zb).apply(null, arguments); }, wr = w._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = function () { return (wr = w._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = w.asm.Ab).apply(null, arguments); }, zr = w._emscripten_enum_draco_DataType_DT_INVALID = function () { return (zr = w._emscripten_enum_draco_DataType_DT_INVALID = w.asm.Bb).apply(null, arguments); }, Vr = w._emscripten_enum_draco_DataType_DT_INT8 = function () { return (Vr = w._emscripten_enum_draco_DataType_DT_INT8 = w.asm.Cb).apply(null, arguments); }, Br = w._emscripten_enum_draco_DataType_DT_UINT8 = function () { return (Br = w._emscripten_enum_draco_DataType_DT_UINT8 = w.asm.Db).apply(null, arguments); }, Wr = w._emscripten_enum_draco_DataType_DT_INT16 = function () { return (Wr = w._emscripten_enum_draco_DataType_DT_INT16 = w.asm.Eb).apply(null, arguments); }, kr = w._emscripten_enum_draco_DataType_DT_UINT16 = function () { return (kr = w._emscripten_enum_draco_DataType_DT_UINT16 = w.asm.Fb).apply(null, arguments); }, Qr = w._emscripten_enum_draco_DataType_DT_INT32 = function () { return (Qr = w._emscripten_enum_draco_DataType_DT_INT32 = w.asm.Gb).apply(null, arguments); }, Hr = w._emscripten_enum_draco_DataType_DT_UINT32 = function () { return (Hr = w._emscripten_enum_draco_DataType_DT_UINT32 = w.asm.Hb).apply(null, arguments); }, xr = w._emscripten_enum_draco_DataType_DT_INT64 = function () { return (xr = w._emscripten_enum_draco_DataType_DT_INT64 = w.asm.Ib).apply(null, arguments); }, Yr = w._emscripten_enum_draco_DataType_DT_UINT64 = function () { return (Yr = w._emscripten_enum_draco_DataType_DT_UINT64 = w.asm.Jb).apply(null, arguments); }, qr = w._emscripten_enum_draco_DataType_DT_FLOAT32 = function () { return (qr = w._emscripten_enum_draco_DataType_DT_FLOAT32 = w.asm.Kb).apply(null, arguments); }, Xr = w._emscripten_enum_draco_DataType_DT_FLOAT64 = function () { return (Xr = w._emscripten_enum_draco_DataType_DT_FLOAT64 = w.asm.Lb).apply(null, arguments); }, Kr = w._emscripten_enum_draco_DataType_DT_BOOL = function () { return (Kr = w._emscripten_enum_draco_DataType_DT_BOOL = w.asm.Mb).apply(null, arguments); }, Zr = w._emscripten_enum_draco_DataType_DT_TYPES_COUNT = function () { return (Zr = w._emscripten_enum_draco_DataType_DT_TYPES_COUNT = w.asm.Nb).apply(null, arguments); }, Jr = w._emscripten_enum_draco_StatusCode_OK = function () { return (Jr = w._emscripten_enum_draco_StatusCode_OK = w.asm.Ob).apply(null, arguments); }, tn = w._emscripten_enum_draco_StatusCode_DRACO_ERROR = function () { return (tn = w._emscripten_enum_draco_StatusCode_DRACO_ERROR = w.asm.Pb).apply(null, arguments); }, en = w._emscripten_enum_draco_StatusCode_IO_ERROR = function () { return (en = w._emscripten_enum_draco_StatusCode_IO_ERROR = w.asm.Qb).apply(null, arguments); }, rn = w._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = function () { return (rn = w._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = w.asm.Rb).apply(null, arguments); }, nn = w._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = function () { return (nn = w._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = w.asm.Sb).apply(null, arguments); }, on = w._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = function () { return (on = w._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = w.asm.Tb).apply(null, arguments); }; w._free = function () { return (w._free = w.asm.Ub).apply(null, arguments); }; var _n = w._malloc = function () { return (_n = w._malloc = w.asm.Vb).apply(null, arguments); }; let pn; if (w.callRuntimeCallbacks = a, ht = function t() { pn || u(), pn || (ht = t); }, w.run = u, w.preInit) for (typeof w.preInit == "function" && (w.preInit = [w.preInit]); w.preInit.length > 0;)w.preInit.pop()(); u(), l.prototype = Object.create(l.prototype), l.prototype.constructor = l, l.prototype.__class__ = l, l.__cache__ = {}, w.WrapperObject = l, w.getCache = y, w.wrapPointer = f, w.castObject = function (t, e) { return f(t.ptr, e); }, w.NULL = f(0), w.destroy = function (t) { if (!t.__destroy__) throw "Error: Cannot destroy object. (Did you create it yourself?)"; t.__destroy__(), delete y(t.__class__)[t.ptr]; }, w.compare = function (t, e) { return t.ptr === e.ptr; }, w.getPointer = function (t) { return t.ptr; }, w.getClass = function (t) { return t.__class__; }; var cn = { "buffer": 0, "size": 0, "pos": 0, "temps": [], "needed": 0, "prepare": function () { if (cn.needed) { for (let t = 0; t < cn.temps.length; t++)w._free(cn.temps[t]); cn.temps.length = 0, w._free(cn.buffer), cn.buffer = 0, cn.size += cn.needed, cn.needed = 0; }cn.buffer || (cn.size += 128, cn.buffer = w._malloc(cn.size), r(cn.buffer)), cn.pos = 0; }, "alloc": function (t, e) { return r(cn.buffer), t = (t = t.length * e.BYTES_PER_ELEMENT) + 7 & -8, cn.pos + t >= cn.size ? (r(t > 0), cn.needed += t, e = w._malloc(t), cn.temps.push(e)) : (e = cn.buffer + cn.pos, cn.pos += t), e; }, "copy": function (t, e, r) { switch (r >>>= 0, e.BYTES_PER_ELEMENT) { case 2: r >>>= 1; break; case 4: r >>>= 2; break; case 8: r >>>= 3; } for (let n = 0; n < t.length; n++)e[r + n] = t[n]; } }; return b.prototype = Object.create(l.prototype), b.prototype.constructor = b, b.prototype.__class__ = b, b.__cache__ = {}, w.VoidPtr = b, b.prototype.__destroy__ = b.prototype.__destroy__ = function () { Et(this.ptr); }, h.prototype = Object.create(l.prototype), h.prototype.constructor = h, h.prototype.__class__ = h, h.__cache__ = {}, w.DecoderBuffer = h, h.prototype.Init = h.prototype.Init = function (t, e) { let r = this.ptr; cn.prepare(), typeof t == "object" && (t = d(t)), e && typeof e == "object" && (e = e.ptr), Gt(r, t, e); }, h.prototype.__destroy__ = h.prototype.__destroy__ = function () { Rt(this.ptr); }, A.prototype = Object.create(l.prototype), A.prototype.constructor = A, A.prototype.__class__ = A, A.__cache__ = {}, w.AttributeTransformData = A, A.prototype.transform_type = A.prototype.transform_type = function () { return Pt(this.ptr); }, A.prototype.__destroy__ = A.prototype.__destroy__ = function () { Ft(this.ptr); }, T.prototype = Object.create(l.prototype), T.prototype.constructor = T, T.prototype.__class__ = T, T.__cache__ = {}, w.GeometryAttribute = T, T.prototype.__destroy__ = T.prototype.__destroy__ = function () { Ut(this.ptr); }, D.prototype = Object.create(l.prototype), D.prototype.constructor = D, D.prototype.__class__ = D, D.__cache__ = {}, w.PointAttribute = D, D.prototype.size = D.prototype.size = function () { return gt(this.ptr); }, D.prototype.GetAttributeTransformData = D.prototype.GetAttributeTransformData = function () { return f(Ct(this.ptr), A); }, D.prototype.attribute_type = D.prototype.attribute_type = function () { return Lt(this.ptr); }, D.prototype.data_type = D.prototype.data_type = function () { return vt(this.ptr); }, D.prototype.num_components = D.prototype.num_components = function () { return $t(this.ptr); }, D.prototype.normalized = D.prototype.normalized = function () { return !!wt(this.ptr); }, D.prototype.byte_stride = D.prototype.byte_stride = function () { return zt(this.ptr); }, D.prototype.byte_offset = D.prototype.byte_offset = function () { return Vt(this.ptr); }, D.prototype.unique_id = D.prototype.unique_id = function () { return Bt(this.ptr); }, D.prototype.__destroy__ = D.prototype.__destroy__ = function () { Wt(this.ptr); }, I.prototype = Object.create(l.prototype), I.prototype.constructor = I, I.prototype.__class__ = I, I.__cache__ = {}, w.AttributeQuantizationTransform = I, I.prototype.InitFromAttribute = I.prototype.InitFromAttribute = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), !!Qt(e, t); }, I.prototype.quantization_bits = I.prototype.quantization_bits = function () { return Ht(this.ptr); }, I.prototype.min_value = I.prototype.min_value = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), xt(e, t); }, I.prototype.range = I.prototype.range = function () { return Yt(this.ptr); }, I.prototype.__destroy__ = I.prototype.__destroy__ = function () { qt(this.ptr); }, j.prototype = Object.create(l.prototype), j.prototype.constructor = j, j.prototype.__class__ = j, j.__cache__ = {}, w.AttributeOctahedronTransform = j, j.prototype.InitFromAttribute = j.prototype.InitFromAttribute = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), !!Kt(e, t); }, j.prototype.quantization_bits = j.prototype.quantization_bits = function () { return Zt(this.ptr); }, j.prototype.__destroy__ = j.prototype.__destroy__ = function () { Jt(this.ptr); }, E.prototype = Object.create(l.prototype), E.prototype.constructor = E, E.prototype.__class__ = E, E.__cache__ = {}, w.PointCloud = E, E.prototype.num_attributes = E.prototype.num_attributes = function () { return ee(this.ptr); }, E.prototype.num_points = E.prototype.num_points = function () { return re(this.ptr); }, E.prototype.__destroy__ = E.prototype.__destroy__ = function () { ne(this.ptr); }, O.prototype = Object.create(l.prototype), O.prototype.constructor = O, O.prototype.__class__ = O, O.__cache__ = {}, w.Mesh = O, O.prototype.num_faces = O.prototype.num_faces = function () { return _e(this.ptr); }, O.prototype.num_attributes = O.prototype.num_attributes = function () { return ie(this.ptr); }, O.prototype.num_points = O.prototype.num_points = function () { return pe(this.ptr); }, O.prototype.__destroy__ = O.prototype.__destroy__ = function () { ce(this.ptr); }, G.prototype = Object.create(l.prototype), G.prototype.constructor = G, G.prototype.__class__ = G, G.__cache__ = {}, w.Metadata = G, G.prototype.__destroy__ = G.prototype.__destroy__ = function () { se(this.ptr); }, R.prototype = Object.create(l.prototype), R.prototype.constructor = R, R.prototype.__class__ = R, R.__cache__ = {}, w.Status = R, R.prototype.code = R.prototype.code = function () { return ue(this.ptr); }, R.prototype.ok = R.prototype.ok = function () { return !!le(this.ptr); }, R.prototype.error_msg = R.prototype.error_msg = function () { return o(ye(this.ptr)); }, R.prototype.__destroy__ = R.prototype.__destroy__ = function () { fe(this.ptr); }, S.prototype = Object.create(l.prototype), S.prototype.constructor = S, S.prototype.__class__ = S, S.__cache__ = {}, w.DracoFloat32Array = S, S.prototype.GetValue = S.prototype.GetValue = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), de(e, t); }, S.prototype.size = S.prototype.size = function () { return be(this.ptr); }, S.prototype.__destroy__ = S.prototype.__destroy__ = function () { he(this.ptr); }, P.prototype = Object.create(l.prototype), P.prototype.constructor = P, P.prototype.__class__ = P, P.__cache__ = {}, w.DracoInt8Array = P, P.prototype.GetValue = P.prototype.GetValue = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), Te(e, t); }, P.prototype.size = P.prototype.size = function () { return De(this.ptr); }, P.prototype.__destroy__ = P.prototype.__destroy__ = function () { Ie(this.ptr); }, F.prototype = Object.create(l.prototype), F.prototype.constructor = F, F.prototype.__class__ = F, F.__cache__ = {}, w.DracoUInt8Array = F, F.prototype.GetValue = F.prototype.GetValue = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), Ee(e, t); }, F.prototype.size = F.prototype.size = function () { return Oe(this.ptr); }, F.prototype.__destroy__ = F.prototype.__destroy__ = function () { Ge(this.ptr); }, N.prototype = Object.create(l.prototype), N.prototype.constructor = N, N.prototype.__class__ = N, N.__cache__ = {}, w.DracoInt16Array = N, N.prototype.GetValue = N.prototype.GetValue = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), Se(e, t); }, N.prototype.size = N.prototype.size = function () { return Pe(this.ptr); }, N.prototype.__destroy__ = N.prototype.__destroy__ = function () { Fe(this.ptr); }, U.prototype = Object.create(l.prototype), U.prototype.constructor = U, U.prototype.__class__ = U, U.__cache__ = {}, w.DracoUInt16Array = U, U.prototype.GetValue = U.prototype.GetValue = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), Ue(e, t); }, U.prototype.size = U.prototype.size = function () { return Me(this.ptr); }, U.prototype.__destroy__ = U.prototype.__destroy__ = function () { ge(this.ptr); }, M.prototype = Object.create(l.prototype), M.prototype.constructor = M, M.prototype.__class__ = M, M.__cache__ = {}, w.DracoInt32Array = M, M.prototype.GetValue = M.prototype.GetValue = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), Le(e, t); }, M.prototype.size = M.prototype.size = function () { return ve(this.ptr); }, M.prototype.__destroy__ = M.prototype.__destroy__ = function () { $e(this.ptr); }, g.prototype = Object.create(l.prototype), g.prototype.constructor = g, g.prototype.__class__ = g, g.__cache__ = {}, w.DracoUInt32Array = g, g.prototype.GetValue = g.prototype.GetValue = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), ze(e, t); }, g.prototype.size = g.prototype.size = function () { return Ve(this.ptr); }, g.prototype.__destroy__ = g.prototype.__destroy__ = function () { Be(this.ptr); }, C.prototype = Object.create(l.prototype), C.prototype.constructor = C, C.prototype.__class__ = C, C.__cache__ = {}, w.MetadataQuerier = C, C.prototype.HasEntry = C.prototype.HasEntry = function (t, e) { let r = this.ptr; return cn.prepare(), t && typeof t == "object" && (t = t.ptr), e = e && typeof e == "object" ? e.ptr : m(e), !!ke(r, t, e); }, C.prototype.GetIntEntry = C.prototype.GetIntEntry = function (t, e) { let r = this.ptr; return cn.prepare(), t && typeof t == "object" && (t = t.ptr), e = e && typeof e == "object" ? e.ptr : m(e), Qe(r, t, e); }, C.prototype.GetIntEntryArray = C.prototype.GetIntEntryArray = function (t, e, r) { let n = this.ptr; cn.prepare(), t && typeof t == "object" && (t = t.ptr), e = e && typeof e == "object" ? e.ptr : m(e), r && typeof r == "object" && (r = r.ptr), He(n, t, e, r); }, C.prototype.GetDoubleEntry = C.prototype.GetDoubleEntry = function (t, e) { let r = this.ptr; return cn.prepare(), t && typeof t == "object" && (t = t.ptr), e = e && typeof e == "object" ? e.ptr : m(e), xe(r, t, e); }, C.prototype.GetStringEntry = C.prototype.GetStringEntry = function (t, e) { let r = this.ptr; return cn.prepare(), t && typeof t == "object" && (t = t.ptr), e = e && typeof e == "object" ? e.ptr : m(e), o(Ye(r, t, e)); }, C.prototype.NumEntries = C.prototype.NumEntries = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), qe(e, t); }, C.prototype.GetEntryName = C.prototype.GetEntryName = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), o(Xe(r, t, e)); }, C.prototype.__destroy__ = C.prototype.__destroy__ = function () { Ke(this.ptr); }, L.prototype = Object.create(l.prototype), L.prototype.constructor = L, L.prototype.__class__ = L, L.__cache__ = {}, w.Decoder = L, L.prototype.DecodeArrayToPointCloud = L.prototype.DecodeArrayToPointCloud = function (t, e, r) { let n = this.ptr; return cn.prepare(), typeof t == "object" && (t = d(t)), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), f(Je(n, t, e, r), R); }, L.prototype.DecodeArrayToMesh = L.prototype.DecodeArrayToMesh = function (t, e, r) { let n = this.ptr; return cn.prepare(), typeof t == "object" && (t = d(t)), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), f(tr(n, t, e, r), R); }, L.prototype.GetAttributeId = L.prototype.GetAttributeId = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), er(r, t, e); }, L.prototype.GetAttributeIdByName = L.prototype.GetAttributeIdByName = function (t, e) { let r = this.ptr; return cn.prepare(), t && typeof t == "object" && (t = t.ptr), e = e && typeof e == "object" ? e.ptr : m(e), rr(r, t, e); }, L.prototype.GetAttributeIdByMetadataEntry = L.prototype.GetAttributeIdByMetadataEntry = function (t, e, r) { let n = this.ptr; return cn.prepare(), t && typeof t == "object" && (t = t.ptr), e = e && typeof e == "object" ? e.ptr : m(e), r = r && typeof r == "object" ? r.ptr : m(r), nr(n, t, e, r); }, L.prototype.GetAttribute = L.prototype.GetAttribute = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), f(or(r, t, e), D); }, L.prototype.GetAttributeByUniqueId = L.prototype.GetAttributeByUniqueId = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), f(_r(r, t, e), D); }, L.prototype.GetMetadata = L.prototype.GetMetadata = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), f(ir(e, t), G); }, L.prototype.GetAttributeMetadata = L.prototype.GetAttributeMetadata = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), f(pr(r, t, e), G); }, L.prototype.GetFaceFromMesh = L.prototype.GetFaceFromMesh = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!cr(n, t, e, r); }, L.prototype.GetTriangleStripsFromMesh = L.prototype.GetTriangleStripsFromMesh = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), ar(r, t, e); }, L.prototype.GetTrianglesUInt16Array = L.prototype.GetTrianglesUInt16Array = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!sr(n, t, e, r); }, L.prototype.GetTrianglesUInt32Array = L.prototype.GetTrianglesUInt32Array = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!ur(n, t, e, r); }, L.prototype.GetAttributeFloat = L.prototype.GetAttributeFloat = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!lr(n, t, e, r); }, L.prototype.GetAttributeFloatForAllPoints = L.prototype.GetAttributeFloatForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!yr(n, t, e, r); }, L.prototype.GetAttributeIntForAllPoints = L.prototype.GetAttributeIntForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!fr(n, t, e, r); }, L.prototype.GetAttributeInt8ForAllPoints = L.prototype.GetAttributeInt8ForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!mr(n, t, e, r); }, L.prototype.GetAttributeUInt8ForAllPoints = L.prototype.GetAttributeUInt8ForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!dr(n, t, e, r); }, L.prototype.GetAttributeInt16ForAllPoints = L.prototype.GetAttributeInt16ForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!br(n, t, e, r); }, L.prototype.GetAttributeUInt16ForAllPoints = L.prototype.GetAttributeUInt16ForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!hr(n, t, e, r); }, L.prototype.GetAttributeInt32ForAllPoints = L.prototype.GetAttributeInt32ForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!Ar(n, t, e, r); }, L.prototype.GetAttributeUInt32ForAllPoints = L.prototype.GetAttributeUInt32ForAllPoints = function (t, e, r) { let n = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), !!Tr(n, t, e, r); }, L.prototype.GetAttributeDataArrayForAllPoints = L.prototype.GetAttributeDataArrayForAllPoints = function (t, e, r, n, o) { let _ = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), r && typeof r == "object" && (r = r.ptr), n && typeof n == "object" && (n = n.ptr), o && typeof o == "object" && (o = o.ptr), !!Dr(_, t, e, r, n, o); }, L.prototype.SkipAttributeTransform = L.prototype.SkipAttributeTransform = function (t) { let e = this.ptr; t && typeof t == "object" && (t = t.ptr), Ir(e, t); }, L.prototype.GetEncodedGeometryType_Deprecated = L.prototype.GetEncodedGeometryType_Deprecated = function (t) { let e = this.ptr; return t && typeof t == "object" && (t = t.ptr), jr(e, t); }, L.prototype.DecodeBufferToPointCloud = L.prototype.DecodeBufferToPointCloud = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), f(Er(r, t, e), R); }, L.prototype.DecodeBufferToMesh = L.prototype.DecodeBufferToMesh = function (t, e) { let r = this.ptr; return t && typeof t == "object" && (t = t.ptr), e && typeof e == "object" && (e = e.ptr), f(Or(r, t, e), R); }, L.prototype.__destroy__ = L.prototype.__destroy__ = function () { Gr(this.ptr); }, (function ()
        {
            function t() { w.ATTRIBUTE_INVALID_TRANSFORM = Rr(), w.ATTRIBUTE_NO_TRANSFORM = Sr(), w.ATTRIBUTE_QUANTIZATION_TRANSFORM = Pr(), w.ATTRIBUTE_OCTAHEDRON_TRANSFORM = Fr(), w.INVALID = Nr(), w.POSITION = Ur(), w.NORMAL = Mr(), w.COLOR = gr(), w.TEX_COORD = Cr(), w.GENERIC = Lr(), w.INVALID_GEOMETRY_TYPE = vr(), w.POINT_CLOUD = $r(), w.TRIANGULAR_MESH = wr(), w.DT_INVALID = zr(), w.DT_INT8 = Vr(), w.DT_UINT8 = Br(), w.DT_INT16 = Wr(), w.DT_UINT16 = kr(), w.DT_INT32 = Qr(), w.DT_UINT32 = Hr(), w.DT_INT64 = xr(), w.DT_UINT64 = Yr(), w.DT_FLOAT32 = qr(), w.DT_FLOAT64 = Xr(), w.DT_BOOL = Kr(), w.DT_TYPES_COUNT = Zr(), w.OK = Jr(), w.DRACO_ERROR = tn(), w.IO_ERROR = en(), w.INVALID_PARAMETER = rn(), w.UNSUPPORTED_VERSION = nn(), w.UNKNOWN_VERSION = on(); }

            mt ? t() : yt.unshift(t);
        }()), w.mainCallbacks = yt, typeof w.onModuleParsed == "function" && w.onModuleParsed(), w.Decoder.prototype.GetEncodedGeometryType = function (t) { if (t.__class__ && t.__class__ === w.DecoderBuffer) return w.Decoder.prototype.GetEncodedGeometryType_Deprecated(t); if (t.byteLength < 8) return w.INVALID_GEOMETRY_TYPE; switch (t[7]) { case 0: return w.POINT_CLOUD; case 1: return w.TRIANGULAR_MESH; default: return w.INVALID_GEOMETRY_TYPE; } }, e.ready;
    };
}()); typeof exports == "object" && typeof module == "object" ? module.exports = DracoDecoderModule : typeof define == "function" && define.amd ? define([], function () { return DracoDecoderModule; }) : typeof exports == "object" && (exports.DracoDecoderModule = DracoDecoderModule);
`;
DracoDecoderWASM = "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BiAHSwRAIAAoAgQhASAAIAIgA2siAEEBTgR/IAEgAyAAEAogAGoFIAELNgIEDwsgACAEIAVqNgIEDwsgBARAIAAgBDYCBCAEEAggAEEANgIIIABCADcCAEEAIQULAkAgA0F/TA0AIAYgBUEBdSICIAIgBkkbQf////8DIAVBAnVB/////wFJGyICQYCAgIAETw0AIAAgAkECdCIEEAkiAjYCACAAIAI2AgQgACACIARqNgIIIAAgA0EBTgR/IAIgASADEAogA2oFIAILNgIEDwsQDAALBgAQgwEACwQAQQELawICfwF+AkAgAEEFSw0AIAIpAxAiBSACKQMIWQ0AIAIoAgAgBadqLQAAIQMgAiAFQgF8NwMQIAEgA0GAAXEEfyAAQQFqIAEgAhAVRQ0BIANB/wBxIAEoAgBBB3RyBSADCzYCAEEBIQQLIAQLeQEDfyAALQAMIQMCQCAAKAIIIgFB/x9LDQAgACgCBCICQQFIDQAgACACQQFrIgI2AgQgACgCACACai0AACABQQh0ciEBCyAAQQAgA2tB/wFxIgAgAUEIdmwiAyABQf8BcSICaiABIAAgA2prIAAgAksiABs2AgggAAtDAQN/AkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAUEBaiEBIABBAWohACACQQFrIgINAQwCCwsgBCAFayEDCyADC3oBAn8gAARAIAAoAlghASAAQQA2AlggAQRAIAEoAggiAgRAIAEgAjYCDCACEAgLIAEQCAsgACgCRCIBBEAgACABNgJIIAEQCAsgACgCQCEBIABBADYCQCABBEAgASgCACICBEAgASACNgIEIAIQCAsgARAICyAAEAgLC/sBAQd/IAEgACgCCCIFIAAoAgQiAmtBAnVNBEAgACABBH8gAkEAIAFBAnQiABALIABqBSACCzYCBA8LAkAgAiAAKAIAIgRrIgZBAnUiByABaiIDQYCAgIAESQRAQQAhAgJ/IAMgBSAEayIFQQF1IgggAyAISxtB/////wMgBUECdUH/////AUkbIgMEQCADQYCAgIAETw0DIANBAnQQCSECCyAHQQJ0IAJqC0EAIAFBAnQiARALIAFqIQEgBkEBTgRAIAIgBCAGEAoaCyAAIAIgA0ECdGo2AgggACABNgIEIAAgAjYCACAEBEAgBBAICw8LEAwAC0HYCxANAAv8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BEAgBCAIQwAAgB+UOAIACyABQQhqIQEgBUEBaiIFIAIgACwAGCIEIAIgBEgbSA0ACwsgAiAETA0DDAULQQEhByACIAAsABgiBCACIARIG0EBTgRAIAAoAgAiBCgCACAAKQMwIAApAyggAa1+fKdqIQEgBCgCBCEGA0AgASAGTw0FIAMgBUECdGogASoCADgCACABQQRqIQEgBUEBaiIFIAIgACwAGCIEIAIgBEgbSA0ACwsgAiAETA0CDAQLQQEhByACIAAsABgiBCACIARIG0EBTgRAIAAoAgAiBCgCACAAKQMwIAApAyggAa1+fKdqIQEgBCgCBCEGA0AgASAGTw0EIAMgBUECdGogASsDALY4AgAgAUEIaiEBIAVBAWoiBSACIAAsABgiBCACIARIG0gNAAsLIAIgBEwNAQwDC0EBIQcgAiAALAAYIgQgAiAESBtBAU4EQCAAKAIAIgYoAgAgACkDMCAAKQMoIAGtfnynaiEBA0AgASAGKAIETw0DIAMgBUECdGpDAACAP0MAAAAAIAEtAAAbOAIAIAFBAWohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQAgAyAEQQJ0akEAIAIgBGtBAnQQCxoLIAcPC0EADwsgAyAEQQJ0akEAIAIgBGtBAnQQCxpBAQt0AQF/IAJFBEAgACgCBCABKAIERg8LIAAgAUYEQEEBDwsgASgCBCICLQAAIQECQCAAKAIEIgMtAAAiAEUNACAAIAFHDQADQCACLQABIQEgAy0AASIARQ0BIAJBAWohAiADQQFqIQMgACABRg0ACwsgACABRguOAQEBfyAABEAgACgCTCIBBEAgACABNgJQIAEQCAsgAEFAaygCACIBBEAgACABNgJEIAEQCAsgACgCMCIBBEAgACABNgI0IAEQCAsgACgCGCIBBEAgACABNgIcIAEQCAsgACgCDCIBBEAgACABNgIQIAEQCAsgACgCACIBBEAgACABNgIEIAEQCAsgABAICwsuAQF/IABBADYCECAAIAAoAgAiATYCBCAAIAE2AgwgAQRAIAAgATYCBCABEAgLCwQAQQAL4ggBBH8jAEEQayIEJAAgACABNgIMIABBADYCCCAAQgA3AgAgAEEQaiIDIgJCADcCACACQgA3AAUgA0EQaiICQgA3AgAgAkIANwAFIANBIGoiAkIANwIAIAJCADcABSADQTBqIgJCADcCACACQgA3AAUgA0FAayICQgA3AgAgAkIANwAFIANB0ABqIgJCADcCACACQgA3AAUgA0HgAGoiAkIANwIAIAJCADcABSADQfAAaiICQgA3AgAgAkIANwAFIANBgAFqIgJCADcCACACQgA3AAUgA0GQAWoiAkIANwIAIAJCADcABSADQaABaiICQgA3AgAgAkIANwAFIANBsAFqIgJCADcCACACQgA3AAUgA0HAAWoiAkIANwIAIAJCADcABSADQdABaiICQgA3AgAgAkIANwAFIANB4AFqIgJCADcCACACQgA3AAUgA0HwAWoiAkIANwIAIAJCADcABSADQYACaiICQgA3AgAgAkIANwAFIANBkAJqIgJCADcCACACQgA3AAUgA0GgAmoiAkIANwIAIAJCADcABSADQbACaiICQgA3AgAgAkIANwAFIANBwAJqIgJCADcCACACQgA3AAUgA0HQAmoiAkIANwIAIAJCADcABSADQeACaiICQgA3AgAgAkIANwAFIANB8AJqIgJCADcCACACQgA3AAUgA0GAA2oiAkIANwIAIAJCADcABSADQZADaiICQgA3AgAgAkIANwAFIANBoANqIgJCADcCACACQgA3AAUgA0GwA2oiAkIANwIAIAJCADcABSADQcADaiICQgA3AgAgAkIANwAFIANB0ANqIgJCADcCACACQgA3AAUgA0HgA2oiAkIANwIAIAJCADcABSADQfADaiIDQgA3AgAgA0IANwAFIABCADcCkAQgAEIANwCVBCAAQgA3AqAEIABBADYCsAQgAEIANwKoBCAAQgA3ArQEIABBADYCxAQgAEIANwK8BCAAQgA3AsgEIABBADYC2AQgAEIANwLQBCAAQQA2AuQEIABCADcC3AQCQCABBEAgAUGAgICABE8NASAAIAFBAnQiAxAJIgI2AtwEIAAgAiADaiIFNgLkBCACQQAgAxALGiAAIAU2AuAECyAAQgA3AugEIABBADYC8AQgAQRAIAAgAUECdCIDEAkiAjYC6AQgACACIANqIgU2AvAEIAJBACADEAsaIAAgBTYC7AQLIARBADYCCCAEQgA3AwAgAQRAIAQgAUECdCIDEAkiAjYCACAEIAIgA2oiBTYCCCACQQAgAxALGiAEIAU2AgQLIABB9ARqIAFB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QANAIABBDGsiACABQQxrIgEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCABIARHDQALCyADIAYgAkEMbGo2AgggAyAFNgIEIAMgADYCACAEBEAgBBAICw8LEAwAC0H58wAQDQALIgEBfyAABEAgACgCACIBBEAgACABNgIEIAEQCAsgABAICwsYAQF/QQwQCSIAQgA3AgAgAEEANgIIIAAL2QECAn8CfgJAIAAoAkANAEEgEAkiAyICQgA3AxAgAkEANgIIIAJCADcCACACQgA3AxggACgCQCECIAAgAzYCQCACRQ0AIAIoAgAiAwRAIAIgAzYCBCADEAgLIAIQCAsgACgCQEEAAn8gACgCHEEBayICQQpNBEAgAkECdEHY7QBqKAIADAELQX8LIAAsABhsrCIEIAGtfhDiASIDBEAgACAAKAJAIgI2AgAgACACKQMQNwMIIAIpAxghBSAAQgA3AzAgACAENwMoIAAgBTcDECAAIAE2AlALIAMLnQIBCH8gAEEEaiEGAkACQCAAKAIEIgBFDQAgASgCACABIAEtAAsiBEEYdEEYdUEASCICGyEHIAEoAgQgBCACGyEDIAYhAgNAAkAgAyAAKAIUIAAtABsiASABQRh0QRh1QQBIIgkbIgggAyAISSIFGyIEBEAgAEEQaiIBKAIAIAEgCRsgByAEEBciAQ0BC0F/IAUgAyAISxshAQsgAiAAIAFBAEgbIQIgACABQR12QQRxaigCACIADQALIAIgBkYNAAJAIAIoAhQgAi0AGyIAIABBGHRBGHVBAEgiBBsiBSADIAMgBUsbIgEEQCAHIAJBEGoiACgCACAAIAQbIAEQFyIADQELIAMgBUkNAQwCCyAAQX9KDQELIAYhAgsgAgtrAgJ/AX4CQCAAQQVLDQAgAikDECIFIAIpAwhZDQAgAigCACAFp2otAAAhAyACIAVCAXw3AxAgASADQYABcQR/IABBAWogASACED5FDQEgA0H/AHEgASgCAEEHdHIFIAMLNgIAQQEhBAsgBAv8AQEHfyABIAAoAggiBSAAKAIEIgJrQQN1TQRAIAAgAQR/IAJBACABQQN0IgAQCyAAagUgAgs2AgQPCwJAIAIgACgCACIEayIGQQN1IgcgAWoiA0GAgICAAkkEQEEAIQICfyADIAUgBGsiBUECdSIIIAMgCEsbQf////8BIAVBA3VB/////wBJGyIDBEAgA0GAgICAAk8NAyADQQN0EAkhAgsgB0EDdCACagtBACABQQN0IgEQCyABaiEBIAZBAU4EQCACIAQgBhAKGgsgACACIANBA3RqNgIIIAAgATYCBCAAIAI2AgAgBARAIAQQCAsPCxAMAAtBstcAEA0AC9ACAQN/IAAoAgghASAAKAIAIQMCQCAALQAMBEACQAJAAkACQCABQX9GDQAgAUEBaiICIAFBAmsgAkEDcBsiAUF/Rg0AIAMoAgwgAUECdGooAgAiAUF/Rw0BCyAAQX82AggMAQsgACABQQFqIgIgAUECayACQQNwGyIBNgIIIAFBf0cNAQsCf0F/IAAoAgQiAkF/Rg0AGkF/QX9BAiACQQNwGyACaiICQX9GDQAaQX8gAygCDCACQQJ0aigCACICQX9GDQAaIAJBAWsgAkEDcA0AGiACQQJqCyEBIABBADoADCAAIAE2AggPCyABIAAoAgRHDQEgAEF/NgIIDwsgAAJ/QX8gAUF/Rg0AGkF/QX9BAiABQQNwGyABaiIBQX9GDQAaQX8gAygCDCABQQJ0aigCACIBQX9GDQAaIAFBAWsgAUEDcA0AGiABQQJqCzYCCAsLkgMBB38CQCAAKAIIIgEtAFQNACAAKAIQIgRFDQAgBC0AVEUNACABKAJIIQMgASgCRCECIARBADoAVAJAIAMgAmtBAnUiAyAEKAJIIAQoAkQiBWtBAnUiAksEQCAEQcQAaiADIAJrQbAPEF8gACgCCCEBDAELIAIgA00NACAEIAUgA0ECdGo2AkgLIAEtAFQNACABKAJIIAEoAkQiBGsiAUUNACABIAFBH3UiA2ogA3NBAnYgAUF/IAFBf0obIgFBASABQQFIG2wiAUEBIAFBAUsbIgJBA3EhBSAAKAIQKAJEIQNBACEBIAJBAWtBA08EQCACQXxxIQcDQCADIAFBAnQiAmogAiAEaigCADYCACADIAJBBHIiBmogBCAGaigCADYCACADIAJBCHIiBmogBCAGaigCADYCACADIAJBDHIiAmogAiAEaigCADYCACABQQRqIQEgB0EEayIHDQALCyAFRQ0AA0AgAyABQQJ0IgJqIAIgBGooAgA2AgAgAUEBaiEBIAVBAWsiBQ0ACwsgACgCEAutAwEBfwJAIAAgARAORQ0AIABBEGogARAORQ0AIABBIGogARAORQ0AIABBMGogARAORQ0AIABBQGsgARAORQ0AIABB0ABqIAEQDkUNACAAQeAAaiABEA5FDQAgAEHwAGogARAORQ0AIABBgAFqIAEQDkUNACAAQZABaiABEA5FDQAgAEGgAWogARAORQ0AIABBsAFqIAEQDkUNACAAQcABaiABEA5FDQAgAEHQAWogARAORQ0AIABB4AFqIAEQDkUNACAAQfABaiABEA5FDQAgAEGAAmogARAORQ0AIABBkAJqIAEQDkUNACAAQaACaiABEA5FDQAgAEGwAmogARAORQ0AIABBwAJqIAEQDkUNACAAQdACaiABEA5FDQAgAEHgAmogARAORQ0AIABB8AJqIAEQDkUNACAAQYADaiABEA5FDQAgAEGQA2ogARAORQ0AIABBoANqIAEQDkUNACAAQbADaiABEA5FDQAgAEHAA2ogARAORQ0AIABB0ANqIAEQDkUNACAAQeADaiABEA5FDQAgAEHwA2ogARAORQ0AIABBgARqIAEQDiECCyACC/oBAQV/IABBADYCCCAAQgA3AgACQAJAIAEEQCABQdaq1aoBTw0BIAAgAUEMbCIDEAkiATYCACAAIAE2AgQgACABIANqIgQ2AggCQCACKAIEIAIoAgAiBWsiAkUEQCABQQAgA0EMayIBIAFBDHBrQQxqEAsaDAELIAJBf0wNAyACQQJ1QQJ0IQYgAkECdkECdCEHA0AgAUEANgIIIAFCADcCACABIAIQCSIDNgIAIAEgAzYCBCABIAMgBmo2AgggASADIAUgAhAKIAdqNgIEIAFBDGoiASAERw0ACwsgACAENgIECw8LEAwACyABQQA2AgggAUIANwIAEAwAC9UDAQR/IwBBEGsiAiQAIAAgATYCDCAAQQA2AgggAEIANwIAIABBEGoiA0IANwIAIANCADcABSAAQgA3AiAgAEEANgIwIABCADcCKCAAQgA3AjQgAEEANgJEIABCADcCPCAAQgA3AkggAEEANgJYIABCADcCUCAAQQA2AmQgAEIANwJcAkAgAQRAIAFBgICAgARPDQEgACABQQJ0IgMQCSIENgJcIAAgAyAEaiIFNgJkIARBACADEAsaIAAgBTYCYAsgAEIANwJoIABBADYCcCABBEAgACABQQJ0IgMQCSIENgJoIAAgAyAEaiIFNgJwIARBACADEAsaIAAgBTYCbAsgAkEANgIIIAJCADcDACABBEAgAiABQQJ0IgMQCSIENgIAIAIgAyAEaiIFNgIIIARBACADEAsaIAIgBTYCBAsgAEH0AGogAUEFdEEBciIEIAIQQyACKAIAIgMEQCACIAM2AgQgAxAICyACQQA2AgggAkIANwMAIAEEQCACIAFBAnQiARAJIgM2AgAgAiABIANqIgU2AgggA0EAIAEQCxogAiAFNgIECyAAQYABaiAEIAIQQyACKAIAIgEEQCACIAE2AgQgARAICyACQRBqJAAgAA8LEAwAC/YBAQR/IAAoAoABIgIEQAJ/IAIgAiAAKAKEASIBRg0AGgNAIAFBDGsiBCgCACIDBEAgAUEIayADNgIAIAMQCAsgBCIBIAJHDQALIAAoAoABCyEBIAAgAjYChAEgARAICyAAKAJ0IgIEQAJ/IAIgAiAAKAJ4IgFGDQAaA0AgAUEMayIEKAIAIgMEQCABQQhrIAM2AgAgAxAICyAEIgEgAkcNAAsgACgCdAshASAAIAI2AnggARAICyAAKAJoIgEEQCAAIAE2AmwgARAICyAAKAJcIgEEQCAAIAE2AmAgARAICyAAQcgAahArIABBNGoQKyAAQSBqECsL1wMBBH8jAEEQayICJAAgACABNgIMIABBADYCCCAAQgA3AgAgAEIANwIQIABBADYCICAAQgA3AhggAEIANwIkIABBADYCNCAAQgA3AiwgAEIANwI4IABBADYCSCAAQgA3AkAgAEIANwJMIABBADYCXCAAQgA3AlQgAEEANgJoIABCADcCYAJAIAEEQCABQYCAgIAETw0BIAAgAUECdCIDEAkiBDYCYCAAIAMgBGoiBTYCaCAEQQAgAxALGiAAIAU2AmQLIABCADcCbCAAQQA2AnQgAQRAIAAgAUECdCIDEAkiBDYCbCAAIAMgBGoiBTYCdCAEQQAgAxALGiAAIAU2AnALIAJBADYCCCACQgA3AwAgAQRAIAIgAUECdCIDEAkiBDYCACACIAMgBGoiBTYCCCAEQQAgAxALGiACIAU2AgQLIABB+ABqIAFBBXRBAXIiBCACEEMgAigCACIDBEAgAiADNgIEIAMQCAsgAkEANgIIIAJCADcDACABBEAgAiABQQJ0IgEQCSIDNgIAIAIgASADaiIFNgIIIANBACABEAsaIAIgBTYCBAsgAEGEAWogBCACEEMgAigCACIBBEAgAiABNgIEIAEQCAsgAkEQaiQAIAAPCxAMAAv9AQEEfyAAKAKEASICBEACfyACIAIgACgCiAEiAUYNABoDQCABQQxrIgQoAgAiAwRAIAFBCGsgAzYCACADEAgLIAQiASACRw0ACyAAKAKEAQshASAAIAI2AogBIAEQCAsgACgCeCICBEACfyACIAIgACgCfCIBRg0AGgNAIAFBDGsiBCgCACIDBEAgAUEIayADNgIAIAMQCAsgBCIBIAJHDQALIAAoAngLIQEgACACNgJ8IAEQCAsgACgCbCIBBEAgACABNgJwIAEQCAsgACgCYCIBBEAgACABNgJkIAEQCAsgAEHMAGoQKyAAQThqECsgAEEkahArIABBEGoQKwsXACAALQAAQSBxRQRAIAEgAiAAEH4aCwtrAgJ/AX4CQCAAQQVLDQAgAikDECIFIAIpAwhZDQAgAigCACAFp2otAAAhAyACIAVCAXw3AxAgASADQYABcQR/IABBAWogASACEElFDQEgA0H/AHEgASgCAEEHdHIFIAMLNgIAQQEhBAsgBAvTAwEGfyAAKAIAIgQgAUEDdkH8////AXFqIgIgAigCAEEBIAF0cjYCACAAKAJAIQUCf0F/IAFBf0YiBg0AGkF/IAFBAWoiAyABQQJrIANBA3AbIgNBf0YNABogBSgCACADQQJ0aigCAAshAiAAKAIMIgMgAkEDdkH8////AXFqIgcgBygCAEEBIAJ0cjYCAAJAAn8gBkUEQEF/IQJBf0ECIAFBA3AbIAFqIgZBf0cEQCAFKAIAIAZBAnRqKAIAIQILIAMgAkEDdkH8////AXFqIgYgBigCAEEBIAJ0cjYCACAFKAIMIAFBAnRqKAIAIgFBf0YNAiAAQQA6ABggBCABQQN2Qfz///8BcWoiACAAKAIAQQEgAXRyNgIAQX8hAEF/IQIgAUEBaiIEIAFBAmsgBEEDcBsiBEF/RwRAIAUoAgAgBEECdGooAgAhAgsgAyACQQN2Qfz///8BcWoiBCAEKAIAQQEgAnRyNgIAQX9BAiABQQNwGyABaiIBQX9HBEAgBSgCACABQQJ0aigCACEACyADIABBA3ZB/P///wFxaiIBKAIAQQEgAHRyDAELIANB/P///wFqIQEgAygC/P///wFBgICAgHhyCyEAIAEgADYCAAsLtAIBBX8gAiABayIDQQJ1IgYgACgCCCIFIAAoAgAiBGtBAnVNBEAgASABIAAoAgQiBSAEayIDaiACIAYgA0ECdSIHSxsiA0cEQANAIAQgASgCADYCACAEQQRqIQQgAUEEaiIBIANHDQALCyAGIAdLBEAgACACIANrIgBBAU4EfyAFIAMgABAKIABqBSAFCzYCBA8LIAAgBDYCBA8LIAQEQCAAIAQ2AgQgBBAIIABBADYCCCAAQgA3AgBBACEFCwJAIANBf0wNACAGIAVBAXUiAiACIAZJG0H/////AyAFQQJ1Qf////8BSRsiAkGAgICABE8NACAAIAJBAnQiBBAJIgI2AgAgACACNgIEIAAgAiAEajYCCCAAIANBAU4EfyACIAEgAxAKIANqBSACCzYCBA8LEAwAC5UBAQF+An8CQCABRQ0AIAAvASZBgQRNBEBBACAAKQMIIAApAxAiA0IIfFMNAhogAiAAKAIAIAOnaikAADcDACAAIAApAxBCCHw3AxAMAQtBAEEBIAIgABDhAUUNARoLIABBAToAJCAAQQA2AiAgACAAKAIAIAApAxAiA6dqIgI2AhggACACIAApAwggA32najYCHEEBCwtAACAAQgA3AwggAEEANgIAIABCADcDKCAAQQk2AhwgAEEBOgAYIABC/////w83AzggAEIANwMQIABCADcDMCAAC4kBAQF/IAAoAlQiAQRAIAAgATYCWCABEAgLIAAoAkgiAQRAIAAgATYCTCABEAgLIAAoAjQiAQRAIAAgATYCOCABEAgLIAAoAigiAQRAIAAgATYCLCABEAgLIAAoAhwiAQRAIAAgATYCICABEAgLIAAoAgwiAQRAIAEQCAsgACgCACIABEAgABAICwvBAQEEfwJAIAEgACgCECAAKAIMIgNrQQJ1IgJLBEAgAEEMaiABIAJrEBkMAQsgASACTw0AIAAgAyABQQJ0ajYCEAsCQAJAIAAoAgggACgCACICa0ECdSABTw0AIAFBgICAgARPDQEgACgCBCEDIAFBAnQiBBAJIgEgBGohBCABIAMgAmsiA2ohBSADQQFOBEAgASACIAMQChoLIAAgBDYCCCAAIAU2AgQgACABNgIAIAJFDQAgAhAICw8LQbzfABANAAuIDwIMfwR+IwBBEGsiCiQAAkACQAJAAkAgACgCBC0AJEEBTQRA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1aoBIANBqtWq1QBJGyIERQ0AGiAEQdaq1aoBTw0CIARBDGwQCQsiBiADQQxsaiIDIAEpAgA3AgAgAyABKAIINgIIIAMgBUF0bUEMbGohASAFQQFOBEAgASACIAUQChoLIAAgBiAEQQxsajYCCCAAIANBDGo2AgQgACABNgIAIAIEQCACEAgLDwsQDAALQajoABANAAuUBAEDfyABIAAgAUYiAzoADAJAIAMNAANAIAEoAggiAy0ADA0BAkAgAyADKAIIIgIoAgAiBEYEQAJAIAIoAgQiBEUNACAELQAMDQAMAgsCQCABIAMoAgBGBEAgAyEBDAELIAMgAygCBCIBKAIAIgA2AgQgASAABH8gACADNgIIIAMoAggFIAILNgIIIAMoAggiACAAKAIAIANHQQJ0aiABNgIAIAEgAzYCACADIAE2AgggASgCCCECCyABQQE6AAwgAkEAOgAMIAIgAigCACIAKAIEIgE2AgAgAQRAIAEgAjYCCAsgACACKAIINgIIIAIoAggiASABKAIAIAJHQQJ0aiAANgIAIAAgAjYCBCACIAA2AggPCwJAIARFDQAgBC0ADA0ADAELAkAgASADKAIARwRAIAMhAQwBCyADIAEoAgQiADYCACABIAAEfyAAIAM2AgggAygCCAUgAgs2AgggAygCCCIAIAAoAgAgA0dBAnRqIAE2AgAgASADNgIEIAMgATYCCCABKAIIIQILIAFBAToADCACQQA6AAwgAiACKAIEIgAoAgAiATYCBCABBEAgASACNgIICyAAIAIoAgg2AgggAigCCCIBIAEoAgAgAkdBAnRqIAA2AgAgACACNgIAIAIgADYCCAwCCyAEQQxqIQEgA0EBOgAMIAIgACACRjoADCABQQE6AAAgAiIBIABHDQALCwsEAEECCyUBAX8gAEGQGDYCACAAKAIgIgEEQCAAIAE2AiQgARAICyAAEAgLtAQBCH8gASAAKAIIIgUgACgCBCIEa0ECdU0EQAJAIAFFDQAgAUECdCEGIAQhAyABQQJ0QQRrIgVBAnZBAWpBB3EiAQRAA0AgAyACKAIANgIAIANBBGohAyABQQFrIgENAAsLIAQgBmohBCAFQRxJDQADQCADIAIoAgA2AgAgAyACKAIANgIEIAMgAigCADYCCCADIAIoAgA2AgwgAyACKAIANgIQIAMgAigCADYC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EAgLIAAoAhQiAQRAIAAgATYCGCABEAgLIAAoAggiAQRAAn8gASABIAAoAgwiAkYNABoDQCACQQRrIgIoAgAhAyACQQA2AgAgAwRAIAMQGAsgASACRw0ACyAAKAIICyECIAAgATYCDCACEAgLIAAoAgQhASAAQQA2AgQgAQRAIAEQkgELIAALBABBAQsEAEF/CxQAIAAEQCAAIAAoAgAoAgQRAgALC90MBAR/AX4BfQF8AkACQAJAIANFDQACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhxBAWsOCwABAgMEBQYHCAkKCwtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQ0gAyAFQQJ0aiABLAAANgIAIAFBAWohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQoMDAtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQwgAyAFQQJ0aiABLQAANgIAIAFBAWohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQkMCwtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQsgAyAFQQJ0aiABLgEANgIAIAFBAmohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQgMCgtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQogAyAFQQJ0aiABLwEANgIAIAFBAmohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQcMCQtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQkgAyAFQQJ0aiABKAIANgIAIAFBBGohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQYMCAtBASEHIAIgACwAGCIEIAIgBEgbQQFO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AgAiBCgCACAAKQMwIAApAyggAa1+fKdqIQEgBCgCBCEGA0AgASAGTw0HIAEpAwAiCEKAgICACHxC/////w9WDQcgAyAFQQJ0aiAIPgIAIAFBCGohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQQMBgtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQYgASkDACIIQv////8HVg0GIAMgBUECdGogCD4CACABQQhqIQEgBUEBaiIFIAIgACwAGCIEIAIgBEgbSA0ACwsgAiAETA0DDAULQQEhByACIAAsABgiBCACIARIG0EBTgRAIAAoAgAiBCgCACAAKQMwIAApAyggAa1+fKdqIQEgBCgCBCEGA0AgASAGTw0FIAMgBUECdGoCfyABKgIAIgmLQwAAAE9dBEAgCagMAQtBgICAgHgLNgIAIAFBBGohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQIMBAtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQQgAyAFQQJ0agJ/IAErAwAiCplEAAAAAAAA4EFjBEAgCqoMAQtBgICAgHgLNgIAIAFBCGohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQEMAwtBASEHIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQMgAyAFQQJ0aiABLQAANgIAIAFBAWohASAFQQFqIgUgAiAALAAYIgQgAiAESBtIDQALCyACIARMDQAgAyAEQQJ0akEAIAIgBGtBAnQQCxoLIAcPC0EADwsgAyAEQQJ0akEAIAIgBGtBAnQQCxpBAQuFDQQEfwF+AX0BfAJAAkACQCADRQ0AAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcQQFrDgsAAQIDBAUGBwgJCgsLIAIgACwAGCIEIAIgBEgbQQFOBEAgACgCACIEKAIAIAApAzAgACkDKCABrX58p2ohASAEKAIEIQYDQCABIAZPDQ0gASwAACIEQQBI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ACIHQv8BVg0GIAEgA2ogBzwAACABQQFqIgEgAiAALAAYIgQgAiAESBtODQEgBUEIaiIFIAAoAgAoAgRJDQALDAULIAIgBEwNAyADIARqQQAgAiAEaxALGgwDCwJAIAIgACwAGCIEIAIgBEgbQQFIDQAgACkDMCAAKQMoIAGtfnynIgEgACgCACIEKAIEIAQoAgAiBGtODQQgASAEaiEFQQAhAQNAIAEgA2oCfyAFKgIAIghDAACAT10gCEMAAAAAYHEEQCAIqQwBC0EACzoAACABQQFqIgEgAiAALAAYIgQgAiAESBtODQEgBUEEaiIFIAAoAgAoAgRJDQALDAQLIAIgBEwNAiADIARqQQAgAiAEaxALGgwCCwJAIAIgACwAGCIEIAIgBEgbQQFIDQAgACkDMCAAKQMoIAGtfnynIgEgACgCACIEKAIEIAQoAgAiBGtODQMgASAEaiEFQQAhAQNAIAEgA2oCfyAFKwMAIglEAAAAAAAA8EFjIAlEAAAAAAAAAABmcQRAIAmrDAELQQALOgAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQhqIgUgACgCACgCBEkNAAsMAwsgAiAETA0BIAMgBGpBACACIARrEAsaDAELAkAgAiAALAAYIgQgAiAESBtBAUgNACAAKQMwIAApAyggAa1+fKciASAAKAIAIgQoAgQgBCgCACIEa04NAiABIARqIQVBACEBA0AgASADaiAFLQAAOgAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQFqIgUgACgCACgCBEkNAAsMAgsgAiAETA0AIAMgBGpBACACIARrEAsaC0EBIQYLIAYLqA8EA38BfgF9AXwCQCADRQ0AAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhxBAWsOCwABAgMEBQYHCAkKDAsCQCACIAAsABgiBCACIARIG0EBSA0AIAApAzAgACkDKCABrX58pyIBIAAoAgAiBCgCBCAEKAIAIgRrTg0MIAEgBGohBUEAIQEDQCABIANqIAUtAAA6AAAgAUEBaiIBIAIgACwAGCIEIAIgBEgbTg0BIAVBAWoiBSAAKAIAKAIESQ0ACwwMCyACIARMDQogAyAEakEAIAIgBGsQCxoMCgsCQCACIAAsABgiBCACIARIG0EBSA0AIAApAzAgACkDKCABrX58pyIBIAAoAgAiBCgCBCAEKAIAIgRrTg0LIAEgBGohBUEAIQEDQCAFLAAAIgRBAEgNDCABIANqIAQ6AAAgAUEBaiIBIAIgACwAGCIEIAIgBEgbTg0BIAVBAWoiBSAAKAIAKAIESQ0ACwwLCyACIARMDQkgAyAEakEAIAIgBGsQCxoMCQsCQCACIAAsABgiBCACIARIG0EBSA0AIAApAzAgACkDKCABrX58pyIBIAAoAgAiBCgCBCAEKAIAIgRrTg0KIAEgBGohBUEAIQEDQCAFLwEAIgRBgAFqQf//A3FB/wFLDQsgASADaiAEOgAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQJqIgUgACgCACgCBEkNAAsMCgsgAiAETA0IIAMgBGpBACACIARrEAsaDAgLAkAgAiAALAAYIgQgAiAESBtBAUgNACAAKQMwIAApAyggAa1+fKciASAAKAIAIgQoAgQgBCgCACIEa04NCSABIARqIQVBACEBA0AgBS8BACIEQf8ASw0KIAEgA2ogBDoAACABQQFqIgEgAiAALAAYIgQgAiAESBtODQEgBUECaiIFIAAoAgAoAgRJDQALDAkLIAIgBEwNByADIARqQQAgAiAEaxALGgwHCwJAIAIgACwAGCIEIAIgBEgbQQFIDQAgACkDMCAAKQMoIAGtfnynIgEgACgCACIEKAIEIAQoAgAiBGtODQggASAEaiEFQQAhAQNAIAUoAgAiBEGAAWpB/wFLDQkgASADaiAEOgAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQRqIgUgACgCACgCBEkNAAsMCAsgAiAETA0GIAMgBGpBACACIARrEAsaDAYLAkAgAiAALAAYIgQgAiAESBtBAUgNACAAKQMwIAApAyggAa1+fKciASAAKAIAIgQoAgQgBCgCACIEa04NByABIARqIQVBACEBA0AgBSgCACIEQf8ASw0IIAEgA2ogBDoAACABQQFqIgEgAiAALAAYIgQgAiAESBtODQEgBUEEaiIFIAAoAgAoAgRJDQALDAcLIAIgBEwNBSADIARqQQAgAiAEaxALGgwFCwJAIAIgACwAGCIEIAIgBEgbQQFIDQAgACkDMCAAKQMoIAGtfnynIgEgACgCACIEKAIEIAQoAgAiBGtODQYgASAEaiEFQQAhAQNAIAUpAwAiB0KAAXxC/wFWDQcgASADaiAHPAAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQhqIgUgACgCACgCBEkNAAsMBgsgAiAETA0EIAMgBGpBACACIARrEAsaDAQLAkAgAiAALAAYIgQgAiAESBtBAUgNACAAKQMwIAApAyggAa1+fKciASAAKAIAIgQoAgQgBCgCACIEa04NBSABIARqIQVBACEBA0AgBSkDACIHQv8AVg0GIAEgA2ogBzwAACABQQFqIgEgAiAALAAYIgQgAiAESBtODQEgBUEIaiIFIAAoAgAoAgRJDQALDAULIAIgBEwNAyADIARqQQAgAiAEaxALGgwDCwJAIAIgACwAGCIEIAIgBEgbQQFIDQAgACkDMCAAKQMoIAGtfnynIgEgACgCACIEKAIEIAQoAgAiBGtODQQgASAEaiEFQQAhAQNAIAEgA2oCfyAFKgIAIgiLQwAAAE9dBEAgCKgMAQtBgICAgHgLOgAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQRqIgUgACgCACgCBEkNAAsMBAsgAiAETA0CIAMgBGpBACACIARrEAsaDAILAkAgAiAALAAYIgQgAiAESBtBAUgNACAAKQMwIAApAyggAa1+fKciASAAKAIAIgQoAgQgBCgCACIEa04NAyABIARqIQVBACEBA0AgASADagJ/IAUrAwAiCZlEAAAAAAAA4EFjBEAgCaoMAQtBgICAgHgLOgAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQhqIgUgACgCACgCBEkNAAsMAwsgAiAETA0BIAMgBGpBACACIARrEAsaDAELAkAgAiAALAAYIgQgAiAESBtBAUgNACAAKQMwIAApAyggAa1+fKciASAAKAIAIgQoAgQgBCgCACIEa04NAiABIARqIQVBACEBA0AgASADaiAFLQAAOgAAIAFBAWoiASACIAAsABgiBCACIARIG04NASAFQQFqIgUgACgCACgCBEkNAAsMAgsgAiAETA0AIAMgBGpBACACIARrEAsaC0EBIQYLIAYLFgAgACABpxA2IAAgACkDGEIBfDcDGAtwACAAIAEpAwA3AwAgACABKQM4NwM4IAAgASkDMDcDMCAAIAEpAyg3AyggACABKQMgNwMgIAAgASkDGDcDGCAAIAEpAxA3AxAgACABKQMINwMIIABBADYCWCAAQgA3AkAgAEIANwJIIABCADcATSAAC3MBA38gARAcIgJBcEkEQAJAAkAgAkELTwRAIAJBEGpBcHEiBBAJIQMgACAEQYCAgIB4cjYCCCAAIAM2AgAgACACNgIEDAELIAAgAjoACyAAIQMgAkUNAQsgAyABIAIQChoLIAIgA2pBADoAACAADwsQHQALlAkCAn8CfiMAQTBrIgMkACADQfbpACkBADcBJiADQfDpACkDADcDICADQejpACkDADcDGCADQeDpACkDADcDEAJAAkAgASkDCCABKQMQIgVCBXxTBEAgA0EQahAcIgFBcE8NAgJAAkAgAUELTwRAIAFBEGpBcHEiBBAJIQIgAyAEQYCAgIB4cjYCCCADIAI2AgAgAyABNgIEDAELIAMgAToACyADIQIgAUUNAQsgAiADQRBqIAEQChoLIAEgAmpBADoAACAAQX42AgAgAEEEaiADEBEaIAMsAAtBf0oNASADKAIAEAgMAQsgAiABKAIAIAWnaiIEKAAANgAAIAIgBC0ABDoABCABIAEpAxBCBXwiBTcDECACQf7pAEEFEBcEQCADQSAQCSIBNgIAIANCkYCAgICEgICAfzcCBCABQQA6ABEgAUGU6gAtAAA6ABAgAUGM6gApAAA3AAggAUGE6gApAAA3AAAgAEF/NgIAIABBBGogAxARGiADLAALQX9KDQEgAygCABAIDAELIAUgASkDCFkEQCADQRBqEBwiAUFwTw0CAkACQCABQQtPBEAgAUEQakFwcSIEEAkhAiADIARBgICAgHhyNgIIIAMgAjYCACADIAE2AgQMAQsgAyABOgALIAMhAiABRQ0BCyACIANBEGogARAKGgsgASACakEAOgAAIABBfjYCACAAQQRqIAMQERogAywAC0F/Sg0BIAMoAgAQCAwBCyACIAEoAgAgBadqLQAAOgAFIAEgASkDEEIBfCIFNwMQIAUgASkDCFkEQCADQRBqEBwiAUFwTw0CAkACQCABQQtPBEAgAUEQakFwcSIEEAkhAiADIARBgICAgHhyNgIIIAMgAjYCACADIAE2AgQMAQsgAyABOgALIAMhAiABRQ0BCyACIANBEGogARAKGgsgASACakEAOgAAIABBfjYCACAAQQRqIAMQERogAywAC0F/Sg0BIAMoAgAQCAwBCyACIAEoAgAgBadqLQAAOgAGIAEgASkDEEIBfCIFNwMQIAUgASkDCFkEQCADQRBqEBwiAUFwTw0CAkACQCABQQtPBEAgAUEQakFwcSIEEAkhAiADIARBgICAgHhyNgIIIAMgAjYCACADIAE2AgQMAQsgAyABOgALIAMhAiABRQ0BCyACIANBEGogARAKGgsgASACakEAOgAAIABBfjYCACAAQQRqIAMQERogAywAC0F/Sg0BIAMoAgAQCAwBCyACIAEoAgAgBadqLQAAOgAHIAEgASkDEEIBfCIFNwMQIAUgASkDCFkEQCADIANBEGoQcCEBIABBfjYCACAAQQRqIAEQERogASwAC0F/Sg0BIAEoAgAQCAwBCyACIAEoAgAgBadqLQAAOgAIIAEgASkDECIFQgF8IgY3AxAgASkDCCAFQgN8UwRAIAMgA0EQahBwIQEgAEF+NgIAIABBBGogARARGiABLAALQX9KDQEgASgCABAIDAELIAIgASgCACAGp2ovAAA7AQogASABKQMQQgJ8NwMQIABCADcCCCAAQgA3AgALIANBMGokAA8LEB0ACzMAIABBADYCACAAIAE2AjggAEIANwMwIAAgBTcDKCAAIAQ6ACAgACADNgIcIAAgAjoAGAupAQEFfwJAIAFFBEAMAQtBACAALQAMa0H/AXEhBiAAKAIIIQMDQAJAIANB/x9LDQAgACgCBCIEQQFIDQAgACAEQQFrIgQ2AgQgACgCACAEai0AACADQQh0ciEDCyAAIANBCHYgBmwiBCADQf8BcSIHaiADIAQgBmprIAYgB0siBBsiAzYCCCAEIAVyIQUgAUEBayIBRQ0BIAVBAXQhBQwACwALIAIgBTYCAAvhBgEJfyACIAIoAgQgASgCECIJayIGrUIghiACKAIAIAlrIgSthDcCAAJAIAEoAhAiCiAGIAZBH3UiBWogBXMgBCAEQR91IgVqIAVzak4iCwRAIAYhBQwBCwJAAkAgBEEATgRAQQEhCEEBIQcgBkF/Sg0CQQEhBUF/IQhBfyEHIARBAU4NAQwCC0F/IQVBfyEIQX8hByAGQQFIDQELQX9BASAGQQFIGyEIIAUhBwsgAiAIIApsIgxBACAEQQF0IAcgCmwiBGsiBWsgBSAHIAhsQX9KIgcbakECbSIFNgIEIAIgBEEAIAZBAXQgDGsiBGsgBCAHG2pBAm0iBDYCAAsCQAJAAkACQAJAIARFBEAgBQ0BQQEhCEEAIQVBACEGQQAhBwwFC0EBIQggBEEASCAFQQFIcSEGAkAgBEEBTgRAQQJBASAFQX9KGyEHIAZFDQEgBCEGDAYLQQNBACAFQQBKGyEHIAZFDQAgBCEGDAULIAdBAWshCEEAIQcgBCEGAkAgCA4DAwACBAtBACAFayEFQQAgBGshBkECIQcMAwsgBUEBSA0BC0EAIAVrIQZBAyEHIAQhBQwBC0EBIQcgBSEGQQAgBGshBQsgAiAGrSAFrUIghoQ3AgBBACEICyADKAIEIAVqIQICQCABKAIQIgUgAygCACAGaiIESARAIAQgASgCBGshBAwBCyAEQQAgBWtODQAgASgCBCAEaiEECwJAIAIgBUoEQCACIAEoAgRrIQIMAQsgAkEAIAVrTg0AIAEoAgQgAmohAgsCQCAIBEAgAiEBDAELIAIhAQJAAkACQEEEIAdrQQNxQQFrDgMAAQIDC0EAIARrIQEgAiEEDAILQQAgAmshAUEAIARrIQQMAQsgBCEBQQAgAmshBAsCQCALBEAgASECDAELAkACQCAEQQBOBEBBASECQQEhBiABQX9KDQJBASEDQX8hAkF/IQYgBEEBTg0BDAILQX8hA0F/IQJBfyEGIAFBAUgNAQtBf0EBIAFBAUgbIQIgAyEGCyAAIARBAXQgBSAGbCIEayIDNgIAIAIgBWwiBUEAIANrIAMgAiAGbEF/SiIDG2pBAm0hAkEAIAFBAXQgBWsiAWsgASADGyAEakECbSEECyAAIAQgCWqtIAIgCWqtQiCGhDcCAAuyBAEIfyACIAIoAgQgASgCECIKayIHrUIghiACKAIAIAprIgSthDcCAAJAIAEoAhAiBiAHIAdBH3UiBWogBXMgBCAEQR91IgVqIAVzak4iCwRAIAchBQwBCwJAAkAgBEEATgRAQQEhBUEBIQggB0F/Sg0CQQEhCUF/IQVBfyEIIARBAU4NAQwCC0F/IQlBfyEFQX8hCCAHQQFIDQELQX9BASAHQQFIGyEFIAkhCAsgAiAFIAZsIglBACAEQQF0IAYgCGwiBmsiBGsgBCAFIAhsQX9KIggbakECbSIFNgIEIAJBACAHQQF0IAlrIgJrIAIgCBsgBmpBAm0iBDYCACABKAIQIQYLIAMoAgQgBWohAgJAIAMoAgAgBGoiBCAGSgRAIAQgASgCBGshBAwBCyAEQQAgBmtODQAgASgCBCAEaiEECwJAIAIgBkoEQCACIAEoAgRrIQIMAQsgAkEAIAZrTg0AIAEoAgQgAmohAgsCQCALBEAgAiEGDAELAkACQCAEQQBOBEBBASEBQQEhBSACQX9KDQJBASEDQX8hAUF/IQUgBEEBTg0BDAILQX8hA0F/IQFBfyEFIAJBAUgNAQtBf0EBIAJBAUgbIQEgAyEFCyAAIARBAXQgBSAGbCIHayIDNgIAIAEgBmwiCEEAIANrIAMgASAFbEF/SiIBG2pBAm0hBkEAIAJBAXQgCGsiAmsgAiABGyAHakECbSEECyAAIAQgCmqtIAYgCmqtQiCGhDcCAAslAQF/AkAgASgCOA0AIAEtABhBA0cNACAAIAE2AjBBASECCyACC0AAAkAgACgCMEUNACAAKAI0RQ0AIAAoAhxFDQAgACgCIEUNACAAKAIkRQ0AIAAoAihFDQAgACgCTEF/Rw8LQQAL+wEBB38gASAAKAIIIgUgACgCBCICa0ECdU0EQCAAIAEEfyACQQAgAUECdCIAEAsgAGoFIAILNgIEDwsCQCACIAAoAgAiBGsiBkECdSIHIAFqIgNBgICAgARJBEBBACECAn8gAyAFIARrIgVBAXUiCCADIAhLG0H/////AyAFQQJ1Qf////8BSRsiAwRAIANBgICAgARPDQMgA0ECdBAJIQILIAdBAnQgAmoLQQAgAUECdCIBEAsgAWohASAGQQFOBEAgAiAEIAYQChoLIAAgAiADQQJ0ajYCCCAAIAE2AgQgACACNgIAIAQEQCAEEAgLDwsQDAALQdwJEA0ACyoBAX8CQCABRQ0AIAEoAjgNACABLQAYQQNHDQAgACABNgI8QQEhAgsgAgszAQF/AkAgACgCPEUNACAAKAIsRQ0AIAAoAjBFDQAgACgCNEUNACAAKAI4QQBHIQELIAEL5wYCB38DfgJAIAAgACgCACgCLBEAACIIQQFIDQAgASgCBCABKAIAa0ECdSIHIQYjAEHQAGsiBSQAIAVBEGoQTSIEIAAoAggoAjggCEEYdEEYdUEFQQACf0Ho7QAoAgAMAAsgCGysEHJB4AAQCSIDIAQQbyEEIAUgAzYCCCAEQQE6AFQgBCAEKAJENgJIIAQgBhA8GiAFQQA2AgggACgCECEEIAAgAzYCEAJAIARFDQAgBBAYIAUoAgghBCAFQQA2AgggBEUNACAEEBgLIAVB0ABqJAAgACgCECIFKAJQRQ0AIAUoAgAoAgAiA0UNACACKQMIIgwgAikDECIKVw0AIAcgCGwhBCADIAUoAjBqIQUgAigCACIDIAqnai0AACEHIAIgCkIBfCILNwMQAkACfwJAIAcEQCAEIAggAiAFEKkBDQEMBAsgCyAMWQ0DIAMgC6dqLQAAIQYgAiAKQgJ8NwMQIAAoAhAoAkAiAygCBCADKAIAayEDAkAgBkHo7QAoAgBGBEAgAyAEQQJ0IgNJDQUgAikDCCACKQMQIgogA60iC3xZDQEMBQsgBCAGbCADSw0EIAIpAwgiDCACKQMQIgp9IAatIgsgBK1+Uw0EQQEgBEUNAhpBACEDIAwgCiALfFMNA0EAIQcDQCAFIAdBAnRqIAIoAgAgCqdqIAYQChogAiACKQMQIAt8Igo3AxAgB0EBaiIHIARGDQIgAikDCCAKIAt8WQ0ACwwDCyAFIAIoAgAgCqdqIAMQChogAiACKQMQIAt8NwMQC0EBIARFDQAaIAAoAhQiAwRAQQAgAyADKAIAKAIgEQAADQEaC0EAIQMCQCAEQQFIDQAgBEEBRwRAIARBfnEhBwNAIAUgA0ECdCIGakEAIAUgBmooAgAiCUEBcWsgCUEBdnM2AgAgBSAGQQRyIgZqQQAgBSAGaigCACIGQQFxayAGQQF2czYCACADQQJqIQMgB0ECayIHDQALCyAEQQFxRQ0AIAUgA0ECdCIDakEAIAMgBWooAgAiA0EBcWsgA0EBdnM2AgALQQALIQcCQCAAKAIUIgNFDQAgAyACIAMoAgAoAigRAQBFDQIgBw0AQQAhAyAAKAIUIgAgBSAFIAQgCCABKAIAIAAoAgAoAiwRCABFDQELQQEhAwsgAw8LQQALOgECfiACKQMIIgQgAikDECIDVQRAIAIoAgAgA6dqLQAAIQEgAiADQgF8NwMQIAAgATYCBAsgAyAEUwsuAQF/IAAoAhAiAQRAIAAgATYCFCABEAgLIAAoAgAiAQRAIAAgATYCBCABEAgLC5ACAQN/AkAgASACKAIQIgQEfyAEBUEAIQQCfyACIAItAEoiA0EBayADcjoASiACKAIAIgNBCHEEQCACIANBIHI2AgBBfwwBCyACQgA3AgQgAiACKAIsIgM2AhwgAiADNgIUIAIgAyACKAIwajYCEEEACw0BIAIoAhALIAIoAhQiBWtLBEAgAiAAIAEgAigCJBEDAA8LAn8gAiwAS0F/SgRAIAEhBANAIAEgBCIDRQ0CGiAAIANBAWsiBGotAABBCkcNAAsgAiAAIAMgAigCJBEDACIEIANJDQIgACADaiEAIAIoAhQhBSABIANrDAELIAELIQQgBSAAIAQQChogAiACKAIUIARqNgIUIAEhBAsgBAvpAgEGfyAAQgA3AhAgAEEANgIIIABCADcCACAAQQA2AhggASgCBCABKAIAayIGQRRtIQUCQAJAAkAgBgRAIAVBzZmz5gBPDQEgACAGEAkiAzYCECAAIAM2AhQgACADIAVBFGxqNgIYIAACfyADIAEoAgQgASgCACIEayIBQQFIDQAaIAMgBCABEAogAUEUbkEUbGoLIgQ2AhQLIABBADYCHCAEIANrIgFFDQIgAUEUbSIBQQEgAUEBSxsiBEEBcSEGIAFBAkkEQEEAIQEMAgsgBEF+cSEEQQAhAQNAIAMgAUEBckEUbGoiBSgCECAFKAIMbCIFIAMgAUEUbGoiBygCECAHKAIMbCIHIAIgAiAHSRsiAiACIAVJGyECIAFBAmohASAEQQJrIgQNAAsMAQsQDAALIAZFDQAgAyABQRRsaiIBKAIQIAEoAgxsIgEgAiABIAJLGyECCyAAIAIQNiAAIAAoAgA2AgwgAAs2AQJ/IABBjP8ANgIAAkAgACgCBEEMayICIgEgASgCCEEBayIBNgIIIAFBf0oNACACEAgLIAALOwACfyAALQALQQd2BEAgACgCBAwBCyAALQALC0UEQBCDAQALAn8gAC0AC0EHdgRAIAAoAgAMAQsgAAsLvgQBCn8gAQJ/IAAiAi0AC0EHdgRAIAIoAgQMAQsgAi0ACwsiA0sEQCMAQRBrIgckACABIANrIgUEQCACLQALQQd2BH8gAigCCEH/////B3FBAWsFQQoLIQMCfyACLQALQQd2BEAgACgCBAwBCyAALQALCyIGIAVqIQEgBSADIAZrSwRAAkAjAEEQayICJAAgASADayIEQW8gA2tNBEACfyAALQALQQd2BEAgACgCAAwBCyAACyEJAn8gA0Hn////B0kEQCACIANBAXQ2AgggAiADIARqNgIMAn8jAEEQayIEJAAgAkEMaiIIKAIAIAJBCGoiCigCAEkhCyAEQRBqJAAgCiAIIAsbKAIAIgRBC08LBH8gBEEQakFwcSIEIARBAWsiBCAEQQtGGwVBCgsMAQtBbgtBAWoiCBAJIQQgBgRAIAQgCSAGEGMLIANBCkcEQCAJEAgLIAAgBDYCACAAIAhBgICAgHhyNgIIIAJBEGokAAwBCxAdAAsLIAYCfyAALQALQQd2BEAgACgCAAwBCyAACyICaiEDIAUEQCADQQAgBRALGgsCQCAALQALQQd2BEAgACABNgIEDAELIAAgAToACwsgB0EAOgAPIAEgAmogBy0ADzoAAAsgB0EQaiQADwsjAEEQayIAJAACQCACLQALQQd2BEAgAigCACEDIABBADoADyABIANqIAAtAA86AAAgAiABNgIEDAELIABBADoADiABIAJqIAAtAA46AAAgAiABOgALCyAAQRBqJAALBQAQAAALsxQCD38CfiMAQdAAayIGJAAgBiABNgJMIAZBN2ohEyAGQThqIRBBACEBAkADQAJAIA1BAEgNAEH/////ByANayABSARAQeCGAUE9NgIAQX8hDQwBCyABIA1qIQ0LIAYoAkwiByEBAkACQAJAIActAAAiBQRAA0ACQAJAIAVB/wFxIgVFBEAgASEFDAELIAVBJUcNASABIQUDQCABLQABQSVHDQEgBiABQQJqIgg2AkwgBUEBaiEFIAEtAAIhCyAIIQEgC0ElRg0ACwsgBSAHayEBIAAEQCAAIAcgARBICyABDQYgBigCTCEBIAYCfwJAIAYoAkwsAAFBMGtBCk8NACABLQACQSRHDQAgASwAAUEwayEPQQEhESABQQNqDAELQX8hDyABQQFqCyIBNgJMQQAhCAJAIAEsAAAiDkEgayIFQR9LDQBBASAFdCIFQYnRBHFFDQADQAJAIAYgAUEBaiIINgJMIAEsAAEiDkEgayIBQSBPDQBBASABdCIBQYnRBHFFDQAgASAFciEFIAghAQwBCwsgCCEBIAUhCAsCQCAOQSpGBEAgBgJ/AkAgASwAAUEwa0EKTw0AIAYoAkwiAS0AAkEkRw0AIAEsAAFBAnQgBGpBwAFrQQo2AgAgASwAAUEDdCADakGAA2soAgAhCkEBIREgAUEDagwBCyARDQZBACERQQAhCiAABEAgAiACKAIAIgFBBGo2AgAgASgCACEKCyAGKAJMQQFqCyIBNgJMIApBf0oNAUEAIAprIQogCEGAwAByIQgMAQsgBkHMAGoQxAEiCkEASA0EIAYoAkwhAQtBfyEJAkAgAS0AAEEuRw0AIAEtAAFBKkYEQAJAIAEsAAJBMGtBCk8NACAGKAJMIgEtAANBJEcNACABLAACQQJ0IARqQcABa0EKNgIAIAEsAAJBA3QgA2pBgANrKAIAIQkgBiABQQRqIgE2AkwMAgsgEQ0FIAAEfyACIAIoAgAiAUEEajYCACABKAIABUEACyEJIAYgBigCTEECaiIBNgJMDAELIAYgAUEBajYCTCAGQcwAahDEASEJIAYoAkwhAQtBACEFA0AgBSESQX8hDCABLAAAQcEAa0E5Sw0IIAYgAUEBaiIONgJMIAEsAAAhBSAOIQEgBSASQTpsakGP9ABqLQAAIgVBAWtBCEkNAAsCQAJAIAVBE0cEQCAFRQ0KIA9BAE4EQCAEIA9BAnRqIAU2AgAgBiADIA9BA3RqKQMANwNADAILIABFDQggBkFAayAFIAIQwwEgBigCTCEODAILIA9Bf0oNCQtBACEBIABFDQcLIAhB//97cSILIAggCEGAwABxGyEFQQAhDEG99AAhDyAQIQgCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAOQQFrLAAAIgFBX3EgASABQQ9xQQNGGyABIBIbIgFB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIAFBwQBrDgcOFAsUDg4OAAsgAUHTAEYNCQwTCyAGKQNAIRRBvfQADAULQQAhAQJAAkACQAJAAkACQAJAIBJB/wFxDggAAQIDBBoFBhoLIAYoAkAgDTYCAAwZCyAGKAJAIA02AgAMGAsgBigCQCANrDcDAAwXCyAGKAJAIA07AQAMFgsgBigCQCANOgAADBULIAYoAkAgDTYCAAwUCyAGKAJAIA2sNwMADBMLIAlBCCAJQQhLGyEJIAVBCHIhBUH4ACEBCyAQIQcgAUEgcSELIAYpA0AiFFBFBEADQCAHQQFrIgcgFKdBD3FBoPgAai0AACALcjoAACAUQgSIIhRCAFINAAsLIAVBCHFFDQMgBikDQFANAyABQQR2Qb30AGohD0ECIQwMAwsgECEBIAYpA0AiFFBFBEADQCABQQFrIgEgFKdBB3FBMHI6AAAgFEIDiCIUQgBSDQALCyABIQcgBUEIcUUNAiAJIBAgB2siAUEBaiABIAlIGyEJDAILIAYpA0AiFEJ/VwRAIAZCACAUfSIUNwNAQQEhDEG99AAMAQsgBUGAEHEEQEEBIQxBvvQADAELQb/0AEG99AAgBUEBcSIMGwshDyAQIQECQCAUQoCAgIAQVARAIBQhFQwBCwNAIAFBAWsiASAUIBRCCoAiFUIKfn2nQTByOgAAIBRC/////58BViEHIBUhFCAHDQALCyAVpyIHBEADQCABQQFrIgEgByAHQQpuIgtBCmxrQTByOgAAIAdBCUshDiALIQcgDg0ACwsgASEHCyAFQf//e3EgBSAJQX9KGyEFIAYpA0AhFAJAIAkNACAUUEUNAEEAIQkgECEHDAwLIAkgFFAgECAHa2oiASABIAlIGyEJDAsLAn8gBigCQCIBQcf0ACABGyIHIQUgCSIBQQBHIQgCQAJAAkAgAUUNACAFQQNxRQ0AA0AgBS0AAEUNAiAFQQFqIQUgAUEBayIBQQBHIQggAUUNASAFQQNxDQALCyAIRQ0BCwJAIAUtAABFDQAgAUEESQ0AA0AgBSgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0BIAVBBGohBSABQQRrIgFBA0sNAAsLIAFFDQADQCAFIAUtAABFDQIaIAVBAWohBSABQQFrIgENAAsLQQALIgEgByAJaiABGyEIIAshBSABIAdrIAkgARshCQwKCyAJBEAgBigCQAwCC0EAIQEgAEEgIApBACAFEDgMAgsgBkEANgIMIAYgBikDQD4CCCAGIAZBCGo2AkBBfyEJIAZBCGoLIQhBACEBAkADQCAIKAIAIgdFDQECQCAGQQRqIAcQxQEiB0EASCILDQAgByAJIAFrSw0AIAhBBGohCCAJIAEgB2oiAUsNAQwCCwtBfyEMIAsNCwsgAEEgIAogASAFEDggAUUEQEEAIQEMAQtBACEIIAYoAkAhDgNAIA4oAgAiB0UNASAGQQRqIAcQxQEiByAIaiIIIAFKDQEgACAGQQRqIAcQSCAOQQRqIQ4gASAISw0ACwsgAEEgIAogASAFQYDAAHMQOCAKIAEgASAKSBshAQwICyAAIAYrA0AgCiAJIAUgAUEAERMAIQEMBwsgBiAGKQNAPAA3QQEhCSATIQcgCyEFDAQLIAYgAUEBaiIINgJMIAEtAAEhBSAIIQEMAAsACyANIQwgAA0EIBFFDQJBASEBA0AgBCABQQJ0aigCACIABEAgAyABQQN0aiAAIAIQwwFBASEMIAFBAWoiAUEKRw0BDAYLC0EBIQwgAUEKTw0EA0AgBCABQQJ0aigCAA0BIAFBAWoiAUEKRw0ACwwEC0F/IQwMAwsgAEEgIAwgCCAHayILIAkgCSALSBsiCWoiCCAKIAggCkobIgEgCCAFEDggACAPIAwQSCAAQTAgASAIIAVBgIAEcxA4IABBMCAJIAtBABA4IAAgByALEEggAEEgIAEgCCAFQYDAAHMQOAwBCwtBACEMCyAGQdAAaiQAIAwL6QoBDH8gACABQQxsaiIKIgsgCigCCDYCDEF/IAJBA24gAkF/RhshCEEBIQwgAiEHAkACQAJAA0ACQCAOBEAgB0F/Rg0BIABBf0ECIAdBA3AbIAdqENABQX9GDQUgB0EBaiICIAdBAmsgAkEDcBsiAkF/Rg0FIAJBAWoiAyACQQJrIANBA3AbIgJBf0YNBSAAKAIEKAIMIAJBAnRqKAIAIgJBf0YNBSACQQFqIgMgAkECayADQQNwGyICQX9GDQUgAkEDbiEICwJAIAAoAjggCEEDdkH8////AXFqIgQoAgAiBUEBIAh0IglxDQBBACEDA0AgBCAFIAlyNgIAAkAgCygCDCIGIAooAhBHBEAgBiAINgIAIAsgBkEEajYCDAwBCyAGIAooAggiBmsiBEECdSINQQFqIgVBgICAgARPDQUCf0EAIAUgBEEBdSIJIAUgCUsbQf////8DIA1B/////wFJGyIFRQ0AGiAFQYCAgIAETw0HIAVBAnQQCQsiCSANQQJ0aiINIAg2AgAgBEEBTgRAIAkgBiAEEAoaCyAKIAk2AgggCyANQQRqNgIMIAogCSAFQQJ0ajYCECAGRQ0AIAYQCAsgA0EBaiEGAkACfyACIANFDQAaIAZBAXEEQCACQX9GBEBBfyECDAMLIAJBAWoiAyACQQJrIANBA3AbDAELIAIgByAOGyEHIAJBf0YEQEF/IQIMAgsgAkEBayACQQNwDQAaIAJBAmoLIQNBfyECIANBf0YNACAAKAIEKAIMIANBAnRqKAIAIQICf0F/IANBAWoiBCADQQJrIARBA3AbIgRBAEgNABogACgCACgCYCAEQQNuIgVBDGxqIAQgBUEDbGtBAnRqKAIACyEEAn8gAkF/RgRAIARBf0YhBEEBDAELAn8gBEF/RkF/QQIgAkEDcBsgAmoiBUF/TA0AGiAEIAAoAgAoAmAgBUEDbiIJQQxsaiAFIAlBA2xrQQJ0aigCAEYLIQRBAAshBSAERQRAQX8hAgwBCwJAAkACfwJAQX9BAiADQQNwGyADaiIDQQBOBEAgACgCACgCYCADQQNuIgRBDGxqIAMgBEEDbGtBAnRqKAIAIQMgBUUNASADQX9HDAILQX8hAyAFDQILIANBf0cgAkEBaiIEIAJBAmsgBEEDcBsiBEF/TA0AGiADIAAoAgAoAmAgBEEDbiIFQQxsaiAEIAVBA2xrQQJ0aigCAEcLBEBBfyECDAMLIAJBf0cNAUF/IQIMAgsgAkF/Rw0AQX8hAgwBCyAGIQMgACgCOCACQQNuIghBA3ZB/P///wBxaiIEKAIAIgVBASAIdCIJcUUNAQsLIAZBAXFFIA5Bf3NyQQFxDQAgACgCOCALKAIMQQRrIgIoAgAiA0EDdkH8////AXFqIgYgBigCAEF+IAN3cTYCACALIAI2AgwMBQtBASEOIAwhA0EAIQwgAw0BDAQLC0F/IQcgAEF/ENABGgwCCxAMAAtB8PAAEA0ACyAAIAFBAnRqIAc2AiwCQCALKAIMIAooAggiB2siAUUNACABIAFBH3UiAmogAnNBAnYgAUF/IAFBf0obIgFBASABQQFIG2wiAUEBIAFBAUsbIgNBAXEhBiAAKAI4IQBBACECIAFBAk8EQCADQX5xIQgDQCAAIAcgAkECdCIBaigCACIDQQN2Qfz///8BcWoiDCAMKAIAQX4gA3dxNgIAIAAgByABQQRyaigCACIBQQN2Qfz///8BcWoiAyADKAIAQX4gAXdxNgIAIAJBAmohAiAIQQJrIggNAAsLIAZFDQAgACAHIAJBAnRqKAIAIgFBA3ZB/P///wFxaiIAIAAoAgBBfiABd3E2AgALC44LAQt/IAAgACgCNDYCOCAAIAAoAig2AiwCQAJAAkAgACgCQCIBKAIcIAEoAhgiBEcEQEEAIQEDQCABIQMCQCAEIApBAnRqKAIAIghBf0YNAAJAIAAoAjgiASAAKAI8RwRAIAEgAzYCACAAIAFBBGo2AjgMAQsgASAAKAI0IgZrIgdBAnUiBEEBaiICQYCAgIAETw0EAn9BACACIAdBAXUiASABIAJJG0H/////AyAEQf////8BSRsiBUUNABogBUGAgICABE8NByAFQQJ0EAkLIgIgBEECdGoiASADNgIAIAdBAU4EQCACIAYgBxAKGgsgACACIAVBAnRqNgI8IAAgAUEEajYCOCAAIAI2AjQgBkUNACAGEAgLAkAgACgCDCAKQQN2Qfz///8BcWooAgAgCnZBAXFFDQAgCEEBaiIBIAhBAmsgAUEDcBsiAUF/Rg0AIAAoAgAgAUEDdkH8////AXFqKAIAIAF2QQFxDQAgACgCQCgCDCABQQJ0aigCACICQX9GDQAgAkEBaiIBIAJBAmsgAUEDcBsiBEF/Rg0AA0AgBCIIQQFqIgEgBEECayABQQNwGyIBQX9GDQEgACgCACABQQN2Qfz///8BcWooAgAgAXZBAXENASAAKAJAKAIMIAFBAnRqKAIAIgJBf0YNASACQQFqIgEgAkECayABQQNwGyIEQX9HDQALCyAAKAIcIAhBAnRqIAM2AgACQCAAKAIsIgEgACgCMEcEQCABIAg2AgAgACABQQRqNgIsDAELIAEgACgCKCIGayIHQQJ1IgRBAWoiAkGAgICABE8NBQJ/QQAgAiAHQQF1IgEgASACSRtB/////wMgBEH/////AUkbIgVFDQAaIAVBgICAgARPDQcgBUECdBAJCyICIARBAnRqIgEgCDYCACAHQQFOBEAgAiAGIAcQChoLIAAgAiAFQQJ0ajYCMCAAIAFBBGo2AiwgACACNgIoIAZFDQAgBhAICyADQQFqIQFBf0ECIAhBA3AbIAhqIgJBf0YNACAAKAJAKAIMIAJBAnRqKAIAIgJBf0YNACACQX9BAiACQQNwG2oiBEF/Rg0AIAQgCEYNAANAIAAoAgAgBEEBaiICIARBAmsgAkEDcBsiAkEDdkH8////AXFqKAIAIAJ2QQFxBEACQCAAKAI4IgMgACgCPEcEQCADIAE2AgAgACADQQRqNgI4DAELIAMgACgCNCIJayIGQQJ1IgVBAWoiAkGAgICABE8NBgJ/QQAgAiAGQQF1IgMgAiADSxtB/////wMgBUH/////AUkbIgdFDQAaIAdBgICAgARPDQkgB0ECdBAJCyICIAVBAnRqIgMgATYCACAGQQFOBEAgAiAJIAYQChoLIAAgAiAHQQJ0ajYCPCAAIANBBGo2AjggACACNgI0IAlFDQAgCRAICyABQQFqIQICQCAAKAIsIgMgACgCMEcEQCADIAQ2AgAgACADQQRqNgIsDAELIAMgACgCKCILayIJQQJ1IgdBAWoiBUGAgICABE8NBwJ/QQAgBSAJQQF1IgMgAyAFSRtB/////wMgB0H/////AUkbIgZFDQAaIAZBgICAgARPDQkgBkECdBAJCyIFIAdBAnRqIgMgBDYCACAJQQFOBEAgBSALIAkQChoLIAAgBSAGQQJ0ajYCMCAAIANBBGo2AiwgACAFNgIoIAtFDQAgCxAICyABIQMgAiEBCyAAKAIcIARBAnRqIAM2AgBBf0ECIARBA3AbIARqIgJBf0YNASAAKAJAKAIMIAJBAnRqKAIAIgJBf0YNASACQX9BAiACQQNwG2oiBEF/Rg0BIAQgCEcNAAsLIApBAWoiCiAAKAJAIgMoAhwgAygCGCIEa0ECdUkNAAsLDwsQDAALEAwAC0Gs8AAQDQAL3wMBBn8jAEEQayIGJAACQAJAIAEEQCAAQgA3AlggACgCVCECIABBADYCVCACBEAgAhAICyAAQgA3AkwgACgCSCECIABBADYCSCACBEAgAhAICyABKAIAIQIgASgCBCEDIAZBADoADyAAIAMgAmtBAnUgBkEPahAeIAEoAhwhAiABKAIYIQMgBkEAOgAOIABBDGogAiADa0ECdSAGQQ5qEB4gAEEcaiABKAIEIAEoAgBrQQJ1QajwABCIAQJAIAEoAhwgASgCGGsiA0ECdSIEIAAoAjwgACgCNCICa0ECdU0NACADQX9MDQIgACgCOCEFIAMQCSIDIARBAnRqIQcgAyAFIAJrIgRqIQUgBEEBTgRAIAMgAiAEEAoaCyAAIAc2AjwgACAFNgI4IAAgAzYCNCACRQ0AIAIQCAsCQCABKAIcIAEoAhhrIgNBAnUiBCAAKAIwIAAoAigiAmtBAnVNDQAgA0F/TA0DIAAoAiwhBSADEAkiAyAEQQJ0aiEHIAMgBSACayIEaiEFIARBAU4EQCADIAIgBBAKGgsgACAHNgIwIAAgBTYCLCAAIAM2AiggAkUNACACEAgLIABBAToAGCAAIAE2AkALIAZBEGokAA8LQazwABANAAtBrPAAEA0AC80EAQd/IAEgACgCCCIDIAAoAgAiBGtBAnVNBEACQCAAKAIEIgYgBGtBAnUiByABIAEgB0sbIgVFDQAgBUEBayEJAkAgBUEHcSIIRQRAIAQhAwwBCyAEIQMDQCADIAIoAgA2AgAgBUEBayEFIANBBGohAyAIQQFrIggNAAsLIAlBB0kNAANAIAMgAigCADYCACADIAIoAgA2AgQgAyACKAIANgIIIAMgAigCADYCDCADIAIoAgA2AhAgAyACKAIANgIUIAMgAigCADYCGCADIAIoAgA2AhwgA0EgaiEDIAVBCGsiBQ0ACwsgASAHSwRAIAAgASAHayIABH8gBiAAQQJ0aiEAA0AgBiACKAIANgIAIAZBBGoiBiAARw0ACyAABSAGCzYCBA8LIAAgBCABQQJ0ajYCBA8LIAQEQCAAIAQ2AgQgBBAIIABBADYCCCAAQgA3AgBBACEDCwJAIAFBgICAgARPDQAgASADQQF1IgQgASAESxtB/////wMgA0ECdUH/////AUkbIgNBgICAgARPDQAgACADQQJ0IgMQCSIENgIAIAAgAyAEajYCCCACKAIAIQIgBCEDIAFBAnQiAUEEayIGQQJ2QQFqQQdxIgUEQANAIAMgAjYCACADQQRqIQMgBUEBayIFDQALCyABIARqIQEgBkEcTwRAA0AgAyACNgIcIAMgAjYCGCADIAI2AhQgAyACNgIQIAMgAjYCDCADIAI2AgggAyACNgIEIAMgAjYCACADQSBqIgMgAUcNAAsLIAAgATYCBA8LEAwAC4gCAQR/AkAgASACckEATgR/AkAgAUHVqtWqBUsNACAAIAFBA2wiA0Hk7gAQiAEgAEEMaiADQejuABCIAQJAIAAoAiAgACgCGCIDa0ECdSACTw0AIAJBgICAgARPDQMgACgCHCEEIAJBAnQiBRAJIgIgBWohBSACIAQgA2siBGohBiAEQQFOBEAgAiADIAQQChoLIAAgBTYCICAAIAY2AhwgACACNgIYIANFDQAgAxAICyAAQgA3AlAgACgCTCECIABBADYCTCACBEAgAhAICyAAQgA3AkQgAEFAayICKAIAIQAgAkEANgIAIABFDQAgABAICyABQdaq1aoFSQVBAAsPC0Hs7gAQDQAL5wEBA38gAEEANgIIIABCADcCAAJAAkAgAUUNACABQX9MDQEgAUEBa0EFdiIEQQFqIgVBAnQQCSEDIAAgBTYCCCAAIAM2AgAgAi0AACEFIAAgATYCBCADIAMgBEECdGogAUEhSRtBADYCACABQQV2IgJBAnQhBCAFBEAgA0H/ASAEEAshAyABQR9xIgFFDQEgAyACQQJ0aiICIAIoAgBBf0EgIAFrdnI2AgAgAA8LIANBACAEEAshAyABQR9xIgFFDQAgAyACQQJ0aiICIAIoAgBBf0EgIAFrdkF/c3E2AgALIAAPCxAMAAtZACAAQgA3AgAgAEEANgI4IABCADcCMCAAQgA3AiggAEIANwIgIABCADcCGCAAQgA3AhAgAEIANwIIIABBQGtCADcCACAAQgA3AkggAEIANwJQIAAgADYCPAsEAEECCysAIAEEQCAAIAEoAgAQjQEgACABKAIEEI0BIAFBFGogASgCGBBSIAEQCAsLbAICfwF+AkAgAEEFSw0AIAIpAxAiBSACKQMIWQ0AIAIoAgAgBadqLQAAIQMgAiAFQgF8NwMQIAEgA0GAAXEEfyAAQQFqIAEgAhCOAUUNASADQf8AcSABKAIAQQd0cgUgAws2AgBBASEECyAECxAAIAAoAgQgACgCAGtBAnULBwAgACgCUAsLACAABEAgABAICwuLAQEDfyAABEAgACgCGCICBEACfyACIAIgACgCHCIDRg0AGgNAIANBBGsiAygCACEBIANBADYCACABBEAgAUEMaiABKAIQECEgASABKAIEECAgARAICyACIANHDQALIAAoAhgLIQEgACACNgIcIAEQCAsgAEEMaiAAKAIQECEgACAAKAIEECAgABAICws3ACAAQQA2AiggAEG06QA2AgAgAEIANwIEIABCADcCDCAAQgA3AhQgAEIANwIcIABBADsBJCAAC4MBAQN/IABBtOkANgIAIAAoAhQiAQRAIAAgATYCGCABEAgLIAAoAggiAQRAAn8gASABIAAoAgwiAkYNABoDQCACQQRrIgIoAgAhAyACQQA2AgAgAwRAIAMgAygCACgCBBECAAsgASACRw0ACyAAKAIICyECIAAgATYCDCACEAgLIAAQCAttAQJ/QSgQCSICQX82AgAgAkEIaiIDQgA3AxAgA0EANgIIIANCADcCACADQgA3AxggACACIAAoAgAoAhARBAAgASgCWCEAIAEgAjYCWCAABEAgACgCCCIBBEAgACABNgIMIAEQCAsgABAIC0EBC/gFAQV/QX8hAwJ/QX8gAUF/Rg0AGiABQQFqIgIgAUEC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hAEgCSAHQQRqNgKIASAGIAMgBUECdGo2AowBIAJFDQAgAhAICyAEQQFqIgQgACgC3AEgACgC2AFrQZABbUkNAQwECwsQDAALQbzfABANAAtBACEEIAAoAtgBIgYgACgC3AFGDQADQAJAIAYgBEGQAWxqIgYiCSgCiAEiAiAGKAKMASIDSQRAIAIgATYCACAJIAJBBGo2AogBDAELIAIgBigChAEiAmsiCkECdSIHQQFqIgVBgICAgARPDQQCf0EAIAUgAyACayIDQQF1IgsgBSALSxtB/////wMgA0ECdUH/////AUkbIgVFDQAaIAVBgICAgARPDQYgBUECdBAJCyIDIAdBAnRqIgcgATYCACAKQQFOBEAgAyACIAoQChoLIAYgAzYChAEgCSAHQQRqNgKIASAGIAMgBUECdGo2AowBIAJFDQAgAhAICyAEQQFqIgQgACgC3AEgACgC2AEiBmtBkAFtSQ0ACwsgDEEBaiIMQQNHBEAgCCAMQQJ0aigCACEBDAELCyAIQRBqJABBAQ8LEAwAC0G83wAQDQALdQECfyAAIAE2ApABIAEgASgCACgCIBEAACgCICICKAIAIAIoAhBqIQIgASABKAIAKAIgEQAAKAIgIgMpAwggAykDEH2nIQMgACABIAEoAgAoAiARAAAoAiAvASY7ASYgACACNgIAIABCADcDECAAIAOtNwMIC4cLAQZ/IAEgACgCBCIDIAAoAgAiBGtBkAFtIgJLBEACQCABIAJrIgIgACIDKAIIIgEgACgCBCIAa0GQAW1NBEAgAyACBH8gACACQZABbGohAQNAIABBfzYCACAAQQRqENEBIABCADcCaCAAQQE6AGQgAEIANwJwIABCADcCeCAAQgA3AoABIABCADcCiAEgAEGQAWoiACABRw0ACyABBSAACzYCBAwBCwJAAkACQCAAIAMoAgAiBGtBkAFtIgYgAmoiAEHyuJwOSQRAAn9BACAAIAEgBGtBkAFtIgFBAXQiBCAAIARLG0HxuJwOIAFBuJyOB0kbIgRFDQAaIARB8ricDk8NAiAEQZABbBAJCyIHIAZBkAFsaiIBIAJBkAFsaiEGIAEhAANAIABBfzYCACAAQQRqENEBIABCADcCaCAAQQE6AGQgAEIANwJwIABCADcCeCAAQgA3AoABIABCADcCiAEgAEGQAWoiACAGRw0ACyAHIARBkAFsaiEHIAMoAgQiACADKAIAIgRGDQIDQCABQZABayICIABBkAFrIgAiASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCABQQA2AgwgAUIANwIEIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAFBADYCGCABQgA3AhAgAS0AHCEFIAJBADYCKCACQgA3AiAgAiAFOgAcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAFBADYCKCABQgA3AiAgAkEANgI0IAJCADcCLCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCABQQA2AjQgAUIANwIsIAJBQGsiBUEANgIAIAJCADcCOCACIAEoAjg2AjggAiABKAI8NgI8IAUgAUFAayIFKAIANgIAIAVBADYCACABQgA3AjggAiABKAJENgJEIAEoAkghBSACQQA2AlQgAkIANwJMIAIgBTYCSCACIAEoAkw2AkwgAiABKAJQNgJQIAIgASgCVDYCVCABQQA2AlQgAUIANwJMIAJBADYCYCACQgA3AlggAiABKAJYNgJYIAIgASgCXDYCXCACIAEoAmA2AmAgAUEANgJgIAFCADcCWCABLQBkIQUgAkEANgJwIAJCADcCaCACIAU6AGQgAiABKAJoNgJoIAIgASgCbDYCbCACIAEoAnA2AnAgAUEANgJwIAFCADcCaCACQQA2AnwgAkIANwJ0IAIgASgCdDYCdCACIAEoAng2AnggAiABKAJ8NgJ8IAFBADYCfCABQgA3AnQgASgCgAEhBSACQQA2AowBIAJCADcChAEgAiAFNgKAASACIAEoAoQBNgKEASACIAEoAogBNgKIASACIAEoAowBNgKMASABQQA2AowBIAFCADcChAEgAiEBIAAgBEcNAAsgAyAHNgIIIAMoAgQhACADIAY2AgQgAygCACEEIAMgATYCACAAIARGDQMDQCAAQQxrKAIAIgEEQCAAQQhrIAE2AgAgARAICyAAQRxrKAIAIgEEQCAAQRhrIAE2AgAgARAICyAAQShrKAIAIgEEQCAAQSRrIAE2AgAgARAICyAAQYwBaxBOIABBkAFrIgEhACABIARHDQALDAMLEAwAC0G83wAQDQALIAMgBzYCCCADIAY2AgQgAyABNgIACyAEBEAgBBAICwsPCyABIAJJBEAgBCABQZABbGoiASADRwRAA0AgA0EMaygCACICBEAgA0EIayACNgIAIAIQCAsgA0EcaygCACICBEAgA0EYayACNgIAIAIQCAsgA0EoaygCACICBEAgA0EkayACNgIAIAIQCAsgA0GMAWsQTiADQZABayICIQMgASACRw0ACwsgACABNgIECwuKAQEDfyAAKAIEIgIgACgCACIDRwRAA0AgAkEMaygCACIBBEAgAkEIayABNgIAIAEQCAsgAkEcaygCACIBBEAgAkEYayABNgIAIAEQCAsgAkEoaygCACIBBEAgAkEkayABNgIAIAEQCAsgAkGMAWsQTiACQZABayIBIQIgASADRw0ACwsgACADNgIEC/0CAQd/IAEgACgCCCIEIAAoAgQiAmtBAnVNBEAgACABBH8gAkEAIAFBAnQiABALIABqBSACCzYCBA8LAkACQAJAIAIgACgCACIGa0ECdSIFIAFqIgNBgICAgARJBEACfyADIAQgBmsiBEEBdSIHIAMgB0sbQf////8DIARBAnVB/////wFJGyIDBEAgA0GAgICABE8NAyADQQJ0EAkhCAsgCCAFQQJ0aiIEC0EAIAFBAnQiARALIgcgAWohBSAIIANBAnRqIQEgAiAGRg0CA0AgAkEEayICKAIAIQMgAkEANgIAIARBBGsiBCADNgIAIAIgBkcNAAsgACABNgIIIAAoAgQhASAAIAU2AgQgACgCACECIAAgBDYCACABIAJGDQMDQCABQQRrIgEoAgAhACABQQA2AgAgAARAIAAgACgCACgCBBECAAsgASACRw0ACwwDCxAMAAtBvN8AEA0ACyAAIAE2AgggACAFNgIEIAAgBzYCAAsgAgRAIAIQCAsLhQMBAn8gACABKQIENwIEIAAgASgCFDYCFCAAIAEpAgw3AgwCQAJAIAAgAUcEQCAAIAEoAhwiAgR/AkAgACgCIEEFdCACTwRAIAAoAhghAwwBCyAAKAIYIgMEQCADEAggAEEANgIgIABCADcCGCABKAIcIQILIAJBf0wNAyACQQFrQQV2QQFqIgJBAnQQCSEDIAAgAjYCICAAQQA2AhwgACADNgIYIAEoAhwhAgsgAyABKAIYIAJBAWtBA3ZB/P///wFxQQRqECMaIAEoAhwFQQALNgIcIAAgASgCKCICBH8CQCAAKAIsQQV0IAJPBEAgACgCJCEDDAELIAAoAiQiAwRAIAMQCCAAQQA2AiwgAEIANwIkIAEoAighAgsgAkF/TA0EIAJBAWtBBXZBAWoiAkECdBAJIQMgACACNgIsIABBADYCKCAAIAM2AiQgASgCKCECCyADIAEoAiQgAkEBa0EDdkH8////AXFBBGoQIxogASgCKAVBAAs2AigLDwsQDAALEAwAC8oQAgt/A34jAEHwAGsiBCQAAkAgACgCBCIGKAIgIgMpAwgiDyADKQMQIg5XDQAgAygCACIKIA6nai0AACEFIAMgDkIBfCINNwMQIA0gD1kNACAKIA2nai0AACEIIAMgDkICfCINNwMQAkAgBUEYdEEYdSIJQQBOBEAgACgC3AEgACgC2AEiAmtBkAFtIAVNDQIgAiAFQZABbGoiAigCAEF/TA0BDAILIAAoAtQBQX9KDQEgAEHUAWohAgsgAiABNgIAQQAhAiAGLwEkIgdBCHQgB0EIdnJB//8DcUGCAk8EQEEAIQcgDSAPWQ0BIAogDadqLQAAIQIgAyAOQgN8NwMQIAJBAUsiAw0BQQAgAiADGyECCwJAAkACQCAIRQRAIAlBf0wEfyAAQbgBagUgACgC2AEgBUGQAWxqIgNBADoAZCADQegAagshBUEAIQcCQCACDgIAAgULIwBBQGoiAiQAIAAoAgQoAiwhCkHQABAJIgNB8OMANgIAIANBADYCBCADQQA2AkwgAyAFNgJIIAMgCjYCRCADQZTlADYCCCADQgA3AgwgA0IANwIUIANCADcCHCADQgA3AiQgA0IANwIsIANBADYCNCADQUBrQQA2AgAgA0E4aiIJQgA3AgAgACgCCCEGIAJCADcDKCACQgA3AyAgAkEYaiIIQgA3AwAgAkIANwMQIAJCADcDCCACQQA2AjggAkIANwMwIAJBlOUANgIAIAIgBjYCBCAGKAIAIQsgBigCBCEMIAJBADoAPyAIIAwgC2tBAnVBA24gAkE/ahAeIAIoAgQiCCgCHCELIAgoAhghCCACQQA6AD8gAkEkaiALIAhrQQJ1IAJBP2oQHiACIAM2AhQgAiAKNgIQIAIgBTYCDCACIAY2AgggA0EIaiACEKMBIAkgAigCMCACKAI0EEsgBCADNgIwIAJBlOUANgIAIAIoAjAiAwRAIAIgAzYCNCADEAgLIAJB3OMANgIAIAIoAiQiAwRAIAMQCAsgAigCGCIDBEAgAxAICyACQUBrJAAMAgtBACEHIAINAyAJQQBIDQMgBigCLCEDIAAoAtgBIQdB0AAQCSICQQA2AkwgAiADNgJEIAJBtN0ANgIIIAJBlOYANgIAIAJBADYCBCACIAcgBUGQAWxqIgVB6ABqIgc2AkggAkFAa0EANgIAIAJCADcCOCACQQA2AjQgAkIANwIsIAJCADcCJCACQgA3AhwgAkIANwIUIAJCADcCDCAEIAM2AiggBEIANwJUIARCADcCTCAEQgA3AkQgBEIANwI8IARCADcCZCAEQgA3AlwgBCACNgIsIAQgBCkDKDcDCCAEIAVBBGoiAzYCICAEIAc2AiQgBEIANwI0IARBtN0ANgIwIAQgBCkDIDcDACAEQTBqIAMgBBDvASACQQhqIgUgBEEwaiIDEKMBIAMgBUcEQCACQThqIAMoAjAgAygCNBBLCyAEQTBqEO4BGgwCCyMAQfAAayIDJAAgACgCBCgCLCEKQfgAEAkiAkGc4AA2AgAgAkEANgIEIAJBADYCdCACIAU2AnAgAiAKNgJsIAJCADcCDCACQgA3AhQgAkIANwIcIAJCADcCJCACQgA3AiwgAkEANgI0IAJCADcCOCACQfDhADYCCCACQUBrQgA3AgAgAkIANwJIIAJCADcCUCACQQA2AlggAkEANgJoIAJCADcCYCAAKAIIIQYgA0IANwMwIANCADcDKCADQSBqIglCADcDACADQgA3AxggA0IANwMQIANBQGtCADcDACADQgA3A0ggA0IANwNQIANBADYCWCADQQA2AmggA0IANwM4IANB8OEANgIIIANCADcDYCADIAY2AgwgBigCACEIIAYoAgQhCyADQQA6AG8gCSALIAhrQQJ1QQNuIANB7wBqEB4gAygCDCIJKAIcIQggCSgCGCEJIANBADoAbyADQSxqIAggCWtBAnUgA0HvAGoQHiADIAI2AhwgAyAKNgIYIAMgBTYCFCADIAY2AhAgAkEIaiIGIANBCGoiBRCjAQJAIAUgBkYEQCACIAUoAlQ2AlwMAQsgAkE4aiAFKAIwIAUoAjQQSyACQcQAaiAFKAI8IAVBQGsoAgAQSyACQdAAaiAFKAJIIAUoAkwQSyACIAUoAlQ2AlwgAkHgAGogBSgCWCAFKAJcEBILIAQgAjYCMCADQfDhADYCCCADKAJgIgIEQCADIAI2AmQgAhAICyADKAJQIgIEQCADIAI2AlQgAhAICyADKAJEIgIEQCADIAI2AkggAhAICyADKAI4IgIEQCADIAI2AjwgAhAICyADQdzjADYCCCADKAIsIgIEQCACEAgLIAMoAiAiAgRAIAIQCAsgA0HwAGokAAsgBCgCMCICRQ0BC0HAABAJIQMgBCACNgIYIAMgBEEYahCtASEDIAQoAhghAiAEQQA2AhggAgRAIAIgAigCACgCBBECAAsgACgCBCEAIAQgAzYCEAJAIAFBAEgNACAAQQhqIQcCQCAAKAIMIgIgACgCCCIGa0ECdSIDIAFKDQAgAUEBaiEFIAEgA08EQCAHIAUgA2sQogEMAQsgAyAFTQ0AIAYgBUECdGoiBSACRwRAA0AgAkEEayICKAIAIQMgAkEANgIAIAMEQCADIAMoAgAoAgQRAgALIAIgBUcNAAsLIAAgBTYCDAsgBCgCECECIAcoAgAhACAEQQA2AhAgACABQQJ0aiIDKAIAIQAgAyACNgIAIABFDQAgACAAKAIAKAIEEQIACyABQX9zQR92IQcgBCgCECEAIARBADYCECAARQ0AIAAgACgCACgCBBECAAsgBEHwAGokACAHC9ABAQR/IAAoAtgBIgIgACgC3AFHBEADQAJAIAIgBEGQAWxqKAIAIgJBAEgNACACIAAoAgQiAygCDCADKAIIIgVrQQJ1Tg0AQQAhAyAFIAJBAnRqKAIAIgIgAigCACgCGBEAAEEATA0AA0AgAiADIAIoAgAoAhQRAQAgAUcEQCACIAIoAgAoAhgRAAAgA0EBaiIDSg0BDAILCyAAKALYASAEQZABbGpB6ABqDwsgBEEBaiIEIAAoAtwBIAAoAtgBIgJrQZABbUkNAAsLIABBuAFqC9UBAQR/IAAoAtgBIgIgACgC3AFHBEADQAJAIAIgBEGQAWxqKAIAIgJBAEgNACACIAAoAgQiAygCDCADKAIIIgVrQQJ1Tg0AQQAhAyAFIAJBAnRqKAIAIgIgAigCACgCGBEAAEEATA0AA0AgAiADIAIoAgAoAhQRAQAgAUcEQCACIAIoAgAoAhgRAAAgA0EBaiIDSg0BDAILCyAAKALYASAEQZABbGoiAEEEakEAIAAtAGQbDwsgBEEBaiIEIAAoAtwBIAAoAtgBIgJrQZABbUkNAAsLQQALCwAgACABNgIEQQEL7gYCCH8CfgJAIAEvASYiAkUNAAJAIAJB/wNNBEAgASkDCCABKQMQIgpCBHxTDQIgACABKAIAIAqnaigAACIDNgIMIAEgASkDEEIEfDcDEAwBC0EBIABBDGogARA1RQ0BIAAoAgwhAwsCQCAAKAIEIAAoAgAiBWtBAnUiAiADSQRAIAAgAyACaxAaIAAoAgwhAwwBCyACIANNDQAgACAFIANBAnRqNgIECyADRQRAQQEhBgwBCyABKQMIIQtBACEFA0AgCyABKQMQIgpXDQEgASgCACIHIAqnai0AACEIIAEgCkIBfCIKNwMQIAhBAnYhAkEAIQQCQAJAAkACQCAIQQNxIgkOBAIBAQABCyADIAIgBWoiAk0EQEEADwsgACgCACAFQQJ0akEAIAhB/AFxQQRqEAsaIAIhBQwCCwNAIAogC1kEQEEADwsgByAKp2otAAAhAyABIApCAXwiCjcDECADIARBA3RBBnJ0IAJyIQIgBEEBaiIEIAlHDQALCyAAKAIAIAVBAnRqIAI2AgALIAVBAWoiBSAAKAIMIgNJDQALIABBEGohCCAAKAIAIQYCQCAAKAIUIAAoAhAiAWsiAkECdSIFQf8fTQRAIAhBgCAgBWsQGgwBCyACQYCAAUYNACAAIAFBgIABajYCFAsCQCAAKAIgIABBHGoiASgCACIFa0EDdSICIANJBEAgASADIAJrED8gASgCACEFDAELIAIgA0sEQCAAIAUgA0EDdGo2AiALIAMNAEEADwsgBigCACEAQQAhAiAFQQA2AgQgBSAANgIAAn9BASAGKAIAIgFBgCBLDQAaQQAhBAJAA0ACQCABIgAgAk0NACAAIAJBf3NqIQkgCCgCACEHIAAgAmtBB3EiAQRAA0AgByACQQJ0aiAENgIAIAJBAWohAiABQQFrIgENAAsLIAlBBk0NAANAIAcgAkECdGoiASAENgIAIAEgBDYCHCABIAQ2AhggASAENgIUIAEgBDYCECABIAQ2AgwgASAENgIIIAEgBDYCBCACQQhqIgIgAEcNAAsLIAMgBEEBaiIERwRAIAYgBEECdGoiASgCACECIAUgBEEDdGoiByAANgIEIAcgAjYCACAAIgIgASgCAGoiAUGAIEsNAgwBCwsgACEBCyADIARLC0EBcyABQYAgRnEPCyAGC5dRAhR/A34gAEUEQEEBDwsCQCACKQMQIhggAikDCFkNACACKAIAIBinai0AACEGIAIgGEIBfDcDEAJAAkAgBg4CAAECCyAAIQogASEGIwBBQGoiBSQAIAVBADYCOCAFQgA3AzAgBUIANwMoIAVCADcDICAFQgA3AxggBUIANwMQIAVCADcDCAJAIAVBCGogAhCoAUUNACAFQQhqIAIQ8gFFDQAgCgRAIAUoAhRFDQELIAJBAEEAEEwaAkAgCkUNACAFKAIkIQ8gBSgCMCEQIAUoAhghESAGQQBMBEAgBSgCOCEHA0ACQCAHQf//AEsNACAFKAI0IQADQCAAQQFIDQEgBSAAQQFrIgA2AjQgBSAAIBBqLQAAIAdBCHRyIgc2AjggB0GAgAFJDQALCyAFIA8gESAHQf8fcSIAQQJ0aigCAEEDdGoiASgCACAHQQx2bCAAaiABKAIEayIHNgI4IAYgCWoiCSAKSQ0ACwwBCwJAIAItACQEQCAGQQJ0IRUgBSgCOCEIA0ACQCAIQf//AEsNACAFKAI0IQADQCAAQQFIDQEgBSAAQQFrIgA2AjQgBSAAIBBqLQAAIAhBCHRyIgg2AjggCEGAgAFJDQALCyAFIA8gESAIQf8fcSIAQQJ0aigCACIMQQN0aiIBKAIAIAhBDHZsIABqIAEoAgRrIgg2AjggDEEgSw0CAn8gDEUEQCADIAtBAnRqQQAgFRALGiAGIAtqDAELIAxBfnEhBCAMQQFxIRYgBiALaiEUIAIoAiAhASACKAIcIRIgAigCGCETA0BBACEHIAEhAEEAIQkgBCENIAxBAUcEQANAAkAgEiATIABBA3ZqIg5NBEBBACEODAELIA4tAAAhDiACIABBAWoiATYCICAOIABBB3F2QQFxIAd0IQ4gASEACyAJIA5yIQkCQCASIBMgAEEDdmoiDk0EQEEAIQ4MAQsgDi0AACEOIAIgAEEBaiIBNgIgIA4gAEEHcXZBAXEgB0EBcnQhDiABIQALIAdBAmohByAJIA5yIQkgDUECayINDQALCyADIAtBAnRqIBYEfwJ/QQAgEiATIABBA3ZqIg1NDQAaIA0tAAAhDSACIABBAWoiATYCICANIABBB3F2QQFxIAd0CyAJcgUgCQs2AgAgC0EBaiILIBRHDQALIBQLIQsgCiAGIBdqIhdLDQALDAILAkAgBSgCOCIHQf//AEsNACAFKAI0IQADQCAAQQFIDQEgBSAAQQFrIgA2AjQgBSAAIBBqLQAAIAdBCHRyIgc2AjggB0GAgAFJDQALCyAFIA8gESAHQf8fcSIAQQJ0aigCAEEDdGoiASgCACAHQQx2bCAAaiABKAIEazYCOAtBACEHDAELIAJBADoAJCACIAIpAxAgAjUCIEIHfEIDiHw3AxBBASEHCyAFKAIkIgAEQCAFIAA2AiggABAICyAFKAIYIgAEQCAFIAA2AhwgABAICyAFKAIIIgAEQCAFIAA2AgwgABAICyAFQUBrJAAgBw8LAn9BACEBAkACQAJAIAIpAxAiGCACKQMIWQ0AIAIoAgAgGKdqLQAAIQYgAiAYQgF8NwMQAkACQAJAAkACQAJAAkAgBkEBaw4SCAgICAAICAgBAgMEBQkJCQkGBwtBACEGIwBBQGoiASQAIAFBADYCOCABQgA3AzAgAUIANwMoIAFCADcDICABQgA3AxggAUIANwMQIAFCADcDCAJAIAFBCGogAhCoAUUNACAABEAgASgCFEUNAQsgAUEIaiACEPIBRQ0AIABFBEBBASEGDAELIAEoAiQhDSABKAIwIQQgASgCGCEFIAEoAjghAgNAAkAgAkH//wBLDQAgASgCNCEGA0AgBkEBSA0BIAEgBkEBayIGNgI0IAEgBCAGai0AACACQQh0ciICNgI4IAJBgIABSQ0ACwsgASANIAUgAkH/H3EiBkECdGooAgAiB0EDdGoiCCgCACACQQx2bCAGaiAIKAIEayICNgI4IAMgCkECdGogBzYCAEEBIQYgCkEBaiIKIABHDQALCyABKAIkIgAEQCABIAA2AiggABAICyABKAIYIgAEQCABIAA2AhwgABAICyABKAIIIgAEQCABIAA2AgwgABAICyABQUBrJAAgBgwJCyAAIQogAyENQQAhBiMAQUBqIgQkACAEQQA2AjAgBEIANwMoIARCADcDICAEQgA3AxggBEIANwMQIARCADcDCCAEQgA3AwACQAJ/AkAgAi8BJiIARQ0AAkAgAEH/A00EQCACKQMIIAIpAxAiGEIEfFMNAiAEIAIoAgAgGKdqKAAAIgc2AgwgAiACKQMQQgR8NwMQDAELQQEgBEEMaiACEDVFDQEgBCgCDCEHCwJAIAQoAgQgBCgCACIBa0ECdSIAIAdJBEAgBCAHIABrEBogBCgCDCEHDAELIAAgB00NACAEIAEgB0ECdGo2AgQLIAdFBEBBASEIDAELIAIpAwghGQNAIBkgAikDECIYVw0BIAIoAgAiACAYp2otAAAhASACIBhCAXwiGDcDECABQQJ2IQNBACEFAkACQAJAAkAgAUEDcSILDgQCAQEAAQtBACAHIAMgBmoiAE0NBRogBCgCACAGQQJ0akEAIAFB/AFxQQRqEAsaIAAhBgwCCwNAQQAgGCAZWQ0FGiAAIBinai0AACEBIAIgGEIBfCIYNwMQIAEgBUEDdEEGcnQgA3IhAyAFQQFqIgUgC0cNAAsLIAQoAgAgBkECdGogAzYCAAsgBkEBaiIGIAQoAgwiB0kNAAsgBEEQaiELIAQoAgAhCAJAIAQoAhQgBCgCECIAayIBQQJ1IgNB/z9NBEAgC0GAwAAgA2sQGgwBCyABQYCAAkYNACAEIABBgIACajYCFAsCQCAEKAIgIARBHGoiACgCACIGa0EDdSIBIAdJBEAgACAHIAFrED8gACgCACEGDAELIAEgB0sEQCAEIAYgB0EDdGo2AiALIAcNAEEADAILIAgoAgAhAEEAIQMgBkEANgIEIAYgADYCAAJ/QQEgCCgCACIBQYDAAEsNABpBACEFAkADQAJAIAEiACADTQ0AIAAgA0F/c2ohDiALKAIAIQwgACADa0EHcSIBBEADQCAMIANBAnRqIAU2AgAgA0EBaiEDIAFBAWsiAQ0ACwsgDkEGTQ0AA0AgDCADQQJ0aiIBIAU2AgAgASAFNgIcIAEgBTYCGCABIAU2AhQgASAFNgIQIAEgBTYCDCABIAU2AgggASAFNgIEIANBCGoiAyAARw0ACwsgByAFQQFqIgVHBEAgCCAFQQJ0aiIBKAIAIQMgBiAFQQN0aiIMIAA2AgQgDCADNgIAIAAiAyABKAIAaiIBQYDAAEsNAgwBCwsgACEBCyAFIAdJC0EBcyABQYDAAEZxDAELIAgLRQ0AIAoEQCAEKAIMRQ0BCwJAIAIvASZB/wNNBEAgAikDCCIaIAIpAxAiGEIIfCIZUw0CIAIoAgAgGKdqKQAAIRggAiAZNwMQDAELQQEgBEE4aiACEC9FDQEgAikDECEZIAIpAwghGiAEKQM4IRgLIBggGiAZfVYNACACIBggGXw3AxAgGKciAEEBSA0AIAQgAigCACAZp2oiAjYCKCAEAn8CQAJAAkACQCACIABBAWsiAWoiAy0AAEEGdkEBaw4DAAECAwsgAEECSA0EIAQgAEECayIBNgIsIAAgAmpBAmsiAC0AAUEIdEGA/gBxIAAtAAByDAMLIABBA0gNAyAEIABBA2siATYCLCAAIAJqQQNrIgAtAAJBEHRBgID8AXEgAC0AAUEIdHIgAC0AAHIMAgsgBCAAQQRrIgE2AiwgACACakEEayIALQACQRB0IAAtAANBGHRBgICA+ANxciAALQABQQh0ciAALQAAcgwBCyAEIAE2AiwgAy0AAEE/cQtBgIACaiIANgIwIABB////A0sNACAKRQRAQQEhCQwBCyAEKAIcIQNBACEIIAQoAhAhBgNAAkAgAEH//wFLDQADQCABQQFIDQEgBCABQQFrIgE2AiwgBCABIAJqLQAAIABBCHRyIgA2AjAgAEGAgAJJDQALCyAEIAMgBiAAQf8/cSIFQQJ0aigCACIHQQN0aiIJKAIAIABBDXZsIAVqIAkoAgRrIgA2AjAgDSAIQQJ0aiAHNgIAQQEhCSAIQQFqIgggCkcNAAsLIAQoAhwiAARAIAQgADYCICAAEAgLIAQoAhAiAARAIAQgADYCFCAAEAgLIAQoAgAiAARAIAQgADYCBCAAEAgLIARBQGskACAJDAgLIAAhCiADIQ1BACEGIwBBQGoiBCQAIARBADYCMCAEQgA3AyggBEIANwMgIARCADcDGCAEQgA3AxAgBEIANwMIIARCADcDAAJAAn8CQCACLwEmIgBFDQACQCAAQf8DTQRAIAIpAwggAikDECIYQgR8Uw0CIAQgAigCACAYp2ooAAAiBzYCDCACIAIpAxBCBHw3AxAMAQtBASAEQQxqIAIQNUUNASAEKAIMIQcLAkAgBCgCBCAEKAIAIgFrQQJ1IgAgB0kEQCAEIAcgAGsQGiAEKAIMIQcMAQsgACAHTQ0AIAQgASAHQQJ0ajYCBAsgB0UEQEEBIQgMAQsgAikDCCEZA0AgGSACKQMQIhhXDQEgAigCACIAIBinai0AACEBIAIgGEIBfCIYNwMQIAFBAnYhA0EAIQUCQAJAAkACQCABQQNxIgsOBAIBAQABC0EAIAcgAyAGaiIATQ0FGiAEKAIAIAZBAnRqQQAgAUH8AXFBBGoQCxogACEGDAILA0BBACAYIBlZDQUaIAAgGKdqLQAAIQEgAiAYQgF8Ihg3AxAgASAFQQN0QQZydCADciEDIAVBAWoiBSALRw0ACwsgBCgCACAGQQJ0aiADNgIACyAGQQFqIgYgBCgCDCIHSQ0ACyAEQRBqIQsgBCgCACEIAkAgBCgCFCAEKAIQIgBrIgFBAnUiA0H//wFNBEAgC0GAgAIgA2sQGgwBCyABQYCACEYNACAEIABBgIAIajYCFAsCQCAEKAIgIARBHGoiACgCACIGa0EDdSIBIAdJBEAgACAHIAFrED8gACgCACEGDAELIAEgB0sEQCAEIAYgB0EDdGo2AiALIAcNAEEADAILIAgoAgAhAEEAIQMgBkEANgIEIAYgADYCAAJ/QQEgCCgCACIBQYCAAksNABpBACEFAkADQAJAIAEiACADTQ0AIAAgA0F/c2ohDiALKAIAIQwgACADa0EHcSIBBEADQCAMIANBAnRqIAU2AgAgA0EBaiEDIAFBAWsiAQ0ACwsgDkEGTQ0AA0AgDCADQQJ0aiIBIAU2AgAgASAFNgIcIAEgBTYCGCABIAU2AhQgASAFNgIQIAEgBTYCDCABIAU2AgggASAFNgIEIANBCGoiAyAARw0ACwsgByAFQQFqIgVHBEAgCCAFQQJ0aiIBKAIAIQMgBiAFQQN0aiIMIAA2AgQgDCADNgIAIAAiAyABKAIAaiIBQYCAAksNAgwBCwsgACEBCyAFIAdJC0EBcyABQYCAAkZxDAELIAgLRQ0AIAoEQCAEKAIMRQ0BCwJAIAIvASZB/wNNBEAgAikDCCIaIAIpAxAiGEIIfCIZUw0CIAIoAgAgGKdqKQAAIRggAiAZNwMQDAELQQEgBEE4aiACEC9FDQEgAikDECEZIAIpAwghGiAEKQM4IRgLIBggGiAZfVYNACACIBggGXw3AxAgGKciAEEBSA0AIAQgAigCACAZp2oiAjYCKCAEAn8CQAJAAkACQCACIABBAWsiAWoiAy0AAEEGdkEBaw4DAAECAwsgAEECSA0EIAQgAEECayIBNgIsIAAgAmpBAmsiAC0AAUEIdEGA/gBxIAAtAAByDAMLIABBA0gNAyAEIABBA2siATYCLCAAIAJqQQNrIgAtAAJBEHRBgID8AXEgAC0AAUEIdHIgAC0AAHIMAgsgBCAAQQRrIgE2AiwgACACakEEayIALQACQRB0IAAtAANBGHRBgICA+ANxciAALQABQQh0ciAALQAAcgwBCyAEIAE2AiwgAy0AAEE/cQtBgIAIaiIANgIwIABB////D0sNACAKRQRAQQEhCQwBCyAEKAIcIQNBACEIIAQoAhAhBgNAAkAgAEH//wdLDQADQCABQQFIDQEgBCABQQFrIgE2AiwgBCABIAJqLQAAIABBCHRyIgA2AjAgAEGAgAhJDQALCyAEIAMgBiAAQf//AXEiBUECdGooAgAiB0EDdGoiCSgCACAAQQ92bCAFaiAJKAIEayIANgIwIA0gCEECdGogBzYCAEEBIQkgCEEBaiIIIApHDQALCyAEKAIcIgAEQCAEIAA2AiAgABAICyAEKAIQIgAEQCAEIAA2AhQgABAICyAEKAIAIgAEQCAEIAA2AgQgABAICyAEQUBrJAAgCQwHCyAAIQogAyENQQAhBiMAQUBqIgQkACAEQQA2AjAgBEIANwMoIARCADcDICAEQgA3AxggBEIANwMQIARCADcDCCAEQgA3AwACQAJ/AkAgAi8BJiIARQ0AAkAgAEH/A00EQCACKQMIIAIpAxAiGEIEfFMNAiAEIAIoAgAgGKdqKAAAIgc2AgwgAiACKQMQQgR8NwMQDAELQQEgBEEMaiACEDVFDQEgBCgCDCEHCwJAIAQoAgQgBCgCACIBa0ECdSIAIAdJBEAgBCAHIABrEBogBCgCDCEHDAELIAAgB00NACAEIAEgB0ECdGo2AgQLIAdFBEBBASEIDAELIAIpAwghGQNAIBkgAikDECIYVw0BIAIoAgAiACAYp2otAAAhASACIBhCAXwiGDcDECABQQJ2IQNBACEFAkACQAJAAkAgAUEDcSILDgQCAQEAAQtBACAHIAMgBmoiAE0NBRogBCgCACAGQQJ0akEAIAFB/AFxQQRqEAsaIAAhBgwCCwNAQQAgGCAZWQ0FGiAAIBinai0AACEBIAIgGEIBfCIYNwMQIAEgBUEDdEEGcnQgA3IhAyAFQQFqIgUgC0cNAAsLIAQoAgAgBkECdGogAzYCAAsgBkEBaiIGIAQoAgwiB0kNAAsgBEEQaiELIAQoAgAhCAJAIAQoAhQgBCgCECIAayIBQQJ1IgNB//8DTQRAIAtBgIAEIANrEBoMAQsgAUGAgBBGDQAgBCAAQYCAEGo2AhQLAkAgBCgCICAEQRxqIgAoAgAiBmtBA3UiASAHSQRAIAAgByABaxA/IAAoAgAhBgwBCyABIAdLBEAgBCAGIAdBA3RqNgIgCyAHDQBBAAwCCyAIKAIAIQBBACEDIAZBADYCBCAGIAA2AgACf0EBIAgoAgAiAUGAgARLDQAaQQAhBQJAA0ACQCABIgAgA00NACAAIANBf3NqIQ4gCygCACEMIAAgA2tBB3EiAQRAA0AgDCADQQJ0aiAFNgIAIANBAWohAyABQQFrIgENAAsLIA5BBk0NAANAIAwgA0ECdGoiASAFNgIAIAEgBTYCHCABIAU2AhggASAFNgIUIAEgBTYCECABIAU2AgwgASAFNgIIIAEgBTYCBCADQQhqIgMgAEcNAAsLIAcgBUEBaiIFRwRAIAggBUECdGoiASgCACEDIAYgBUEDdGoiDCAANgIEIAwgAzYCACAAIgMgASgCAGoiAUGAgARLDQIMAQsLIAAhAQsgBSAHSQtBAXMgAUGAgARGcQwBCyAIC0UNACAKBEAgBCgCDEUNAQsCQCACLwEmQf8DTQRAIAIpAwgiGiACKQMQIhhCCHwiGVMNAiACKAIAIBinaikAACEYIAIgGTcDEAwBC0EBIARBOGogAhAvRQ0BIAIpAxAhGSACKQMIIRogBCkDOCEYCyAYIBogGX1WDQAgAiAYIBl8NwMQIBinIgBBAUgNACAEIAIoAgAgGadqIgI2AiggBAJ/AkACQAJAAkAgAiAAQQFrIgFqIgMtAABBBnZBAWsOAwABAgMLIABBAkgNBCAEIABBAmsiATYCLCAAIAJqQQJrIgAtAAFBCHRBgP4AcSAALQAAcgwDCyAAQQNIDQMgBCAAQQNrIgE2AiwgACACakEDayIALQACQRB0QYCA/AFxIAAtAAFBCHRyIAAtAAByDAILIAQgAEEEayIBNgIsIAAgAmpBBGsiAC0AAkEQdCAALQADQRh0QYCAgPgDcXIgAC0AAUEIdHIgAC0AAHIMAQsgBCABNgIsIAMtAABBP3ELQYCAEGoiADYCMCAAQf///x9LDQAgCkUEQEEBIQkMAQsgBCgCHCEDQQAhCCAEKAIQIQYDQAJAIABB//8PSw0AA0AgAUEBSA0BIAQgAUEBayIBNgIsIAQgASACai0AACAAQQh0ciIANgIwIABBgIAQSQ0ACwsgBCADIAYgAEH//wNxIgVBAnRqKAIAIgdBA3RqIgkoAgAgAEEQdmwgBWogCSgCBGsiADYCMCANIAhBAnRqIAc2AgBBASEJIAhBAWoiCCAKRw0ACwsgBCgCHCIABEAgBCAANgIgIAAQCAsgBCgCECIABEAgBCAANgIUIAAQCAsgBCgCACIABEAgBCAANgIEIAAQCAsgBEFAayQAIAkMBgsgACEKIAMhDUEAIQYjAEFAaiIEJAAgBEEANgIwIARCADcDKCAEQgA3AyAgBEIANwMYIARCADcDECAEQgA3AwggBEIANwMAAkACfwJAIAIvASYiAEUNAAJAIABB/wNNBEAgAikDCCACKQMQIhhCBHxTDQIgBCACKAIAIBinaigAACIHNgIMIAIgAikDEEIEfDcDEAwBC0EBIARBDGogAhA1RQ0BIAQoAgwhBwsCQCAEKAIEIAQoAgAiAWtBAnUiACAHSQRAIAQgByAAaxAaIAQoAgwhBwwBCyAAIAdNDQAgBCABIAdBAnRqNgIECyAHRQRAQQEhCAwBCyACKQMIIRkDQCAZIAIpAxAiGFcNASACKAIAIgAgGKdqLQAAIQEgAiAYQgF8Ihg3AxAgAUECdiEDQQAhBQJAAkACQAJAIAFBA3EiCw4EAgEBAAELQQAgByADIAZqIgBNDQUaIAQoAgAgBkECdGpBACABQfwBcUEEahALGiAAIQYMAgsDQEEAIBggGVkNBRogACAYp2otAAAhASACIBhCAXwiGDcDECABIAVBA3RBBnJ0IANyIQMgBUEBaiIFIAtHDQALCyAEKAIAIAZBAnRqIAM2AgALIAZBAWoiBiAEKAIMIgdJDQALIARBEGohCyAEKAIAIQgCQCAEKAIUIAQoAhAiAGsiAUECdSIDQf//D00EQCALQYCAECADaxAaDAELIAFBgIDAAEYNACAEIABBgIBAazYCFAsCQCAEKAIgIARBHGoiACgCACIGa0EDdSIBIAdJBEAgACAHIAFrED8gACgCACEGDAELIAEgB0sEQCAEIAYgB0EDdGo2AiALIAcNAEEADAILIAgoAgAhAEEAIQMgBkEANgIEIAYgADYCAAJ/QQEgCCgCACIBQYCAEEsNABpBACEFAkADQAJAIAEiACADTQ0AIAAgA0F/c2ohDiALKAIAIQwgACADa0EHcSIBBEADQCAMIANBAnRqIAU2AgAgA0EBaiEDIAFBAWsiAQ0ACwsgDkEGTQ0AA0AgDCADQQJ0aiIBIAU2AgAgASAFNgIcIAEgBTYCGCABIAU2AhQgASAFNgIQIAEgBTYCDCABIAU2AgggASAFNgIEIANBCGoiAyAARw0ACwsgByAFQQFqIgVHBEAgCCAFQQJ0aiIBKAIAIQMgBiAFQQN0aiIMIAA2AgQgDCADNgIAIAAiAyABKAIAaiIBQYCAEEsNAgwBCwsgACEBCyAFIAdJC0EBcyABQYCAEEZxDAELIAgLRQ0AIAoEQCAEKAIMRQ0BCwJAIAIvASZB/wNNBEAgAikDCCIaIAIpAxAiGEIIfCIZUw0CIAIoAgAgGKdqKQAAIRggAiAZNwMQDAELQQEgBEE4aiACEC9FDQEgAikDECEZIAIpAwghGiAEKQM4IRgLIBggGiAZfVYNACACIBggGXw3AxAgGKciAEEBSA0AIAQgAigCACAZp2oiAjYCKCAEAn8CQAJAAkACQCACIABBAWsiAWoiAy0AAEEGdkEBaw4DAAECAwsgAEECSA0EIAQgAEECayIBNgIsIAAgAmpBAmsiAC0AAUEIdEGA/gBxIAAtAAByDAMLIABBA0gNAyAEIABBA2siATYCLCAAIAJqQQNrIgAtAAJBEHRBgID8AXEgAC0AAUEIdHIgAC0AAHIMAgsgBCAAQQRrIgE2AiwgACACakEEayIALQACQRB0IAAtAANBGHRBgICA+ANxciAALQABQQh0ciAALQAAcgwBCyAEIAE2AiwgAy0AAEE/cQtBgIBAayIANgIwIABB/////wBLDQAgCkUEQEEBIQkMAQsgBCgCHCEDQQAhCCAEKAIQIQYDQAJAIABB//8/Sw0AA0AgAUEBSA0BIAQgAUEBayIBNgIsIAQgASACai0AACAAQQh0ciIANgIwIABBgIDAAEkNAAsLIAQgAyAGIABB//8PcSIFQQJ0aigCACIHQQN0aiIJKAIAIABBEnZsIAVqIAkoAgRrIgA2AjAgDSAIQQJ0aiAHNgIAQQEhCSAIQQFqIgggCkcNAAsLIAQoAhwiAARAIAQgADYCICAAEAgLIAQoAhAiAARAIAQgADYCFCAAEAgLIAQoAgAiAARAIAQgADYCBCAAEAgLIARBQGskACAJDAULIAAhCiADIQ1BACEGIwBBQGoiBCQAIARBADYCMCAEQgA3AyggBEIANwMgIARCADcDGCAEQgA3AxAgBEIANwMIIARCADcDAAJAAn8CQCACLwEmIgBFDQACQCAAQf8DTQRAIAIpAwggAikDECIYQgR8Uw0CIAQgAigCACAYp2ooAAAiBzYCDCACIAIpAxBCBHw3AxAMAQtBASAEQQxqIAIQNUUNASAEKAIMIQcLAkAgBCgCBCAEKAIAIgFrQQJ1IgAgB0kEQCAEIAcgAGsQGiAEKAIMIQcMAQsgACAHTQ0AIAQgASAHQQJ0ajYCBAsgB0UEQEEBIQgMAQsgAikDCCEZA0AgGSACKQMQIhhXDQEgAigCACIAIBinai0AACEBIAIgGEIBfCIYNwMQIAFBAnYhA0EAIQUCQAJAAkACQCABQQNxIgsOBAIBAQABC0EAIAcgAyAGaiIATQ0FGiAEKAIAIAZBAnRqQQAgAUH8AXFBBGoQCxogACEGDAILA0BBACAYIBlZDQUaIAAgGKdqLQAAIQEgAiAYQgF8Ihg3AxAgASAFQQN0QQZydCADciEDIAVBAWoiBSALRw0ACwsgBCgCACAGQQJ0aiADNgIACyAGQQFqIgYgBCgCDCIHSQ0ACyAEQRBqIQsgBCgCACEIAkAgBCgCFCAEKAIQIgBrIgFBAnUiA0H//x9NBEAgC0GAgCAgA2sQGgwBCyABQYCAgAFGDQAgBCAAQYCAgAFqNgIUCwJAIAQoAiAgBEEcaiIAKAIAIgZrQQN1IgEgB0kEQCAAIAcgAWsQPyAAKAIAIQYMAQsgASAHSwRAIAQgBiAHQQN0ajYCIAsgBw0AQQAMAgsgCCgCACEAQQAhAyAGQQA2AgQgBiAANgIAAn9BASAIKAIAIgFBgIAgSw0AGkEAIQUCQANAAkAgASIAIANNDQAgACADQX9zaiEOIAsoAgAhDCAAIANrQQdxIgEEQANAIAwgA0ECdGogBTYCACADQQFqIQMgAUEBayIBDQALCyAOQQZNDQADQCAMIANBAnRqIgEgBTYCACABIAU2AhwgASAFNgIYIAEgBTYCFCABIAU2AhAgASAFNgIMIAEgBTYCCCABIAU2AgQgA0EIaiIDIABHDQALCyAHIAVBAWoiBUcEQCAIIAVBAnRqIgEoAgAhAyAGIAVBA3RqIgwgADYCBCAMIAM2AgAgACIDIAEoAgBqIgFBgIAgSw0CDAELCyAAIQELIAUgB0kLQQFzIAFBgIAgRnEMAQsgCAtFDQAgCgRAIAQoAgxFDQELAkAgAi8BJkH/A00EQCACKQMIIhogAikDECIYQgh8IhlTDQIgAigCACAYp2opAAAhGCACIBk3AxAMAQtBASAEQThqIAIQL0UNASACKQMQIRkgAikDCCEaIAQpAzghGAsgGCAaIBl9Vg0AIAIgGCAZfDcDECAYpyIAQQFIDQAgBCACKAIAIBmnaiICNgIoIAQCfwJAAkACQAJAIAIgAEEBayIBaiIDLQAAQQZ2QQFrDgMAAQIDCyAAQQJIDQQgBCAAQQJrIgE2AiwgACACakECayIALQABQQh0QYD+AHEgAC0AAHIMAwsgAEEDSA0DIAQgAEEDayIBNgIsIAAgAmpBA2siAC0AAkEQdEGAgPwBcSAALQABQQh0ciAALQAAcgwCCyAEIABBBGsiATYCLCAAIAJqQQRrIgAtAAJBEHQgAC0AA0EYdEGAgID4A3FyIAAtAAFBCHRyIAAtAAByDAELIAQgATYCLCADLQAAQT9xC0GAgIABaiIANgIwIABB/////wFLDQAgCkUEQEEBIQkMAQsgBCgCHCEDQQAhCCAEKAIQIQYDQAJAIABB////AEsNAANAIAFBAUgNASAEIAFBAWsiATYCLCAEIAEgAmotAAAgAEEIdHIiADYCMCAAQYCAgAFJDQALCyAEIAMgBiAAQf//H3EiBUECdGooAgAiB0EDdGoiCSgCACAAQRN2bCAFaiAJKAIEayIANgIwIA0gCEECdGogBzYCAEEBIQkgCEEBaiIIIApHDQALCyAEKAIcIgAEQCAEIAA2AiAgABAICyAEKAIQIgAEQCAEIAA2AhQgABAICyAEKAIAIgAEQCAEIAA2AgQgABAICyAEQUBrJAAgCQwECyAAIAIgAxDxASEBCyABDAILIwBBQGoiASQAIAFBADYCMCABQgA3AyggAUIANwMgIAFCADcDGCABQgA3AxAgAUIANwMIIAFCADcDAAJAIAEgAhCoAUUNACAABEAgASgCDEUNAQsCQCACLwEmQf8DTQRAIAIpAwgiGiACKQMQIhlCCHwiGFMNAiACKAIAIBmnaikAACEZIAIgGDcDEAwBC0EBIAFBOGogAhAvRQ0BIAIpAxAhGCACKQMIIRogASkDOCEZCyAZIBogGH1WDQAgAiAYIBl8NwMQIBmnIgZBAUgNACABIAIoAgAgGKdqIgo2AiggAQJ/AkACQAJAAkAgCiAGQQFrIgJqIgQtAABBBnZBAWsOAwABAgMLIAZBAkgNBCABIAZBAmsiAjYCLCAGIApqQQJrIgYtAAFBCHRBgP4AcSAGLQAAcgwDCyAGQQNIDQMgASAGQQNrIgI2AiwgBiAKakEDayIGLQACQRB0QYCA/AFxIAYtAAFBCHRyIAYtAAByDAILIAEgBkEEayICNgIsIAYgCmpBBGsiBi0AAkEQdCAGLQADQRh0QYCAgPgDcXIgBi0AAUEIdHIgBi0AAHIMAQsgASACNgIsIAQtAABBP3ELQYCAAWoiBjYCMCAGQf///wFLDQAgAEUEQEEBIQ0MAQsgASgCHCEFQQAhBCABKAIQIQcDQAJAIAZB//8ASw0AA0AgAkEBSA0BIAEgAkEBayICNgIsIAEgAiAKai0AACAGQQh0ciIGNgIwIAZBgIABSQ0ACwsgASAFIAcgBkH/H3EiDUECdGooAgAiCEEDdGoiCSgCACAGQQx2bCANaiAJKAIEayIGNgIwIAMgBEECdGogCDYCAEEBIQ0gBEEBaiIEIABHDQALCyABKAIcIgAEQCABIAA2AiAgABAICyABKAIQIgAEQCABIAA2AhQgABAICyABKAIAIgAEQCABIAA2AgQgABAICyABQUBrJAAgDQwBCyAAIAIgAxDxAQshCgsgCgsEAEEDCwQAQX8LAwABC1wBAX8gAEIANwIEIABB0Ao2AgAgAEIANwIMIABCADcCFCAAQgA3AhwgAEIANwIkIABBgBA2AgAgAEIANwIsIABCADcCNCABKAIAIQIgAUEANgIAIAAgAjYCPCAACywAIAAgATYCBCABKAIEKAIIIAJBAnRqKAIAIQEgACACNgIMIAAgATYCCEEBC7sCAQd/AkACQCAAKAIEIgUgACgCAEcEQCAFIQIMAQsgACgCCCIDIAAoAgwiAkkEQCADIAIgA2tBAnVBAWpBAm1BAnQiBGohAiADIAVrIgYEQCACIAZrIgIgBSAGECMaIAAoAgghAwsgACACNgIEIAAgAyAEajYCCAwBCyACIAVrIgJBAXVBASACGyIEQYCAgIAETw0BIARBAnQiAhAJIgggAmohBiAIIARBA2pBfHFqIgIhByADIAVrIgQEQCACIARqIQcgAiEDIAUhBANAIAMgBCgCADYCACAEQQRqIQQgA0EEaiIDIAdHDQALCyAAIAY2AgwgACAHNgIIIAAgAjYCBCAAIAg2AgAgBUUNACAFEAggACgCBCECCyACQQRrIAEoAgA2AgAgACAAKAIEQQRrNgIEDwtB3A0QDQAL9wEBA38gAEGkDDYCACAAKAI8IgIEQAJ/IAIgAiAAQUBrKAIAIgFGDQAaA0AgAUEEayIBKAIAIQMgAUEANgIAIAMEQCADEBgLIAEgAkcNAAsgACgCPAshASAAIAI2AkAgARAICyAAKAIwIgEEQCAAIAE2AjQgARAICyAAKAIkIgIEQAJ/IAIgAiAAKAIoIgFGDQAaA0AgAUEYayIBIAEoAgAoAgARAAAaIAEgAkcNAAsgACgCJAshASAAIAI2AiggARAICyAAQdAKNgIAIAAoAhAiAQRAIAAgATYCFCABEAgLIAAoAgQiAQRAIAAgATYCCCABEAgLIAALbAICfwF+AkAgAEEFSw0AIAIpAxAiBSACKQMIWQ0AIAIoAgAgBadqLQAAIQMgAiAFQgF8NwMQIAEgA0GAAXEEfyAAQQFqIAEgAhCxAUUNASADQf8AcSABKAIAQQd0cgUgAws2AgBBASEECyAEC5MWAhJ/An4CQCABKQMIIAEpAxAiFUIEfFMNACAAIAEoAgAgFadqKAAAIgU2AgAgASABKQMQIhVCBHwiFjcDECAFQSBLDQAgASkDCCAVQgh8Uw0AIAAgASgCACAWp2ooAAAiAzYCBCABIAEpAxBCBHw3AxAgA0UEQEEBIQMMAQtBACEDIABBADYCCCAAQRBqIAEQQkUNACAAQaAEaiABEA9FDQAgAEG0BGogARAPRQ0AIABByARqIAEQD0UNAAJ/IAAoAgQhECACIQlBACECQQAhASMAQSBrIgQkACAAIgUoAgwhAyAEQQA2AhAgBEIANwMIAkAgAwRAIANBgICAgARPDQEgBCADQQJ0IgAQCSICNgIIIAQgACACaiIBNgIQIAJBACAAEAsaIAQgATYCDAsgBSgC9AQiACgCACIGBEAgACAGNgIEIAYQCCAAQQA2AgggAEIANwIAIAUoAgwhAyAEKAIIIQIgBCgCDCEBCyAAIAE2AgQgACACNgIAIAAgBCgCEDYCCEEAIQIgBEEANgIQIARCADcDCEEAIQYCQCADBEAgA0GAgICABE8NASAEIANBAnQiABAJIgY2AgggBCAAIAZqIgI2AhAgBkEAIAAQCxogBCACNgIMCyAFKAKABSIAKAIAIgEEQCAAIAE2AgQgARAIIABBADYCCCAAQgA3AgAgBCgCCCEGIAQoAgwhAgsgACACNgIEIAAgBjYCACAAIAQoAhA2AgggBEIANwMYIARCADcDECAEQgA3AwggBEEIahAQIAQoAgwgBCgCGCAEKAIcaiIAQdUCbiIBQQJ0aigCACAAIAFB1QJsa0EMbGoiAEIANwIEIAAgEDYCAEEBIQEgBCAEKAIcIgBBAWoiAzYCHAJAIAAgA0sNAANAIAQoAgwiASAEKAIYIgIgA0EBayIGaiIAQdUCbiIHQQJ0aigCACAAIAdB1QJsa0EMbGoiACgCCCEKIAAoAgQaIAAoAgAhByAEIAY2AhwgBCgCECIAIAFrIgFBAnVB1QJsQQFrQQAgARsgAiADamtBAWpBqgVPBEAgAEEEaygCABAIIAQgBCgCEEEEazYCEAtBACEBIAcgEEsNASAFKAL0BCEAIAUgByAKQQxsIgggBSgCgAVqIgwQxwEiBiAFKAIMTw0BIAAgCGohCwJAAkAgBSgCACAGQQJ0Ig0gDCgCAGooAgBrIgBFBEBBACEMIAdFDQEDQEEAIQACQCAJKAIQIgMgCSgCFEYNAANAIAsoAgAgAyAAQRRsaiIKKAIEQQJ0aiEBIAooAgAhCAJAIAooAgwiBkEDSw0AIAkoAgwhAiAKKAIQRQRAIAIhAQwBC0EAIQMDQCACIAEgA0ECdGogBhAKIAooAgwiBmohAiADQQFqIgMgCigCEEkNAAsgCSgCDCEBCyAJKAIcIQMgCC0AVEUEQCAIKAJEIANBAnRqKAIAIQMLIAMgCCgCUE8NASAIKAIAKAIAIAMgCCgCKCICbGogASACEAoaIABBAWoiACAJKAIUIAkoAhAiA2tBFG1JDQALCyAJIAkoAhxBAWo2AhwgBSAFKAIIQQFqNgIIIAcgDEEBaiIMRw0ACwwBCwJAAkACQCAHQQJNBEAgBSgC6AQiACAGNgIAQQEhAiAFKAIMIgNBAUsNAQwDCyAFKAIIIAUoAgRLDQYgCyAFKAL0BCIBIApBAWoiDkEMbCIMaiICRwR/IAIgCygCACALKAIEEBIgBSgC9AQFIAELIAxqKAIAIA1qIgEgASgCAEEBIABBAWt0ajYCACAHZ0EfcyIARQRAQQAhAgwCC0EAIQJBACEDA0AgBSADQQR0akEQahAWIAJyIQIgA0EBaiIDIABGDQIgAkEBdCECDAALAAsDQCAAIAJBAnRqQQAgBkEBaiAGIANBAWtGGyIGNgIAIAJBAWoiAiAFKAIMIgNJDQALDAELAkACQAJ/IAdBAXYgAmsiACAHIABrIgNGBEAgAAwBCyAFKALUBCIBIAUoAswERg0BIAEoAgAhAiAFIAUoAtgEIgdBAWoiCzYC2AQgAkGAgICAeCAHdnEhAgJAIAtBIEYEQCAFQQA2AtgEIAUgAUEEajYC1AQgAg0BDAMLIAJFDQILIAMLIQEgACEDDAELIAAhAQsgBSgCgAUiACAIaiICKAIAIgcgDWoiCyALKAIAQQFqNgIAIAAgDGogByACKAIEEBIgAwRAIAQoAhwgBCgCGGoiAiAEKAIQIAQoAgwiAGsiB0ECdUHVAmxBAWtBACAHG0YEQCAEQQhqEBAgBCgCGCAEKAIcaiECIAQoAgwhAAsgACACQdUCbiIHQQJ0aigCACACIAdB1QJsa0EMbGoiACAKNgIIIAAgBjYCBCAAIAM2AgAgBCAEKAIcQQFqNgIcCyABRQ0BIAQoAhwgBCgCGGoiAyAEKAIQIAQoAgwiAmsiAEECdUHVAmxBAWtBACAAG0YEQCAEQQhqEBAgBCgCGCAEKAIcaiEDIAQoAgwhAgsgAiADQdUCbiIAQQJ0aigCACADIABB1QJsa0EMbGoiACAONgIIIAAgBjYCBCAAIAE2AgAgBCAEKAIcQQFqIgM2AhwMAgtBACENIAdFDQADQCADBEAgCygCACEOIAwoAgAhESAFKALcBCECIAUoAugEIRJBACEDA0AgAiASIANBAnRqIgYoAgBBAnRqQQA2AgACQCAFKAIAIBEgBigCAEECdCIBaigCAGsiAEUNACABIAJqIQFBICAFKAKwBCIKayIPIABOBEAgBSgCrAQiCCAFKAKkBEYEQCABQQA2AgAMAgsgASAIKAIAIAp0QSAgAGt2NgIAIAUgBSgCsAQgAGoiADYCsAQgAEEgRw0BIAVBADYCsAQgBSAIQQRqNgKsBAwBCyAFKAKsBCIIQQRqIhMgBSgCpARGBEAgAUEANgIADAELIAgoAgAhFCAFIBM2AqwEIAUgACAPayIPNgKwBCABIAgoAgRBICAPa3YgFCAKdEEgIABrdnI2AgALIAIgBigCAEECdCIAaiIBIAEoAgAgACAOaigCAHI2AgAgA0EBaiIDIAUoAgxJDQALC0EAIQACQCAJKAIQIgMgCSgCFEYNAANAIAUoAtwEIAMgAEEUbGoiCigCBEECdGohASAKKAIAIQgCQCAKKAIMIgZBA0sNACAJKAIMIQIgCigCEEUEQCACIQEMAQtBACEDA0AgAiABIANBAnRqIAYQCiAKKAIMIgZqIQIgA0EBaiIDIAooAhBJDQALIAkoAgwhAQsgCSgCHCEDIAgtAFRFBEAgCCgCRCADQQJ0aigCACEDCyADIAgoAlBPDQEgCCgCACgCACADIAgoAigiAmxqIAEgAhAKGiAAQQFqIgAgCSgCFCAJKAIQIgNrQRRtSQ0ACwsgCSAJKAIcQQFqNgIcIAUgBSgCCEEBajYCCCANQQFqIg0gB0YNASAFKAIMIQMMAAsACyAEKAIcIQMLIAMNAAtBASEBCyAEQQA2AhwgBCgCECIGIAQoAgwiA2tBAnUiAkEDTwRAA0AgAygCABAIIAQgBCgCDEEEaiIDNgIMIAQoAhAiBiADa0ECdSICQQJLDQALC0GqASEAAkACQAJAIAJBAWsOAgEAAgtB1QIhAAsgBCAANgIYCwJAIAMgBkYNAANAIAMoAgAQCCADQQRqIgMgBkcNAAsgBCgCECIAIAQoAgwiAkYNACAEIAAgACACa0EEa0ECdkF/c0ECdGo2AhALIAQoAggiAARAIAAQCAsgBEEgaiQAIAEMAgsQDAALEAwACw8LIAMLkBYCEn8CfgJAIAEpAwggASkDECIVQgR8Uw0AIAAgASgCACAVp2ooAAAiBTYCACABIAEpAxAiFUIEfCIWNwMQIAVBIEsNACABKQMIIBVCCHxTDQAgACABKAIAIBanaigAACIDNgIEIAEgASkDEEIEfDcDECADRQRAQQEhAwwBC0EAIQMgAEEANgIIIABBEGogARBCRQ0AIABBoARqIAEQD0UNACAAQbQEaiABEA9FDQAgAEHIBGogARAPRQ0AAn8gACgCBCEPIAIhCUEAIQFBACECIwBBIGsiBCQAIAAiBSgCDCEDIARBADYCECAEQgA3AwgCQCADBEAgA0GAgICABE8NASAEIANBAnQiABAJIgE2AgggBCAAIAFqIgI2AhAgAUEAIAAQCxogBCACNgIMCyAFKAL0BCIAKAIAIgcEQCAAIAc2AgQgBxAIIABBADYCCCAAQgA3AgAgBSgCDCEDIAQoAgwhAiAEKAIIIQELIAAgAjYCBCAAIAE2AgAgACAEKAIQNgIIQQAhASAEQQA2AhAgBEIANwMIAkAgAwRAIANBgICAgARPDQEgBCADQQJ0IgAQCSIGNgIIIAQgACAGaiIBNgIQIAZBACAAEAsaIAQgATYCDAsgBSgCgAUiACgCACICBEAgACACNgIEIAIQCCAAQQA2AgggAEIANwIAIAQoAgghBiAEKAIMIQELIAAgATYCBCAAIAY2AgAgACAEKAIQNgIIIARCADcDGCAEQgA3AxAgBEIANwMIIARBCGoQECAEKAIMIAQoAhggBCgCHGoiAEHVAm4iAUECdGooAgAgACABQdUCbGtBDGxqIgBCADcCBCAAIA82AgBBASECIAQgBCgCHCIAQQFqIgM2AhwCQCAAIANLDQADQCAEKAIMIgIgBCgCGCIHIANBAWsiBmoiAEHVAm4iAUECdGooAgAgACABQdUCbGtBDGxqIgAoAgghCiAAKAIEIQEgACgCACELIAQgBjYCHCAEKAIQIgAgAmsiAkECdUHVAmxBAWtBACACGyADIAdqa0EBakGqBU8EQCAAQQRrKAIAEAggBCAEKAIQQQRrNgIQCyALIA9LBEBBACECDAILQQAhAkEAIAFBAWogBSgCDCIAQQFrIAFGGyIGIABPDQEgBSgC9AQiACAKQQxsIghqIQwCQAJAIAUoAgAgBkECdCINIAUoAoAFIAhqIhAoAgBqKAIAayIBRQRAQQAhACALRQ0BA0BBACEHAkAgCSgCECIDIAkoAhRGDQADQCAMKAIAIAMgB0EUbGoiCigCBEECdGohAiAKKAIAIQgCQCAKKAIMIgZBA0sNACAJKAIMIQEgCigCEEUEQCABIQIMAQtBACEDA0AgASACIANBAnRqIAYQCiAKKAIMIgZqIQEgA0EBaiIDIAooAhBJDQALIAkoAgwhAgsgCSgCHCEDIAgtAFRFBEAgCCgCRCADQQJ0aigCACEDCyADIAgoAlBPDQEgCCgCACgCACADIAgoAigiAWxqIAIgARAKGiAHQQFqIgcgCSgCFCAJKAIQIgNrQRRtSQ0ACwsgCSAJKAIcQQFqNgIcIAUgBSgCCEEBajYCCCALIABBAWoiAEcNAAsMAQsCQAJAAkAgC0ECTQRAIAUoAugEIgAgBjYCAEEBIQEgBSgCDCIDQQFLDQEMAwsgBSgCCCAFKAIESw0GIAAgCEEMaiICaiAMKAIAIAwoAgQQEiAFKAL0BCACaigCACANaiIAIAAoAgBBASABQQFrdGo2AgAgC2dBH3MiAEUEQEEAIQEMAgtBACEBQQAhAwNAIAUgA0EEdGpBEGoQFiABciEBIANBAWoiAyAARg0CIAFBAXQhAQwACwALA0AgACABQQJ0akEAIAZBAWogBiADQQFrRhsiBjYCACABQQFqIgEgBSgCDCIDSQ0ACwwBCyAKQQFqIQICQAJAAn8gC0EBdiABayIAIAsgAGsiA0YEQCAADAELIAUoAtQEIgEgBSgCzARGDQEgASgCACEHIAUgBSgC2AQiC0EBaiIMNgLYBCAHQYCAgIB4IAt2cSEHAkAgDEEgRgRAIAVBADYC2AQgBSABQQRqNgLUBCAHDQEMAwsgB0UNAgsgAwshByAAIQMMAQsgACEHCyAFKAKABSIAIAhqIgEoAgAiCyANaiIIIAgoAgBBAWo2AgAgACACQQxsaiALIAEoAgQQEiADBEAgBCgCHCAEKAIYaiIBIAQoAhAgBCgCDCIAayILQQJ1QdUCbEEBa0EAIAsbRgRAIARBCGoQECAEKAIYIAQoAhxqIQEgBCgCDCEACyAAIAFB1QJuIgtBAnRqKAIAIAEgC0HVAmxrQQxsaiIAIAo2AgggACAGNgIEIAAgAzYCACAEIAQoAhxBAWo2AhwLIAdFDQEgBCgCHCAEKAIYaiIDIAQoAhAgBCgCDCIBayIAQQJ1QdUCbEEBa0EAIAAbRgRAIARBCGoQECAEKAIYIAQoAhxqIQMgBCgCDCEBCyABIANB1QJuIgBBAnRqKAIAIAMgAEHVAmxrQQxsaiIAIAI2AgggACAGNgIEIAAgBzYCACAEIAQoAhxBAWoiAzYCHAwCC0EAIQAgC0UNAANAIAMEQCAMKAIAIQ0gECgCACERIAUoAtwEIQcgBSgC6AQhEkEAIQMDQCAHIBIgA0ECdGoiBigCAEECdGpBADYCAAJAIAUoAgAgESAGKAIAQQJ0IgJqKAIAayIBRQ0AIAIgB2ohAkEgIAUoArAEIgprIg4gAU4EQCAFKAKsBCIIIAUoAqQERgRAIAJBADYCAAwCCyACIAgoAgAgCnRBICABa3Y2AgAgBSAFKAKwBCABaiIBNgKwBCABQSBHDQEgBUEANgKwBCAFIAhBBGo2AqwEDAELIAUoAqwEIghBBGoiEyAFKAKkBEYEQCACQQA2AgAMAQsgCCgCACEUIAUgEzYCrAQgBSABIA5rIg42ArAEIAIgCCgCBEEgIA5rdiAUIAp0QSAgAWt2cjYCAAsgByAGKAIAQQJ0IgFqIgIgAigCACABIA1qKAIAcjYCACADQQFqIgMgBSgCDEkNAAsLQQAhBwJAIAkoAhAiAyAJKAIURg0AA0AgBSgC3AQgAyAHQRRsaiIKKAIEQQJ0aiECIAooAgAhCAJAIAooAgwiBkEDSw0AIAkoAgwhASAKKAIQRQRAIAEhAgwBC0EAIQMDQCABIAIgA0ECdGogBhAKIAooAgwiBmohASADQQFqIgMgCigCEEkNAAsgCSgCDCECCyAJKAIcIQMgCC0AVEUEQCAIKAJEIANBAnRqKAIAIQMLIAMgCCgCUE8NASAIKAIAKAIAIAMgCCgCKCIBbGogAiABEAoaIAdBAWoiByAJKAIUIAkoAhAiA2tBFG1JDQALCyAJIAkoAhxBAWo2AhwgBSAFKAIIQQFqNgIIIABBAWoiACALRg0BIAUoAgwhAwwACwALIAQoAhwhAwsgAw0AC0EBIQILIARBADYCHCAEKAIQIgYgBCgCDCIDa0ECdSIBQQNPBEADQCADKAIAEAggBCAEKAIMQQRqIgM2AgwgBCgCECIGIANrQQJ1IgFBAksNAAsLQaoBIQACQAJAAkAgAUEBaw4CAQACC0HVAiEACyAEIAA2AhgLAkAgAyAGRg0AA0AgAygCABAIIANBBGoiAyAGRw0ACyAEKAIQIgAgBCgCDCIBRg0AIAQgACAAIAFrQQRrQQJ2QX9zQQJ0ajYCEAsgBCgCCCIABEAgABAICyAEQSBqJAAgAgwCCxAMAAsQDAALDwsgAwugFgISfwJ+AkAgASkDCCABKQMQIhVCBHxTDQAgACABKAIAIBWnaigAACIFNgIAIAEgASkDECIVQgR8IhY3AxAgBUEgSw0AIAEpAwggFUIIfFMNACAAIAEoAgAgFqdqKAAAIgM2AgQgASABKQMQQgR8NwMQIANFBEBBASEDDAELQQAhAyAAQQA2AgggAEEQaiABEEJFDQAgAEGgBGogARAPRQ0AIABBtARqIAEQD0UNACAAQcgEaiABEA9FDQACfyAAKAIEIRAgAiEIQQAhAkEAIQEjAEEgayIEJAAgACIFKAIMIQMgBEEANgIQIARCADcDCAJAIAMEQCADQYCAgIAETw0BIAQgA0ECdCIAEAkiAjYCCCAEIAAgAmoiATYCECACQQAgABALGiAEIAE2AgwLIAUoAvQEIgAoAgAiBgRAIAAgBjYCBCAGEAggAEEANgIIIABCADcCACAFKAIMIQMgBCgCCCECIAQoAgwhAQsgACABNgIEIAAgAjYCACAAIAQoAhA2AghBACECIARBADYCECAEQgA3AwhBACEGAkAgAwRAIANBgICAgARPDQEgBCADQQJ0IgAQCSIGNgIIIAQgACAGaiICNgIQIAZBACAAEAsaIAQgAjYCDAsgBSgCgAUiACgCACIBBEAgACABNgIEIAEQCCAAQQA2AgggAEIANwIAIAQoAgghBiAEKAIMIQILIAAgAjYCBCAAIAY2AgAgACAEKAIQNgIIIARCADcDGCAEQgA3AxAgBEIANwMIIARBCGoQECAEKAIMIAQoAhggBCgCHGoiAEHVAm4iAUECdGooAgAgACABQdUCbGtBDGxqIgBCADcCBCAAIBA2AgBBASEBIAQgBCgCHCIAQQFqIgM2AhwCQCAAIANLDQADQCAEKAIMIgEgBCgCGCIGIANBAWsiC2oiAEHVAm4iAkECdGooAgAgACACQdUCbGtBDGxqIgAoAgghCSAAKAIEIQIgACgCACEKIAQgCzYCHCAEKAIQIgAgAWsiAUECdUHVAmxBAWtBACABGyADIAZqa0EBakGqBU8EQCAAQQRrKAIAEAggBCAEKAIQQQRrNgIQC0EAIQEgCiAQSw0BIAUoAvQEIQAgCUEMbCIHIAUoAoAFaiEMQQAgAkEBaiAFKAIMQQFrIAJGGyIGIAUoAgxPDQEgACAHaiELAkACQCAFKAIAIAZBAnQiDSAMKAIAaigCAGsiAEUEQEEAIQwgCkUNAQNAQQAhAAJAIAgoAhAiAyAIKAIURg0AA0AgCygCACADIABBFGxqIgkoAgRBAnRqIQEgCSgCACEHAkAgCSgCDCIGQQNLDQAgCCgCDCECIAkoAhBFBEAgAiEBDAELQQAhAwNAIAIgASADQQJ0aiAGEAogCSgCDCIGaiECIANBAWoiAyAJKAIQSQ0ACyAIKAIMIQELIAgoAhwhAyAHLQBURQRAIAcoAkQgA0ECdGooAgAhAwsgAyAHKAJQTw0BIAcoAgAoAgAgAyAHKAIoIgJsaiABIAIQChogAEEBaiIAIAgoAhQgCCgCECIDa0EUbUkNAAsLIAggCCgCHEEBajYCHCAFIAUoAghBAWo2AgggCiAMQQFqIgxHDQALDAELAkACQAJAIApBAk0EQCAFKALoBCIAIAY2AgBBASECIAUoAgwiA0EBSw0BDAMLIAUoAgggBSgCBEsNBiALIAUoAvQEIgEgCUEBaiIOQQxsIgxqIgJHBH8gAiALKAIAIAsoAgQQEiAFKAL0BAUgAQsgDGooAgAgDWoiASABKAIAQQEgAEEBa3RqNgIAIApnQR9zIgBFBEBBACECDAILQQAhAkEAIQMDQCAFIANBBHRqQRBqEBYgAnIhAiADQQFqIgMgAEYNAiACQQF0IQIMAAsACwNAIAAgAkECdGpBACAGQQFqIAYgA0EBa0YbIgY2AgAgAkEBaiICIAUoAgwiA0kNAAsMAQsCQAJAAn8gCkEBdiACayIAIAogAGsiA0YEQCAADAELIAUoAtQEIgEgBSgCzARGDQEgASgCACECIAUgBSgC2AQiCkEBaiILNgLYBCACQYCAgIB4IAp2cSECAkAgC0EgRgRAIAVBADYC2AQgBSABQQRqNgLUBCACDQEMAwsgAkUNAgsgAwshASAAIQMMAQsgACEBCyAFKAKABSIAIAdqIgIoAgAiCiANaiILIAsoAgBBAWo2AgAgACAMaiAKIAIoAgQQEiADBEAgBCgCHCAEKAIYaiICIAQoAhAgBCgCDCIAayIKQQJ1QdUCbEEBa0EAIAobRgRAIARBCGoQECAEKAIYIAQoAhxqIQIgBCgCDCEACyAAIAJB1QJuIgpBAnRqKAIAIAIgCkHVAmxrQQxsaiIAIAk2AgggACAGNgIEIAAgAzYCACAEIAQoAhxBAWo2AhwLIAFFDQEgBCgCHCAEKAIYaiIDIAQoAhAgBCgCDCICayIAQQJ1QdUCbEEBa0EAIAAbRgRAIARBCGoQECAEKAIYIAQoAhxqIQMgBCgCDCECCyACIANB1QJuIgBBAnRqKAIAIAMgAEHVAmxrQQxsaiIAIA42AgggACAGNgIEIAAgATYCACAEIAQoAhxBAWoiAzYCHAwCC0EAIQ0gCkUNAANAIAMEQCALKAIAIQ4gDCgCACERIAUoAtwEIQIgBSgC6AQhEkEAIQMDQCACIBIgA0ECdGoiBigCAEECdGpBADYCAAJAIAUoAgAgESAGKAIAQQJ0IgFqKAIAayIARQ0AIAEgAmohAUEgIAUoArAEIglrIg8gAE4EQCAFKAKsBCIHIAUoAqQERgRAIAFBADYCAAwCCyABIAcoAgAgCXRBICAAa3Y2AgAgBSAFKAKwBCAAaiIANgKwBCAAQSBHDQEgBUEANgKwBCAFIAdBBGo2AqwEDAELIAUoAqwEIgdBBGoiEyAFKAKkBEYEQCABQQA2AgAMAQsgBygCACEUIAUgEzYCrAQgBSAAIA9rIg82ArAEIAEgBygCBEEgIA9rdiAUIAl0QSAgAGt2cjYCAAsgAiAGKAIAQQJ0IgBqIgEgASgCACAAIA5qKAIAcjYCACADQQFqIgMgBSgCDEkNAAsLQQAhAAJAIAgoAhAiAyAIKAIURg0AA0AgBSgC3AQgAyAAQRRsaiIJKAIEQQJ0aiEBIAkoAgAhBwJAIAkoAgwiBkEDSw0AIAgoAgwhAiAJKAIQRQRAIAIhAQwBC0EAIQMDQCACIAEgA0ECdGogBhAKIAkoAgwiBmohAiADQQFqIgMgCSgCEEkNAAsgCCgCDCEBCyAIKAIcIQMgBy0AVEUEQCAHKAJEIANBAnRqKAIAIQMLIAMgBygCUE8NASAHKAIAKAIAIAMgBygCKCICbGogASACEAoaIABBAWoiACAIKAIUIAgoAhAiA2tBFG1JDQALCyAIIAgoAhxBAWo2AhwgBSAFKAIIQQFqNgIIIA1BAWoiDSAKRg0BIAUoAgwhAwwACwALIAQoAhwhAwsgAw0AC0EBIQELIARBADYCHCAEKAIQIgYgBCgCDCIDa0ECdSICQQNPBEADQCADKAIAEAggBCAEKAIMQQRqIgM2AgwgBCgCECIGIANrQQJ1IgJBAksNAAsLQaoBIQACQAJAAkAgAkEBaw4CAQACC0HVAiEACyAEIAA2AhgLAkAgAyAGRg0AA0AgAygCABAIIANBBGoiAyAGRw0ACyAEKAIQIgAgBCgCDCICRg0AIAQgACAAIAJrQQRrQQJ2QX9zQQJ0ajYCEAsgBCgCCCIABEAgABAICyAEQSBqJAAgAQwCCxAMAAsQDAALDwsgAwu/FQITfwJ+AkAgASkDCCABKQMQIhZCBHxTDQAgACABKAIAIBanaigAACIJNgIAIAEgASkDECIWQgR8Ihc3AxAgCUEgSw0AIAEpAwggFkIIfFMNACAAIAEoAgAgF6dqKAAAIgQ2AgQgASABKQMQQgR8NwMQIARFBEBBASEEDAELQQAhBCAAQQA2AgggAEEQaiABEA5FDQAgAEEgaiABEA9FDQAgAEE0aiABEA9FDQAgAEHIAGogARAPRQ0AAn8gACgCBCEPIAIhCUEAIQFBACECIwBBIGsiAyQAIAAiBCgCDCEAIANBADYCECADQgA3AwgCQCAABEAgAEGAgICABE8NASADIABBAnQiBRAJIgE2AgggAyABIAVqIgI2AhAgAUEAIAUQCxogAyACNgIMCyAEKAJ0IgUoAgAiBwRAIAUgBzYCBCAHEAggBUEANgIIIAVCADcCACADKAIMIQIgAygCCCEBIAQoAgwhAAsgBSACNgIEIAUgATYCACAFIAMoAhA2AghBACEBIANBADYCECADQgA3AwgCQCAABEAgAEGAgICABE8NASADIABBAnQiABAJIgY2AgggAyAAIAZqIgE2AhAgBkEAIAAQCxogAyABNgIMCyAEKAKAASIAKAIAIgIEQCAAIAI2AgQgAhAIIABBADYCCCAAQgA3AgAgAygCCCEGIAMoAgwhAQsgACABNgIEIAAgBjYCACAAIAMoAhA2AgggA0IANwMYIANCADcDECADQgA3AwggA0EIahAQIAMoAgwgAygCGCADKAIcaiIAQdUCbiIBQQJ0aigCACAAIAFB1QJsa0EMbGoiAEIANwIEIAAgDzYCAEEBIQUgAyADKAIcIgFBAWoiADYCHAJAIAAgAUkNACAEQRBqIRADQCADKAIMIgUgAygCGCIGIABBAWsiCGoiAUHVAm4iAkECdGooAgAgASACQdUCbGtBDGxqIgEoAgghAiABKAIEIQcgASgCACEKIAMgCDYCHCADKAIQIgEgBWsiBUECdUHVAmxBAWtBACAFGyAAIAZqa0EBakGqBU8EQCABQQRrKAIAEAggAyADKAIQQQRrNgIQCyAKIA9LBEBBACEFDAILQQAhBUEAIAdBAWogBCgCDCIAQQFrIAdGGyIGIABPDQEgBCgCdCIAIAJBDGwiAWohDAJAIAQoAgAgBkECdCIIIAQoAoABIAFqIg0oAgBqKAIAayIHRQRAIApFDQEDQEEAIQcCQCAJKAIQIgAgCSgCFEYNAANAIAwoAgAgACAHQRRsaiIIKAIEQQJ0aiECIAgoAgAhCwJAIAgoAgwiBkEDSw0AIAkoAgwhASAIKAIQRQRAIAEhAgwBC0EAIQADQCABIAIgAEECdGogBhAKIAgoAgwiBmohASAAQQFqIgAgCCgCEEkNAAsgCSgCDCECCyAJKAIcIQAgCy0AVEUEQCALKAJEIABBAnRqKAIAIQALIAAgCygCUE8NASALKAIAKAIAIAAgCygCKCIBbGogAiABEAoaIAdBAWoiByAJKAIUIAkoAhAiAGtBFG1JDQALCyAJIAkoAhxBAWo2AhwgBCAEKAIIQQFqNgIIIAogBUEBaiIFRw0ACwwBCwJAAkACQAJAIApBAk0EQCAEKAJoIgIgBjYCAEEBIQEgBCgCDCIAQQFLDQEMBAsgBCgCCCAEKAIESw0GIAAgAUEMaiIFaiAMKAIAIAwoAgQQEiAEKAJ0IAVqKAIAIAhqIgAgACgCAEEBIAdBAWt0ajYCACADQQA2AgQgECAKZ0EfcyADQQRqEHMgAkEBaiELAn8gCkEBdiADKAIEayIAIAogAGsiBUYEQCAADAELIAQoAlQiByAEKAJMRg0CIAcoAgAhCiAEIAQoAlgiDEEBaiINNgJYIApBgICAgHggDHZxIQoCQCANQSBGBEAgBEEANgJYIAQgB0EEajYCVCAKDQEMBAsgCkUNAwsgBQshByAAIQUMAgsDQCACIAFBAnRqQQAgBkEBaiAGIABBAWtGGyIGNgIAIAFBAWoiASAEKAIMIgBJDQALDAILIAAhBwsgBCgCgAEiACABaiIBKAIAIgogCGoiCCAIKAIAQQFqNgIAIAAgC0EMbGogCiABKAIEEBIgBQRAIAMoAhwgAygCGGoiACADKAIQIAMoAgwiAWsiCkECdUHVAmxBAWtBACAKG0YEQCADQQhqEBAgAygCDCEBIAMoAhggAygCHGohAAsgASAAQdUCbiIKQQJ0aigCACAAIApB1QJsa0EMbGoiACACNgIIIAAgBjYCBCAAIAU2AgAgAyADKAIcQQFqNgIcCyAHRQ0BIAMoAhwgAygCGGoiACADKAIQIAMoAgwiAWsiAkECdUHVAmxBAWtBACACG0YEQCADQQhqEBAgAygCDCEBIAMoAhggAygCHGohAAsgASAAQdUCbiICQQJ0aigCACAAIAJB1QJsa0EMbGoiACALNgIIIAAgBjYCBCAAIAc2AgAgAyADKAIcQQFqNgIcDAELIApFDQADQCAABEAgDCgCACERIA0oAgAhEiAEKAJcIQcgBCgCaCETQQAhAANAIAcgEyAAQQJ0aiIGKAIAQQJ0akEANgIAAkAgBCgCACASIAYoAgBBAnQiAmooAgBrIgFFDQAgAiAHaiECQSAgBCgCMCIIayIOIAFOBEAgBCgCLCILIAQoAiRGBEAgAkEANgIADAILIAIgCygCACAIdEEgIAFrdjYCACAEIAQoAjAgAWoiATYCMCABQSBHDQEgBEEANgIwIAQgC0EEajYCLAwBCyAEKAIsIgtBBGoiFCAEKAIkRgRAIAJBADYCAAwBCyALKAIAIRUgBCAUNgIsIAQgASAOayIONgIwIAIgCygCBEEgIA5rdiAVIAh0QSAgAWt2cjYCAAsgByAGKAIAQQJ0IgFqIgIgAigCACABIBFqKAIAcjYCACAAQQFqIgAgBCgCDEkNAAsLQQAhBwJAIAkoAhAiACAJKAIURg0AA0AgBCgCXCAAIAdBFGxqIggoAgRBAnRqIQIgCCgCACELAkAgCCgCDCIGQQNLDQAgCSgCDCEBIAgoAhBFBEAgASECDAELQQAhAANAIAEgAiAAQQJ0aiAGEAogCCgCDCIGaiEBIABBAWoiACAIKAIQSQ0ACyAJKAIMIQILIAkoAhwhACALLQBURQRAIAsoAkQgAEECdGooAgAhAAsgACALKAJQTw0BIAsoAgAoAgAgACALKAIoIgFsaiACIAEQChogB0EBaiIHIAkoAhQgCSgCECIAa0EUbUkNAAsLIAkgCSgCHEEBajYCHCAEIAQoAghBAWo2AgggBUEBaiIFIApGDQEgBCgCDCEADAALAAsgAygCHCIADQALQQEhBQsgA0EANgIcIAMoAhAiBiADKAIMIgBrQQJ1IgFBA08EQANAIAAoAgAQCCADIAMoAgxBBGoiADYCDCADKAIQIgYgAGtBAnUiAUECSw0ACwtBqgEhAgJAAkACQCABQQFrDgIBAAILQdUCIQILIAMgAjYCGAsCQCAAIAZGDQADQCAAKAIAEAggAEEEaiIAIAZHDQALIAMoAhAiACADKAIMIgFGDQAgAyAAIAAgAWtBBGtBAnZBf3NBAnRqNgIQCyADKAIIIgAEQCAAEAgLIANBIGokACAFDAILEAwACxAMAAsPCyAEC9IVAhN/An4CQCABKQMIIAEpAxAiFkIEfFMNACAAIAEoAgAgFqdqKAAAIgg2AgAgASABKQMQIhZCBHwiFzcDECAIQSBLDQAgASkDCCAWQgh8Uw0AIAAgASgCACAXp2ooAAAiBDYCBCABIAEpAxBCBHw3AxAgBEUEQEEBIQQMAQtBACEEIABBADYCCCAAQRBqIAEQDkUNACAAQSBqIAEQD0UNACAAQTRqIAEQD0UNACAAQcgAaiABEA9FDQACfyAAKAIEIRAgAiEIQQAhAUEAIQIjAEEgayIDJAAgACIEKAIMIQAgA0EANgIQIANCADcDCAJAIAAEQCAAQYCAgIAETw0BIAMgAEECdCIFEAkiATYCCCADIAEgBWoiAjYCECABQQAgBRALGiADIAI2AgwLIAQoAnQiBSgCACIGBEAgBSAGNgIEIAYQCCAFQQA2AgggBUIANwIAIAMoAgwhAiADKAIIIQEgBCgCDCEACyAFIAI2AgQgBSABNgIAIAUgAygCEDYCCEEAIQEgA0EANgIQIANCADcDCAJAIAAEQCAAQYCAgIAETw0BIAMgAEECdCIAEAkiBzYCCCADIAAgB2oiATYCECAHQQAgABALGiADIAE2AgwLIAQoAoABIgAoAgAiAgRAIAAgAjYCBCACEAggAEEANgIIIABCADcCACADKAIIIQcgAygCDCEBCyAAIAE2AgQgACAHNgIAIAAgAygCEDYCCCADQgA3AxggA0IANwMQIANCADcDCCADQQhqEBAgAygCDCADKAIYIAMoAhxqIgBB1QJuIgFBAnRqKAIAIAAgAUHVAmxrQQxsaiIAQgA3AgQgACAQNgIAQQEhBiADIAMoAhwiAUEBaiIANgIcAkAgACABSQ0AIARBEGohEQNAIAMoAgwiBiADKAIYIgcgAEEBayILaiIBQdUCbiICQQJ0aigCACABIAJB1QJsa0EMbGoiAigCCCEBIAIoAgQhBSACKAIAIQkgAyALNgIcIAMoAhAiAiAGayIGQQJ1QdUCbEEBa0EAIAYbIAAgB2prQQFqQaoFTwRAIAJBBGsoAgAQCCADIAMoAhBBBGs2AhALQQAhBiAJIBBLDQEgBCgCdCEAIAFBDGwiAiAEKAKAAWohDEEAIAVBAWogBCgCDEEBayAFRhsiByAEKAIMTw0BIAAgAmohCwJAIAQoAgAgB0ECdCIKIAwoAgBqKAIAayIARQRAQQAhDCAJRQ0BA0BBACEFAkAgCCgCECIAIAgoAhRGDQADQCALKAIAIAAgBUEUbGoiBigCBEECdGohAiAGKAIAIQoCQCAGKAIMIgdBA0sNACAIKAIMIQEgBigCEEUEQCABIQIMAQtBACEAA0AgASACIABBAnRqIAcQCiAGKAIMIgdqIQEgAEEBaiIAIAYoAhBJDQALIAgoAgwhAgsgCCgCHCEAIAotAFRFBEAgCigCRCAAQQJ0aigCACEACyAAIAooAlBPDQEgCigCACgCACAAIAooAigiAWxqIAIgARAKGiAFQQFqIgUgCCgCFCAIKAIQIgBrQRRtSQ0ACwsgCCAIKAIcQQFqNgIcIAQgBCgCCEEBajYCCCAJIAxBAWoiDEcNAAsMAQsCQAJAAkACQCAJQQJNBEAgBCgCaCICIAc2AgBBASEBIAQoAgwiAEEBSw0BDAQLIAQoAgggBCgCBEsNBiALIAQoAnQiBSABQQFqIg1BDGwiDGoiBkcEfyAGIAsoAgAgCygCBBASIAQoAnQFIAULIAxqKAIAIApqIgUgBSgCAEEBIABBAWt0ajYCACADQQA2AgQgESAJZ0EfcyADQQRqEHMCfyAJQQF2IAMoAgRrIgAgCSAAayIGRgRAIAAMAQsgBCgCVCIFIAQoAkxGDQIgBSgCACEJIAQgBCgCWCILQQFqIg42AlggCUGAgICAeCALdnEhCQJAIA5BIEYEQCAEQQA2AlggBCAFQQRqNgJUIAkNAQwECyAJRQ0DCyAGCyEFIAAhBgwCCwNAIAIgAUECdGpBACAHQQFqIAcgAEEBa0YbIgc2AgAgAUEBaiIBIAQoAgwiAEkNAAsMAgsgACEFCyAKIAQoAoABIgAgAmoiAigCACIJaiILIAsoAgBBAWo2AgAgACAMaiAJIAIoAgQQEiAGBEAgAygCHCADKAIYaiIAIAMoAhAgAygCDCICayIJQQJ1QdUCbEEBa0EAIAkbRgRAIANBCGoQECADKAIMIQIgAygCGCADKAIcaiEACyACIABB1QJuIglBAnRqKAIAIAAgCUHVAmxrQQxsaiIAIAE2AgggACAHNgIEIAAgBjYCACADIAMoAhxBAWo2AhwLIAVFDQEgAygCHCADKAIYaiIAIAMoAhAgAygCDCIBayICQQJ1QdUCbEEBa0EAIAIbRgRAIANBCGoQECADKAIMIQEgAygCGCADKAIcaiEACyABIABB1QJuIgJBAnRqKAIAIAAgAkHVAmxrQQxsaiIAIA02AgggACAHNgIEIAAgBTYCACADIAMoAhxBAWo2AhwMAQtBACENIAlFDQADQCAABEAgCygCACEOIAwoAgAhEiAEKAJcIQUgBCgCaCETQQAhAANAIAUgEyAAQQJ0aiIGKAIAQQJ0akEANgIAAkAgBCgCACASIAYoAgBBAnQiAmooAgBrIgFFDQAgAiAFaiECQSAgBCgCMCIHayIPIAFOBEAgBCgCLCIKIAQoAiRGBEAgAkEANgIADAILIAIgCigCACAHdEEgIAFrdjYCACAEIAQoAjAgAWoiATYCMCABQSBHDQEgBEEANgIwIAQgCkEEajYCLAwBCyAEKAIsIgpBBGoiFCAEKAIkRgRAIAJBADYCAAwBCyAKKAIAIRUgBCAUNgIsIAQgASAPayIPNgIwIAIgCigCBEEgIA9rdiAVIAd0QSAgAWt2cjYCAAsgBSAGKAIAQQJ0IgFqIgIgAigCACABIA5qKAIAcjYCACAAQQFqIgAgBCgCDEkNAAsLQQAhBQJAIAgoAhAiACAIKAIURg0AA0AgBCgCXCAAIAVBFGxqIgYoAgRBAnRqIQIgBigCACEKAkAgBigCDCIHQQNLDQAgCCgCDCEBIAYoAhBFBEAgASECDAELQQAhAANAIAEgAiAAQQJ0aiAHEAogBigCDCIHaiEBIABBAWoiACAGKAIQSQ0ACyAIKAIMIQILIAgoAhwhACAKLQBURQRAIAooAkQgAEECdGooAgAhAAsgACAKKAJQTw0BIAooAgAoAgAgACAKKAIoIgFsaiACIAEQChogBUEBaiIFIAgoAhQgCCgCECIAa0EUbUkNAAsLIAggCCgCHEEBajYCHCAEIAQoAghBAWo2AgggDUEBaiINIAlGDQEgBCgCDCEADAALAAsgAygCHCIADQALQQEhBgsgA0EANgIcIAMoAhAiByADKAIMIgBrQQJ1IgFBA08EQANAIAAoAgAQCCADIAMoAgxBBGoiADYCDCADKAIQIgcgAGtBAnUiAUECSw0ACwtBqgEhAgJAAkACQCABQQFrDgIBAAILQdUCIQILIAMgAjYCGAsCQCAAIAdGDQADQCAAKAIAEAggAEEEaiIAIAdHDQALIAMoAhAiACADKAIMIgFGDQAgAyAAIAAgAWtBBGtBAnZBf3NBAnRqNgIQCyADKAIIIgAEQCAAEAgLIANBIGokACAGDAILEAwACxAMAAsPCyAEC98WAhJ/An4CQCABKQMIIAEpAxAiFUIEfFMNACAAIAEoAgAgFadqKAAAIgo2AgAgASABKQMQIhVCBHwiFjcDECAKQSBLDQAgASkDCCAVQgh8Uw0AIAAgASgCACAWp2ooAAAiBDYCBCABIAEpAxBCBHw3AxAgBEUEQEEBIQQMAQtBACEEIABBADYCCCAAQRBqIAEQD0UNACAAQSRqIAEQD0UNACAAQThqIAEQD0UNACAAQcwAaiABEA9FDQACfyAAKAIEIQ8gAiEKQQAhAUEAIQIjAEEgayIDJAAgACIEKAIMIQAgA0EANgIQIANCADcDCAJAIAAEQCAAQYCAgIAETw0BIAMgAEECdCIFEAkiATYCCCADIAEgBWoiAjYCECABQQAgBRALGiADIAI2AgwLIAQoAngiBSgCACIGBEAgBSAGNgIEIAYQCCAFQQA2AgggBUIANwIAIAMoAgwhAiADKAIIIQEgBCgCDCEACyAFIAI2AgQgBSABNgIAIAUgAygCEDYCCEEAIQEgA0EANgIQIANCADcDCAJAIAAEQCAAQYCAgIAETw0BIAMgAEECdCIAEAkiBzYCCCADIAAgB2oiATYCECAHQQAgABALGiADIAE2AgwLIAQoAoQBIgAoAgAiAgRAIAAgAjYCBCACEAggAEEANgIIIABCADcCACADKAIIIQcgAygCDCEBCyAAIAE2AgQgACAHNgIAIAAgAygCEDYCCCADQgA3AxggA0IANwMQIANCADcDCCADQQhqEBAgAygCDCADKAIYIAMoAhxqIgBB1QJuIgFBAnRqKAIAIAAgAUHVAmxrQQxsaiIAQgA3AgQgACAPNgIAQQEhBSADIAMoAhwiAUEBaiIANgIcAkAgACABSQ0AA0AgAygCDCIFIAMoAhgiByAAQQFrIglqIgFB1QJuIgJBAnRqKAIAIAEgAkHVAmxrQQxsaiIBKAIIIQIgASgCBCEGIAEoAgAhCyADIAk2AhwgAygCECIBIAVrIgVBAnVB1QJsQQFrQQAgBRsgACAHamtBAWpBqgVPBEAgAUEEaygCABAIIAMgAygCEEEEazYCEAsgCyAPSwRAQQAhBQwCC0EAIQVBACAGQQFqIAQoAgwiAEEBayAGRhsiByAATw0BIAQoAngiACACQQxsIgFqIQwCQAJAIAQoAgAgB0ECdCIJIAQoAoQBIAFqIg0oAgBqKAIAayIGRQRAIAtFDQEDQEEAIQYCQCAKKAIQIgAgCigCFEYNAANAIAwoAgAgACAGQRRsaiIJKAIEQQJ0aiECIAkoAgAhCAJAIAkoAgwiB0EDSw0AIAooAgwhASAJKAIQRQRAIAEhAgwBC0EAIQADQCABIAIgAEECdGogBxAKIAkoAgwiB2ohASAAQQFqIgAgCSgCEEkNAAsgCigCDCECCyAKKAIcIQAgCC0AVEUEQCAIKAJEIABBAnRqKAIAIQALIAAgCCgCUE8NASAIKAIAKAIAIAAgCCgCKCIBbGogAiABEAoaIAZBAWoiBiAKKAIUIAooAhAiAGtBFG1JDQALCyAKIAooAhxBAWo2AhwgBCAEKAIIQQFqNgIIIAsgBUEBaiIFRw0ACwwBCwJAAkACQAJAIAtBAk0EQCAEKAJsIgIgBzYCAEEBIQEgBCgCDCIAQQFLDQEMBAsgBCgCCCAEKAIESw0HIAAgAUEMaiIFaiAMKAIAIAwoAgQQEiAEKAJ4IAVqKAIAIAlqIgAgACgCAEEBIAZBAWt0ajYCAAJAIAtnQR9zIgBBICAEKAIgIgVrIghMBEAgBCgCHCIGIAQoAhRGBEBBACEFDAILIAYoAgAhCCAEIAAgBWoiDDYCICAIIAV0QSAgAGt2IQUgDEEgRw0BIARBADYCICAEIAZBBGo2AhwMAQsgBCgCHCIGQQRqIgwgBCgCFEYEQEEAIQUMAQsgBigCACENIAQgDDYCHCAEIAAgCGsiCDYCICAGKAIEQSAgCGt2IA0gBXRBICAAa3ZyIQULIAJBAWohCAJ/IAtBAXYgBWsiACALIABrIgVGBEAgAAwBCyAEKAJYIgYgBCgCUEYNAiAGKAIAIQsgBCAEKAJcIgxBAWoiDTYCXCALQYCAgIB4IAx2cSELAkAgDUEgRgRAIARBADYCXCAEIAZBBGo2AlggCw0BDAQLIAtFDQMLIAULIQYgACEFDAILA0AgAiABQQJ0akEAIAdBAWogByAAQQFrRhsiBzYCACABQQFqIgEgBCgCDCIASQ0ACwwCCyAAIQYLIAQoAoQBIgAgAWoiASgCACILIAlqIgkgCSgCAEEBajYCACAAIAhBDGxqIAsgASgCBBASIAUEQCADKAIcIAMoAhhqIgAgAygCECADKAIMIgFrIgtBAnVB1QJsQQFrQQAgCxtGBEAgA0EIahAQIAMoAgwhASADKAIYIAMoAhxqIQALIAEgAEHVAm4iC0ECdGooAgAgACALQdUCbGtBDGxqIgAgAjYCCCAAIAc2AgQgACAFNgIAIAMgAygCHEEBajYCHAsgBkUNASADKAIcIAMoAhhqIgAgAygCECADKAIMIgFrIgJBAnVB1QJsQQFrQQAgAhtGBEAgA0EIahAQIAMoAgwhASADKAIYIAMoAhxqIQALIAEgAEHVAm4iAkECdGooAgAgACACQdUCbGtBDGxqIgAgCDYCCCAAIAc2AgQgACAGNgIAIAMgAygCHEEBaiIANgIcDAILIAtFDQADQCAABEAgDCgCACEQIA0oAgAhESAEKAJgIQYgBCgCbCESQQAhAANAIAYgEiAAQQJ0aiIHKAIAQQJ0akEANgIAAkAgBCgCACARIAcoAgBBAnQiAmooAgBrIgFFDQAgAiAGaiECQSAgBCgCNCIJayIOIAFOBEAgBCgCMCIIIAQoAihGBEAgAkEANgIADAILIAIgCCgCACAJdEEgIAFrdjYCACAEIAQoAjQgAWoiATYCNCABQSBHDQEgBEEANgI0IAQgCEEEajYCMAwBCyAEKAIwIghBBGoiEyAEKAIoRgRAIAJBADYCAAwBCyAIKAIAIRQgBCATNgIwIAQgASAOayIONgI0IAIgCCgCBEEgIA5rdiAUIAl0QSAgAWt2cjYCAAsgBiAHKAIAQQJ0IgFqIgIgAigCACABIBBqKAIAcjYCACAAQQFqIgAgBCgCDEkNAAsLQQAhBgJAIAooAhAiACAKKAIURg0AA0AgBCgCYCAAIAZBFGxqIgkoAgRBAnRqIQIgCSgCACEIAkAgCSgCDCIHQQNLDQAgCigCDCEBIAkoAhBFBEAgASECDAELQQAhAANAIAEgAiAAQQJ0aiAHEAogCSgCDCIHaiEBIABBAWoiACAJKAIQSQ0ACyAKKAIMIQILIAooAhwhACAILQBURQRAIAgoAkQgAEECdGooAgAhAAsgACAIKAJQTw0BIAgoAgAoAgAgACAIKAIoIgFsaiACIAEQChogBkEBaiIGIAooAhQgCigCECIAa0EUbUkNAAsLIAogCigCHEEBajYCHCAEIAQoAghBAWo2AgggBUEBaiIFIAtGDQEgBCgCDCEADAALAAsgAygCHCEACyAADQALQQEhBQsgA0EANgIcIAMoAhAiByADKAIMIgBrQQJ1IgFBA08EQANAIAAoAgAQCCADIAMoAgxBBGoiADYCDCADKAIQIgcgAGtBAnUiAUECSw0ACwtBqgEhAgJAAkACQCABQQFrDgIBAAILQdUCIQILIAMgAjYCGAsCQCAAIAdGDQADQCAAKAIAEAggAEEEaiIAIAdHDQALIAMoAhAiACADKAIMIgFGDQAgAyAAIAAgAWtBBGtBAnZBf3NBAnRqNgIQCyADKAIIIgAEQCAAEAgLIANBIGokACAFDAILEAwACxAMAAsPCyAEC/IWAhJ/An4CQCABKQMIIAEpAxAiFUIEfFMNACAAIAEoAgAgFadqKAAAIgg2AgAgASABKQMQIhVCBHwiFjcDECAIQSBLDQAgASkDCCAVQgh8Uw0AIAAgASgCACAWp2ooAAAiBDYCBCABIAEpAxBCBHw3AxAgBEUEQEEBIQQMAQtBACEEIABBADYCCCAAQRBqIAEQD0UNACAAQSRqIAEQD0UNACAAQThqIAEQD0UNACAAQcwAaiABEA9FDQACfyAAKAIEIREgAiEIQQAhAUEAIQIjAEEgayIDJAAgACIEKAIMIQAgA0EANgIQIANCADcDCAJAIAAEQCAAQYCAgIAETw0BIAMgAEECdCIFEAkiATYCCCADIAEgBWoiAjYCECABQQAgBRALGiADIAI2AgwLIAQoAngiBSgCACIGBEAgBSAGNgIEIAYQCCAFQQA2AgggBUIANwIAIAMoAgwhAiADKAIIIQEgBCgCDCEACyAFIAI2AgQgBSABNgIAIAUgAygCEDYCCEEAIQEgA0EANgIQIANCADcDCAJAIAAEQCAAQYCAgIAETw0BIAMgAEECdCIAEAkiBzYCCCADIAAgB2oiATYCECAHQQAgABALGiADIAE2AgwLIAQoAoQBIgAoAgAiAgRAIAAgAjYCBCACEAggAEEANgIIIABCADcCACADKAIIIQcgAygCDCEBCyAAIAE2AgQgACAHNgIAIAAgAygCEDYCCCADQgA3AxggA0IANwMQIANCADcDCCADQQhqEBAgAygCDCADKAIYIAMoAhxqIgBB1QJuIgFBAnRqKAIAIAAgAUHVAmxrQQxsaiIAQgA3AgQgACARNgIAQQEhBSADIAMoAhwiAUEBaiIANgIcAkAgACABSQ0AA0AgAygCDCIFIAMoAhgiByAAQQFrIgtqIgFB1QJuIgJBAnRqKAIAIAEgAkHVAmxrQQxsaiICKAIIIQEgAigCBCEGIAIoAgAhCiADIAs2AhwgAygCECICIAVrIgVBAnVB1QJsQQFrQQAgBRsgACAHamtBAWpBqgVPBEAgAkEEaygCABAIIAMgAygCEEEEazYCEAtBACEFIAogEUsNASAEKAJ4IQAgAUEMbCIJIAQoAoQBaiEMQQAgBkEBaiAEKAIMQQFrIAZGGyIHIAQoAgxPDQEgACAJaiELAkACQCAEKAIAIAdBAnQiDSAMKAIAaigCAGsiAEUEQEEAIQwgCkUNAQNAQQAhBgJAIAgoAhAiACAIKAIURg0AA0AgCygCACAAIAZBFGxqIgUoAgRBAnRqIQIgBSgCACEJAkAgBSgCDCIHQQNLDQAgCCgCDCEBIAUoAhBFBEAgASECDAELQQAhAANAIAEgAiAAQQJ0aiAHEAogBSgCDCIHaiEBIABBAWoiACAFKAIQSQ0ACyAIKAIMIQILIAgoAhwhACAJLQBURQRAIAkoAkQgAEECdGooAgAhAAsgACAJKAJQTw0BIAkoAgAoAgAgACAJKAIoIgFsaiACIAEQChogBkEBaiIGIAgoAhQgCCgCECIAa0EUbUkNAAsLIAggCCgCHEEBajYCHCAEIAQoAghBAWo2AgggCiAMQQFqIgxHDQALDAELAkACQAJAAkAgCkECTQRAIAQoAmwiAiAHNgIAQQEhASAEKAIMIgBBAUsNAQwECyAEKAIIIAQoAgRLDQcgCyAEKAJ4IgIgAUEBaiIOQQxsIgxqIgVHBH8gBSALKAIAIAsoAgQQEiAEKAJ4BSACCyAMaigCACANaiICIAIoAgBBASAAQQFrdGo2AgACQCAKZ0EfcyIAQSAgBCgCICICayIGTARAIAQoAhwiBiAEKAIURgRAQQAhBQwCCyAGKAIAIQUgBCAAIAJqIgs2AiAgBSACdEEgIABrdiEFIAtBIEcNASAEQQA2AiAgBCAGQQRqNgIcDAELIAQoAhwiBUEEaiILIAQoAhRGBEBBACEFDAELIAUoAgAhDyAEIAs2AhwgBCAAIAZrIgY2AiAgBSgCBEEgIAZrdiAPIAJ0QSAgAGt2ciEFCwJ/IApBAXYgBWsiACAKIABrIgVGBEAgAAwBCyAEKAJYIgIgBCgCUEYNAiACKAIAIQYgBCAEKAJcIgpBAWoiCzYCXCAGQYCAgIB4IAp2cSEGAkAgC0EgRgRAIARBADYCXCAEIAJBBGo2AlggBg0BDAQLIAZFDQMLIAULIQYgACEFDAILA0AgAiABQQJ0akEAIAdBAWogByAAQQFrRhsiBzYCACABQQFqIgEgBCgCDCIASQ0ACwwCCyAAIQYLIA0gBCgChAEiACAJaiICKAIAIgpqIgsgCygCAEEBajYCACAAIAxqIAogAigCBBASIAUEQCADKAIcIAMoAhhqIgAgAygCECADKAIMIgJrIgpBAnVB1QJsQQFrQQAgChtGBEAgA0EIahAQIAMoAgwhAiADKAIYIAMoAhxqIQALIAIgAEHVAm4iCkECdGooAgAgACAKQdUCbGtBDGxqIgAgATYCCCAAIAc2AgQgACAFNgIAIAMgAygCHEEBajYCHAsgBkUNASADKAIcIAMoAhhqIgAgAygCECADKAIMIgFrIgJBAnVB1QJsQQFrQQAgAhtGBEAgA0EIahAQIAMoAgwhASADKAIYIAMoAhxqIQALIAEgAEHVAm4iAkECdGooAgAgACACQdUCbGtBDGxqIgAgDjYCCCAAIAc2AgQgACAGNgIAIAMgAygCHEEBaiIANgIcDAILQQAhDSAKRQ0AA0AgAARAIAsoAgAhDiAMKAIAIQ8gBCgCYCEFIAQoAmwhEkEAIQADQCAFIBIgAEECdGoiBigCAEECdGpBADYCAAJAIAQoAgAgDyAGKAIAQQJ0IgJqKAIAayIBRQ0AIAIgBWohAkEgIAQoAjQiB2siECABTgRAIAQoAjAiCSAEKAIoRgRAIAJBADYCAAwCCyACIAkoAgAgB3RBICABa3Y2AgAgBCAEKAI0IAFqIgE2AjQgAUEgRw0BIARBADYCNCAEIAlBBGo2AjAMAQsgBCgCMCIJQQRqIhMgBCgCKEYEQCACQQA2AgAMAQsgCSgCACEUIAQgEzYCMCAEIAEgEGsiEDYCNCACIAkoAgRBICAQa3YgFCAHdEEgIAFrdnI2AgALIAUgBigCAEECdCIBaiICIAIoAgAgASAOaigCAHI2AgAgAEEBaiIAIAQoAgxJDQALC0EAIQYCQCAIKAIQIgAgCCgCFEYNAANAIAQoAmAgACAGQRRsaiIFKAIEQQJ0aiECIAUoAgAhCQJAIAUoAgwiB0EDSw0AIAgoAgwhASAFKAIQRQRAIAEhAgwBC0EAIQADQCABIAIgAEECdGogBxAKIAUoAgwiB2ohASAAQQFqIgAgBSgCEEkNAAsgCCgCDCECCyAIKAIcIQAgCS0AVEUEQCAJKAJEIABBAnRqKAIAIQALIAAgCSgCUE8NASAJKAIAKAIAIAAgCSgCKCIBbGogAiABEAoaIAZBAWoiBiAIKAIUIAgoAhAiAGtBFG1JDQALCyAIIAgoAhxBAWo2AhwgBCAEKAIIQQFqNgIIIA1BAWoiDSAKRg0BIAQoAgwhAAwACwALIAMoAhwhAAsgAA0AC0EBIQULIANBADYCHCADKAIQIgcgAygCDCIAa0ECdSIBQQNPBEADQCAAKAIAEAggAyADKAIMQQRqIgA2AgwgAygCECIHIABrQQJ1IgFBAksNAAsLQaoBIQICQAJAAkAgAUEBaw4CAQACC0HVAiECCyADIAI2AhgLAkAgACAHRg0AA0AgACgCABAIIABBBGoiACAHRw0ACyADKAIQIgAgAygCDCIBRg0AIAMgACAAIAFrQQRrQQJ2QX9zQQJ0ajYCEAsgAygCCCIABEAgABAICyADQSBqJAAgBQwCCxAMAAsQDAALDwsgBAvmAgEFfyMAQRBrIgQkACAEIAE2AgxB5IEBKAIAIQIjAEHQAWsiAyQAIAMgATYCzAEgA0GgAWpBAEEoEAsaIAMgAygCzAE2AsgBAkBBACAAIANByAFqIANB0ABqIANBoAFqEIQBQQBIDQAgAigCTEEATiEFIAIoAgAhASACLABKQQBMBEAgAiABQV9xNgIACyABQSBxIQYCfyACKAIwBEAgAiAAIANByAFqIANB0ABqIANBoAFqEIQBDAELIAJB0AA2AjAgAiADQdAAajYCECACIAM2AhwgAiADNgIUIAIoAiwhASACIAM2AiwgAiAAIANByAFqIANB0ABqIANBoAFqEIQBIAFFDQAaIAJBAEEAIAIoAiQRAwAaIAJBADYCMCACIAE2AiwgAkEANgIcIAJBADYCECACKAIUGiACQQA2AhRBAAsaIAIgAigCACAGcjYCACAFRQ0ACyADQdABaiQAIARBEGokAAsxACABAn8gAigCTEF/TARAIAAgASACEH4MAQsgACABIAIQfgsiAEYEQA8LIAAgAW4aC88CAgl9An8CQCACKAIcQQlHDQAgAi0AGEEDRw0AIAAoAgQiAEECa0EcSw0AQQEhDCACKAJQIg1FDQBDAAAAQEEBIAB0QQJrspUhCCACKAIAKAIAIAIoAjBqIQIgASgCACgCACABKAIwaiEAQQAhAQNAQwAAAAAhA0MAAAAAIQlDAAAAACEKIAggACgCBLKUQwAAgL+SIgRDAACAPyAIIAAoAgCylEMAAIC/kiIFi5MgBIuTIgeMQwAAAACXIgYgBowiCyAEQwAAAABdG5IiBCAElCAHIAeUIAUgBiALIAVDAAAAAF0bkiIFIAWUkpIiBrtEje21oPfGsD5jRQRAIARDAACAPyAGkZUiA5QhCiAFIAOUIQkgByADlCEDCyAAQQhqIQAgAiAKOAAIIAIgCTgABCACIAM4AAAgAkEMaiECIAFBAWoiASANRw0ACwsgDAubLgEMfyMAQRBrIgwkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQbCHASgCACIFQRAgAEELakF4cSAAQQtJGyIIQQN2IgJ2IgFBA3EEQCABQX9zQQFxIAJqIgNBA3QiAUHghwFqKAIAIgRBCGohAAJAIAQoAggiAiABQdiHAWoiAUYEQEGwhwEgBUF+IAN3cTYCAAwBCyACIAE2AgwgASACNgIICyAEIANBA3QiAUEDcjYCBCABIARqIgEgASgCBEEBcjYCBAwNCyAIQbiHASgCACIKTQ0BIAEEQAJAQQIgAnQiAEEAIABrciABIAJ0cSIAQQAgAGtxQQFrIgAgAEEMdkEQcSICdiIBQQV2QQhxIgAgAnIgASAAdiIBQQJ2QQRxIgByIAEgAHYiAUEBdkECcSIAciABIAB2IgFBAXZBAXEiAHIgASAAdmoiA0EDdCIAQeCHAWooAgAiBCgCCCIBIABB2IcBaiIARgRAQbCHASAFQX4gA3dxIgU2AgAMAQsgASAANgIMIAAgATYCCAsgBEEIaiEAIAQgCEEDcjYCBCAEIAhqIgIgA0EDdCIBIAhrIgNBAXI2AgQgASAEaiADNgIAIAoEQCAKQQN2IgFBA3RB2IcBaiEHQcSHASgCACEEAn8gBUEBIAF0IgFxRQRAQbCHASABIAVyNgIAIAcMAQsgBygCCAshASAHIAQ2AgggASAENgIMIAQgBzYCDCAEIAE2AggLQcSHASACNgIAQbiHASADNgIADA0LQbSHASgCACIGRQ0BIAZBACAGa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEHgiQFqKAIAIgEoAgRBeHEgCGshAyABIQIDQAJAIAIoAhAiAEUEQCACKAIUIgBFDQELIAAoAgRBeHEgCGsiAiADIAIgA0kiAhshAyAAIAEgAhshASAAIQIMAQsLIAEgCGoiCSABTQ0CIAEoAhghCyABIAEoAgwiBEcEQCABKAIIIgBBwIcBKAIASRogACAENgIMIAQgADYCCAwMCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQQgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCwtBfyEIIABBv39LDQAgAEELaiIAQXhxIQhBtIcBKAIAIglFDQBBHyEFQQAgCGshAwJAAkACQAJ/IAhB////B00EQCAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgCCAAQRVqdkEBcXJBHGohBQsgBUECdEHgiQFqKAIAIgJFCwRAQQAhAAwBC0EAIQAgCEEAQRkgBUEBdmsgBUEfRht0IQEDQAJAIAIoAgRBeHEgCGsiByADTw0AIAIhBCAHIgMNAEEAIQMgAiEADAMLIAAgAigCFCIHIAcgAiABQR12QQRxaigCECICRhsgACAHGyEAIAFBAXQhASACDQALCyAAIARyRQRAQQIgBXQiAEEAIABrciAJcSIARQ0DIABBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEHgiQFqKAIAIQALIABFDQELA0AgACgCBEF4cSAIayIBIANJIQIgASADIAIbIQMgACAEIAIbIQQgACgCECIBBH8gAQUgACgCFAsiAA0ACwsgBEUNACADQbiHASgCACAIa08NACAEIAhqIgYgBE0NASAEKAIYIQUgBCAEKAIMIgFHBEAgBCgCCCIAQcCHASgCAEkaIAAgATYCDCABIAA2AggMCgsgBEEUaiICKAIAIgBFBEAgBCgCECIARQ0EIARBEGohAgsDQCACIQcgACIBQRRqIgIoAgAiAA0AIAFBEGohAiABKAIQIgANAAsgB0EANgIADAkLIAhBuIcBKAIAIgJNBEBBxIcBKAIAIQMCQCACIAhrIgFBEE8EQEG4hwEgATYCAEHEhwEgAyAIaiIANgIAIAAgAUEBcjYCBCACIANqIAE2AgAgAyAIQQNyNgIEDAELQcSHAUEANgIAQbiHAUEANgIAIAMgAkEDcjYCBCACIANqIgAgACgCBEEBcjYCBAsgA0EIaiEADAsLIAhBvIcBKAIAIgZJBEBBvIcBIAYgCGsiATYCAEHIhwFByIcBKAIAIgIgCGoiADYCACAAIAFBAXI2AgQgAiAIQQNyNgIEIAJBCGohAAwLC0EAIQAgCEEvaiIJAn9BiIsBKAIABEBBkIsBKAIADAELQZSLAUJ/NwIAQYyLAUKAoICAgIAENwIAQYiLASAMQQxqQXBxQdiq1aoFczYCAEGciwFBADYCAEHsigFBADYCAEGAIAsiAWoiBUEAIAFrIgdxIgIgCE0NCkHoigEoAgAiBARAQeCKASgCACIDIAJqIgEgA00NCyABIARLDQsLQeyKAS0AAEEEcQ0FAkACQEHIhwEoAgAiAwRAQfCKASEAA0AgAyAAKAIAIgFPBEAgASAAKAIEaiADSw0DCyAAKAIIIgANAAsLQQAQNyIBQX9GDQYgAiEFQYyLASgCACIDQQFrIgAgAXEEQCACIAFrIAAgAWpBACADa3FqIQULIAUgCE0NBiAFQf7///8HSw0GQeiKASgCACIEBEBB4IoBKAIAIgMgBWoiACADTQ0HIAAgBEsNBwsgBRA3IgAgAUcNAQwICyAFIAZrIAdxIgVB/v///wdLDQUgBRA3IgEgACgCACAAKAIEakYNBCABIQALAkAgCEEwaiAFTQ0AIABBf0YNAEGQiwEoAgAiASAJIAVrakEAIAFrcSIBQf7///8HSwRAIAAhAQwICyABEDdBf0cEQCABIAVqIQUgACEBDAgLQQAgBWsQNxoMBQsgACIBQX9HDQYMBAsAC0EAIQQMBwtBACEBDAULIAFBf0cNAgtB7IoBQeyKASgCAEEEcjYCAAsgAkH+////B0sNASACEDchAUEAEDchACABQX9GDQEgAEF/Rg0BIAAgAU0NASAAIAFrIgUgCEEoak0NAQtB4IoBQeCKASgCACAFaiIANgIAQeSKASgCACAASQRAQeSKASAANgIACwJAAkACQEHIhwEoAgAiBwRAQfCKASEAA0AgASAAKAIAIgMgACgCBCICakYNAiAAKAIIIgANAAsMAgtBwIcBKAIAIgBBACAAIAFNG0UEQEHAhwEgATYCAAtBACEAQfSKASAFNgIAQfCKASABNgIAQdCHAUF/NgIAQdSHAUGIiwEoAgA2AgBB/IoBQQA2AgADQCAAQQN0IgNB4IcBaiADQdiHAWoiAjYCACADQeSHAWogAjYCACAAQQFqIgBBIEcNAAtBvIcBIAVBKGsiA0F4IAFrQQdxQQAgAUEIakEHcRsiAGsiAjYCAEHIhwEgACABaiIANgIAIAAgAkEBcjYCBCABIANqQSg2AgRBzIcBQZiLASgCADYCAAwCCyABIAdNDQAgACgCDEEIcQ0AIAMgB0sNACAAIAIgBWo2AgRByIcBIAdBeCAHa0EHcUEAIAdBCGpBB3EbIgBqIgI2AgBBvIcBQbyHASgCACAFaiIBIABrIgA2AgAgAiAAQQFyNgIEIAEgB2pBKDYCBEHMhwFBmIsBKAIANgIADAELQcCHASgCACABSwRAQcCHASABNgIACyABIAVqIQJB8IoBIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQfCKASEAA0AgByAAKAIAIgJPBEAgAiAAKAIEaiIEIAdLDQMLIAAoAgghAAwACwALIAAgATYCACAAIAAoAgQgBWo2AgQgAUF4IAFrQQdxQQAgAUEIakEHcRtqIgkgCEEDcjYCBCACQXggAmtBB3FBACACQQhqQQdxG2oiBSAIIAlqIgZrIQIgBSAHRgRAQciHASAGNgIAQbyHAUG8hwEoAgAgAmoiADYCACAGIABBAXI2AgQMAwsgBUHEhwEoAgBGBEBBxIcBIAY2AgBBuIcBQbiHASgCACACaiIANgIAIAYgAEEBcjYCBCAAIAZqIAA2AgAMAwsgBSgCBCIAQQNxQQFGBEAgAEF4cSEHAkAgAEH/AU0EQCAFKAIIIgMgAEEDdiIAQQN0QdiHAWpGGiADIAUoAgwiAUYEQEGwhwFBsIcBKAIAQX4gAHdxNgIADAILIAMgATYCDCABIAM2AggMAQsgBSgCGCEIAkAgBSAFKAIMIgFHBEAgBSgCCCIAIAE2AgwgASAANgIIDAELAkAgBUEUaiIAKAIAIgMNACAFQRBqIgAoAgAiAw0AQQAhAQwBCwNAIAAhBCADIgFBFGoiACgCACIDDQAgAUEQaiEAIAEoAhAiAw0ACyAEQQA2AgALIAhFDQACQCAFIAUoAhwiA0ECdEHgiQFqIgAoAgBGBEAgACABNgIAIAENAUG0hwFBtIcBKAIAQX4gA3dxNgIADAILIAhBEEEUIAgoAhAgBUYbaiABNgIAIAFFDQELIAEgCDYCGCAFKAIQIgAEQCABIAA2AhAgACABNgIYCyAFKAIUIgBFDQAgASAANgIUIAAgATYCGAsgBSAHaiEFIAIgB2ohAgsgBSAFKAIEQX5xNgIEIAYgAkEBcjYCBCACIAZqIAI2AgAgAkH/AU0EQCACQQN2IgBBA3RB2IcBaiECAn9BsIcBKAIAIgFBASAAdCIAcUUEQEGwhwEgACABcjYCACACDAELIAIoAggLIQAgAiAGNgIIIAAgBjYCDCAGIAI2AgwgBiAANgIIDAMLQR8hACACQf///wdNBEAgAkEIdiIAIABBgP4/akEQdkEIcSIDdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIANyIAByayIAQQF0IAIgAEEVanZBAXFyQRxqIQALIAYgADYCHCAGQgA3AhAgAEECdEHgiQFqIQQCQEG0hwEoAgAiA0EBIAB0IgFxRQRAQbSHASABIANyNgIAIAQgBjYCACAGIAQ2AhgMAQsgAkEAQRkgAEEBdmsgAEEfRht0IQAgBCgCACEBA0AgASIDKAIEQXhxIAJGDQMgAEEddiEBIABBAXQhACADIAFBBHFqIgQoAhAiAQ0ACyAEIAY2AhAgBiADNgIYCyAGIAY2AgwgBiAGNgIIDAILQbyHASAFQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBByIcBIAAgAWoiADYCACAAIAJBAXI2AgQgASADakEoNgIEQcyHAUGYiwEoAgA2AgAgByAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAdBEGpJGyICQRs2AgQgAkH4igEpAgA3AhAgAkHwigEpAgA3AghB+IoBIAJBCGo2AgBB9IoBIAU2AgBB8IoBIAE2AgBB/IoBQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAdGDQMgAiACKAIEQX5xNgIEIAcgAiAHayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEHYhwFqIQICf0GwhwEoAgAiAUEBIAB0IgBxRQRAQbCHASAAIAFyNgIAIAIMAQsgAigCCAshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AggMBAtBHyEAIAdCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAcgADYCHCAAQQJ0QeCJAWohAwJAQbSHASgCACICQQEgAHQiAXFFBEBBtIcBIAEgAnI2AgAgAyAHNgIAIAcgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAwsgAygCCCIAIAY2AgwgAyAGNgIIIAZBADYCGCAGIAM2AgwgBiAANgIICyAJQQhqIQAMBQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIIC0G8hwEoAgAiACAITQ0AQbyHASAAIAhrIgE2AgBByIcBQciHASgCACICIAhqIgA2AgAgACABQQFyNgIEIAIgCEEDcjYCBCACQQhqIQAMAwtB4IYBQTA2AgBBACEADAILAkAgBUUNAAJAIAQoAhwiAkECdEHgiQFqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQbSHASAJQX4gAndxIgk2AgAMAgsgBUEQQRQgBSgCECAERhtqIAE2AgAgAUUNAQsgASAFNgIYIAQoAhAiAARAIAEgADYCECAAIAE2AhgLIAQoAhQiAEUNACABIAA2AhQgACABNgIYCwJAIANBD00EQCAEIAMgCGoiAEEDcjYCBCAAIARqIgAgACgCBEEBcjYCBAwBCyAEIAhBA3I2AgQgBiADQQFyNgIEIAMgBmogAzYCACADQf8BTQRAIANBA3YiAEEDdEHYhwFqIQICf0GwhwEoAgAiAUEBIAB0IgBxRQRAQbCHASAAIAFyNgIAIAIMAQsgAigCCAshACACIAY2AgggACAGNgIMIAYgAjYCDCAGIAA2AggMAQtBHyEAIANB////B00EQCADQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgAyAAQRVqdkEBcXJBHGohAAsgBiAANgIcIAZCADcCECAAQQJ0QeCJAWohAgJAAkAgCUEBIAB0IgFxRQRAQbSHASABIAlyNgIAIAIgBjYCACAGIAI2AhgMAQsgA0EAQRkgAEEBdmsgAEEfRht0IQAgAigCACEIA0AgCCIBKAIEQXhxIANGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgIoAhAiCA0ACyACIAY2AhAgBiABNgIYCyAGIAY2AgwgBiAGNgIIDAELIAEoAggiACAGNgIMIAEgBjYCCCAGQQA2AhggBiABNgIMIAYgADYCCAsgBEEIaiEADAELAkAgC0UNAAJAIAEoAhwiAkECdEHgiQFqIgAoAgAgAUYEQCAAIAQ2AgAgBA0BQbSHASAGQX4gAndxNgIADAILIAtBEEEUIAsoAhAgAUYbaiAENgIAIARFDQELIAQgCzYCGCABKAIQIgAEQCAEIAA2AhAgACAENgIYCyABKAIUIgBFDQAgBCAANgIUIAAgBDYCGAsCQCADQQ9NBEAgASADIAhqIgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQsgASAIQQNyNgIEIAkgA0EBcjYCBCADIAlqIAM2AgAgCgRAIApBA3YiAEEDdEHYhwFqIQRBxIcBKAIAIQICf0EBIAB0IgAgBXFFBEBBsIcBIAAgBXI2AgAgBAwBCyAEKAIICyEAIAQgAjYCCCAAIAI2AgwgAiAENgIMIAIgADYCCAtBxIcBIAk2AgBBuIcBIAM2AgALIAFBCGohAAsgDEEQaiQAIAALowEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQgACgCECICRQRAIABBATYCJCAAIAM2AhggACABNgIQIANBAUcNASAAKAIwQQFHDQEgAEEBOgA2DwsgASACRgRAIAAoAhgiAkECRgRAIAAgAzYCGCADIQILIAAoAjBBAUcNASACQQFHDQEgAEEBOgA2DwsgAEEBOgA2IAAgACgCJEEBajYCJAsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLCwQAQQELAwABC4IBAQN/IwBBEGsiBSQAIwBBEGsiAyQAIAEgAGtBAnUhAQNAIAEEQCADIAA2AgwgAyADKAIMIAFBAXYiBEECdGo2AgwgASAEQX9zaiAEIAMoAgwoAgAgAigCAEkiBBshASADKAIMQQRqIAAgBBshAAwBCwsgA0EQaiQAIAVBEGokACAAC/AMAQh/IwBBEGsiBCQAIAQgADYCDAJAIABB0wFNBEBBwPgAQYD6ACAEQQxqEMEBKAIAIQAMAQsgAEF8TwRAEIMBAAsgBCAAIABB0gFuIgdB0gFsIgNrNgIIQYD6AEHA+wAgBEEIahDBAUGA+gBrQQJ1IQUCQANAIAVBAnRBgPoAaigCACADaiEAQQUhAyAGIQECQAJAA0AgASEGIANBL0YEQEHTASEDA0AgACADbiIBIANJDQQgACABIANsRg0DIAAgA0EKaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EMaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EQaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0ESaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EWaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EcaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EeaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EkaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EoaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EqaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EuaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0E0aiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0E6aiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0E8aiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HCAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBxgBqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQcgAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HOAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB0gBqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQdgAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HgAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB5ABqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQeYAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HqAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB7ABqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQfAAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0H4AGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB/gBqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQYIBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GIAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBigFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQY4BaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GUAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBlgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQZwBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GiAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBpgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQagBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GsAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBsgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQbQBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0G6AWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBvgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQcABaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HEAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBxgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQdABaiIBbiICIAFJDQQgA0HSAWohAyAAIAEgAmxHDQALDAILIAAgA0ECdEHA+ABqKAIAIgFuIgIgAWwhCCABIAJLIgJFBEAgACAGIAIbIQEgA0EBaiEDIAAgCEcNAQsLIAINAyAAIAhHDQMLQQAgBUEBaiIAIABBMEYiABshBSAAIAdqIgdB0gFsIQMMAQsLIAQgADYCDAwBCyAEIAA2AgwgACAGIAIbIQALIARBEGokACAAC7sCAAJAIAFBFEsNAAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOCgABAgMEBQYHCAkKCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEyAQA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEzAQA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEwAAA3AwAPCyACIAIoAgAiAUEEajYCACAAIAExAAA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAErAwA5AwAPCyAAIAJBABEEAAsLUwEDfwJAIAAoAgAsAABBMGtBCk8NAANAIAAoAgAiAiwAACEDIAAgAkEBajYCACABIANqQTBrIQEgAiwAAUEwa0EKTw0BIAFBCmwhAQwACwALIAELmwIAIABFBEBBAA8LAn8CQCAABH8gAUH/AE0NAQJAQaSEASgCACgCAEUEQCABQYB/cUGAvwNGDQMMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAgwECyABQYCwA09BACABQYBAcUGAwANHG0UEQCAAIAFBP3FBgAFyOgACIAAgAUEMdkHgAXI6AAAgACABQQZ2QT9xQYABcjoAAUEDDAQLIAFBgIAEa0H//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDAQLC0HghgFBGTYCAEF/BUEBCwwBCyAAIAE6AABBAQsL1ZQBAhh/An4jAEGgBWsiFSQAAkACQAJAIAEpAwggASkDECIbQgR8Uw0AIAAgASgCACAbp2ooAAAiAzYCACABIAEpAxAiG0IEfCIcNwMQIANBH0sNACABKQMIIBtCCHxTDQAgACABKAIAIBynaigAADYCBCABIAEpAxAiG0IEfCIcNwMQIAEpAwggG0IIfFMNACAAIAEoAgAgHKdqKAAAIgM2AgwgASABKQMQIhtCBHwiHDcDECAAKAIUIgVBACADIAVHGw0AIAEpAwggG0IIfFMNACAAIAEoAgAgHKdqKAAAIgU2AhAgASABKQMQQgR8NwMQIAVBB08EQCAVIAU2AgBBvPMAIBUQuQEMAQsgFSACNgKYBQJAIANFDQACQCACKAIIIAIoAgAiEmtBDG0gA08NACADQdaq1aoBSQRAIAIoAgQhCCADQQxsIgMQCSIFIANqIQQgBSAIIBJrQQxtQQxsaiIFIQMgCCASRwRAIAUhAwNAIANBDGsiAyAIQQxrIggoAgA2AgAgAyAIKAIENgIEIAMgCCgCCDYCCCAIIBJHDQALCyACIAQ2AgggAiAFNgIEIAIgAzYCACASRQ0BIBIQCAwBCwwDCwJAAkACQAJAAkACQAJAIAAoAhAOBwABAgMEBQYICyAVQQhqQQMQRiIXIQMgFUGYBWohEgJAIAEpAwggASkDECIbQgR8Uw0AIAMgASgCACAbp2ooAAAiBTYCACABIAEpAxAiG0IEfCIcNwMQIAVBIEsNACABKQMIIBtCCHxTDQAgAyABKAIAIBynaigAACIFNgIEIAEgASkDEEIEfDcDECAFRQ0AIANBADYCCCADQRBqIAEQD0UNACADQSRqIAEQD0UNACADQThqIAEQD0UNACADQcwAaiABEA9FDQAgAygCBCEQQQAhBSMAQSBrIgQkACADKAIMIQEgBEEANgIQIARCADcDCAJAIAEEQCABQYCAgIAETw0MIAQgAUECdCIIEAkiBTYCCCAEIAUgCGoiBzYCECAFQQAgCBALGiAEIAc2AgwLIAMoAngiCCgCACIJBEAgCCAJNgIEIAkQCCAIQQA2AgggCEIANwIAIAQoAgwhByAEKAIIIQUgAygCDCEBCyAIIAc2AgQgCCAFNgIAIAggBCgCEDYCCEEAIQUgBEEANgIQIARCADcDCAJAIAEEQCABQYCAgIAETw0BIAQgAUECdCIBEAkiBjYCCCAEIAEgBmoiBTYCECAGQQAgARALGiAEIAU2AgwLIAMoAoQBIgEoAgAiCARAIAEgCDYCBCAIEAggAUEANgIIIAFCADcCACAEKAIIIQYgBCgCDCEFCyABIAU2AgQgASAGNgIAIAEgBCgCEDYCCCAEQgA3AxggBEIANwMQIARCADcDCCAEQQhqEBAgBCgCDCAEKAIYIAQoAhxqIgFB1QJuIgVBAnRqKAIAIAEgBUHVAmxrQQxsaiIBQgA3AgQgASAQNgIAIAQgBCgCHCIFQQFqIgE2AhwCQCABIAVJDQAgA0HgAGohGANAIAQoAgwiByAEKAIYIgkgAUEBayIMaiIFQdUCbiIIQQJ0aigCACAFIAhB1QJsa0EMbGoiBSgCCCELIAUoAgQhBiAFKAIAIQggBCAMNgIcIAQoAhAiBSAHayIHQQJ1QdUCbEEBa0EAIAcbIAEgCWprQQFqQaoFTwRAIAVBBGsoAgAQCCAEIAQoAhBBBGs2AhALQQAhBSAIIBBLDQEgAygCeCEBIAtBDGwiByADKAKEAWohDEEAIAZBAWogAygCDEEBayAGRhsiBiADKAIMTw0BIAEgB2ohCQJAAkACQAJAAkACQAJAIAMoAgAgBkECdCIKIAwoAgBqKAIAayIBRQRAIAhFDQYDQCAJKAIAIgEoAgghCiABKAIEIQ4gASgCACENAkAgEigCACIHKAIEIgEgBygCCCIMSQRAIAEgCjYCCCABIA42AgQgASANNgIAIAcgAUEMajYCBAwBCyABIAcoAgAiC2tBDG0iEUEBaiIGQdaq1aoBTw0YAn9BACAGIAwgC2tBDG0iDEEBdCIPIAYgD0sbQdWq1aoBIAxBqtWq1QBJGyIMRQ0AGiAMQdaq1aoBTw0YIAxBDGwQCQsiDyARQQxsaiIGIAo2AgggBiAONgIEIAYgDTYCACAGQQxqIQogASALRwRAA0AgBkEMayIGIAFBDGsiASgCADYCACAGIAEoAgQ2AgQgBiABKAIINgIIIAEgC0cNAAsLIAcgDyAMQQxsajYCCCAHIAo2AgQgByAGNgIAIAtFDQAgCxAICyADIAMoAghBAWo2AgggCCAFQQFqIgVHDQALDAYLIAhBAk0EQCADKAJsIgcgBjYCAEEBIQUgAygCDCIBQQFLDQIMBQsgAygCCCADKAIESw0IIAkgAygCeCIFIAtBAWoiDkEMbCIMaiINRwR/IA0gCSgCACAJKAIEEBIgAygCeAUgBQsgDGooAgAgCmoiBSAFKAIAQQEgAUEBa3RqNgIAAkAgCGdBH3MiAUEgIAMoAiAiBWsiDUwEQCADKAIcIgkgAygCFEYEQEEAIQUMAgsgCSgCACENIAMgASAFaiIRNgIgIA0gBXRBICABa3YhBSARQSBHDQEgA0EANgIgIAMgCUEEajYCHAwBCyADKAIcIglBBGoiESADKAIURgRAQQAhBQwBCyAJKAIAIQ8gAyARNgIcIAMgASANayINNgIgIAkoAgRBICANa3YgDyAFdEEgIAFrdnIhBQsCfyAIQQF2IAVrIgEgCCABayIFRgRAIAEMAQsgAygCWCIIIAMoAlBGDQMgCCgCACEJIAMgAygCXCINQQFqIhE2AlwgCUGAgICAeCANdnEhCQJAIBFBIEYEQCADQQA2AlwgAyAIQQRqNgJYIAkNAQwFCyAJRQ0ECyAFCyEIIAEhBQwDCwALA0AgByAFQQJ0akEAIAZBAWogBiABQQFrRhsiBjYCACAFQQFqIgUgAygCDCIBSQ0ACwwCCyABIQgLIAMoAoQBIgEgB2oiBygCACIJIApqIgogCigCAEEBajYCACABIAxqIAkgBygCBBASIAUEQCAEKAIcIAQoAhhqIgEgBCgCECAEKAIMIgdrIglBAnVB1QJsQQFrQQAgCRtGBEAgBEEIahAQIAQoAgwhByAEKAIYIAQoAhxqIQELIAcgAUHVAm4iCUECdGooAgAgASAJQdUCbGtBDGxqIgEgCzYCCCABIAY2AgQgASAFNgIAIAQgBCgCHEEBajYCHAsgCEUNASAEKAIcIAQoAhhqIgEgBCgCECAEKAIMIgVrIgdBAnVB1QJsQQFrQQAgBxtGBEAgBEEIahAQIAQoAgwhBSAEKAIYIAQoAhxqIQELIAUgAUHVAm4iB0ECdGooAgAgASAHQdUCbGtBDGxqIgEgDjYCCCABIAY2AgQgASAINgIAIAQgBCgCHEEBaiIBNgIcDAILQQAhCyAIRQ0AA0AgAQRAIAkoAgAhESAMKAIAIQ8gAygCYCEHIAMoAmwhFEEAIQEDQCAHIBQgAUECdGoiCigCAEECdGpBADYCAAJAIAMoAgAgDyAKKAIAQQJ0IgZqKAIAayIFRQ0AIAYgB2ohBkEgIAMoAjQiDmsiEyAFTgRAIAMoAjAiDSADKAIoRgRAIAZBADYCAAwCCyAGIA0oAgAgDnRBICAFa3Y2AgAgAyADKAI0IAVqIgU2AjQgBUEgRw0BIANBADYCNCADIA1BBGo2AjAMAQsgAygCMCINQQRqIhYgAygCKEYEQCAGQQA2AgAMAQsgDSgCACEZIAMgFjYCMCADIAUgE2siEzYCNCAGIA0oAgRBICATa3YgGSAOdEEgIAVrdnI2AgALIAcgCigCAEECdCIFaiIGIAYoAgAgBSARaigCAHI2AgAgAUEBaiIBIAMoAgxJDQALCyASIBgQOSADIAMoAghBAWo2AgggC0EBaiILIAhGDQEgAygCDCEBDAALAAsgBCgCHCEBCyABDQALCyAEQQA2AhwgBCgCECIBIAQoAgwiA2tBAnUiBkEDTwRAA0AgAygCABAIIAQgBCgCDEEEaiIDNgIMIAQoAhAiASADa0ECdSIGQQJLDQALC0GqASEFAkACQAJAIAZBAWsOAgEAAgtB1QIhBQsgBCAFNgIYCwJAIAEgA0YNAANAIAMoAgAQCCADQQRqIgMgAUcNAAsgBCgCECIBIAQoAgwiA0YNACAEIAEgASADa0EEa0ECdkF/c0ECdGo2AhALIAQoAggiAQRAIAEQCAsgBEEgaiQADAELDAsLCyAXEEcMBgsgFUEIakEDEEYiFyEDIBVBmAVqIRICQCABKQMIIAEpAxAiG0IEfFMNACADIAEoAgAgG6dqKAAAIgU2AgAgASABKQMQIhtCBHwiHDcDECAFQSBLDQAgASkDCCAbQgh8Uw0AIAMgASgCACAcp2ooAAAiBTYCBCABIAEpAxBCBHw3AxAgBUUNACADQQA2AgggA0EQaiABEA9FDQAgA0EkaiABEA9FDQAgA0E4aiABEA9FDQAgA0HMAGogARAPRQ0AIAMoAgQhEEEAIQUjAEEgayIEJAAgAygCDCEBIARBADYCECAEQgA3AwgCQCABBEAgAUGAgICABE8NCyAEIAFBAnQiCBAJIgc2AgggBCAHIAhqIgU2AhAgB0EAIAgQCxogBCAFNgIMCyADKAJ4IggoAgAiBgRAIAggBjYCBCAGEAggCEEANgIIIAhCADcCACAEKAIMIQUgBCgCCCEHIAMoAgwhAQsgCCAFNgIEIAggBzYCACAIIAQoAhA2AghBACEHIARBADYCECAEQgA3AwhBACEGAkAgAQRAIAFBgICAgARPDQEgBCABQQJ0IgEQCSIGNgIIIAQgASAGaiIHNgIQIAZBACABEAsaIAQgBzYCDAsgAygChAEiASgCACIFBEAgASAFNgIEIAUQCCABQQA2AgggAUIANwIAIAQoAgwhByAEKAIIIQYLIAEgBzYCBCABIAY2AgAgASAEKAIQNgIIIARCADcDGCAEQgA3AxAgBEIANwMIIARBCGoQECAEKAIMIAQoAhggBCgCHGoiAUHVAm4iBUECdGooAgAgASAFQdUCbGtBDGxqIgFCADcCBCABIBA2AgAgBCAEKAIcIgVBAWoiATYCHAJAIAEgBUkNACADQeAAaiEYA0AgBCgCDCIHIAQoAhgiCyABQQFrIgxqIgVB1QJuIghBAnRqKAIAIAUgCEHVAmxrQQxsaiIFKAIIIQkgBSgCBCEGIAUoAgAhCCAEIAw2AhwgBCgCECIFIAdrIgdBAnVB1QJsQQFrQQAgBxsgASALamtBAWpBqgVPBEAgBUEEaygCABAIIAQgBCgCEEEEazYCEAsgCCAQSw0BQQAhBUEAIAZBAWogAygCDCIBQQFrIAZGGyIGIAFPDQEgAygCeCIBIAlBDGwiB2ohCwJAAkACQAJAAkACQAJAIAMoAgAgBkECdCIMIAMoAoQBIAdqIg0oAgBqKAIAayIKRQRAIAhFDQYDQCALKAIAIgEoAgghCiABKAIEIQ4gASgCACENAkAgEigCACIHKAIEIgEgBygCCCIMSQRAIAEgCjYCCCABIA42AgQgASANNgIAIAcgAUEMajYCBAwBCyABIAcoAgAiCWtBDG0iEUEBaiIGQdaq1aoBTw0XAn9BACAGIAwgCWtBDG0iDEEBdCIPIAYgD0sbQdWq1aoBIAxBqtWq1QBJGyIMRQ0AGiAMQdaq1aoBTw0XIAxBDGwQCQsiDyARQQxsaiIGIAo2AgggBiAONgIEIAYgDTYCACAGQQxqIQogASAJRwRAA0AgBkEMayIGIAFBDGsiASgCADYCACAGIAEoAgQ2AgQgBiABKAIINgIIIAEgCUcNAAsLIAcgDyAMQQxsajYCCCAHIAo2AgQgByAGNgIAIAlFDQAgCRAICyADIAMoAghBAWo2AgggCCAFQQFqIgVHDQALDAYLIAhBAk0EQCADKAJsIgUgBjYCAEEBIQcgAygCDCIBQQFLDQIMBQsgAygCCCADKAIESw0IIAEgB0EMaiIFaiALKAIAIAsoAgQQEiADKAJ4IAVqKAIAIAxqIgEgASgCAEEBIApBAWt0ajYCAAJAIAhnQR9zIgFBICADKAIgIgVrIgpMBEAgAygCHCILIAMoAhRGBEBBACEFDAILIAsoAgAhCiADIAEgBWoiDjYCICAKIAV0QSAgAWt2IQUgDkEgRw0BIANBADYCICADIAtBBGo2AhwMAQsgAygCHCILQQRqIg4gAygCFEYEQEEAIQUMAQsgCygCACENIAMgDjYCHCADIAEgCmsiCjYCICALKAIEQSAgCmt2IA0gBXRBICABa3ZyIQULIAlBAWohCwJ/IAhBAXYgBWsiASAIIAFrIgVGBEAgAQwBCyADKAJYIgggAygCUEYNAyAIKAIAIQogAyADKAJcIg5BAWoiDTYCXCAKQYCAgIB4IA52cSEKAkAgDUEgRgRAIANBADYCXCADIAhBBGo2AlggCg0BDAULIApFDQQLIAULIQggASEFDAMLAAsDQCAFIAdBAnRqQQAgBkEBaiAGIAFBAWtGGyIGNgIAIAdBAWoiByADKAIMIgFJDQALDAILIAEhCAsgDCADKAKEASIBIAdqIgcoAgAiCmoiDCAMKAIAQQFqNgIAIAEgC0EMbGogCiAHKAIEEBIgBQRAIAQoAhwgBCgCGGoiASAEKAIQIAQoAgwiB2siDEECdUHVAmxBAWtBACAMG0YEQCAEQQhqEBAgBCgCDCEHIAQoAhggBCgCHGohAQsgByABQdUCbiIMQQJ0aigCACABIAxB1QJsa0EMbGoiASAJNgIIIAEgBjYCBCABIAU2AgAgBCAEKAIcQQFqNgIcCyAIRQ0BIAQoAhwgBCgCGGoiASAEKAIQIAQoAgwiB2siBUECdUHVAmxBAWtBACAFG0YEQCAEQQhqEBAgBCgCDCEHIAQoAhggBCgCHGohAQsgByABQdUCbiIFQQJ0aigCACABIAVB1QJsa0EMbGoiASALNgIIIAEgBjYCBCABIAg2AgAgBCAEKAIcQQFqIgE2AhwMAgtBACEJIAhFDQADQCABBEAgCygCACERIA0oAgAhDyADKAJgIQcgAygCbCEUQQAhAQNAIAcgFCABQQJ0aiIMKAIAQQJ0akEANgIAAkAgAygCACAPIAwoAgBBAnQiBmooAgBrIgVFDQAgBiAHaiEGQSAgAygCNCIKayITIAVOBEAgAygCMCIOIAMoAihGBEAgBkEANgIADAILIAYgDigCACAKdEEgIAVrdjYCACADIAMoAjQgBWoiBTYCNCAFQSBHDQEgA0EANgI0IAMgDkEEajYCMAwBCyADKAIwIg5BBGoiFiADKAIoRgRAIAZBADYCAAwBCyAOKAIAIRkgAyAWNgIwIAMgBSATayITNgI0IAYgDigCBEEgIBNrdiAZIAp0QSAgBWt2cjYCAAsgByAMKAIAQQJ0IgVqIgYgBigCACAFIBFqKAIAcjYCACABQQFqIgEgAygCDEkNAAsLIBIgGBA5IAMgAygCCEEBajYCCCAJQQFqIgkgCEYNASADKAIMIQEMAAsACyAEKAIcIQELIAENAAsLIARBADYCHCAEKAIQIgEgBCgCDCIDa0ECdSIGQQNPBEADQCADKAIAEAggBCAEKAIMQQRqIgM2AgwgBCgCECIBIANrQQJ1IgZBAksNAAsLQaoBIQcCQAJAAkAgBkEBaw4CAQACC0HVAiEHCyAEIAc2AhgLAkAgASADRg0AA0AgAygCABAIIANBBGoiAyABRw0ACyAEKAIQIgEgBCgCDCIDRg0AIAQgASABIANrQQRrQQJ2QX9zQQJ0ajYCEAsgBCgCCCIBBEAgARAICyAEQSBqJAAMAQsMCgsLIBcQRwwFCyAVQQhqQQMQRCIXIQMgFUGYBWohEgJAIAEpAwggASkDECIbQgR8Uw0AIAMgASgCACAbp2ooAAAiBTYCACABIAEpAxAiG0IEfCIcNwMQIAVBIEsNACABKQMIIBtCCHxTDQAgAyABKAIAIBynaigAACIFNgIEIAEgASkDEEIEfDcDECAFRQ0AIANBADYCCCADQRBqIAEQDkUNACADQSBqIAEQD0UNACADQTRqIAEQD0UNACADQcgAaiABEA9FDQAgAygCBCEQQQAhBSMAQSBrIgQkACADKAIMIQEgBEEANgIQIARCADcDCAJAIAEEQCABQYCAgIAETw0KIAQgAUECdCIIEAkiBTYCCCAEIAUgCGoiBzYCECAFQQAgCBALGiAEIAc2AgwLIAMoAnQiCCgCACIJBEAgCCAJNgIEIAkQCCAIQQA2AgggCEIANwIAIAQoAgwhByAEKAIIIQUgAygCDCEBCyAIIAc2AgQgCCAFNgIAIAggBCgCEDYCCEEAIQUgBEEANgIQIARCADcDCAJAIAEEQCABQYCAgIAETw0BIAQgAUECdCIBEAkiBjYCCCAEIAEgBmoiBTYCECAGQQAgARALGiAEIAU2AgwLIAMoAoABIgEoAgAiCARAIAEgCDYCBCAIEAggAUEANgIIIAFCADcCACAEKAIIIQYgBCgCDCEFCyABIAU2AgQgASAGNgIAIAEgBCgCEDYCCCAEQgA3AxggBEIANwMQIARCADcDCCAEQQhqEBAgBCgCDCAEKAIYIAQoAhxqIgFB1QJuIgVBAnRqKAIAIAEgBUHVAmxrQQxsaiIBQgA3AgQgASAQNgIAIAQgBCgCHCIFQQFqIgE2AhwCQCABIAVJDQAgA0HcAGohGCADQRBqIREDQCAEKAIMIgcgBCgCGCIJIAFBAWsiDGoiBUHVAm4iCEECdGooAgAgBSAIQdUCbGtBDGxqIgUoAgghCyAFKAIEIQYgBSgCACEIIAQgDDYCHCAEKAIQIgUgB2siB0ECdUHVAmxBAWtBACAHGyABIAlqa0EBakGqBU8EQCAFQQRrKAIAEAggBCAEKAIQQQRrNgIQC0EAIQUgCCAQSw0BIAMoAnQhASALQQxsIgcgAygCgAFqIQxBACAGQQFqIAMoAgxBAWsgBkYbIgYgAygCDE8NASABIAdqIQkCQAJAAkACQAJAAkAgAygCACAGQQJ0IgogDCgCAGooAgBrIgFFBEAgCEUNBgNAIAkoAgAiASgCCCEKIAEoAgQhDiABKAIAIQ0CQCASKAIAIgcoAgQiASAHKAIIIgxJBEAgASAKNgIIIAEgDjYCBCABIA02AgAgByABQQxqNgIEDAELIAEgBygCACILa0EMbSIPQQFqIgZB1qrVqgFPDRUCf0EAIAYgDCALa0EMbSIMQQF0IhQgBiAUSxtB1arVqgEgDEGq1arVAEkbIgxFDQAaIAxB1qrVqgFPDRUgDEEMbBAJCyIUIA9BDGxqIgYgCjYCCCAGIA42AgQgBiANNgIAIAZBDGohCiABIAtHBEADQCAGQQxrIgYgAUEMayIBKAIANgIAIAYgASgCBDYCBCAGIAEoAgg2AgggASALRw0ACwsgByAUIAxBDGxqNgIIIAcgCjYCBCAHIAY2AgAgC0UNACALEAgLIAMgAygCCEEBajYCCCAIIAVBAWoiBUcNAAsMBgsgCEECTQRAIAMoAmgiByAGNgIAQQEhBSADKAIMIgFBAUsNAgwFCyADKAIIIAMoAgRLDQcgCSADKAJ0IgUgC0EBaiIOQQxsIgxqIg1HBH8gDSAJKAIAIAkoAgQQEiADKAJ0BSAFCyAMaigCACAKaiIFIAUoAgBBASABQQFrdGo2AgAgBEEANgIEIBEgCGdBH3MgBEEEahBzAn8gCEEBdiAEKAIEayIBIAggAWsiBUYEQCABDAELIAMoAlQiCCADKAJMRg0DIAgoAgAhCSADIAMoAlgiDUEBaiIPNgJYIAlBgICAgHggDXZxIQkCQCAPQSBGBEAgA0EANgJYIAMgCEEEajYCVCAJDQEMBQsgCUUNBAsgBQshCCABIQUMAwsACwNAIAcgBUECdGpBACAGQQFqIAYgAUEBa0YbIgY2AgAgBUEBaiIFIAMoAgwiAUkNAAsMAgsgASEICyADKAKAASIBIAdqIgcoAgAiCSAKaiIKIAooAgBBAWo2AgAgASAMaiAJIAcoAgQQEiAFBEAgBCgCHCAEKAIYaiIBIAQoAhAgBCgCDCIHayIJQQJ1QdUCbEEBa0EAIAkbRgRAIARBCGoQECAEKAIMIQcgBCgCGCAEKAIcaiEBCyAHIAFB1QJuIglBAnRqKAIAIAEgCUHVAmxrQQxsaiIBIAs2AgggASAGNgIEIAEgBTYCACAEIAQoAhxBAWo2AhwLIAhFDQEgBCgCHCAEKAIYaiIBIAQoAhAgBCgCDCIFayIHQQJ1QdUCbEEBa0EAIAcbRgRAIARBCGoQECAEKAIMIQUgBCgCGCAEKAIcaiEBCyAFIAFB1QJuIgdBAnRqKAIAIAEgB0HVAmxrQQxsaiIBIA42AgggASAGNgIEIAEgCDYCACAEIAQoAhxBAWo2AhwMAQtBACELIAhFDQADQCABBEAgCSgCACEPIAwoAgAhFCADKAJcIQcgAygCaCETQQAhAQNAIAcgEyABQQJ0aiIKKAIAQQJ0akEANgIAAkAgAygCACAUIAooAgBBAnQiBmooAgBrIgVFDQAgBiAHaiEGQSAgAygCMCIOayIWIAVOBEAgAygCLCINIAMoAiRGBEAgBkEANgIADAILIAYgDSgCACAOdEEgIAVrdjYCACADIAMoAjAgBWoiBTYCMCAFQSBHDQEgA0EANgIwIAMgDUEEajYCLAwBCyADKAIsIg1BBGoiGSADKAIkRgRAIAZBADYCAAwBCyANKAIAIRogAyAZNgIsIAMgBSAWayIWNgIwIAYgDSgCBEEgIBZrdiAaIA50QSAgBWt2cjYCAAsgByAKKAIAQQJ0IgVqIgYgBigCACAFIA9qKAIAcjYCACABQQFqIgEgAygCDEkNAAsLIBIgGBA5IAMgAygCCEEBajYCCCALQQFqIgsgCEYNASADKAIMIQEMAAsACyAEKAIcIgENAAsLIARBADYCHCAEKAIQIgEgBCgCDCIDa0ECdSIGQQNPBEADQCADKAIAEAggBCAEKAIMQQRqIgM2AgwgBCgCECIBIANrQQJ1IgZBAksNAAsLQaoBIQUCQAJAAkAgBkEBaw4CAQACC0HVAiEFCyAEIAU2AhgLAkAgASADRg0AA0AgAygCABAIIANBBGoiAyABRw0ACyAEKAIQIgEgBCgCDCIDRg0AIAQgASABIANrQQRrQQJ2QX9zQQJ0ajYCEAsgBCgCCCIBBEAgARAICyAEQSBqJAAMAQsMCQsLIBcQRQwECyAVQQhqQQMQRCIXIQMgFUGYBWohEgJAIAEpAwggASkDECIbQgR8Uw0AIAMgASgCACAbp2ooAAAiBTYCACABIAEpAxAiG0IEfCIcNwMQIAVBIEsNACABKQMIIBtCCHxTDQAgAyABKAIAIBynaigAACIFNgIEIAEgASkDEEIEfDcDECAFRQ0AIANBADYCCCADQRBqIAEQDkUNACADQSBqIAEQD0UNACADQTRqIAEQD0UNACADQcgAaiABEA9FDQAgAygCBCEQQQAhBSMAQSBrIgQkACADKAIMIQEgBEEANgIQIARCADcDCAJAIAEEQCABQYCAgIAETw0JIAQgAUECdCIIEAkiBzYCCCAEIAcgCGoiBTYCECAHQQAgCBALGiAEIAU2AgwLIAMoAnQiCCgCACIGBEAgCCAGNgIEIAYQCCAIQQA2AgggCEIANwIAIAQoAgwhBSAEKAIIIQcgAygCDCEBCyAIIAU2AgQgCCAHNgIAIAggBCgCEDYCCEEAIQcgBEEANgIQIARCADcDCEEAIQYCQCABBEAgAUGAgICABE8NASAEIAFBAnQiARAJIgY2AgggBCABIAZqIgc2AhAgBkEAIAEQCxogBCAHNgIMCyADKAKAASIBKAIAIgUEQCABIAU2AgQgBRAIIAFBADYCCCABQgA3AgAgBCgCDCEHIAQoAgghBgsgASAHNgIEIAEgBjYCACABIAQoAhA2AgggBEIANwMYIARCADcDECAEQgA3AwggBEEIahAQIAQoAgwgBCgCGCAEKAIcaiIBQdUCbiIFQQJ0aigCACABIAVB1QJsa0EMbGoiAUIANwIEIAEgEDYCACAEIAQoAhwiBUEBaiIBNgIcAkAgASAFSQ0AIANB3ABqIRggA0EQaiERA0AgBCgCDCIHIAQoAhgiCyABQQFrIgxqIgVB1QJuIghBAnRqKAIAIAUgCEHVAmxrQQxsaiIFKAIIIQkgBSgCBCEGIAUoAgAhCCAEIAw2AhwgBCgCECIFIAdrIgdBAnVB1QJsQQFrQQAgBxsgASALamtBAWpBqgVPBEAgBUEEaygCABAIIAQgBCgCEEEEazYCEAsgCCAQSw0BQQAhBUEAIAZBAWogAygCDCIBQQFrIAZGGyIGIAFPDQEgAygCdCIBIAlBDGwiB2ohCwJAAkACQAJAAkACQCADKAIAIAZBAnQiDCADKAKAASAHaiINKAIAaigCAGsiCkUEQCAIRQ0GA0AgCygCACIBKAIIIQogASgCBCEOIAEoAgAhDQJAIBIoAgAiBygCBCIBIAcoAggiDEkEQCABIAo2AgggASAONgIEIAEgDTYCACAHIAFBDGo2AgQMAQsgASAHKAIAIglrQQxtIg9BAWoiBkHWqtWqAU8NFAJ/QQAgBiAMIAlrQQxtIgxBAXQiFCAGIBRLG0HVqtWqASAMQarVqtUASRsiDEUNABogDEHWqtWqAU8NFCAMQQxsEAkLIhQgD0EMbGoiBiAKNgIIIAYgDjYCBCAGIA02AgAgBkEMaiEKIAEgCUcEQANAIAZBDGsiBiABQQxrIgEoAgA2AgAgBiABKAIENgIEIAYgASgCCDYCCCABIAlHDQALCyAHIBQgDEEMbGo2AgggByAKNgIEIAcgBjYCACAJRQ0AIAkQCAsgAyADKAIIQQFqNgIIIAggBUEBaiIFRw0ACwwGCyAIQQJNBEAgAygCaCIFIAY2AgBBASEHIAMoAgwiAUEBSw0CDAULIAMoAgggAygCBEsNByABIAdBDGoiBWogCygCACALKAIEEBIgAygCdCAFaigCACAMaiIBIAEoAgBBASAKQQFrdGo2AgAgBEEANgIEIBEgCGdBH3MgBEEEahBzIAlBAWohCwJ/IAhBAXYgBCgCBGsiASAIIAFrIgVGBEAgAQwBCyADKAJUIgggAygCTEYNAyAIKAIAIQogAyADKAJYIg5BAWoiDTYCWCAKQYCAgIB4IA52cSEKAkAgDUEgRgRAIANBADYCWCADIAhBBGo2AlQgCg0BDAULIApFDQQLIAULIQggASEFDAMLAAsDQCAFIAdBAnRqQQAgBkEBaiAGIAFBAWtGGyIGNgIAIAdBAWoiByADKAIMIgFJDQALDAILIAEhCAsgDCADKAKAASIBIAdqIgcoAgAiCmoiDCAMKAIAQQFqNgIAIAEgC0EMbGogCiAHKAIEEBIgBQRAIAQoAhwgBCgCGGoiASAEKAIQIAQoAgwiB2siDEECdUHVAmxBAWtBACAMG0YEQCAEQQhqEBAgBCgCDCEHIAQoAhggBCgCHGohAQsgByABQdUCbiIMQQJ0aigCACABIAxB1QJsa0EMbGoiASAJNgIIIAEgBjYCBCABIAU2AgAgBCAEKAIcQQFqNgIcCyAIRQ0BIAQoAhwgBCgCGGoiASAEKAIQIAQoAgwiB2siBUECdUHVAmxBAWtBACAFG0YEQCAEQQhqEBAgBCgCDCEHIAQoAhggBCgCHGohAQsgByABQdUCbiIFQQJ0aigCACABIAVB1QJsa0EMbGoiASALNgIIIAEgBjYCBCABIAg2AgAgBCAEKAIcQQFqNgIcDAELQQAhCSAIRQ0AA0AgAQRAIAsoAgAhDyANKAIAIRQgAygCXCEHIAMoAmghE0EAIQEDQCAHIBMgAUECdGoiDCgCAEECdGpBADYCAAJAIAMoAgAgFCAMKAIAQQJ0IgZqKAIAayIFRQ0AIAYgB2ohBkEgIAMoAjAiCmsiFiAFTgRAIAMoAiwiDiADKAIkRgRAIAZBADYCAAwCCyAGIA4oAgAgCnRBICAFa3Y2AgAgAyADKAIwIAVqIgU2AjAgBUEgRw0BIANBADYCMCADIA5BBGo2AiwMAQsgAygCLCIOQQRqIhkgAygCJEYEQCAGQQA2AgAMAQsgDigCACEaIAMgGTYCLCADIAUgFmsiFjYCMCAGIA4oAgRBICAWa3YgGiAKdEEgIAVrdnI2AgALIAcgDCgCAEECdCIFaiIGIAYoAgAgBSAPaigCAHI2AgAgAUEBaiIBIAMoAgxJDQALCyASIBgQOSADIAMoAghBAWo2AgggCUEBaiIJIAhGDQEgAygCDCEBDAALAAsgBCgCHCIBDQALCyAEQQA2AhwgBCgCECIBIAQoAgwiA2tBAnUiBkEDTwRAA0AgAygCABAIIAQgBCgCDEEEaiIDNgIMIAQoAhAiASADa0ECdSIGQQJLDQALC0GqASEHAkACQAJAIAZBAWsOAgEAAgtB1QIhBwsgBCAHNgIYCwJAIAEgA0YNAANAIAMoAgAQCCADQQRqIgMgAUcNAAsgBCgCECIBIAQoAgwiA0YNACAEIAEgASADa0EEa0ECdkF/c0ECdGo2AhALIAQoAggiAQRAIAEQCAsgBEEgaiQADAELDAgLCyAXEEUMAwsgFUEIakEDEC0iFyEFIBVBmAVqIRICQCABKQMIIAEpAxAiG0IEfFMNACAFIAEoAgAgG6dqKAAAIgM2AgAgASABKQMQIhtCBHwiHDcDECADQSBLDQAgASkDCCAbQgh8Uw0AIAUgASgCACAcp2ooAAAiAzYCBCABIAEpAxBCBHw3AxAgA0UNACAFQQA2AgggBUEQaiABEEJFDQAgBUGgBGogARAPRQ0AIAVBtARqIAEQD0UNACAFQcgEaiABEA9FDQAgBSgCBCEMQQAhAUEAIQgjAEEgayIEJAAgBSgCDCEDIARBADYCECAEQgA3AwgCQCADBEAgA0GAgICABE8NCCAEIANBAnQiBhAJIgE2AgggBCABIAZqIgg2AhAgAUEAIAYQCxogBCAINgIMCyAFKAL0BCIGKAIAIgcEQCAGIAc2AgQgBxAIIAZBADYCCCAGQgA3AgAgBSgCDCEDIAQoAgwhCCAEKAIIIQELIAYgCDYCBCAGIAE2AgAgBiAEKAIQNgIIQQAhASAEQQA2AhAgBEIANwMIQQAhBgJAIAMEQCADQYCAgIAETw0BIAQgA0ECdCIDEAkiBjYCCCAEIAMgBmoiATYCECAGQQAgAxALGiAEIAE2AgwLIAUoAoAFIgMoAgAiCARAIAMgCDYCBCAIEAggA0EANgIIIANCADcCACAEKAIIIQYgBCgCDCEBCyADIAE2AgQgAyAGNgIAIAMgBCgCEDYCCCAEQgA3AxggBEIANwMQIARCADcDCCAEQQhqEBAgBCgCDCAEKAIYIAQoAhxqIgFB1QJuIgNBAnRqKAIAIAEgA0HVAmxrQQxsaiIBQgA3AgQgASAMNgIAIAQgBCgCHCIBQQFqIgM2AhwCQCABIANLDQAgBUHcBGohGANAIAQoAgwiByAEKAIYIgsgA0EBayIQaiIBQdUCbiIIQQJ0aigCACABIAhB1QJsa0EMbGoiASgCCCEJIAEoAgQhBiABKAIAIQggBCAQNgIcIAQoAhAiASAHayIHQQJ1QdUCbEEBa0EAIAcbIAMgC2prQQFqQaoFTwRAIAFBBGsoAgAQCCAEIAQoAhBBBGs2AhALIAggDEsNASAFKAL0BCEBIAlBDGwiCyAFKAKABWohEEEAIAZBAWogBSgCDEEBayAGRhsiBiAFKAIMTw0BIAEgC2ohBwJAAkACQAJAAkACQCAFKAIAIAZBAnQiCiAQKAIAaigCAGsiAUUEQEEAIRAgCEUNBQNAIAcoAgAiASgCCCEKIAEoAgQhDiABKAIAIQ0CQCASKAIAIgEoAgQiAyABKAIIIgtJBEAgAyAKNgIIIAMgDjYCBCADIA02AgAgASADQQxqNgIEDAELIAMgASgCACIJa0EMbSIRQQFqIgZB1qrVqgFPDRMCf0EAIAYgCyAJa0EMbSILQQF0Ig8gBiAPSxtB1arVqgEgC0Gq1arVAEkbIgtFDQAaIAtB1qrVqgFPDRMgC0EMbBAJCyIPIBFBDGxqIgYgCjYCCCAGIA42AgQgBiANNgIAIAZBDGohCiADIAlHBEADQCAGQQxrIgYgA0EMayIDKAIANgIAIAYgAygCBDYCBCAGIAMoAgg2AgggAyAJRw0ACwsgASAPIAtBDGxqNgIIIAEgCjYCBCABIAY2AgAgCUUNACAJEAgLIAUgBSgCCEEBajYCCCAIIBBBAWoiEEcNAAsMBQsgCEECTQRAIAUoAugEIgkgBjYCAEEBIQEgBSgCDCIDQQFLDQIMBAsgBSgCCCAFKAIESw0HIAcgBSgC9AQiAyAJQQFqIg5BDGwiEGoiDUcEfyANIAcoAgAgBygCBBASIAUoAvQEBSADCyAQaigCACAKaiIDIAMoAgBBASABQQFrdGo2AgAgCGdBH3MiB0UEQEEAIQEMAwtBACEBQQAhAwNAIAUgA0EEdGpBEGoQFiABciEBIANBAWoiAyAHRg0DIAFBAXQhAQwACwALAAsDQCAJIAFBAnRqQQAgBkEBaiAGIANBAWtGGyIGNgIAIAFBAWoiASAFKAIMIgNJDQALDAELAkACQAJ/IAhBAXYgAWsiASAIIAFrIgNGBEAgAQwBCyAFKALUBCIIIAUoAswERg0BIAgoAgAhByAFIAUoAtgEIg1BAWoiETYC2AQgB0GAgICAeCANdnEhBwJAIBFBIEYEQCAFQQA2AtgEIAUgCEEEajYC1AQgBw0BDAMLIAdFDQILIAMLIQggASEDDAELIAEhCAsgBSgCgAUiASALaiIHKAIAIgsgCmoiCiAKKAIAQQFqNgIAIAEgEGogCyAHKAIEEBIgAwRAIAQoAhwgBCgCGGoiASAEKAIQIAQoAgwiB2siC0ECdUHVAmxBAWtBACALG0YEQCAEQQhqEBAgBCgCDCEHIAQoAhggBCgCHGohAQsgByABQdUCbiILQQJ0aigCACABIAtB1QJsa0EMbGoiASAJNgIIIAEgBjYCBCABIAM2AgAgBCAEKAIcQQFqNgIcCyAIRQ0BIAQoAhwgBCgCGGoiAyAEKAIQIAQoAgwiAWsiB0ECdUHVAmxBAWtBACAHG0YEQCAEQQhqEBAgBCgCGCAEKAIcaiEDIAQoAgwhAQsgASADQdUCbiIHQQJ0aigCACADIAdB1QJsa0EMbGoiASAONgIIIAEgBjYCBCABIAg2AgAgBCAEKAIcQQFqIgM2AhwMAgtBACELIAhFDQADQCADBEAgBygCACERIBAoAgAhDyAFKALcBCEJIAUoAugEIRRBACEDA0AgCSAUIANBAnRqIgooAgBBAnRqQQA2AgACQCAFKAIAIA8gCigCAEECdCIGaigCAGsiAUUNACAGIAlqIQZBICAFKAKwBCIOayITIAFOBEAgBSgCrAQiDSAFKAKkBEYEQCAGQQA2AgAMAgsgBiANKAIAIA50QSAgAWt2NgIAIAUgBSgCsAQgAWoiATYCsAQgAUEgRw0BIAVBADYCsAQgBSANQQRqNgKsBAwBCyAFKAKsBCINQQRqIhYgBSgCpARGBEAgBkEANgIADAELIA0oAgAhGSAFIBY2AqwEIAUgASATayITNgKwBCAGIA0oAgRBICATa3YgGSAOdEEgIAFrdnI2AgALIAkgCigCAEECdCIBaiIGIAYoAgAgASARaigCAHI2AgAgA0EBaiIDIAUoAgxJDQALCyASIBgQOSAFIAUoAghBAWo2AgggC0EBaiILIAhGDQEgBSgCDCEDDAALAAsgBCgCHCEDCyADDQALCyAEQQA2AhwgBCgCECIDIAQoAgwiAWtBAnUiBkEDTwRAA0AgASgCABAIIAQgBCgCDEEEaiIBNgIMIAQoAhAiAyABa0ECdSIGQQJLDQALC0GqASEIAkACQAJAIAZBAWsOAgEAAgtB1QIhCAsgBCAINgIYCwJAIAEgA0YNAANAIAEoAgAQCCABQQRqIgEgA0cNAAsgBCgCECIBIAQoAgwiA0YNACAEIAEgASADa0EEa0ECdkF/c0ECdGo2AhALIAQoAggiAQRAIAEQCAsgBEEgaiQADAELDAcLCyAXEC4MAgsgFUEIakEDEC0iFyEFIBVBmAVqIRICQCABKQMIIAEpAxAiG0IEfFMNACAFIAEoAgAgG6dqKAAAIgM2AgAgASABKQMQIhtCBHwiHDcDECADQSBLDQAgASkDCCAbQgh8Uw0AIAUgASgCACAcp2ooAAAiAzYCBCABIAEpAxBCBHw3AxAgA0UNACAFQQA2AgggBUEQaiABEEJFDQAgBUGgBGogARAPRQ0AIAVBtARqIAEQD0UNACAFQcgEaiABEA9FDQAgBSgCBCEQQQAhAUEAIQgjAEEgayIEJAAgBSgCDCEDIARBADYCECAEQgA3AwgCQCADBEAgA0GAgICABE8NByAEIANBAnQiBhAJIgE2AgggBCABIAZqIgg2AhAgAUEAIAYQCxogBCAINgIMCyAFKAL0BCIGKAIAIgcEQCAGIAc2AgQgBxAIIAZBADYCCCAGQgA3AgAgBSgCDCEDIAQoAgwhCCAEKAIIIQELIAYgCDYCBCAGIAE2AgAgBiAEKAIQNgIIQQAhASAEQQA2AhAgBEIANwMIQQAhBgJAIAMEQCADQYCAgIAETw0BIAQgA0ECdCIDEAkiBjYCCCAEIAMgBmoiATYCECAGQQAgAxALGiAEIAE2AgwLIAUoAoAFIgMoAgAiCARAIAMgCDYCBCAIEAggA0EANgIIIANCADcCACAEKAIIIQYgBCgCDCEBCyADIAE2AgQgAyAGNgIAIAMgBCgCEDYCCCAEQgA3AxggBEIANwMQIARCADcDCCAEQQhqEBAgBCgCDCAEKAIYIAQoAhxqIgFB1QJuIgNBAnRqKAIAIAEgA0HVAmxrQQxsaiIBQgA3AgQgASAQNgIAIAQgBCgCHCIBQQFqIgM2AhwCQCABIANLDQAgBUHcBGohGANAIAQoAgwiByAEKAIYIgsgA0EBayIMaiIBQdUCbiIIQQJ0aigCACABIAhB1QJsa0EMbGoiASgCCCEJIAEoAgQhBiABKAIAIQggBCAMNgIcIAQoAhAiASAHayIHQQJ1QdUCbEEBa0EAIAcbIAMgC2prQQFqQaoFTwRAIAFBBGsoAgAQCCAEIAQoAhBBBGs2AhALIAggEEsNAUEAIAZBAWogBSgCDCIBQQFrIAZGGyIGIAFPDQEgBSgC9AQiASAJQQxsIgdqIQsCQAJAAkACQAJAAkAgBSgCACAGQQJ0IgwgBSgCgAUgB2oiDSgCAGooAgBrIgNFBEBBACEHIAhFDQUDQCALKAIAIgEoAgghCiABKAIEIQ4gASgCACENAkAgEigCACIBKAIEIgMgASgCCCIMSQRAIAMgCjYCCCADIA42AgQgAyANNgIAIAEgA0EMajYCBAwBCyADIAEoAgAiCWtBDG0iEUEBaiIGQdaq1aoBTw0SAn9BACAGIAwgCWtBDG0iDEEBdCIPIAYgD0sbQdWq1aoBIAxBqtWq1QBJGyIMRQ0AGiAMQdaq1aoBTw0SIAxBDGwQCQsiDyARQQxsaiIGIAo2AgggBiAONgIEIAYgDTYCACAGQQxqIQogAyAJRwRAA0AgBkEMayIGIANBDGsiAygCADYCACAGIAMoAgQ2AgQgBiADKAIINgIIIAMgCUcNAAsLIAEgDyAMQQxsajYCCCABIAo2AgQgASAGNgIAIAlFDQAgCRAICyAFIAUoAghBAWo2AgggCCAHQQFqIgdHDQALDAULIAhBAk0EQCAFKALoBCIHIAY2AgBBASEBIAUoAgwiA0EBSw0CDAQLIAUoAgggBSgCBEsNByABIAdBDGoiCmogCygCACALKAIEEBIgBSgC9AQgCmooAgAgDGoiASABKAIAQQEgA0EBa3RqNgIAIAhnQR9zIgtFBEBBACEBDAMLQQAhAUEAIQMDQCAFIANBBHRqQRBqEBYgAXIhASADQQFqIgMgC0YNAyABQQF0IQEMAAsACwALA0AgByABQQJ0akEAIAZBAWogBiADQQFrRhsiBjYCACABQQFqIgEgBSgCDCIDSQ0ACwwBCyAJQQFqIQsCQAJAAn8gCEEBdiABayIBIAggAWsiA0YEQCABDAELIAUoAtQEIgggBSgCzARGDQEgCCgCACEKIAUgBSgC2AQiDkEBaiINNgLYBCAKQYCAgIB4IA52cSEKAkAgDUEgRgRAIAVBADYC2AQgBSAIQQRqNgLUBCAKDQEMAwsgCkUNAgsgAwshCCABIQMMAQsgASEICyAMIAUoAoAFIgEgB2oiBygCACIKaiIMIAwoAgBBAWo2AgAgASALQQxsaiAKIAcoAgQQEiADBEAgBCgCHCAEKAIYaiIBIAQoAhAgBCgCDCIHayIMQQJ1QdUCbEEBa0EAIAwbRgRAIARBCGoQECAEKAIMIQcgBCgCGCAEKAIcaiEBCyAHIAFB1QJuIgxBAnRqKAIAIAEgDEHVAmxrQQxsaiIBIAk2AgggASAGNgIEIAEgAzYCACAEIAQoAhxBAWo2AhwLIAhFDQEgBCgCHCAEKAIYaiIDIAQoAhAgBCgCDCIBayIHQQJ1QdUCbEEBa0EAIAcbRgRAIARBCGoQECAEKAIYIAQoAhxqIQMgBCgCDCEBCyABIANB1QJuIgdBAnRqKAIAIAMgB0HVAmxrQQxsaiIBIAs2AgggASAGNgIEIAEgCDYCACAEIAQoAhxBAWoiAzYCHAwCC0EAIQcgCEUNAANAIAMEQCALKAIAIREgDSgCACEPIAUoAtwEIQkgBSgC6AQhFEEAIQMDQCAJIBQgA0ECdGoiDCgCAEECdGpBADYCAAJAIAUoAgAgDyAMKAIAQQJ0IgZqKAIAayIBRQ0AIAYgCWohBkEgIAUoArAEIgprIhMgAU4EQCAFKAKsBCIOIAUoAqQERgRAIAZBADYCAAwCCyAGIA4oAgAgCnRBICABa3Y2AgAgBSAFKAKwBCABaiIBNgKwBCABQSBHDQEgBUEANgKwBCAFIA5BBGo2AqwEDAELIAUoAqwEIg5BBGoiFiAFKAKkBEYEQCAGQQA2AgAMAQsgDigCACEZIAUgFjYCrAQgBSABIBNrIhM2ArAEIAYgDigCBEEgIBNrdiAZIAp0QSAgAWt2cjYCAAsgCSAMKAIAQQJ0IgFqIgYgBigCACABIBFqKAIAcjYCACADQQFqIgMgBSgCDEkNAAsLIBIgGBA5IAUgBSgCCEEBajYCCCAHQQFqIgcgCEYNASAFKAIMIQMMAAsACyAEKAIcIQMLIAMNAAsLIARBADYCHCAEKAIQIgMgBCgCDCIFa0ECdSIGQQNPBEADQCAFKAIAEAggBCAEKAIMQQRqIgU2AgwgBCgCECIDIAVrQQJ1IgZBAksNAAsLQaoBIQECQAJAAkAgBkEBaw4CAQACC0HVAiEBCyAEIAE2AhgLAkAgAyAFRg0AA0AgBSgCABAIIAVBBGoiBSADRw0ACyAEKAIQIgEgBCgCDCIDRg0AIAQgASABIANrQQRrQQJ2QX9zQQJ0ajYCEAsgBCgCCCIBBEAgARAICyAEQSBqJAAMAQsMBgsLIBcQLgwBCyAVQQhqQQMQLSIXIQUgFUGYBWohEgJAIAEpAwggASkDECIbQgR8Uw0AIAUgASgCACAbp2ooAAAiAzYCACABIAEpAxAiG0IEfCIcNwMQIANBIEsNACABKQMIIBtCCHxTDQAgBSABKAIAIBynaigAACIDNgIEIAEgASkDEEIEfDcDECADRQ0AIAVBADYCCCAFQRBqIAEQQkUNACAFQaAEaiABEA9FDQAgBUG0BGogARAPRQ0AIAVByARqIAEQD0UNACAFKAIEIQxBACEBQQAhCCMAQSBrIgQkACAFKAIMIQMgBEEANgIQIARCADcDCAJAIAMEQCADQYCAgIAETw0GIAQgA0ECdCIGEAkiATYCCCAEIAEgBmoiCDYCECABQQAgBhALGiAEIAg2AgwLIAUoAvQEIgYoAgAiBwRAIAYgBzYCBCAHEAggBkEANgIIIAZCADcCACAFKAIMIQMgBCgCDCEIIAQoAgghAQsgBiAINgIEIAYgATYCACAGIAQoAhA2AghBACEBIARBADYCECAEQgA3AwhBACEGAkAgAwRAIANBgICAgARPDQEgBCADQQJ0IgMQCSIGNgIIIAQgAyAGaiIBNgIQIAZBACADEAsaIAQgATYCDAsgBSgCgAUiAygCACIIBEAgAyAINgIEIAgQCCADQQA2AgggA0IANwIAIAQoAgghBiAEKAIMIQELIAMgATYCBCADIAY2AgAgAyAEKAIQNgIIIARCADcDGCAEQgA3AxAgBEIANwMIIARBCGoQECAEKAIMIAQoAhggBCgCHGoiAUHVAm4iA0ECdGooAgAgASADQdUCbGtBDGxqIgFCADcCBCABIAw2AgAgBCAEKAIcIgFBAWoiAzYCHAJAIAEgA0sNACAFQdwEaiEYA0AgBCgCDCIGIAQoAhgiByADQQFrIgtqIgFB1QJuIghBAnRqKAIAIAEgCEHVAmxrQQxsaiIBKAIIIQkgASgCBBogASgCACEIIAQgCzYCHCAEKAIQIgEgBmsiBkECdUHVAmxBAWtBACAGGyADIAdqa0EBakGqBU8EQCABQQRrKAIAEAggBCAEKAIQQQRrNgIQCyAIIAxLDQEgBSgC9AQhASAFIAggCUEMbCILIAUoAoAFaiIQEMcBIgYgBSgCDE8NASABIAtqIQcCQAJAAkACQAJAAkAgBSgCACAGQQJ0IgogECgCAGooAgBrIgFFBEBBACEQIAhFDQUDQCAHKAIAIgEoAgghCiABKAIEIQ4gASgCACENAkAgEigCACIBKAIEIgMgASgCCCILSQRAIAMgCjYCCCADIA42AgQgAyANNgIAIAEgA0EMajYCBAwBCyADIAEoAgAiCWtBDG0iEUEBaiIGQdaq1aoBTw0RAn9BACAGIAsgCWtBDG0iC0EBdCIPIAYgD0sbQdWq1aoBIAtBqtWq1QBJGyILRQ0AGiALQdaq1aoBTw0RIAtBDGwQCQsiDyARQQxsaiIGIAo2AgggBiAONgIEIAYgDTYCACAGQQxqIQogAyAJRwRAA0AgBkEMayIGIANBDGsiAygCADYCACAGIAMoAgQ2AgQgBiADKAIINgIIIAMgCUcNAAsLIAEgDyALQQxsajYCCCABIAo2AgQgASAGNgIAIAlFDQAgCRAICyAFIAUoAghBAWo2AgggCCAQQQFqIhBHDQALDAULIAhBAk0EQCAFKALoBCIJIAY2AgBBASEBIAUoAgwiA0EBSw0CDAQLIAUoAgggBSgCBEsNByAHIAUoAvQEIgMgCUEBaiIOQQxsIhBqIg1HBH8gDSAHKAIAIAcoAgQQEiAFKAL0BAUgAwsgEGooAgAgCmoiAyADKAIAQQEgAUEBa3RqNgIAIAhnQR9zIgdFBEBBACEBDAMLQQAhAUEAIQMDQCAFIANBBHRqQRBqEBYgAXIhASADQQFqIgMgB0YNAyABQQF0IQEMAAsACwALA0AgCSABQQJ0akEAIAZBAWogBiADQQFrRhsiBjYCACABQQFqIgEgBSgCDCIDSQ0ACwwBCwJAAkACfyAIQQF2IAFrIgEgCCABayIDRgRAIAEMAQsgBSgC1AQiCCAFKALMBEYNASAIKAIAIQcgBSAFKALYBCINQQFqIhE2AtgEIAdBgICAgHggDXZxIQcCQCARQSBGBEAgBUEANgLYBCAFIAhBBGo2AtQEIAcNAQwDCyAHRQ0CCyADCyEIIAEhAwwBCyABIQgLIAUoAoAFIgEgC2oiBygCACILIApqIgogCigCAEEBajYCACABIBBqIAsgBygCBBASIAMEQCAEKAIcIAQoAhhqIgEgBCgCECAEKAIMIgdrIgtBAnVB1QJsQQFrQQAgCxtGBEAgBEEIahAQIAQoAgwhByAEKAIYIAQoAhxqIQELIAcgAUHVAm4iC0ECdGooAgAgASALQdUCbGtBDGxqIgEgCTYCCCABIAY2AgQgASADNgIAIAQgBCgCHEEBajYCHAsgCEUNASAEKAIcIAQoAhhqIgMgBCgCECAEKAIMIgFrIgdBAnVB1QJsQQFrQQAgBxtGBEAgBEEIahAQIAQoAhggBCgCHGohAyAEKAIMIQELIAEgA0HVAm4iB0ECdGooAgAgAyAHQdUCbGtBDGxqIgEgDjYCCCABIAY2AgQgASAINgIAIAQgBCgCHEEBaiIDNgIcDAILQQAhCyAIRQ0AA0AgAwRAIAcoAgAhESAQKAIAIQ8gBSgC3AQhCSAFKALoBCEUQQAhAwNAIAkgFCADQQJ0aiIKKAIAQQJ0akEANgIAAkAgBSgCACAPIAooAgBBAnQiBmooAgBrIgFFDQAgBiAJaiEGQSAgBSgCsAQiDmsiEyABTgRAIAUoAqwEIg0gBSgCpARGBEAgBkEANgIADAILIAYgDSgCACAOdEEgIAFrdjYCACAFIAUoArAEIAFqIgE2ArAEIAFBIEcNASAFQQA2ArAEIAUgDUEEajYCrAQMAQsgBSgCrAQiDUEEaiIWIAUoAqQERgRAIAZBADYCAAwBCyANKAIAIRkgBSAWNgKsBCAFIAEgE2siEzYCsAQgBiANKAIEQSAgE2t2IBkgDnRBICABa3ZyNgIACyAJIAooAgBBAnQiAWoiBiAGKAIAIAEgEWooAgByNgIAIANBAWoiAyAFKAIMSQ0ACwsgEiAYEDkgBSAFKAIIQQFqNgIIIAtBAWoiCyAIRg0BIAUoAgwhAwwACwALIAQoAhwhAwsgAw0ACwsgBEEANgIcIAQoAhAiAyAEKAIMIgFrQQJ1IgZBA08EQANAIAEoAgAQCCAEIAQoAgxBBGoiATYCDCAEKAIQIgMgAWtBAnUiBkECSw0ACwtBqgEhCAJAAkACQCAGQQFrDgIBAAILQdUCIQgLIAQgCDYCGAsCQCABIANGDQADQCABKAIAEAggAUEEaiIBIANHDQALIAQoAhAiASAEKAIMIgNGDQAgBCABIAEgA2tBBGtBAnZBf3NBAnRqNgIQCyAEKAIIIgEEQCABEAgLIARBIGokAAwBCwwFCwsgFxAuCyAAKAIMIAIoAgQgAigCAGtBDG1GIQYLIBVBoAVqJAAgBg8LQfnzABANAAsQDAAL2QMBBX8CQCABQT9NBEBBACEBIAAoAgwiAEECSQ0BIAIoAgAhAyAAQQFrIgFBA3EhAgJAIABBAmtBA0kEQEEAIQFBASEADAELIAFBfHEhBEEAIQFBASEAA0AgAEEDaiIFIABBAmoiBiAAQQFqIgcgACABIAMgAUECdGooAgAgAyAAQQJ0aigCAEsbIgEgAyABQQJ0aigCACADIAdBAnRqKAIASxsiASADIAFBAnRqKAIAIAMgBkECdGooAgBLGyIBIAMgAUECdGooAgAgAyAFQQJ0aigCAEsbIQEgAEEEaiEAIARBBGsiBA0ACwsgAkUNAQNAIAAgASADIAFBAnRqKAIAIAMgAEECdGooAgBLGyEBIABBAWohACACQQFrIgINAAsMAQtBICAAKALEBCIBayIDQQROBEAgACgCwAQiAiAAKAK4BEYEQEEADwsgAigCACEDIAAgAUEEaiIENgLEBCADIAF0QRx2IQEgBEEgRw0BIABBADYCxAQgACACQQRqNgLABCABDwsgACgCwAQiAkEEaiIEIAAoArgERgRAQQAPCyACKAIAIQUgACAENgLABCAAIAFBHGs2AsQEIAIoAgRBPCABayIAdiAFIAF0IAAgA2t2ciEBCyABC8kMAQd/AkAgAUEASA0AIAAoAgwiAiAAKAIIIgNrQQJ1IAFNDQAgAyABQQJ0aiIEKAIAIgUoAjwhByAFKAI4IQYCQCACIARBBGoiA0cEQANAIAMoAgAhCCADQQA2AgAgBCAINgIAIAUEQCAFEBgLIARBBGohBCACIANBBGoiA0cEQCAEKAIAIQUMAQsLIAAoAgwiAiAERg0BCwNAIAJBBGsiAigCACEDIAJBADYCACADBEAgAxAYCyACIARHDQALCyAAIAQ2AgwCQCAAKAIEIgVFDQAgB0EASA0AIAUoAhgiAiAFKAIcIgNGDQADQCAHIAIoAgAoAhhGBEACQCACQQRqIgQgBSgCHCIHRwRAA0AgBCgCACEIIARBADYCACACKAIAIQMgAiAINgIAIAMEQCADQQxqIAMoAhAQISADIAMoAgQQICADEAgLIAJBBGohAiAEQQRqIgQgB0cNAAsgBSgCHCIEIAJGDQELA0AgBEEEayIEKAIAIQMgBEEANgIAIAMEQCADQQxqIAMoAhAQISADIAMoAgQQICADEAgLIAIgBEcNAAsLIAUgAjYCHAwCCyACQQRqIgIgA0cNAAsLAkAgBkEESg0AAkAgACAGQQxsaiIEKAIUIgIgBCgCGCIDRg0AA0AgAigCACABRg0BIAJBBGoiAiADRw0ACwwBCyACIANGDQAgAyACQQRqIgVrIgMEQCACIAUgAxAjGgsgBCACIANqNgIYCwJAIAAoAhggACgCFCIEayICRQ0AIAIgAkEfdSIDaiADc0ECdiACQX8gAkF/ShsiAkEBIAJBAUgbbCIDQQEgA0EBSxsiBUEBcSEHQQAhAiADQQJPBEAgBUF+cSEDA0AgASAEIAJBAnQiBWoiBigCACIISARAIAYgCEEBazYCAAsgASAEIAVBBHJqIgUoAgAiBkgEQCAFIAZBAWs2AgALIAJBAmohAiADQQJrIgMNAAsLIAdFDQAgBCACQQJ0aiICKAIAIgMgAUwNACACIANBAWs2AgALAkAgACgCJCAAKAIgIgRrIgJFDQAgAiACQR91IgNqIANzQQJ2IAJBfyACQX9KGyICQQEgAkEBSBtsIgNBASADQQFLGyIFQQFxIQdBACECIANBAk8EQCAFQX5xIQMDQCABIAQgAkECdCIFaiIGKAIAIghIBEAgBiAIQQFrNgIACyABIAQgBUEEcmoiBSgCACIGSARAIAUgBkEBazYCAAsgAkECaiECIANBAmsiAw0ACwsgB0UNACAEIAJBAnRqIgIoAgAiAyABTA0AIAIgA0EBazYCAAsCQCAAKAIwIAAoAiwiBGsiAkUNACACIAJBH3UiA2ogA3NBAnYgAkF/IAJBf0obIgJBASACQQFIG2wiA0EBIANBAUsbIgVBAXEhB0EAIQIgA0ECTwRAIAVBfnEhAwNAIAEgBCACQQJ0IgVqIgYoAgAiCEgEQCAGIAhBAWs2AgALIAEgBCAFQQRyaiIFKAIAIgZIBEAgBSAGQQFrNgIACyACQQJqIQIgA0ECayIDDQALCyAHRQ0AIAQgAkECdGoiAigCACIDIAFMDQAgAiADQQFrNgIACwJAIAAoAjwgACgCOCIEayICRQ0AIAIgAkEfdSIDaiADc0ECdiACQX8gAkF/ShsiAkEBIAJBAUgbbCIDQQEgA0EBSxsiBUEBcSEHQQAhAiADQQJPBEAgBUF+cSEDA0AgASAEIAJBAnQiBWoiBigCACIISARAIAYgCEEBazYCAAsgASAEIAVBBHJqIgUoAgAiBkgEQCAFIAZBAWs2AgALIAJBAmohAiADQQJrIgMNAAsLIAdFDQAgBCACQQJ0aiICKAIAIgMgAUwNACACIANBAWs2AgALIAAoAkggACgCRCIEayIARQ0AIAAgAEEfdSICaiACc0ECdiAAQX8gAEF/ShsiAEEBIABBAUgbbCIAQQEgAEEBSxsiA0EBcSEFQQAhAiAAQQJPBEAgA0F+cSEDA0AgASAEIAJBAnQiAGoiBygCACIGSARAIAcgBkEBazYCAAsgASAEIABBBHJqIgAoAgAiB0gEQCAAIAdBAWs2AgALIAJBAmohAiADQQJrIgMNAAsLIAVFDQAgASAEIAJBAnRqIgAoAgAiAk4NACAAIAJBAWs2AgALC5QGAQh/AkAgACgCDCIFIAAoAggiB2tBAnUiAyABSg0AIAMgAUEBaiIESQRAIAQgA2siBCAAKAIQIgYgACgCDCIDa0ECdU0EQCAAIAQEfyADQQAgBEECdCIDEAsgA2oFIAMLNgIMDAILAkACQAJAIAMgACgCCCIHa0ECdSIIIARqIgVBgICAgARJBEACfyAFIAYgB2siBkEBdSIKIAUgCksbQf////8DIAZBAnVB/////wFJGyIGBEAgBkGAgICABE8NAyAGQQJ0EAkhCQsgCSAIQQJ0aiIFC0EAIARBAnQiBBALIgogBGohCCAJIAZBAnRqIQQgAyAHRg0CA0AgA0EEayIDKAIAIQYgA0EANgIAIAVBBGsiBSAGNgIAIAMgB0cNAAsgACAENgIQIAAoAgwhBCAAIAg2AgwgACgCCCEDIAAgBTYCCCADIARGDQMDQCAEQQRrIgQoAgAhBSAEQQA2AgAgBQRAIAUQGAsgAyAERw0ACwwDCxAMAAtB+PIAEA0ACyAAIAQ2AhAgACAINgIMIAAgCjYCCAsgAwRAIAMQCAsMAQsgAyAETQ0AIAcgBEECdGoiAyAFRwRAA0AgBUEEayIFKAIAIQQgBUEANgIAIAQEQCAEEBgLIAMgBUcNAAsLIAAgAzYCDAsCQAJAAkAgAigCACgCOCIDQQRKDQAgACADQQxsaiIDIgkoAhgiBSADKAIcRwRAIAUgATYCACAJIAVBBGo2AhgMAQsgBSADKAIUIgVrIgRBAnUiCEEBaiIHQYCAgIAETw0BAn9BACAHIARBAXUiBiAGIAdJG0H/////AyAIQf////8BSRsiB0UNABogB0GAgICABE8NAyAHQQJ0EAkLIgYgCEECdGoiCCABNgIAIARBAU4EQCAGIAUgBBAKGgsgAyAGNgIUIAkgCEEEajYCGCADIAYgB0ECdGo2AhwgBUUNACAFEAgLIAIoAgAiAyABNgI8IAAoAgghACACQQA2AgAgACABQQJ0aiIBKAIAIQAgASADNgIAIAAEQCAAEBgLDwsQDAALQfjyABANAAt2AQJ/AkAgACgCDCAAKAIIIgNrIgAEQCAAIABBH3UiAmogAnNBAnYgAEF/IABBf0obIgBBASAAQQFIG2wiAEEBIABBAUsbIQJBACEAA0AgAyAAQQJ0aigCACgCPCABRg0CIABBAWoiACACRw0ACwtBfyEACyAACzwBAX9BfyECAkAgAUF/Rg0AIAFBBEoNACAAIAFBDGxqIgAoAhggACgCFCIAa0EBSA0AIAAoAgAhAgsgAgsaACAAQcjyADYCACAAQQRqQQBB0AAQCxogAAtQAQF/IAAgARA9IgEgAEEEakYEQEEADwsgASgCHCIAIAEoAiAiA0cEQCACIAMgAGsQggEgAhCBASABKAIcIgIgASgCICACaxAKGgsgACADRwvLAgEKfyMAQRBrIgMkAAJAIAAoAhgiBiAAKAIcIgxHBEADQCADQQA2AgggA0IANwMAIAYoAgAgASADEM0BIQQgAy0ACyIAQRh0QRh1IQhBAyEJAkACQAJAIARFDQBBACEJIAMoAgQgACAIQQBIGyIKIAIoAgQgAi0ACyIEIARBGHRBGHUiBEEASBtHDQAgAigCACACIARBAEgbIQUgAygCACEHAkAgCEEASCIERQRAIApFDQEgAyEEIAUtAAAgB0H/AXFHDQIDQCAAQQFrIgBFDQIgBS0AASEHIAVBAWohBSAHIARBAWoiBC0AAEYNAAsMAgsgCkUNACAHIAMgBBsgBSAKEBcNAgsgBigCACELQQEhCQsgCEF/Sg0BCyADKAIAEAgLAkAgCQ4EAAMDAAMLIAZBBGoiBiAMRw0ACwtBACELCyADQRBqJAAgCwuLHQIPfwJ+IwBBMGsiByQAQQgQCSICIAE2AgQgAkEANgIAIAcgAkEIaiIBNgIoIAcgATYCJCAHIAI2AiACfwJAAkACQANAIAFBCGsiASgCBCEJIAEoAgAhCCAHIAE2AiQgCARAIAdBADYCGCAHQgA3AxBBASEBAkAgACgCACICKQMIIAIpAxAiEVcNACACKAIAIBGnai0AACEEIAIgEUIBfDcDECAHQRBqIAQQggEgBARAIAAoAgAhAiAHQRBqEIEBIQMgAikDCCACKQMQIhEgBK0iEnxTDQEgAyACKAIAIBGnaiAEEAoaIAIgAikDECASfDcDEAtBGBAJIglCADcCBCAJQRBqIgFCADcCACAJIAlBBGo2AgAgCSABNgIMIAcgCTYCCCMAQSBrIgUkAAJAIAhBDGoiAyAHQRBqIgIQPSILIAhBEGoiEEcNACAFIAI2AhACQAJAIAMoAgQiAQRAIAIoAgAgAiACLQALIgRBGHRBGHVBAEgiCBshBiACKAIEIAQgCBshCCADQQRqIQIDQAJAAkACQAJAAkACQCABKAIUIAEtABsiBCAEQRh0QRh1QQBIIg4bIgQgCCAEIAhJIgwbIgoEQCAGIAFBEGoiDSgCACANIA4bIg4gChAXIg1FBEAgBCAISw0CDAMLIA1Bf0oNAgwBCyAEIAhNDQILIAEoAgAiBA0EDAcLIA4gBiAKEBciBA0BCyAMDQEMBgsgBEF/Sg0FCyABQQRqIQIgASgCBCIERQ0EIAIhAQsgASECIAQhAQwACwALIANBBGohAQsgASECCyAFIAIoAgAiBAR/QQAFQSAQCSIEQRBqIAUoAhAQERogBCABNgIIIARCADcCACAEQQA2AhwgAiAENgIAAn8gBCADKAIAKAIAIgFFDQAaIAMgATYCACACKAIACyEBIAMoAgQgARBcIAMgAygCCEEBajYCCEEBCzoAHCAFIAQ2AhggBSgCGCECIAcoAgghBCAHQQA2AgggAigCHCEBIAIgBDYCHCABRQ0AIAFBDGogASgCEBAhIAEgASgCBBAgIAEQCAsgBUEgaiQAIAcoAgghASAHQQA2AgggAQRAIAFBDGogASgCEBAhIAEgASgCBBAgIAEQCAsgCyAQRyEBCyAHLAAbQX9MBEAgBygCEBAICyABDQQLIAlFDQMgB0EANgIQQQEgB0EQaiAAKAIAEElFDQMCQCAHKAIQIg5FDQBBASEBA0ACf0EAIRAjAEEgayIKJAAgCkEANgIYIApCADcDEAJAAkAgACgCACICKQMIIAIpAxAiEVcNACACKAIAIBGnai0AACEEIAIgEUIBfDcDECAKQRBqIAQQggEgBARAIAAoAgAhAiAKQRBqEIEBIQMgAikDCCACKQMQIhEgBK0iEnxTDQEgAyACKAIAIBGnaiAEEAoaIAIgAikDECASfDcDEAsgCkEANgIMQQEgCkEMaiAAKAIAEElFDQAgCigCDCICRQ0AIApBADYCCCAKQgA3AwAgAkF/TA0BIAogAhAJIgQ2AgAgCiACIARqIgM2AgggBEEAIAIQCyEFIAogAzYCBCAAKAIAIgMpAwggAykDECIRIAKtIhJ8WSIQBEAgBSADKAIAIBGnaiACEAoaIAMgAykDECASfDcDECMAQTBrIgYkACAJIApBEGoiDBA9IgIgCUEEakcEQAJAIAIoAgQiBUUEQCACKAIIIgMoAgAgAkYNASACQQhqIQUDQCAFKAIAIgRBCGohBSAEIAQoAggiAygCAEcNAAsMAQsDQCAFIgMoAgAiBQ0ACwsgAiAJKAIARgRAIAkgAzYCAAsgCSAJKAIIQQFrNgIIIAkoAgQhBQJ/AkAgAiIIIgMoAgAiBARAIAgoAgQiAkUNAQNAIAIiAygCACICDQALCyADKAIEIgQNAEEAIQRBAQwBCyAEIAMoAgg2AghBAAshDQJAIAMgAygCCCILKAIAIgJGBEAgCyAENgIAIAMgBUYEQEEAIQIgBCEFDAILIAsoAgQhAgwBCyALIAQ2AgQLIAMtAAwhDyADIAhHBEAgAyAIKAIIIgs2AgggCyAIKAIIKAIAIAhHQQJ0aiADNgIAIAMgCCgCACILNgIAIAsgAzYCCCADIAgoAgQiCzYCBCALBEAgCyADNgIICyADIAgtAAw6AAwgAyAFIAUgCEYbIQULAkAgD0UNACAFRQ0AIA0EQANAIAItAAwhBAJAIAIgAigCCCIDKAIARwRAAkACQAJAAkACfyAERQRAIAJBAToADCADQQA6AAwgAyADKAIEIgQoAgAiCzYCBCALBEAgCyADNgIICyAEIAMoAgg2AgggAygCCCILIAsoAgAgA0dBAnRqIAQ2AgAgBCADNgIAIAMgBDYCCCACIAUgBSACKAIAIgJGGyEFIAIoAgQhAgsgAigCACIDCwRAIAMtAAxFDQELIAIoAgQiBARAIAQtAAxFDQILIAJBADoADAJAIAUgAigCCCICRgRAIAUhAgwBCyACLQAMDQYLIAJBAToADAwICyACKAIEIgRFDQELIAQtAAwNACACIQMMAQsgA0EBOgAMIAJBADoADCACIAMoAgQiBDYCACAEBEAgBCACNgIICyADIAIoAgg2AgggAigCCCIEIAQoAgAgAkdBAnRqIAM2AgAgAyACNgIEIAIgAzYCCCACIQQLIAMgAygCCCICLQAMOgAMIAJBAToADCAEQQE6AAwgAiACKAIEIgQoAgAiAzYCBCADBEAgAyACNgIICyAEIAIoAgg2AgggAigCCCIDIAMoAgAgAkdBAnRqIAQ2AgAgBCACNgIAIAIgBDYCCAwECwJAIAQEQCACIQQMAQsgAkEBOgAMIANBADoADCADIAIoAgQiBDYCACAEBEAgBCADNgIICyACIAMoAgg2AggCQCADIAMoAggiCygCAEYEQCALIAI2AgAgAygCACEEDAELIAsgAjYCBAsgAiADNgIEIAMgAjYCCCACIAUgAyAFRhshBQsCQAJAIAQoAgAiA0UNACADLQAMDQAgBCECDAELAkAgBCgCBCICBEAgAi0ADEUNAQsgBEEAOgAMIAQoAggiAi0ADEEAIAIgBUcbDQIgAkEBOgAMDAULIAMEQCADLQAMRQRAIAQhAgwCCyAEKAIEIQILIAJBAToADCAEQQA6AAwgBCACKAIAIgM2AgQgAwRAIAMgBDYCCAsgAiAEKAIINgIIIAQoAggiAyADKAIAIARHQQJ0aiACNgIAIAIgBDYCACAEIAI2AgggBCEDCyACIAIoAggiAi0ADDoADCACQQE6AAwgA0EBOgAMIAIgAigCACIEKAIEIgM2AgAgAwRAIAMgAjYCCAsgBCACKAIINgIIIAIoAggiAyADKAIAIAJHQQJ0aiAENgIAIAQgAjYCBCACIAQ2AggMAwsgAigCCCIEIAQoAgAgAkZBAnRqKAIAIQIMAAsACyAEQQE6AAwLIAgoAhwiAgRAIAggAjYCICACEAgLIAgsABtBf0wEQCAIKAIQEAgLIAgQCAsgBkEANgIIIAZCADcDACAGIAooAgQgCigCAGsiAhA2IAYoAgAgCigCACACEAoaIAZBEGogDBARIQQgBkEANgIkIAZCADcCHCAGQRxqIAYoAgQgBigCAGsQNiAGKAIcIAYoAgAiAiAGKAIEIAJrEAoaAkACQCAJKAIEIgIEQCAEKAIAIAQgBC0ACyIDQRh0QRh1QQBIIgUbIQggBCgCBCADIAUbIQUgCUEEaiEEA0ACQAJAAkACQAJAAkAgAigCFCACLQAbIgMgA0EYdEEYdUEASCIMGyIDIAUgAyAFSSINGyILBEAgCCACQRBqIg8oAgAgDyAMGyIMIAsQFyIPRQRAIAMgBUsNAgwDCyAPQX9KDQIMAQsgAyAFTQ0CCyACKAIAIgMNBAwHCyAMIAggCxAXIgMNAQsgDQ0BDAYLIANBf0oNBQsgAkEEaiEEIAIoAgQiA0UNBCAEIQILIAIhBCADIQIMAAsACyAJQQRqIQILIAIhBAsgBiAEKAIAIgMEf0EABUEoEAkiAyAGKAIYNgIYIAMgBikCEDcCECAGQgA3AhAgBkEANgIYIANBADYCJCADQRxqIgVCADcCACAFIAYoAiAgBigCHGsQNiAFKAIAIAYoAhwiBSAGKAIgIAVrEAoaIAMgAjYCCCADQgA3AgAgBCADNgIAAn8gAyAJKAIAKAIAIgJFDQAaIAkgAjYCACAEKAIACyECIAkoAgQgAhBcIAkgCSgCCEEBajYCCEEBCzoALCAGIAM2AiggBigCHCICBEAgBiACNgIgIAIQCAsgBiwAG0F/TARAIAYoAhAQCAsgBigCACICBEAgBiACNgIEIAIQCAsgBkEwaiQAIAooAgAiBEUNAQsgCiAENgIEIAQQCAsgCiwAG0F/TARAIAooAhAQCAsgCkEgaiQAIBAMAQsQDAALRQ0FIAEgDkYNASABQQFqIQEMAAsACyAHQQA2AgRBASAHQQRqIAAoAgAQSUUNAyAHKAIEIgWtIAAoAgAiASkDCCABKQMQfVUNA0EAIQEgBQRAA0ACQCAHKAIkIgIgBygCKCIDSQRAIAJBADYCBCACIAk2AgAgByACQQhqNgIkDAELIAIgBygCICICayIIQQN1IgZBAWoiBEGAgICAAk8NBAJ/QQAgBCADIAJrIgNBAnUiCiAEIApLG0H/////ASADQQN1Qf////8ASRsiBEUNABogBEGAgICAAk8NBiAEQQN0EAkLIgMgBkEDdGoiBkEANgIEIAYgCTYCACAIQQFOBEAgAyACIAgQChoLIAcgAyAEQQN0ajYCKCAHIAZBCGo2AiQgByADNgIgIAJFDQAgAhAICyABQQFqIgEgBUcNAAsLIAcoAiAiCSAHKAIkIgFHDQALQQEMAwsQDAALQbTxABANAAsgBygCICEJQQALIQAgCQRAIAcgCTYCJCAJEAgLIAdBMGokACAAC/cCAQR/QX8hAgJ/An8gAUF/RgRAQX8hBEEBDAELIAAoAgQoAgwgAUECdGooAgAhBCABQQFqIgMgAUECayADQQNwGyIDQQBOBEAgACgCACgCYCADQQNuIgJBDGxqIAMgAkEDbGtBAnRqKAIAIQILAn8gBEF/RgRAIAJBf0YhA0EBDAELAn8gAkF/RkF/QQIgBEEDcBsgBGoiA0F/TA0AGiACIAAoAgAoAmAgA0EDbiIFQQxsaiADIAVBA2xrQQJ0aigCAEYLIQNBAAshBUF/IANFDQEaQX8hAgJAQX9BAiABQQNwGyABaiIBQQBOBEAgACgCACgCYCABQQNuIgJBDGxqIAEgAkEDbGtBAnRqKAIAIQIgBUUNASACQX9GDAILIAVFDQBBAQwBCyACQX9GIARBAWoiASAEQQJrIAFBA3AbIgFBf0wNABogAiAAKAIAKAJgIAFBA24iAEEMbGogASAAQQNsa0ECdGooAgBGCyEBIARBfyABGwsLXQAgAEIANwIAIABCADcCHCAAQQE6ABggAEIANwIQIABCADcCCCAAQgA3AiQgAEIANwIsIABCADcCNCAAQgA3AjwgAEIANwJIIABCADcCUCAAQgA3AlggACAANgJEC9kEAQh/IAEgACgCCCIEIAAoAgQiA2tBAnVNBEACQCABRQ0AIAFBAnQhBSADIQIgAUECdEEEayIEQQJ2QQFqQQdxIgEEQANAIAJB6O4AKAIANgIAIAJBBGohAiABQQFrIgENAAsLIAMgBWohAyAEQRxJDQADQCACQejuACgCADYCACACQejuACgCADYCBCACQejuACgCADYCCCACQejuACgCADYCDCACQejuACgCADYCECACQejuACgCADYCFCACQejuACgCADYCGCACQejuACgCADYCHCACQSBqIgIgA0cNAAsLIAAgAzYCBA8LAkAgAyAAKAIAIgVrIgdBAnUiAyABaiIC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ACgCDBEBAAsHACAAKAIAC9gEAgR/AX4gACgCQEUEQEEgEAkiBCICQgA3AxAgAkEANgIIIAJCADcCACACQgA3AxggACgCQCEDIAAgBDYCQCADBEAgAygCACICBEAgAyACNgIEIAIQCAsgAxAIIAAoAkAhAgsgACACNgIAIAAgAikDEDcDCCACKQMYIQYgAEIANwMwIABCADcDKCAAIAY3AxALAkACQAJ/IAAgAS0AGDoAGCAAIAEoAhw2AhwgACABLQAgOgAgIAAgASkDKDcDKCAAIAEpAzA3AzAgACABKAI4NgI4IAAgASkDCDcDCCAAIAEpAxA3AxAgACABKAI8NgI8IAEoAgAiAkUEQCAAQQA2AgBBAQwBC0EAIAAoAgAiA0UNABogAyACKAIAIgMgAigCBCADa60Q4gEaQQELRQ0AIAAgAS0AVDoAVCAAIAEoAlA2AlAgACABRwRAIABBxABqIAEoAkQgASgCSBBLCyABKAJYIgIEQEEoEAkhASACKAIAIQMgAUEANgIQIAFCADcCCCABIAM2AgAgAigCDCACKAIIayIEBEAgBEF/TA0DIAEgBBAJIgM2AgggASADNgIMIAEgAyAEajYCECABIAIoAgwgAigCCCIFayIEQQFOBH8gAyAFIAQQCiAEagUgAws2AgwLIAEgAikDIDcDICABIAIpAxg3AxggACgCWCECIAAgATYCWCACRQ0BIAIoAggiAARAIAIgADYCDCAAEAgLIAIQCA8LIAAoAlghASAAQQA2AlggAUUNACABKAIIIgAEQCABIAA2AgwgABAICyABEAgLDwsQDAAL7wEBBn8gASAAKAIIIgQgACgCBCICa0EBdU0EQCAAIAEEfyACQQAgAUEBdCIAEAsgAGoFIAILNgIEDwsCQCACIAAoAgAiBWsiBkEBdSIHIAFqIgNBf0oEQEEAIQICfyADIAQgBWsiBCADIARLG0H/////ByAEQQF1Qf////8DSRsiAwRAIANBf0wNAyADQQF0EAkhAgsgAiAHQQF0agtBACABQQF0IgEQCyABaiEBIAZBAU4EQCACIAUgBhAKGgsgACACIANBAXRqNgIIIAAgATYCBCAAIAI2AgAgBQRAIAUQCAsPCxAMAAtBoO4AEA0AC9YBAQV/AkAgACABED0iASAAQQRqRg0AIAFBHGohACABLAAnQX9MBEAg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IAJBnuoAKQAANwAIIAJBluoAKQAANwAAIABBfzYCACAAQQRqIAgQERogCCwAC0F/Sg0BIAgoAgAQCAwBCyABKAIEIQMgCEEANgIYIAMoAgQhBCADIAI2AgQgBARAIAQQkgELIABCADcCACAAQgA3AggLIAgoAhghAiAIQQA2AhggAgRAIAIQkgELIAhBIGokACAAKAIADQEgCSwAC0F/Sg0AIAkoAgAQCAsgASABKAIAKAIMEQAARQRAIAVBMBAJIgE2AgAgBUKhgICAgIaAgIB/NwIEIAFBADoAISABQbLrAC0AADoAICABQarrACkAADcAGCABQaLrACkAADcAECABQZrrACkAADcACCABQZLrACkAADcAACAAQX82AgAgCSAFEBEaIAUsAAtBf0oNASAFKAIAEAgMAQsgASABKAIAKAIUEQAARQRAIAVBtOsAEHAhASAAQX82AgAgCSABEBEaIAEsAAtBf0oNASABKAIAEAgMAQsgASABKAIAKAIYEQAARQRAIAVB1OsAEHAhASAAQX82AgAgCSABEBEaIAEsAAtBf0oNASABKAIAEAgMAQsgAEIANwIAIABCADcCCAsgBUEgaiQAC8cCAQd/IwBBEGsiBSQAQcAAEAkhA0EMEAkiAiAAKAIEKAJQNgIIIAJB9OgANgIAIAJBADYCBCAFIAI2AgggAyAFQQhqEK0BIQYCQCABQQBOBEAgAEEIaiEHAkAgACgCDCICIAAoAggiCGtBAnUiAyABSg0AIAFBAWohBCABIANPBEAgByAEIANrEKIBDAELIAMgBE0NACAIIARBAnRqIgQgAkcEQANAIAJBBGsiAigCACEDIAJBADYCACADBEAgAyADKAIAKAIEEQIACyACIARHDQALCyAAIAQ2AgwLIAcoAgAgAUECdGoiAigCACEAIAIgBjYCACAARQ0BIAAgACgCACgCBBECAAwBCyAGIAMoAgAoAgQRAgALIAUoAgghACAFQQA2AgggAARAIAAgACgCACgCBBECAAsgBUEQaiQAIAFBf3NBH3YLsgUBB38CQAJAIAEEQCABQYCAgIAETw0CIAFBAnQQCSECIAAoAgAhAyAAIAI2AgAgAwRAIAMQCAsgACABNgIEIAFBASABQQFLGyIDQQNxIQVBACECIANBAWtBA08EQCADQXxxIQQDQCACQQJ0IgMgACgC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IgEgASgCACIBQQFqNgIAQQJBASABQQFIGyECCyAAKAJUIAJOCwRAIAUhASAAKAIYIQUMAQsLAkAgACACQQxsaiIBIggoAjQiAyABKAI4RwRAIAMgBTYCACAIIANBBGo2AjQMAQsgAyABKAIwIgNrIgRBAnUiCUEBaiIGQYCAgIAETw0GAn9BACAGIARBAXUiByAGIAdLG0H/////AyAJQf////8BSRsiBkUNABogBkGAgICABE8NCSAGQQJ0EAkLIgcgCUECdGoiCSAFNgIAIARBAU4EQCAHIAMgBBAKGgsgASAHNgIwIAggCUEEajYCNCABIAcgBkECdGo2AjggA0UNACADEAgLIAAoAlQiAyACTA0BIAAgAjYCVCACIQMMAQsgACgCVCEDCyADQQNIDQALC0EBDwsQDAALEAwACxAMAAtBvN8AEA0AC8oFAQV/IABBsNoANgIAIABB6AFqIgIoAsQBIgEEQCACIAE2AsgBIAEQCAsgAigCuAEiBARAAn8gBCAEIAIoArwBIgFGDQAaA0AgAUEMayIDKAIAIgUEQCABQQhrIAU2AgAgBRAICyADIgEgBEcNAAsgAigCuAELIQEgAiAENgK8ASABEAgLIAIoApwBIgEEQCACIAE2AqABIAEQCAsgAigCiAEhAyACQQA2AogBIAMEQCADQQRrIgIoAgAiAQRAIAMgAUEEdGohAQNAIAFBEGsiASADRw0ACwsgAhAICyAAKALYASIDBEACfyADIAMgACgC3AEiAUYNABoDQCABQQxrKAIAIgIEQCABQQhrIAI2AgAgAhAICyABQRxrKAIAIgIEQCABQRhrIAI2AgAgAhAICyABQShrKAIAIgIEQCABQSRrIAI2AgAgAhAICyABQYwBaxBOIAFBkAFrIgIhASACIANHDQALIAAoAtgBCyEBIAAgAzYC3AEgARAICyAAKALEASIBBEAgACABNgLIASABEAgLIAAoArgBIgEEQCAAIAE2ArwBIAEQCAsgACgCrAEiAQRAIAAgATYCsAEgARAICyAAKAKgASIBBEAgACABNgKkASABEAgLIAAoApABIgEEQANAIAEoAgAhAyABEAggAyIBDQALCyAAKAKIASEBIABBADYCiAEgAQRAIAEQCAsgACgCeCIBBEAgARAICyAAKAJsIgEEQCABEAgLIAAoAmAiAQRAIAEQCAsgACgCSCIBBEAgACABNgJMIAEQCAsgACgCPCIBBEAgARAICyAAKAIwIgEEQCAAIAE2AjQgARAICyAAKAIkIgEEQCAAIAE2AiggARAICyAAKAIYIgEEQCAAIAE2AhwgARAICyAAKAIMIgEEQCAAIAE2AhAgARAICyAAKAIIIQEgAEEANgIIIAEEQCABECoLIAAL0gQBBH8gAEGA2gA2AgAgACgChAMiAQRAIAAgATYCiAMgARAICyAAKALwAiEEIABBADYC8AIgBARAIARBBGsiAygCACIBBEAgBCABQQR0aiECA0AgAkEQayICIARHDQALCyADEAgLIAAoAtgBIgMEQAJ/IAMgAyAAKALcASICRg0AGgNAIAJBDGsoAgAiAQRAIAJBCGsgATYCACABEAgLIAJBHGsoAgAiAQRAIAJBGGsgATYCACABEAgLIAJBKGsoAgAiAQRAIAJBJGsgATYCACABEAgLIAJBjAFrEE4gAkGQAWsiASECIAEgA0cNAAsgACgC2AELIQEgACADNgLcASABEAgLIAAoAsQBIgEEQCAAIAE2AsgBIAEQCAsgACgCuAEiAQRAIAAgATYCvAEgARAICyAAKAKsASIBBEAgACABNgKwASABEAgLIAAoAqABIgEEQCAAIAE2AqQBIAEQCAsgACgCkAEiAgRAA0AgAigCACEBIAIQCCABIgINAAsLIAAoAogBIQEgAEEANgKIASABBEAgARAICyAAKAJ4IgEEQCABEAgLIAAoAmwiAQRAIAEQCAsgACgCYCIBBEAgARAICyAAKAJIIgEEQCAAIAE2AkwgARAICyAAKAI8IgEEQCABEAgLIAAoAjAiAQRAIAAgATYCNCABEAgLIAAoAiQiAQRAIAAgATYCKCABEAgLIAAoAhgiAQRAIAAgATYCHCABEAgLIAAoAgwiAQRAIAAgATYCECABEAgLIAAoAgghASAAQQA2AgggAQRAIAEQKgsgAAu7BAEEfyAAQczZADYCACAAKALwAiEEIABBADYC8AIgBARAIARBBGsiAygCACIBBEAgBCABQQR0aiECA0AgAkEQayICIARHDQALCyADEAgLIAAoAtgBIgMEQAJ/IAMgAyAAKALcASICRg0AGgNAIAJBDGsoAgAiAQRAIAJBCGsgATYCACABEAgLIAJBHGsoAgAiAQRAIAJBGGsgATYCACABEAgLIAJBKGsoAgAiAQRAIAJBJGsgATYCACABEAgLIAJBjAFrEE4gAkGQAWsiASECIAEgA0cNAAsgACgC2AELIQEgACADNgLcASABEAgLIAAoAsQBIgEEQCAAIAE2AsgBIAEQCAsgACgCuAEiAQRAIAAgATYCvAEgARAICyAAKAKsASIBBEAgACABNgKwASABEAgLIAAoAqABIgEEQCAAIAE2AqQBIAEQCAsgACgCkAEiAgRAA0AgAigCACEBIAIQCCABIgINAAsLIAAoAogBIQEgAEEANgKIASABBEAgARAICyAAKAJ4IgEEQCABEAgLIAAoAmwiAQRAIAEQCAsgACgCYCIBBEAgARAICyAAKAJIIgEEQCAAIAE2AkwgARAICyAAKAI8IgEEQCABEAgLIAAoAjAiAQRAIAAgATYCNCABEAgLIAAoAiQiAQRAIAAgATYCKCABEAgLIAAoAhgiAQRAIAAgATYCHCABEAgLIAAoAgwiAQRAIAAgATYCECABEAgLIAAoAgghASAAQQA2AgggAQRAIAEQKgsgAAvhAQEFf0EBIQUCQCAAKAKMASICQQFIDQBBfyACQQR0IgFBBHIgAkH/////AHEgAkcbEAkiAyACNgIAIANBBGoiAyABaiECIAMhAQNAIAFCADcCACABQgA3AAUgAUEQaiIBIAJHDQALIAAoAogBIQQgACADNgKIASAEBEAgBEEEayICKAIAIgMEQCAEIANBBHRqIQEDQCABQRBrIgEgBEcNAAsLIAIQCAtBACEBIAAoAowBQQBMDQADQCAAKAKIASABQQR0aiAAEA4iBUUNASABQQFqIgEgACgCjAFIDQALCyAFC7UDAgF/A34jAEEQayICJAAgACAAKQMANwMoIAAgACkDIDcDSCAAQUBrIAApAxg3AwAgACAAKQMQNwM4IAAgACkDCDcDMAJ/AkAgAEEoakEBIAJBCGoQTARAIAAgACkDKDcDACAAIAApA0g3AyAgACAAKQNANwMYIAAgACkDOCIDNwMQIAAgACkDMCIENwMIIAIpAwgiBSAEIAN9WA0BC0EADAELIAAgAyAFfDcDEAJAIAAvASZBgQRNBEAgACAAKQMANwNgIAAgACkDIDcDgAEgACAAKQMYNwN4IAAgACkDEDcDcCAAIAApAwg3A2gCQCAAQeAAakEBIAJBCGoQTARA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CHZyQf//A3EhCSMAQSBrIggkACABKAIEKAIIIAZBAnRqKAIAIQQgASABKAIAKAIIEQAAIQUCQAJAIAJBAWtBBUsNACAFQQFHDQAgASABKAIAKAIkEQAAIgtBACABIAYgASgCACgCLBEBACIFG0UEQCAHQQA2AgAMAgsgASAGIAEoAgAoAigRAQAiBgRAIAEoAiwhASAIIAY2AgwgCCABNgIIIAggBTYCFCAIIAVBDGo2AhAgCEEIaiEFQQAhAQJAAkACQAJAAkACQAJAAkAgAkEBaw4GAAEDAgQFBwtBPBAJIgEgBDYCBCABQZAYNgIAIAMpAgghDCADKQIQIQ0gAykCACEOIAFBADYCKCABQgA3AiAgASANNwIYIAEgDDcCECABIA43AgggAygCHCADKAIYIgZrIgIEQCACQX9MDQYgASACEAkiBDYCICABIAQ2AiQgASAEIAJBAnVBAnRqNgIoIAEgBCAGIAIQCiACajYCJAsgASAFKQIANwIsIAEgBSkCCDcCNCABQcwSNgIADAYLQTwQCSIBIAQ2AgQgAUGQGDYCACADKQIIIQwgAykCECENIAMpAgAhDiABQQA2AiggAUIANwIgIAEgDTcCGCABIAw3AhAgASAONwIIIAMoAhwgAygCGCIGayICBEAgAkF/TA0FIAEgAhAJIgQ2AiAgASAENgIkIAEgBCACQQJ1QQJ0ajYCKCABIAQgBiACEAogAmo2AiQLIAEgBSkCADcCLCABIAUpAgg3AjQgAUHIGDYCAAwFC0HwABAJIgEgBDYCBCABQZAYNgIAIAMpAgghDCADKQIQIQ0gAykCACEOIAFBADYCKCABQgA3AiAgASANNwIYIAEgDDcCECABIA43AgggAygCHCADKAIYIgZrIgIEQCACQX9MDQQgASACEAkiBDYCICABIAQ2AiQgASAEIAJBAnVBAnRqNgIoIAEgBCAGIAIQCiACajYCJAsgASAFKQIANwIsIAEgBSkCCDcCNCABQgA3AjwgAUG0GjYCACABQgA3AkQgAUIANwJMIAFCADcCVCABQgA3AlwgAUIANwJkIAFBADYCbAwEC0HcABAJIgEgBDYCBCABQZAYNgIAIAMpAgghDCADKQIQIQ0gAykCACEOIAFBADYCKCABQgA3AiAgASANNwIYIAEgDDcCECABIA43AgggAygCHCADKAIYIgZrIgIEQCACQX9MDQMgASACEAkiBDYCICABIAQ2AiQgASAEIAJBAnVBAnRqNgIoIAEgBCAGIAIQCiACajYCJAsgASAFKQIANwIsIAEgBSkCCDcCNCABQgA3AjwgAUGsHDYCACABQgA3AkQgAUIANwJMIAFBADYCVCABIAk2AlgMAwtB6AAQCSIBIAQ2AgQgAUGQGDYCACADKQIIIQwgAykCECENIAMpAgAhDiABQQA2AiggAUIANwIgIAEgDTcCGCABIAw3AhAgASAONwIIIAMoAhwgAygCGCIGayICBEAgAkF/TA0CIAEgAhAJIgQ2AiAgASAENgIkIAEgBCACQQJ1QQJ0ajYCKCABIAQgBiACEAogAmo2AiQLIAEgBSkCADcCLCAFKQIIIQwgAUEANgJUIAFCADcCTCABQgA3AjwgAUGQHjYCACABIAw3AjQgASAFKQIANwJYIAEgBSkCCDcCYAwCCwJ/QYABEAkiASAENgIEIAFBkBg2AgAgAykCCCEMIAMpAhAhDSADKQIAIQ4gAUEANgIoIAFCADcCICABIA03AhggASAMNwIQIAEgDjcCCAJAIAMoAhwgAygCGGsiBARAIARBf0wNASABIAQQCSICNgIgIAEgAjYCJCABIAIgBEECdUECdGo2AiggASADKAIcIAMoAhgiBmsiBEEBTgR/IAIgBiAEEAogBGoFIAILNgIkCyABQdgXNgIAIAEgBSkCADcCLCABIAUpAgg3AjQgAUFAa0IANwIAIAFB8CQ2AjwgAUH8HzYCACABIAUpAgA3AkggASAFKQIINwJQIAFCgICA/HM3AmggAUJ/NwJgIAFCgYCAgHA3AlggAUHoITYCPCABQgA3AnAgAUIANwB1IAEMAQsQDAALIQEMAQsQDAALIAcgATYCACAHKAIARQ0BDAILIAEoAiwhASAIIAs2AgwgCCABNgIIIAggBTYCFCAIIAVBDGo2AhAgCEEIaiEFQQAhAQJAAkACQAJAAkACQAJAAkAgAkEBaw4GAAEDAgQFBwtBPBAJIgEgBDYCBCABQZAYNgIAIAMpAgghDCADKQIQIQ0gAykCACEOIAFBADYCKCABQgA3AiAgASANNwIYIAEgDDcCECABIA43AgggAygCHCADKAIYIgZrIgIEQCACQX9MDQYgASACEAkiBDYCICABIAQ2AiQgASAEIAJBAnVBAnRqNgIoIAEgBCAGIAIQCiACajYCJAsgASAFKQIANwIsIAEgBSkCCDcCNCABQYwlNgIADAYLQTwQCSIBIAQ2AgQgAUGQGDYCACADKQIIIQwgAykCECENIAMpAgAhDiABQQA2AiggAUIANwIgIAEgDTcCGCABIAw3AhAgASAONwIIIAMoAhwgAygCGCIGayICBEAgAkF/TA0FIAEgAhAJIgQ2AiAgASAENgIkIAEgBCACQQJ1QQJ0ajYCKCABIAQgBiACEAogAmo2AiQLIAEgBSkCADcCLCABIAUpAgg3AjQgAUG0KDYCAAwFC0HwABAJIgEgBDYCBCABQZAYNgIAIAMpAgghDCADKQIQIQ0gAykCACEOIAFBADYCKCABQgA3AiAgASANNwIYIAEgDDcCECABIA43AgggAygCHCADKAIYIgZrIgIEQCACQX9MDQQgASACEAkiBDYCICABIAQ2AiQgASAEIAJBAnVBAnRqNgIoIAEgBCAGIAIQCiACajYCJAsgASAFKQIANwIsIAEgBSkCCDcCNCABQgA3AjwgAUGUKjYCACABQgA3AkQgAUIANwJMIAFCADcCVCABQgA3AlwgAUIANwJkIAFBADYCbAwEC0HcABAJIgEgBDYCBCABQZAYNgIAIAMpAgghDCADKQIQIQ0gAykCACEOIAFBADYCKCABQgA3AiAgASANNwIYIAEgDDcCECABIA43AgggAygCHCADKAIYIgZrIgIEQCACQX9MDQMgASACEAkiBDYCICABIAQ2AiQgASAEIAJBAnVBAnRqNgIoIAEgBCAGIAIQCiACajYCJAsgASAFKQIANwIsIAEgBSkCCDcCNCABQgA3AjwgAUGALDYCACABQgA3AkQgAUIANwJMIAFBADYCVCABIAk2AlgMAwtB6AAQCSIBIAQ2AgQgAUGQGDYCACADKQIIIQwgAykCECENIAMpAgAhDiABQQA2AiggAUIANwIgIAEgDTcCGCABIAw3AhAgASAONwIIIAMoAhwgAygCGCIGayICBEAgAkF/TA0CIAEgAhAJIgQ2AiAgASAENgIkIAEgBCACQQJ1QQJ0ajYCKCABIAQgBiACEAogAmo2AiQLIAEgBSkCADcCLCAFKQIIIQwgAUEANgJUIAFCADcCTCABQgA3AjwgAUHYLTYCACABIAw3AjQgASAFKQIANwJYIAEgBSkCCDcCYAwCCwJ/QYABEAkiASAENgIEIAFBkBg2AgAgAykCCCEMIAMpAhAhDSADKQIAIQ4gAUEANgIoIAFCADcCICABIA03AhggASAMNwIQIAEgDjcCCAJAIAMoAhwgAygCGGsiBARAIARBf0wNASABIAQQCSICNgIgIAEgAjYCJCABIAIgBEECdUECdGo2AiggASADKAIcIAMoAhgiBmsiBEEBTgR/IAIgBiAEEAogBGoFIAILNgIkCyABQfwnNgIAIAEgBSkCADcCLCABIAUpAgg3AjQgAUFAa0IANwIAIAFBgDQ2AjwgAUG4LzYCACABIAUpAgA3AkggASAFKQIINwJQIAFCgICA/HM3AmggAUJ/NwJgIAFCgYCAgHA3AlggAUGUMTYCPCABQgA3AnAgAUIANwB1IAEMAQsQDAALIQEMAQsQDAALIAcgATYCACAHKAIADQELIAdBADYCAAsgCEEgaiQAIAcoAgANAyAHQQA2AgALQSwQCSIFIAo2AgQgBUGQGDYCACADKQIIIQwgAykCECENIAMpAgAhDiAFQQA2AiggBUIANwIgIAUgDTcCGCAFIAw3AhAgBSAONwIIIAMoAhwgAygCGCIDayIBBEAgAUF/TA0CIAUgARAJIgI2AiAgBSACNgIkIAUgAiABQQJ1QQJ0ajYCKCAFIAIgAyABEAogAWo2AiQLIAVBnDQ2AgALIAcgBTYCAAwBCxAMAAsgBygCICIBBEAgByABNgIkIAEQCAsgACAHKAIANgIACyAHQTBqJAALyQICBH8DfiMAQRBrIgQkAAJAIAIpAwgiCSACKQMQIgdXDQAgAigCACIFIAenaiwAACEDIAIgB0IBfCIINwMQAkAgA0F+Rg0AIAggCVkNASAFIAinaiwAACEFIAIgB0ICfDcDECAFQQFqQf8BcUEESw0BIARBCGogACADIAUgACgCACgCKBEJACAEKAIIIQUgBEEANgIIIAAoAhQhAyAAIAU2AhQgA0UNACADIAMoAgAoAgQRAgAgBCgCCCEDIARBADYCCCADRQ0AIAMgAygCACgCBBECAAsgACgCFCIDBEAgACADIAAoAgAoAhwRAQBFDQELIAAgASACIAAoAgAoAiQRAwBFDQACQCAAKAIEIgJFDQAgAi0AJEEBSw0AIAAgASgCBCABKAIAa0ECdSAAKAIAKAIwEQEARQ0BC0EBIQYLIARBEGokACAGCzkBAX8CfyAAKAIEIgIEQEEBIAItACRBAkkNARoLIAAgASgCBCABKAIAa0ECdSAAKAIAKAIwEQEACwtEAQF/An9BACAAKAIUIAAoAhAiAmtBAnUgAUwNABpBACACIAFBAnRqKAIAIgFBAEgNABogACgCJCABQQJ0aigCABBBCwvUAQEDfyAAQYAQNgIAIAAoAjwhASAAQQA2AjwgAQRAIAEgASgCACgCBBECAAsgACgCMCIBBEAgACABNgI0IAEQCAsgACgCJCIBBEACfyABIAEgACgCKCICRg0AGgNAIAJBBGsiAigCACEDIAJBADYCACADBEAgAyADKAIAKAIEEQIACyABIAJHDQALIAAoAiQLIQIgACABNgIoIAIQCAsgAEHQCjYCACAAKAIQIgEEQCAAIAE2AhQgARAICyAAKAIEIgEEQCAAIAE2AgggARAICyAAEAgL0gEBA38gAEGAEDYCACAAKAI8IQEgAEEANgI8IAEEQCABIAEoAgAoAgQRAgALIAAoAjAiAQRAIAAgATYCNCABEAgLIAAoAiQiAQRAAn8gASABIAAoAigiAkYNABoDQCACQQRrIgIoAgAhAyACQQA2AgAgAwRAIAMgAygCACgCBBECAAsgASACRw0ACyAAKAIkCyECIAAgATYCKCACEAgLIABB0Ao2AgAgACgCECIBBEAgACABNgIUIAEQCAsgACgCBCIBBEAgACABNgIIIAEQCAsgAAuyAgACQAJAAkACQAJAIAIOBAABAgMEC0EUEAkiASICQv////8PNwIMIAJCADcCBCACQdwONgIAIAAgATYCAA8LIAACf0EYEAkiAEL/////DzcCDCAAQgA3AgQgAEHcDjYCACAAQQA2AhQgAEHYETYCACAACzYCAA8LIAACf0EwEAkiACIBQv////8PNwIMIAFCADcCBCABQdwONgIAIAFBADYCFCABQdgRNgIAIABCADcCICAAQX82AhwgAEH0CDYCGCAAQfDUADYCACAAQgA3AiggAAs2AgAPCyAAAn9BIBAJIgAiAUL/////DzcCDCABQgA3AgQgAUHcDjYCACABQQA2AhQgAUHYETYCACAAQX82AhwgAEGICDYCGCAAQbw1NgIAIAALNgIADwsgAEEANgIAC8IEARB/IwBBEGsiBSQAQQEh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IAEpAxBCAFUNACABIAEoAgQgAkEPaiACQRBqEGELIAJBEGokACAAQX9HCwQAQgALGwAgACABKAIIIAUQKQRAIAEgAiADIAQQvQELCzgAIAAgASgCCCAFECkEQCABIAIgAyAEEL0BDwsgACgCCCIAIAEgAiADIAQgBSAAKAIAKAIUEQwAC6cBACAAIAEoAgggBBApBEACQCABKAIEIAJHDQAgASgCHEEBRg0AIAEgAzYCHAsPCwJAIAAgASgCACAEEClFDQACQCACIAEoAhBHBEAgASgCFCACRw0BCyADQQFHDQEgAUEBNgIgDwsgASACNgIUIAEgAzYCICABIAEoAihBAWo2AigCQCABKAIkQQFHDQAgASgCGEECRw0AIAFBAToANgsgAUEENgIsCwuIAgAgACABKAIIIAQQKQRAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLDwsCQCAAIAEoAgAgBBApBEACQCACIAEoAhBHBEAgASgCFCACRw0BCyADQQFHDQIgAUEBNgIgDwsgASADNgIgAkAgASgCLEEERg0AIAFBADsBNCAAKAIIIgAgASACIAJBASAEIAAoAgAoAhQRDAAgAS0ANQRAIAFBAzYCLCABLQA0RQ0BDAMLIAFBBDYCLAsgASACNgIUIAEgASgCKEEBajYCKCABKAIkQQFHDQEgASgCGEECRw0BIAFBAToANg8LIAAoAggiACABIAIgAyAEIAAoAgAoAhgRCwALC64MAg5/AX4jAEHABWsiBSQAQQEhCgJAAkACQAJAIAEvASZBgwRJDQBBACEKIAEpAxAiECABKQMIWQ0AIAEoAgAgEKdqLQAAIQ4gASAQQgF8NwMQIAAgACgCACgCHBEAACgCBCgCUCENIAAgACgCACgCGBEAACECIAVBADYCuAUgBUIANwOwBSACBEAgAkHNmbPmAE8NAiAFIAJBFGwiAhAJIgM2ArAFIAUgAiADajYCuAUgBSADQQAgAkEUa0EUbkEUbEEUaiICEAsgAmo2ArQFCwJAIAAgACgCACgCGBEAAEEBTgRAA0AgACALIAAoAgAoAhQRAQAhAiAAIAAoAgAoAhwRAAAoAgQoAgggAkECdGooAgAiAyANEDwaIANBAToAVCADIAMoAkQ2AkggAygCHCICQQlLDQICQAJAAkBBASACdCIEQSpxRQRA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AgAoAgQRAgALIAEgAkcNAAsgACgCCAshAiAAIAE2AgwgAhAICyAACxQAIAAoAjAiACAAKAIAKAIcEQAACxQAIAAoAjAiACAAKAIAKAIYEQAAC5ALAgJ/AX4gACgCICIBKQMIIAEpAxAiA1UEfyABKAIAIAOnai0AACECIAEgA0IBfDcDECAAKAIwIQEgAEEANgIwIAEEQCABIAEoAgAoAgQRAgALAkACQAJAAkACQCACDgMAAQIDC0GAAxAJIgFBzNkANgIAIAFBBGpBAEHQABALGiABQgA3AmAgAUF/NgJcIAFCfzcCVCABQgA3AmggAUIANwJwIAFCADcCeCABQgA3AoABIAFCADcCiAEgAUIANwKQASABQgA3ApwBIAFBgICA/AM2ApgBIAFCADcCpAEgAUIANwKsASABQgA3ArQBIAFCADcCvAEgAUIANwLEASABQgA3AswBIAFC/////w83AtQBIAFCADcC3AEgAUHoAWoiAkEAOwEmIAJBADYCACACQgA3AwggAkIANwMQIAJCADcDGCACQgA3AB0gAUGQAmoiAkEAOwEmIAJBADYCACACQgA3AwggAkIANwMQIAJCADcDGCACQgA3AB0gAUG4AmoiAkIANwIAIAJCADcABSABQcgCaiICQQA7ASYgAkEANgIAIAJCADcDCCACQgA3AxAgAkIANwMYIAJCADcAHSABQQA2AvgCIAFCADcC8AIgACgCMCECIAAgATYCMCACRQ0DIAIgAigCACgCBBECAAwCC0GoAxAJIgFBgNoANgIAIAFBBGpBAEHQABALGiABQgA3AmAgAUF/NgJcIAFCfzcCVCABQgA3AmggAUIANwJwIAFCADcCeCABQgA3AoABIAFCADcCiAEgAUIANwKQASABQgA3ApwBIAFBgICA/AM2ApgBIAFCADcCpAEgAUIANwKsASABQgA3ArQBIAFCADcCvAEgAUIANwLEASABQgA3AswBIAFC/////w83AtQBIAFCADcC3AEgAUHoAWoiAkEAOwEmIAJBADYCACACQgA3AwggAkIANwMQIAJCADcDGCACQgA3AB0gAUGQAmoiAkEAOwEmIAJBADYCACACQgA3AwggAkIANwMQIAJCADcDGCACQgA3AB0gAUG4AmoiAkIANwIAIAJCADcABSABQcgCaiICQQA7ASYgAkEANgIAIAJCADcDCCACQgA3AxAgAkIANwMYIAJCADcAHSABQgA3AogDIAFCADcCgAMgAUIANwL4AiABQgA3AvACIAFBkANqIgJCADcCACACQgA3AAUgAUJ/NwOgAyAAKAIwIQIgACABNgIwIAJFDQIgAiACKAIAKAIEEQIADAELQbgDEAkiAUGw2gA2AgAgAUEEakEAQdAAEAsaIAFCADcCYCABQX82AlwgAUJ/NwJUIAFCADcCaCABQgA3AnAgAUIANwJ4IAFCADcCgAEgAUIANwKIASABQgA3ApABIAFCADcCnAEgAUGAgID8AzYCmAEgAUIANwKkASABQgA3AqwBIAFCADcCtAEgAUIANwK8ASABQgA3AsQBIAFCADcCzAEgAUL/////DzcC1AEgAUIANwLcASABQegBaiICQQA7ASYgAkEANgIAIAJCADcDCCACQgA3AxAgAkIANwMYIAJCADcAHSABQZACaiICQQA7ASYgAkEANgIAIAJCADcDCCACQgA3AxAgAkIANwMYIAJCADcAHSABQbgCaiICQgA3AgAgAkIANwAFIAFByAJqIgJBADsBJiACQQA2AgAgAkIANwMIIAJCADcDECACQgA3AxggAkIANwAdIAFCADcCiAMgAUIANwKAAyABQgA3AvgCIAFCADcC8AIgAUIANwKgAyABQoKAgIDwADcDmAMgAUJ/NwOQAyABQgA3AqgDIAFCADcCsAMgACgCMCECIAAgATYCMCACRQ0BIAIgAigCACgCBBECAAsgACgCMCIBDQBBAA8LIAEgACABKAIAKAIIEQEABUEACwsWACAAKAIwIgAgASAAKAIAKAIUEQEACyMBAX8gAEH0CDYCACAAKAIIIgEEQCAAIAE2AgwgARAICyAAC4EBAQN/IABBtOkANgIAIAAoAhQiAQRAIAAgATYCGCABEAgLIAAoAggiAQRAAn8gASABIAAoAgwiAkYNABoDQCACQQRrIgIoAgAhAyACQQA2AgAgAwRAIAMgAygCACgCBBECAAsgASACRw0ACyAAKAIICyECIAAgATYCDCACEAgLIAALGgAgACgCLARAIAAgACgCACgCMBEAAA8LQQALkQECA38BfiMAQRBrIgIkAAJAIAAoAgQiA0F/Rg0AIAEpAxBCAFUNACABIAEoAgQgACgCCCAAKAIMEGEgASkDEEIBWQ0AIAEgASgC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IHN1cHBvcnRlZCBzaXplAE41ZHJhY28xOEF0dHJpYnV0ZVRyYW5zZm9ybUUAAAAAaEAAACAFAAAAAAAAzAUAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAjAAAAJAAAAE41ZHJhY28xN0F0dHJpYnV0ZXNEZWNvZGVyRQBONWRyYWNvMjZBdHRyaWJ1dGVzRGVjb2RlckludGVyZmFjZUUAAAAAaEAAAJwFAACQQAAAgAUAAMQFAABhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAAAAAADQBgAAJQAAACYAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAJwAAACgAAAApAAAAS2RUcmVlQXR0cmlidXRlc0RlY29kZXI6IGNvbXByZXNzaW9uIGxldmVsICVpIG5vdCBzdXBwb3J0ZWQuCgBza2lwX2F0dHJpYnV0ZV90cmFuc2Zvcm0ATjVkcmFjbzIzS2RUcmVlQXR0cmlidXRlc0RlY29kZXJFAAAAAJBAAACrBgAAzAUAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUATWV0aG9kIG5vdCBzdXBwb3J0ZWQuIAoAVmVyc2lvbiBub3Qgc3VwcG9ydGVkLiAKAAAAAAAAAACoBwAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADEAAAAyAAAATjVkcmFjbzI2U2VxdWVudGlhbEF0dHJpYnV0ZURlY29kZXJFAAAAAGhAAACABwAA/////2FsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAAIAIAAAzAAAANAAAABsAAAA1AAAANgAAAB4AAAAfAAAAIAAAADcAAAA4AAAAOQAAADoAAAA7AAAAc2tpcF9hdHRyaWJ1dGVfdHJhbnNmb3JtAE41ZHJhY28zN1NlcXVlbnRpYWxBdHRyaWJ1dGVEZWNvZGVyc0NvbnRyb2xsZXJFAAAAAJBAAABNCAAAzAUAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAADgJAAA8AAAAPQAAAD4AAAAtAAAALgAAAC8AAAA/AAAAMQAAAEAAAABBAAAAQgAAAEMAAABEAAAATjVkcmFjbzMzU2VxdWVudGlhbEludGVnZXJBdHRyaWJ1dGVEZWNvZGVyRQCQQAAADAkAAKgHAAAAAAAAxAsAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAUAAAAE41ZHJhY280ME1lc2hQcmVkaWN0aW9uU2NoZW1lUGFyYWxsZWxvZ3JhbURlY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBEZWNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjdNZXNoUHJlZGljdGlvblNjaGVtZURlY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBEZWNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjNQcmVkaWN0aW9uU2NoZW1lRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVFRQBONWRyYWNvMzdQcmVkaWN0aW9uU2NoZW1lVHlwZWREZWNvZGVySW50ZXJmYWNlSWlpRUUATjVkcmFjbzMyUHJlZGljdGlvblNjaGVtZURlY29kZXJJbnRlcmZhY2VFAE41ZHJhY28yNVByZWRpY3Rpb25TY2hlbWVJbnRlcmZhY2VFAGhAAABoCwAAkEAAAD0LAACMCwAAkEAAAAkLAACUCwAAkEAAALUKAACgCwAAkEAAAB8KAACsCwAAkEAAAHwJAAC4CwAAAAAAALgLAABFAAAAUQAAACIAAABIAAAAIgAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAACIAAAAAAAAArAsAAEUAAABSAAAAIgAAAEgAAAAiAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAIgAAAAAAAAAgDQAARQAAAFMAAABUAAAASAAAAFUAAABKAAAASwAAAEwAAABNAAAATgAAAE8AAABWAAAATjVkcmFjbzQ1TWVzaFByZWRpY3Rpb25TY2hlbWVNdWx0aVBhcmFsbGVsb2dyYW1EZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUAkEAAAHgMAAC4CwAAAAAAABgOAABXAAAAWAAAAFkAAABIAAAAWgAAAEoAAABLAAAATAAAAE0AAABOAAAAWwAAAFwAAABONWRyYWNvNTZNZXNoUHJlZGljdGlvblNjaGVtZUNvbnN0cmFpbmVkTXVsdGlQYXJhbGxlbG9ncmFtRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAACQQAAAZA0AALgLAAAAAAAA/A4AAF0AAABeAAAAXwAAAEgAAABgAAAAYQAAAGIAAABjAAAATQAAAE4AAABkAAAAZQAAAE41ZHJhY28zNk1lc2hQcmVkaWN0aW9uU2NoZW1lVGV4Q29vcmRzRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAACQQAAAXA4AALgLAAAAAAAA6A8AAGYAAABnAAAAaAAAAEgAAABpAAAAagAAAGsAAABsAAAATQAAAE4AAABtAAAAbgAAAE41ZHJhY280NE1lc2hQcmVkaWN0aW9uU2NoZW1lVGV4Q29vcmRzUG9ydGFibGVEZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUAAJBAAABADwAAuAsAAAAAAADUEAAAbwAAAHAAAABxAAAASAAAAHIAAABzAAAAdAAAAHUAAABNAAAATgAAAHYAAAB3AAAATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxEZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUAAAAAkEAAACwQAAC4CwAAAAAAAFwSAAB4AAAAeQAAAHoAAAB7AAAAfAAAAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQXJlYUlpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQmFzZUlpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAAAAaEAAAKcRAACQQAAA/BAAAFQSAAAAAAAAVBIAAHgAAAB9AAAAIgAAAHsAAAAiAAAAAAAAAOgTAABFAAAAfgAAAH8AAABIAAAAgAAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAIEAAABONWRyYWNvNDBNZXNoUHJlZGljdGlvblNjaGVtZVBhcmFsbGVsb2dyYW1EZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjdNZXNoUHJlZGljdGlvblNjaGVtZURlY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBEZWNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAACQQAAAUhMAAKwLAACQQAAAvBIAANwTAAAAAAAA3BMAAEUAAACCAAAAIgAAAEgAAAAiAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAIgAAAAAAAAAAFQAARQAAAIMAAACEAAAASAAAAIUAAABKAAAASwAAAEwAAABNAAAATgAAAE8AAACGAAAATjVkcmFjbzQ1TWVzaFByZWRpY3Rpb25TY2hlbWVNdWx0aVBhcmFsbGVsb2dyYW1EZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQAAkEAAAGQUAADcEwAAAAAAAOwVAACHAAAAiAAAAIkAAABIAAAAigAAAEoAAABLAAAATAAAAE0AAABOAAAAiwAAAIwAAABONWRyYWNvNTZNZXNoUHJlZGljdGlvblNjaGVtZUNvbnN0cmFpbmVkTXVsdGlQYXJhbGxlbG9ncmFtRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUAAACQQAAARBUAANwTAAAAAAAAxBYAAI0AAACOAAAAjwAAAEgAAACQAAAAkQAAAJIAAACTAAAATQAAAE4AAACUAAAAlQAAAE41ZHJhY28zNk1lc2hQcmVkaWN0aW9uU2NoZW1lVGV4Q29vcmRzRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUAAACQQAAAMBYAANwTAAAAAAAApBcAAJYAAACXAAAAmAAAAEgAAACZAAAAmgAAAJsAAACcAAAATQAAAE4AAACdAAAAngAAAE41ZHJhY280NE1lc2hQcmVkaWN0aW9uU2NoZW1lVGV4Q29vcmRzUG9ydGFibGVEZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQAAAJBAAAAIFwAA3BMAAAAAAACAGAAAnwAAAKAAAAChAAAASAAAAKIAAACjAAAApAAAAKUAAABNAAAATgAAAKYAAACnAAAATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxEZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQCQQAAA6BcAANwTAAAAAAAA7BkAAKgAAACpAAAAqgAAAKsAAACsAAAATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JBcmVhSWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvNDhNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbFByZWRpY3RvckJhc2VJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBEZWNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAGhAAABGGQAAkEAAAKgYAADkGQAAAAAAAOQZAACoAAAArQAAACIAAACrAAAAIgAAAAAAAACoGgAARQAAAK4AAACvAAAASAAAALAAAABKAAAASwAAAEwAAABNAAAATgAAAE8AAACxAAAATjVkcmFjbzI4UHJlZGljdGlvblNjaGVtZURlbHRhRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVFRQAAAACQQAAATBoAAKwLAAAAAAAAHBsAALIAAACzAAAAtAAAAC0AAAAuAAAAtQAAAD8AAAAxAAAAQAAAALYAAAC3AAAAuAAAALkAAABONWRyYWNvMzJTZXF1ZW50aWFsTm9ybWFsQXR0cmlidXRlRGVjb2RlckUAAJBAAADwGgAAOAkAAAAAAAAoHQAAugAAALsAAAC8AAAAvQAAAL4AAAC/AAAAwAAAAMEAAADCAAAAwwAAAMQAAADFAAAATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxEZWNvZGVySWlOU180OVByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjdNZXNoUHJlZGljdGlvblNjaGVtZURlY29kZXJJaU5TXzQ5UHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25EZWNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY28yM1ByZWRpY3Rpb25TY2hlbWVEZWNvZGVySWlOU180OVByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uRGVjb2RpbmdUcmFuc2Zvcm1JaUVFRUUAkEAAALEcAACgCwAAkEAAABAcAAAQHQAAkEAAAGAbAAAcHQAAAAAAAMQeAADGAAAAxwAAAMgAAADJAAAAygAAAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQXJlYUlpTlNfNDlQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkRlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JCYXNlSWlOU180OVByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBoQAAABh4AAJBAAABQHQAAvB4AAAAAAABMIAAAywAAAMwAAADNAAAAvQAAAM4AAADPAAAA0AAAANEAAADCAAAAwwAAANIAAADTAAAATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxEZWNvZGVySWlOU180OVByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY28yN01lc2hQcmVkaWN0aW9uU2NoZW1lRGVjb2RlcklpTlNfNDlQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkRlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQAAkEAAAKsfAAAQHQAAkEAAAAgfAABAIAAAAAAAANAhAADUAAAA1QAAANYAAADXAAAA2AAAAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQXJlYUlpTlNfNDlQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkRlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvNDhNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbFByZWRpY3RvckJhc2VJaU5TXzQ5UHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25EZWNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUAAABoQAAAHSEAAJBAAAB0IAAAyCEAAAAAAAB4IgAA2QAAANoAAADbAAAAvQAAANwAAADdAAAA3gAAAN8AAADCAAAAwwAAAOAAAADhAAAATjVkcmFjbzI4UHJlZGljdGlvblNjaGVtZURlbHRhRGVjb2RlcklpTlNfNDlQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkRlY29kaW5nVHJhbnNmb3JtSWlFRUVFAJBAAAAUIgAAEB0AAAAAAACsJAAA4gAAAOMAAADkAAAA5QAAAOYAAADnAAAA6AAAAOkAAADqAAAA6wAAAOwAAADtAAAATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxEZWNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZERlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzI3TWVzaFByZWRpY3Rpb25TY2hlbWVEZWNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZERlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzIzUHJlZGljdGlvblNjaGVtZURlY29kZXJJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRGVjb2RpbmdUcmFuc2Zvcm1JaUVFRUUAAJBAAAAnJAAAoAsAAJBAAAB5IwAAlCQAAJBAAAC8IgAAoCQAAAAAAABkJgAA7gAAAO8AAADwAAAA8QAAAPIAAABONWRyYWNvNDhNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbFByZWRpY3RvckFyZWFJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvNDhNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbFByZWRpY3RvckJhc2VJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQAAAGhAAACXJQAAkEAAANQkAABcJgAAAAAAAAgoAADzAAAA9AAAAPUAAADlAAAA9gAAAPcAAAD4AAAA+QAAAOoAAADrAAAA+gAAAPsAAABONWRyYWNvNDJNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbERlY29kZXJJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY28yN01lc2hQcmVkaWN0aW9uU2NoZW1lRGVjb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWREZWNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUAAAAAkEAAAFgnAACUJAAAkEAAAKgmAAD8JwAAAAAAAKQpAAD8AAAA/QAAAP4AAAD/AAAAAAEAAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQXJlYUlpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWREZWNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JCYXNlSWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZERlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBoQAAA5igAAJBAAAAwKAAAnCkAAAAAAABcKgAA2QAAAAEBAAACAQAA5QAAAAMBAAAEAQAABQEAAAYBAADqAAAA6wAAAAcBAAAIAQAATjVkcmFjbzI4UHJlZGljdGlvblNjaGVtZURlbHRhRGVjb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWREZWNvZGluZ1RyYW5zZm9ybUlpRUVFRQAAAACQQAAA6CkAAJQkAAAAAAAA4CoAAAkBAAAKAQAACwEAAC0AAAAuAAAADAEAAD8AAAAxAAAAQAAAAA0BAABCAAAAQwAAAA4BAAAPAQAAEAEAAE41ZHJhY28zOFNlcXVlbnRpYWxRdWFudGl6YXRpb25BdHRyaWJ1dGVEZWNvZGVyRQAAAACQQAAArCoAADgJAABhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAFVuc3VwcG9ydGVkIGVuY29kaW5nIG1ldGhvZC4AVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZS4ASW5wdXQgaXMgbm90IGEgcG9pbnQgY2xvdWQuAElucHV0IGlzIG5vdCBhIG1lc2guAHNraXBfYXR0cmlidXRlX3RyYW5zZm9ybQBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAAAAAAAAAEwsAAARAQAAEgEAABMBAAAUAQAAIgAAABUBAAAWAQAAFwEAABgBAAAZAQAAGgEAABsBAAAiAAAATjVkcmFjbzExTWVzaERlY29kZXJFAAAAkEAAADQsAAAUNgAAAAAAALgsAAAcAQAAHQEAABMBAAAeAQAAHwEAABUBAAAWAQAAFwEAACABAAAhAQAAIgEAACMBAAAkAQAATjVkcmFjbzIyTWVzaEVkZ2VicmVha2VyRGVjb2RlckUAAAAAkEAAAJQsAABMLAAAAAAAANwtAAAlAQAAJgEAACcBAAAoAQAAKQEAACoBAAArAQAALAEAAC0BAAAuAQAA/////wAAAABALgAALwEAADABAAAxAQAAMgEAADMBAAA0AQAANQEAADYBAAA3AQAAOAEAAAAAAACgLgAAOQEAADoBAAA7AQAAPAEAAD0BAAA+AQAAPwEAAEABAABBAQAAQgEAAE41ZHJhY28yNk1lc2hFZGdlYnJlYWtlckRlY29kZXJJbXBsSU5TXzMxTWVzaEVkZ2VicmVha2VyVHJhdmVyc2FsRGVjb2RlckVFRQBONWRyYWNvMzVNZXNoRWRnZWJyZWFrZXJEZWNvZGVySW1wbEludGVyZmFjZUUAAABoQAAApC0AAJBAAABYLQAA1C0AAE41ZHJhY28yNk1lc2hFZGdlYnJlYWtlckRlY29kZXJJbXBsSU5TXzQxTWVzaEVkZ2VicmVha2VyVHJhdmVyc2FsUHJlZGljdGl2ZURlY29kZXJFRUUAAACQQAAA6C0AANQtAABONWRyYWNvMjZNZXNoRWRnZWJyZWFrZXJEZWNvZGVySW1wbElOU18zOE1lc2hFZGdlYnJlYWtlclRyYXZlcnNhbFZhbGVuY2VEZWNvZGVyRUVFAACQQAAATC4AANQtAAAAAAAAnC8AAEMBAABEAQAARQEAAE41ZHJhY28xOURlcHRoRmlyc3RUcmF2ZXJzZXJJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzFfRUVFRQBONWRyYWNvMTNUcmF2ZXJzZXJCYXNlSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUAaEAAAC0vAACQQAAAwC4AAJQvAAAAAAAAlC8AAEYBAABHAQAARQEAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAAAEAAAADAAAABQAAAAcAAAAAAAAA2DAAAEgBAABJAQAASgEAAEsBAABONWRyYWNvMjJNZXNoVHJhdmVyc2FsU2VxdWVuY2VySU5TXzI4TWF4UHJlZGljdGlvbkRlZ3JlZVRyYXZlcnNlcklOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMyX0VFRUVFRQBONWRyYWNvMTVQb2ludHNTZXF1ZW5jZXJFAAAAAGhAAACzMAAAkEAAACwwAADQMAAA/////wAAAADIMQAATAEAAE0BAABOAQAATjVkcmFjbzI4TWF4UHJlZGljdGlvbkRlZ3JlZVRyYXZlcnNlcklOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUATjVkcmFjbzEzVHJhdmVyc2VyQmFzZUlOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUAAGhAAABlMQAAkEAAAPwwAADAMQAAAAAAAMAxAABPAQAAUAEAAE4BAAAAAAAAgDIAAFEBAABSAQAAUwEAAFQBAABONWRyYWNvMjJNZXNoVHJhdmVyc2FsU2VxdWVuY2VySU5TXzE5RGVwdGhGaXJzdFRyYXZlcnNlcklOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMyX0VFRUVFRQAAAJBAAAAAMgAA0DAAAAAAAAAAMwAAVQEAAFYBAABOAQAATjVkcmFjbzE5RGVwdGhGaXJzdFRyYXZlcnNlcklOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUAkEAAAKAyAADAMQAAAAAAALAzAABXAQAAWAEAAFkBAABaAQAATjVkcmFjbzIyTWVzaFRyYXZlcnNhbFNlcXVlbmNlcklOU18xOURlcHRoRmlyc3RUcmF2ZXJzZXJJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzJfRUVFRUVFAACQQAAAJDMAANAwAEHE5wALkgIcNAAAEQEAAFsBAAATAQAAFAEAAFwBAAAVAQAAFgEAABcBAAAYAQAAGQEAABoBAAAbAQAAXQEAAE41ZHJhY28yMU1lc2hTZXF1ZW50aWFsRGVjb2RlckUAkEAAAPwzAABMLAAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAAAAoDQAAF4BAABfAQAAYAEAAGEBAABONWRyYWNvMTVMaW5lYXJTZXF1ZW5jZXJFAAAAkEAAAIQ0AADQMAAAAAAAABQ2AAARAQAAYgEAAGMBAAAUAQAAIgAAAGQBAAAWAQAAFwEAABgBAEHg6QALoQRGYWlsZWQgdG8gcGFyc2UgRHJhY28gaGVhZGVyLgBEUkFDTwBOb3QgYSBEcmFjbyBmaWxlLgBGYWlsZWQgdG8gZGVjb2RlIG1ldGFkYXRhLgBVc2luZyBpbmNvbXBhdGlibGUgZGVjb2RlciBmb3IgdGhlIGlucHV0IGdlb21ldHJ5LgBVbmtub3duIG1ham9yIHZlcnNpb24uAFVua25vd24gbWlub3IgdmVyc2lvbi4ARmFpbGVkIHRvIGluaXRpYWxpemUgdGhlIGRlY29kZXIuAEZhaWxlZCB0byBkZWNvZGUgZ2VvbWV0cnkgZGF0YS4ARmFpbGVkIHRvIGRlY29kZSBwb2ludCBhdHRyaWJ1dGVzLgBONWRyYWNvMTdQb2ludENsb3VkRGVjb2RlckUAAGhAAAD3NQAAAAAAAGw2AAARAQAAZQEAAGMBAAAUAQAAZgEAAGcBAAAWAQAAFwEAABgBAABONWRyYWNvMjNQb2ludENsb3VkS2RUcmVlRGVjb2RlckUAAACQQAAASDYAABQ2AAAAAAAAzDYAABEBAABoAQAAYwEAABQBAABpAQAAagEAABYBAAAXAQAAGAEAAE41ZHJhY28yN1BvaW50Q2xvdWRTZXF1ZW50aWFsRGVjb2RlckUAAACQQAAApDYAABQ2AAABAAAAAQAAAAIAAAACAAAABAAAAAQAAAAIAAAACAAAAAQAAAAIAAAAAQBBk+4AC6gEwAAAAMAAAADAAAAAwGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUA//////////9hbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAAAAAADYNwAAawEAAGwBAABtAQAAbgEAAE41ZHJhY280TWVzaEUAAACQQAAAyDcAAHA5AABhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAP////9hbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAEHE8gALzQJwOQAAbwEAAHABAABxAQAAcgEAAE41ZHJhY28xMFBvaW50Q2xvdWRFAAAAAGhAAABYOQAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBGbG9hdFBvaW50c1RyZWVEZWNvZGVyOiBjb21wcmVz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";
(() => {
  "use strict";
  var A = {};
  const n = { ANIM: { EASINGS: ["linear", "absolute", "smoothstep", "smootherstep", "Cubic In", "Cubic Out", "Cubic In Out", "Expo In", "Expo Out", "Expo In Out", "Sin In", "Sin Out", "Sin In Out", "Quart In", "Quart Out", "Quart In Out", "Quint In", "Quint Out", "Quint In Out", "Back In", "Back Out", "Back In Out", "Elastic In", "Elastic Out", "Bounce In", "Bounce Out"], EASING_LINEAR: 0, EASING_ABSOLUTE: 1, EASING_SMOOTHSTEP: 2, EASING_SMOOTHERSTEP: 3, EASING_CUBICSPLINE: 4, EASING_CUBIC_IN: 5, EASING_CUBIC_OUT: 6, EASING_CUBIC_INOUT: 7, EASING_EXPO_IN: 8, EASING_EXPO_OUT: 9, EASING_EXPO_INOUT: 10, EASING_SIN_IN: 11, EASING_SIN_OUT: 12, EASING_SIN_INOUT: 13, EASING_BACK_IN: 14, EASING_BACK_OUT: 15, EASING_BACK_INOUT: 16, EASING_ELASTIC_IN: 17, EASING_ELASTIC_OUT: 18, EASING_BOUNCE_IN: 19, EASING_BOUNCE_OUT: 21, EASING_QUART_IN: 22, EASING_QUART_OUT: 23, EASING_QUART_INOUT: 24, EASING_QUINT_IN: 25, EASING_QUINT_OUT: 26, EASING_QUINT_INOUT: 27 }, OP: { OP_PORT_TYPE_VALUE: 0, OP_PORT_TYPE_NUMBER: 0, OP_PORT_TYPE_FUNCTION: 1, OP_PORT_TYPE_TRIGGER: 1, OP_PORT_TYPE_OBJECT: 2, OP_PORT_TYPE_TEXTURE: 2, OP_PORT_TYPE_ARRAY: 3, OP_PORT_TYPE_DYNAMIC: 4, OP_PORT_TYPE_STRING: 5, OP_VERSION_PREFIX: "_v" }, PORT: { PORT_DIR_IN: 0, PORT_DIR_OUT: 1 }, PACO: { PACO_CLEAR: 0, PACO_VALUECHANGE: 1, PACO_OP_DELETE: 2, PACO_UNLINK: 3, PACO_LINK: 4, PACO_LOAD: 5, PACO_OP_CREATE: 6, PACO_OP_ENABLE: 7, PACO_OP_DISABLE: 8, PACO_UIATTRIBS: 9, PACO_VARIABLES: 10, PACO_TRIGGERS: 11, PACO_PORT_SETVARIABLE: 12, PACO_PORT_SETANIMATED: 13, PACO_PORT_ANIM_UPDATED: 14, PACO_DESERIALIZE: 15 } };
  const e = class {
    constructor(e2, A2, t2, g, i, I) {
      this._valuePort = t2;
      this._varNamePort = g;
      this._op = e2;
      this._type = A2;
      this._typeId = -1;
      this._triggerPort = i;
      this._nextPort = I;
      this._btnCreate = e2.inTriggerButton("Create new variable");
      this._btnCreate.setUiAttribs({ hidePort: true });
      this._btnCreate.onTriggered = this._createVar.bind(this);
      this._helper = e2.inUiTriggerButtons("", ["Rename"]);
      this._helper.setUiAttribs({ hidePort: true });
      this._helper.onTriggered = (A3) => {
        if (A3 == "Rename")
          CABLES.CMD.PATCH.renameVariable(e2.varName.get());
      };
      this._op.setPortGroup("Variable", [this._helper, this._varNamePort, this._btnCreate]);
      this._op.on("uiParamPanel", this._updateVarNamesDropdown.bind(this));
      this._op.patch.addEventListener("variablesChanged", this._updateName.bind(this));
      this._op.patch.addEventListener("variableRename", this._renameVar.bind(this));
      this._varNamePort.onChange = this._updateName.bind(this);
      this._isTexture = this._valuePort.uiAttribs.objType === "texture";
      this._valuePort.changeAlways = true;
      if (this._triggerPort) {
        this._triggerPort.onTriggered = () => {
          this._setVarValue(true);
        };
      } else {
        this._valuePort.onChange = this._setVarValue.bind(this);
      }
      this._op.init = () => {
        this._updateName();
        if (!this._triggerPort)
          this._setVarValue();
        this._updateErrorUi();
      };
      if (A2 == "array")
        this._typeId = n.OP.OP_PORT_TYPE_ARRAY;
      else if (A2 == "object")
        this._typeId = n.OP.OP_PORT_TYPE_OBJECT;
      else if (A2 == "string")
        this._typeId = n.OP.OP_PORT_TYPE_STRING;
      else if (A2 == "texture")
        this._typeId = n.OP.OP_PORT_TYPE_TEXTURE;
      else
        this._typeId = n.OP.OP_PORT_TYPE_VALUE;
    }
    _updateErrorUi() {
      if (CABLES.UI) {
        if (!this._varNamePort.get())
          this._op.setUiError("novarname", "no variable selected");
        else {
          if (this._op.hasUiErrors) {
            this._op.setUiError("novarname", null);
          }
        }
      }
    }
    _updateName() {
      const A2 = this._varNamePort.get();
      this._op.setTitle("var set");
      this._op.setUiAttrib({ extendTitle: "#" + A2 });
      this._updateErrorUi();
      const e2 = this._op.patch.getVar(A2);
      if (e2 && !e2.type)
        e2.type = this._type;
      if (!this._op.patch.hasVar(A2) && A2 != 0 && !this._triggerPort) {
        this._setVarValue();
      }
      if (!this._op.patch.hasVar(A2) && A2 != 0 && this._triggerPort) {
        if (this._type == "string")
          this._op.patch.setVarValue(A2, "");
        else if (this._type == "number")
          this._op.patch.setVarValue(A2, "");
        else
          this._op.patch.setVarValue(A2, null);
      }
      if (this._op.isCurrentUiOp()) {
        this._updateVarNamesDropdown();
        this._op.refreshParams();
      }
      this._updateDisplay();
      this._op.patch.emitEvent("opVariableNameChanged", this._op, this._varNamePort.get());
    }
    _createVar() {
      CABLES.CMD.PATCH.createVariable(this._op, this._type, () => {
        this._updateName();
      });
    }
    _updateDisplay() {
      this._valuePort.setUiAttribs({ greyout: !this._varNamePort.get() });
    }
    _updateVarNamesDropdown() {
      if (CABLES.UI && CABLES.UI.loaded && CABLES.UI.loaded) {
        const A2 = CABLES.UI.uiProfiler.start("[vars] _updateVarNamesDropdown");
        const e2 = [];
        const t2 = this._op.patch.getVars();
        for (const g in t2)
          if (t2[g].type == this._type && g != "0")
            e2.push(g);
        this._varNamePort.uiAttribs.values = e2;
        A2.finish();
      }
    }
    _renameVar(A2, e2) {
      if (A2 != this._varNamePort.get())
        return;
      this._varNamePort.set(e2);
      this._updateName();
    }
    _setVarValue(A2) {
      const e2 = this._varNamePort.get();
      if (!e2)
        return;
      const t2 = this._valuePort.get();
      if (this._typeId == n.OP.OP_PORT_TYPE_VALUE || this._typeId == n.OP.OP_PORT_TYPE_STRING) {
        this._op.patch.setVarValue(e2, t2);
      } else if (this._typeId == n.OP.OP_PORT_TYPE_ARRAY) {
        this._arr = [];
        CABLES.copyArray(t2, this._arr);
        this._op.patch.setVarValue(e2, this._arr);
      } else {
        if (this._typeId == n.OP.OP_PORT_TYPE_OBJECT) {
          if (this._isTexture)
            this._op.patch.setVarValue(e2, CGL.Texture.getEmptyTexture(this._op.patch.cgl));
          else
            this._op.patch.setVarValue(e2, null);
          if (t2 && t2.tex && t2._cgl && !this._isTexture)
            this._op.setUiError("texobj", "Dont use object variables for textures, use varSetTexture");
          else
            this._op.setUiError("texobj", null);
        }
        this._op.patch.setVarValue(e2, t2);
      }
      if (A2 && this._nextPort)
        this._nextPort.trigger();
    }
  };
  const t = class {
    constructor(A2, e2, t2, g) {
      this._op = A2;
      this._type = e2;
      this._varnamePort = t2;
      this._variable = null;
      this._valueOutPort = g;
      this._listenerId = null;
      this._op.on("uiParamPanel", this._updateVarNamesDropdown.bind(this));
      this._op.on("uiErrorChange", this._updateTitle.bind(this));
      this._op.patch.on("variableRename", this._renameVar.bind(this));
      this._op.patch.on("variableDeleted", (A3) => {
        if (this._op.isCurrentUiOp())
          this._op.refreshParams();
      });
      this._varnamePort.onChange = this._changeVar.bind(this);
      this._op.patch.addEventListener("variablesChanged", this._init.bind(this));
      this._op.onDelete = () => {
        if (this._variable && this._listenerId)
          this._variable.off(this._listenerId);
      };
      this._op.init = () => {
        this._init();
      };
    }
    get variable() {
      return this._variable;
    }
    _changeVar() {
      if (this._variable && this._listenerId) {
        this._variable.off(this._listenerId);
      }
      this._init();
    }
    _renameVar(A2, e2) {
      if (A2 != this._varnamePort.get())
        return;
      this._varnamePort.set(e2);
      this._updateVarNamesDropdown();
      this._updateTitle();
      this._listenerId = this._variable.on("change", this._setValueOut.bind(this));
    }
    _updateVarNamesDropdown() {
      if (CABLES.UI && CABLES.UI.loaded) {
        const A2 = [];
        const e2 = this._op.patch.getVars();
        for (const t2 in e2)
          if (e2[t2].type == this._type && t2 != "0")
            A2.push(t2);
        this._op.varName.uiAttribs.values = A2;
      }
    }
    _setValueOut(A2) {
      if (this._valueOutPort)
        this._valueOutPort.set(A2);
    }
    _updateTitle() {
      if (this._variable) {
        this._op.setUiError("unknownvar", null);
        this._op.setTitle("var get");
        this._op.setUiAttrib({ extendTitle: "#" + this._varnamePort.get() });
        if (this._valueOutPort)
          this._valueOutPort.set(this._variable.getValue());
      } else {
        this._op.setUiError("unknownvar", "unknown variable! - there is no setVariable with this name (" + this._varnamePort.get() + ")");
        this._op.setUiAttrib({ extendTitle: "#invalid" });
        if (this._valueOutPort)
          this._valueOutPort.set(0);
      }
    }
    _init() {
      this._updateVarNamesDropdown();
      if (this._variable && this._listenerId)
        this._variable.off(this._listenerId);
      this._variable = this._op.patch.getVar(this._op.varName.get());
      if (this._variable)
        this._listenerId = this._variable.on("change", this._setValueOut.bind(this));
      this._updateTitle();
      this._op.patch.emitEvent("opVariableNameChanged", this._op, this._varnamePort.get());
    }
  };
  CABLES.VarSetOpWrapper = e;
  CABLES.VarGetOpWrapper = t;
  (((void 0).CABLES = (void 0).CABLES || {}).COREMODULES = (void 0).CABLES.COREMODULES || {}).Vargetset = A.Cables;
})();
(() => {
  "use strict";
  var A = {};
  const t = "Ops.Ui.SubPatchInput";
  const g = "Ops.Ui.SubPatchOutput";
  const e = class {
    constructor(t2, A2) {
      A2 = A2 || {};
      this._op = t2;
      t2.patchId = t2.addInPort(new CABLES.Port(t2, "patchId", CABLES.OP_PORT_TYPE_STRING, { display: "readonly", hidePort: true }));
      t2.setUiAttribs({ subPatchOp: { version: 2 } });
      if (t2.uiAttribs.parentOfSubpatch) {
        t2.patchId.set(t2.uiAttribs.parentOfSubpatch);
      } else {
        if (A2.subId)
          t2.patchId.set(A2.subId);
        else
          t2.patchId.set(CABLES.generateUUID());
      }
      t2.patchId.onChange = () => {
        if (A2.subId)
          t2.patchId.value = A2.subId;
      };
      t2.patch.on("subpatchCreated", () => {
        this.createInOutOps();
      });
      t2.on("loadedValueSet", () => {
        this.createInOutOps();
      });
      t2.init = () => {
        t2.setStorage({ subPatchVer: 2 });
      };
      t2.loadDependencies = (A3, e2) => {
        if (CABLES.UI) {
          gui.serverOps.loadProjectDependencies(A3, () => {
            if (e2)
              e2();
          });
        } else if (e2)
          e2();
      };
      t2.on("delete", () => {
        if (t2.patch.clearSubPatchCache)
          t2.patch.clearSubPatchCache(this.patchId);
        const e2 = t2.patch.ops;
        for (let A3 = e2.length - 1; A3 >= 0; A3--)
          if (e2[A3] && e2[A3].uiAttribs && e2[A3].uiAttribs.subPatch == t2.patchId.get())
            t2.patch.deleteOp(e2[A3].id);
      });
      this._op.isExposableSubpatchOp = () => {
        return true;
      };
    }
    get patchId() {
      return this._op.patchId.get();
    }
    createInOutOps() {
      if (this._op.patch.clearSubPatchCache)
        this._op.patch.clearSubPatchCache(this.patchId);
      let A2 = this._op.patch.getSubPatchOp(this.patchId, t);
      let e2 = this._op.patch.getSubPatchOp(this.patchId, g);
      if (!A2)
        this._op.patch.addOp(t, { subPatch: this.patchId, translate: { x: 0, y: 0 } });
      if (!e2)
        this._op.patch.addOp(g, { subPatch: this.patchId, translate: { x: 0, y: 0 } });
    }
  };
  CABLES.SubPatchOp = e;
  (((void 0).CABLES = (void 0).CABLES || {}).COREMODULES = (void 0).CABLES.COREMODULES || {}).Subpatchop = A.Cables;
})();
(() => {
  "use strict";
  var A = {};
  class e {
    constructor(A2, e2, t) {
      this._cgl = A2;
      this._name = e2;
      this._origShaders = {};
      this._uniforms = [];
      this._structUniforms = [];
      this._definesToggled = {};
      this._defines = {};
      this._mods = [];
      this._textures = [];
      this._boundShader = null;
      this._changedDefines = true;
      this._changedUniforms = true;
      this._modulesChanged = false;
      this.needsTexturePush = false;
      this._lastShader = null;
      this._attributes = [];
      if (t && t.opId)
        this.opId = t.opId;
      if (this._cgl.glVersion == 1) {
        this._cgl.enableExtension("OES_texture_float");
        this._cgl.enableExtension("OES_texture_float_linear");
        this._cgl.enableExtension("OES_texture_half_float");
        this._cgl.enableExtension("OES_texture_half_float_linear");
      }
    }
    bind(A2, e2) {
      const t = A2 || this._cgl.getShader();
      if (!t)
        return;
      this._boundShader = this._origShaders[t.id];
      let g = false;
      if (this._boundShader && this._lastShader != this._boundShader.shader) {
        if (!this._boundShader.shader.hasModule(this._mods[0].id))
          g = true;
      }
      if (g || !this._boundShader || t.lastCompile != this._boundShader.lastCompile || this._modulesChanged || t._needsRecompile) {
        if (this._boundShader)
          this._boundShader.shader.dispose();
        if (t._needsRecompile)
          t.compile();
        this.needsTexturePush = true;
        this._boundShader = this._origShaders[t.id] = { lastCompile: t.lastCompile, orig: t, shader: t.copy() };
        this._addModulesToShader(this._boundShader.shader);
        this._updateDefinesShader(this._boundShader.shader);
        this._updateUniformsShader(this._boundShader.shader);
      }
      this._boundShader.wireframe = t.wireframe;
      if (this._changedDefines)
        this._updateDefines();
      if (this._changedUniforms)
        this._updateUniforms();
      if (e2 !== false)
        this._cgl.pushShader(this._boundShader.shader);
      this._boundShader.shader.copyUniformValues(this._boundShader.orig);
      if (this.needsTexturePush) {
        for (let A3 = 0; A3 < this._textures.length; A3++) {
          const i = this._textures[A3][0];
          const I = this._textures[A3][1];
          const n = this._textures[A3][2];
          if (this._getUniform(i)) {
            const o = this.getPrefixedName(i);
            const C = this._boundShader.shader.getUniform(o);
            if (C)
              this._boundShader.shader.pushTexture(C, I, n);
          }
        }
        this.needsTexturePush = false;
        this._textures.length = 0;
      }
      this._modulesChanged = false;
      this._boundShader.shader.fromMod = this;
      if (this.onBind)
        this.onBind(this._boundShader.shader);
      return this._boundShader.shader;
    }
    unbind(A2) {
      if (this._boundShader) {
        if (A2 !== false)
          this._cgl.popShader();
      }
      this._boundShader = null;
    }
    _addModulesToShader(e2) {
      let t;
      if (this._mods.length > 1)
        t = this._mods[0];
      for (let A2 = 0; A2 < this._mods.length; A2++)
        e2.addModule(this._mods[A2], t);
    }
    _removeModulesFromShader(A2) {
      for (const e2 in this._origShaders)
        this._origShaders[e2].shader.removeModule(A2);
    }
    addModule(A2) {
      this._mods.push(A2);
      this._modulesChanged = true;
    }
    removeModule(e2) {
      const t = [];
      let g = false;
      for (let A2 = 0; A2 < this._mods.length; A2++) {
        if (this._mods[A2].title == e2) {
          g = true;
          this._removeModulesFromShader(this._mods[A2]);
          t.push(A2);
        }
      }
      for (let A2 = t.length - 1; A2 >= 0; A2 -= 1)
        this._mods.splice(t[A2], 1);
      this._modulesChanged = true;
    }
    _updateUniformsShader(g) {
      for (let A2 = 0; A2 < this._uniforms.length; A2++) {
        const e2 = this._uniforms[A2];
        const t = this.getPrefixedName(e2.name);
        if (!g.hasUniform(t) && !e2.structName) {
          let A3 = null;
          if (e2.shaderType === "both") {
            A3 = g.addUniformBoth(e2.type, t, e2.v1, e2.v2, e2.v3, e2.v4);
            A3.comment = "mod: " + this._name;
          } else if (e2.shaderType === "frag") {
            A3 = g.addUniformFrag(e2.type, t, e2.v1, e2.v2, e2.v3, e2.v4);
            A3.comment = "mod: " + this._name;
          } else if (e2.shaderType === "vert") {
            A3 = g.addUniformVert(e2.type, t, e2.v1, e2.v2, e2.v3, e2.v4);
            A3.comment = "mod: " + this._name;
          }
        }
      }
      for (let t = 0; t < this._structUniforms.length; t += 1) {
        const i = this._structUniforms[t];
        let A2 = i.uniformName;
        let e2 = i.structName;
        const I = i.members;
        A2 = this.getPrefixedName(i.uniformName);
        e2 = this.getPrefixedName(i.structName);
        if (i.shaderType === "frag") {
          g.addUniformStructFrag(e2, A2, I);
        }
        if (i.shaderType === "vert") {
          g.addUniformStructVert(e2, A2, I);
        }
        if (i.shaderType === "both") {
          g.addUniformStructBoth(e2, A2, I);
        }
      }
    }
    _updateUniforms() {
      for (const A2 in this._origShaders)
        this._updateUniformsShader(this._origShaders[A2].shader);
      this._changedUniforms = false;
    }
    _setUniformValue(A2, e2, t) {
      const g = A2.getUniform(e2);
      if (g)
        g.setValue(t);
    }
    setUniformValue(A2, e2) {
      const t = this._getUniform(A2);
      if (!t)
        return;
      const g = this.getPrefixedName(A2);
      for (const i in this._origShaders) {
        this._setUniformValue(this._origShaders[i].shader, g, e2);
      }
    }
    hasUniform(A2) {
      return this._getUniform(A2);
    }
    _getUniform(e2) {
      for (let A2 = 0; A2 < this._uniforms.length; A2++) {
        if (this._uniforms[A2].name == e2)
          return this._uniforms[A2];
        if (this._uniforms[A2].structName) {
          if (this._uniforms[A2].propertyName == e2)
            return this._uniforms[A2];
        }
      }
      return false;
    }
    _getStructUniform(e2) {
      for (let A2 = 0; A2 < this._structUniforms.length; A2 += 1)
        if (this._structUniforms[A2].uniformName === e2)
          return this._structUniforms[A2];
      return null;
    }
    _isStructUniform(e2) {
      for (let A2 = 0; A2 < this._uniforms.length; A2++) {
        if (this._uniforms[A2].name == e2)
          return false;
        if (this._uniforms[A2].structName) {
          if (this._uniforms[A2].propertyName == e2)
            return true;
        }
      }
      return false;
    }
    addUniform(e2, t, g, i, I, n, o, C, a, r) {
      if (!this._getUniform(t)) {
        let A2 = "both";
        if (r)
          A2 = r;
        this._uniforms.push({ type: e2, name: t, v1: g, v2: i, v3: I, v4: n, structUniformName: o, structName: C, propertyName: a, shaderType: A2 });
        this._changedUniforms = true;
      }
    }
    addUniformFrag(A2, e2, t, g, i, I) {
      this.addUniform(A2, e2, t, g, i, I, null, null, null, "frag");
      this._changedUniforms = true;
    }
    addUniformVert(A2, e2, t, g, i, I) {
      this.addUniform(A2, e2, t, g, i, I, null, null, null, "vert");
      this._changedUniforms = true;
    }
    addUniformBoth(A2, e2, t, g, i, I) {
      this.addUniform(A2, e2, t, g, i, I, null, null, null, "both");
      this._changedUniforms = true;
    }
    addUniformStruct(e2, t, g, i) {
      for (let A2 = 0; A2 < g.length; A2 += 1) {
        const I = g[A2];
        if ((I.type === "2i" || I.type === "i" || I.type === "3i") && i === "both")
          console.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", e2, " with member:", I.name, " of type:", I.type, ".");
        if (!this._getUniform(t + "." + I.name)) {
          this.addUniform(I.type, t + "." + I.name, I.v1, I.v2, I.v3, I.v4, t, e2, I.name, i);
        }
      }
      if (!this._getStructUniform(t)) {
        this._structUniforms.push({ structName: e2, uniformName: t, members: g, shaderType: i });
      }
    }
    addUniformStructVert(A2, e2, t) {
      this.addUniformStruct(A2, e2, t, "vert");
    }
    addUniformStructFrag(A2, e2, t) {
      this.addUniformStruct(A2, e2, t, "frag");
    }
    addUniformStructBoth(A2, e2, t) {
      this.addUniformStruct(A2, e2, t, "both");
    }
    addAttribute(e2) {
      for (let A2 = 0; A2 < this._attributes.length; A2++) {
        if (this._attributes[A2].name == e2.name && this._attributes[A2].nameFrag == e2.nameFrag)
          return;
      }
      this._attributes.push(e2);
    }
    pushTexture(A2, e2, t) {
      if (!e2)
        throw new Error("no texture given to texturestack");
      this._textures.push([A2, e2, t]);
      this.needsTexturePush = true;
    }
    _removeUniformFromShader(A2, e2) {
      if (e2.hasUniform(A2))
        e2.removeUniform(A2);
    }
    removeUniform(e2) {
      if (this._getUniform(e2)) {
        for (let A2 = this._uniforms.length - 1; A2 >= 0; A2 -= 1) {
          const t = e2;
          if (this._uniforms[A2].name == e2 && !this._uniforms[A2].structName) {
            for (const g in this._origShaders) {
              this._removeUniformFromShader(this.getPrefixedName(t), this._origShaders[g].shader);
            }
            this._uniforms.splice(A2, 1);
          }
        }
        this._changedUniforms = true;
      }
    }
    removeUniformStruct(e2) {
      if (this._getStructUniform(e2)) {
        for (let A2 = this._structUniforms.length - 1; A2 >= 0; A2 -= 1) {
          const t = this._structUniforms[A2];
          if (t.uniformName === e2) {
            for (const g in this._origShaders) {
              for (let A3 = 0; A3 < t.members.length; A3 += 1) {
                const i = t.members[A3];
                this._removeUniformFromShader(this.getPrefixedName(i.name), this._origShaders[g].shader);
              }
            }
            this._structUniforms.splice(A2, 1);
          }
        }
        this._changedUniforms = true;
      }
    }
    getPrefixedName(A2) {
      const e2 = this._mods[0].group;
      if (e2 === void 0) {
        return;
      }
      if (A2.startsWith("MOD_")) {
        A2 = A2.substr("MOD_".length);
        A2 = "mod" + e2 + "_" + A2;
      }
      return A2;
    }
    _updateDefinesShader(A2) {
      for (const e2 in this._defines) {
        const t = this.getPrefixedName(e2);
        if (this._defines[e2] !== null && this._defines[e2] !== void 0)
          A2.define(t, this._defines[e2]);
        else
          A2.removeDefine(t);
      }
      for (const e2 in this._definesToggled) {
        const t = this.getPrefixedName(e2);
        A2.toggleDefine(t, this._definesToggled[e2]);
      }
    }
    _updateDefines() {
      for (const A2 in this._origShaders)
        this._updateDefinesShader(this._origShaders[A2].shader);
      this._changedDefines = false;
    }
    define(A2, e2) {
      if (e2 === void 0)
        e2 = true;
      this._defines[A2] = e2;
      this._changedDefines = true;
    }
    removeDefine(A2) {
      this._defines[A2] = null;
      this._changedDefines = true;
    }
    hasDefine(A2) {
      if (this._defines[A2] !== null && this._defines[A2] !== void 0)
        return true;
      return false;
    }
    toggleDefine(A2, e2) {
      this._changedDefines = true;
      this._definesToggled[A2] = e2;
    }
    currentShader() {
      if (!this._boundShader)
        return null;
      return this._boundShader.shader;
    }
    dispose() {
    }
  }
  CGL.ShaderModifier = e;
  (((void 0).CGL = (void 0).CGL || {}).COREMODULES = (void 0).CGL.COREMODULES || {}).Shadermodifier = A.Shadermodifier;
})();
(() => {
  "use strict";
  var A = {};
  class r {
    constructor(A2) {
      this.initiator = A2;
    }
    stack(A2) {
      console.info("[" + this.initiator + "] ", A2);
      console.log(new Error().stack);
    }
    groupCollapsed(A2) {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 0 }, ...arguments) || !CABLES.logSilent)
        console.log("[" + this.initiator + "]", ...arguments);
      console.groupCollapsed("[" + this.initiator + "] " + A2);
    }
    table(A2) {
      console.table(A2);
    }
    groupEnd() {
      console.groupEnd();
    }
    error() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 2 }, ...arguments) || !CABLES.logSilent)
        console.error("[" + this.initiator + "]", ...arguments);
    }
    errorGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 2 }, ...arguments);
    }
    warn() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 1 }, ...arguments) || !CABLES.logSilent)
        console.warn("[" + this.initiator + "]", ...arguments);
    }
    verbose() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 0 }, ...arguments) || !CABLES.logSilent)
        console.log("[" + this.initiator + "]", ...arguments);
    }
    info() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 0 }, ...arguments) || !CABLES.logSilent)
        console.info("[" + this.initiator + "]", ...arguments);
    }
    log() {
      if (CABLES.UI && CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 0 }, ...arguments) || !CABLES.logSilent)
        console.log("[" + this.initiator + "]", ...arguments);
    }
    logGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog({ initiator: this.initiator, level: 0 }, ...arguments);
    }
    userInteraction(A2) {
    }
  }
  const i = {};
  i.float32Concat = function(A2, e2) {
    if (!(A2 instanceof Float32Array))
      A2 = new Float32Array(A2);
    if (!(e2 instanceof Float32Array))
      e2 = new Float32Array(e2);
    const t2 = new Float32Array(A2.length + e2.length);
    t2.set(A2);
    t2.set(e2, A2.length);
    return t2;
  };
  const v = function(A2) {
    let e2 = A2.split(".")[A2.split(".").length - 1];
    if (e2.contains(CONSTANTS.OP.OP_VERSION_PREFIX)) {
      const t2 = e2.split(CONSTANTS.OP.OP_VERSION_PREFIX)[1];
      e2 = e2.substring(0, e2.length - (CONSTANTS.OP.OP_VERSION_PREFIX + t2).length);
    }
    return e2;
  };
  const O = function(e2) {
    for (let A2 = e2.length - 1; A2 > 0; A2--) {
      const t2 = Math.floor(Math.seededRandom() * (A2 + 1));
      const g2 = e2[A2];
      e2[A2] = e2[t2];
      e2[t2] = g2;
    }
    return e2;
  };
  const e = {};
  const t = function() {
    let A2 = Math.random().toString(36).substr(2, 9);
    if (e.hasOwnProperty(A2))
      A2 = t();
    e[A2] = true;
    return A2;
  };
  const k = null;
  const g = function() {
    let t2 = (/* @__PURE__ */ new Date()).getTime();
    const A2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (A3) => {
      const e2 = (t2 + Math.random() * 16) % 16 | 0;
      t2 = Math.floor(t2 / 16);
      return (A3 == "x" ? e2 : e2 & 3 | 8).toString(16);
    });
    return A2;
  };
  const x = null;
  const T = null;
  function I(A2) {
    for (const e2 in A2) {
      if (A2[e2] && typeof objValue === "object" && A2[e2].constructor === Object)
        A2[e2] = I(A2[e2]);
      if (A2[e2] === null || A2[e2] === void 0)
        delete A2[e2];
      else if (Array.isArray(A2[e2]) && A2[e2].length == 0)
        delete A2[e2];
    }
    return A2;
  }
  const n = function(t2, A2 = "id") {
    let g2 = 0;
    if (Array.prototype.reduce) {
      g2 = t2.split("").reduce((A3, e2) => {
        A3 = (A3 << 5) - A3 + e2.charCodeAt(0);
        return A3 & A3;
      }, 0);
    } else {
      if (t2.length > 0) {
        for (let e2 = 0; e2 < t2.length; e2++) {
          let A3 = t2.charCodeAt(e2);
          g2 = (g2 << 5) - g2 + A3;
          g2 &= g2;
        }
      }
    }
    return A2 + "" + g2;
  };
  const J = null;
  let o = 0;
  const Y = function() {
    o++;
    return o;
  };
  const K = function(A2) {
    const e2 = Math.max(0, Math.min(1, (A2 - 0) / (1 - 0)));
    A2 = e2 * e2 * (3 - 2 * e2);
    return A2;
  };
  const j = function(A2) {
    const e2 = Math.max(0, Math.min(1, (A2 - 0) / (1 - 0)));
    A2 = e2 * e2 * e2 * (e2 * (e2 * 6 - 15) + 10);
    return A2;
  };
  const V = function(A2, e2, t2) {
    return Math.min(Math.max(A2, e2), t2);
  };
  const H = function(A2, e2, t2, g2, i2, I2) {
    if (A2 >= t2)
      return i2;
    if (A2 <= e2)
      return g2;
    let n2 = false;
    const o2 = Math.min(e2, t2);
    const C2 = Math.max(e2, t2);
    if (o2 != e2)
      n2 = true;
    let a2 = false;
    const r2 = Math.min(g2, i2);
    const s2 = Math.max(g2, i2);
    if (r2 != g2)
      a2 = true;
    let B2 = 0;
    let Q2 = 0;
    if (n2)
      B2 = (C2 - A2) * (s2 - r2) / (C2 - o2);
    else
      B2 = (A2 - o2) * (s2 - r2) / (C2 - o2);
    if (a2)
      Q2 = s2 - B2;
    else
      Q2 = B2 + r2;
    if (!I2)
      return Q2;
    if (I2 == 1) {
      A2 = Math.max(0, Math.min(1, (Q2 - g2) / (i2 - g2)));
      return g2 + A2 * A2 * (3 - 2 * A2) * (i2 - g2);
    }
    if (I2 == 2) {
      A2 = Math.max(0, Math.min(1, (Q2 - g2) / (i2 - g2)));
      return g2 + A2 * A2 * A2 * (A2 * (A2 * 6 - 15) + 10) * (i2 - g2);
    }
    return Q2;
  };
  Math.randomSeed = 1;
  Math.setRandomSeed = function(A2) {
    Math.randomSeed = A2 * 50728129;
    if (A2 != 0) {
      Math.randomSeed = Math.seededRandom() * 17624813;
      Math.randomSeed = Math.seededRandom() * 9737333;
    }
  };
  Math.seededRandom = function(A2, e2) {
    if (Math.randomSeed === 0)
      Math.randomSeed = Math.random() * 999;
    A2 = A2 || 1;
    e2 = e2 || 0;
    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;
    const t2 = Math.randomSeed / 233280;
    return e2 + t2 * (A2 - e2);
  };
  i.isNumeric = function(A2) {
    return !isNaN(parseFloat(A2)) && isFinite(A2);
  };
  i.isArray = function(A2) {
    return Object.prototype.toString.call(A2) === "[object Array]";
  };
  String.prototype.endl = function() {
    return this + "\n";
  };
  String.prototype.startsWith = function(A2) {
    return this.indexOf(A2) === 0;
  };
  String.prototype.endsWith = String.prototype.endsWith || function(A2) {
    return this.match(A2 + "$") == A2;
  };
  String.prototype.contains = String.prototype.contains || function(A2) {
    return this.indexOf(A2) > -1;
  };
  const q = function(A2 = "") {
    if (!A2)
      return "";
    if (A2.startsWith("data:"))
      return;
    if (A2.contains("?"))
      A2 += "&";
    else
      A2 += "?";
    return A2 + "cache=" + CABLES.uuid();
  };
  const P = function(e2, t2) {
    if (!e2)
      return null;
    t2 = t2 || [];
    t2.length = e2.length;
    for (let A2 = 0; A2 < e2.length; A2++) {
      t2[A2] = e2[A2];
    }
    return t2;
  };
  const W = function(A2) {
    let e2 = CABLES.filename(A2);
    const t2 = e2.split(".");
    e2 = t2[0];
    return e2;
  };
  const X = function() {
    console.log("logstack", new Error().stack);
  };
  const z = function(A2) {
    let e2 = "";
    if (!A2)
      return "";
    if (A2.startsWith("data:") && A2.contains(":")) {
      const t3 = A2.split(",");
      return t3[0];
    }
    let t2 = (A2 + "").split("/");
    if (t2.length > 0) {
      const g2 = t2[t2.length - 1];
      let A3 = g2.split("?");
      e2 = A3[0];
    }
    return e2 || "";
  };
  const Z = function(A2, e2, t2, g2, i2) {
    a({ url: A2, cb: e2, method: t2, data: g2, contenttype: i2, sync: true });
  };
  const $ = function(A2, e2, t2, g2, i2, I2, n2 = {}, o2 = {}) {
    const C2 = { url: A2, cb: e2, method: t2, data: g2, contenttype: i2, sync: false, jsonP: I2, headers: n2 };
    if (o2 && o2.credentials)
      C2.credentials = o2.credentials;
    a(C2);
  };
  const a = function(e2) {
    if (!e2.hasOwnProperty("asynch"))
      e2.asynch = true;
    let t2;
    try {
      t2 = new XMLHttpRequest();
    } catch (A2) {
    }
    t2.onreadystatechange = function() {
      if (t2.readyState != 4)
        return;
      if (e2.cb) {
        if (t2.status == 200 || t2.status == 0)
          e2.cb(false, t2.responseText, t2);
        else
          e2.cb(true, t2.responseText, t2);
      }
    };
    try {
      t2.open(e2.method ? e2.method.toUpperCase() : "GET", e2.url, !e2.sync);
    } catch (A2) {
      if (e2.cb && A2)
        e2.cb(true, A2.msg, t2);
    }
    if (typeof e2.headers === "object") {
      if (e2.headers) {
        const g2 = Object.keys(e2.headers);
        for (let A2 = 0; A2 < g2.length; A2++) {
          const i2 = g2[A2];
          const I2 = e2.headers[i2];
          t2.setRequestHeader(i2, I2);
        }
      }
    }
    if (e2.credentials && e2.credentials !== "omit") {
      t2.withCredentials = true;
    }
    try {
      if (!e2.post && !e2.data) {
        t2.send();
      } else {
        t2.setRequestHeader("Content-type", e2.contenttype ? e2.contenttype : "application/x-www-form-urlencoded");
        t2.send(e2.data || e2.post);
      }
    } catch (A2) {
      if (e2.cb)
        e2.cb(true, A2.msg, t2);
    }
  };
  const AA = function(A2) {
    if (!A2 && A2 !== 0)
      return "Unidentified";
    const e2 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };
    if (e2[A2]) {
      return e2[A2];
    } else {
      return String.fromCharCode(A2);
    }
  };
  window.performance = window.performance || { offset: Date.now(), now: function A2() {
    return Date.now() - this.offset;
  } };
  const C = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const s = new Uint8Array(256);
  for (let A2 = 0; A2 < C.length; A2++)
    s[C.charCodeAt(A2)] = A2;
  const B = s;
  const eA = function(A2) {
    if (A2.buffer)
      A2 = A2.buffer;
    let e2 = new Uint8Array(A2), t2, g2 = e2.length, i2 = "";
    for (t2 = 0; t2 < g2; t2 += 3) {
      i2 += C[e2[t2] >> 2];
      i2 += C[(e2[t2] & 3) << 4 | e2[t2 + 1] >> 4];
      i2 += C[(e2[t2 + 1] & 15) << 2 | e2[t2 + 2] >> 6];
      i2 += C[e2[t2 + 2] & 63];
    }
    if (g2 % 3 === 2)
      i2 = i2.substring(0, i2.length - 1) + "=";
    else if (g2 % 3 === 1)
      i2 = i2.substring(0, i2.length - 2) + "==";
    return i2;
  };
  const Q = function(A2) {
    let e2 = A2.length * 0.75, t2 = A2.length, g2, i2 = 0, I2, n2, o2, C2;
    if (A2[A2.length - 1] === "=") {
      e2--;
      if (A2[A2.length - 2] === "=")
        e2--;
    }
    let a2 = new ArrayBuffer(e2), r2 = new Uint8Array(a2);
    for (g2 = 0; g2 < t2; g2 += 4) {
      I2 = B[A2.charCodeAt(g2)];
      n2 = B[A2.charCodeAt(g2 + 1)];
      o2 = B[A2.charCodeAt(g2 + 2)];
      C2 = B[A2.charCodeAt(g2 + 3)];
      r2[i2++] = I2 << 2 | n2 >> 4;
      r2[i2++] = (n2 & 15) << 4 | o2 >> 2;
      r2[i2++] = (o2 & 3) << 6 | C2 & 63;
    }
    return a2;
  };
  class E {
    constructor(A2) {
      this._init();
      this._first = true;
      this._wireMesh = null;
      if (A2)
        this.apply(A2);
    }
    _init() {
      this._max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
      this._min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
      this._center = [0, 0, 0];
      this._size = [0, 0, 0];
      this._maxAxis = 0;
      this._first = true;
    }
    get maxAxis() {
      return this._maxAxis || 1;
    }
    get size() {
      return this._size;
    }
    get center() {
      return this._center;
    }
    get x() {
      return this._center[0];
    }
    get y() {
      return this._center[1];
    }
    get z() {
      return this._center[2];
    }
    get minX() {
      return this._min[0];
    }
    get minY() {
      return this._min[1];
    }
    get minZ() {
      return this._min[2];
    }
    get maxX() {
      return this._max[0];
    }
    get maxY() {
      return this._max[1];
    }
    get maxZ() {
      return this._max[2];
    }
    apply(e2, A2) {
      if (!e2) {
        return;
      }
      if (e2 instanceof E) {
        const t2 = e2;
        this.applyPos(t2.maxX, t2.maxY, t2.maxZ);
        this.applyPos(t2.minX, t2.minY, t2.minZ);
      } else {
        for (let A3 = 0; A3 < e2.vertices.length; A3 += 3)
          this.applyPos(e2.vertices[A3], e2.vertices[A3 + 1], e2.vertices[A3 + 2]);
      }
      this.calcCenterSize();
    }
    copy() {
      return new E(this);
    }
    get changed() {
      return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE);
    }
    applyPos(A2, e2, t2) {
      if (A2 == Number.MAX_VALUE || A2 == -Number.MAX_VALUE || e2 == Number.MAX_VALUE || e2 == -Number.MAX_VALUE || t2 == Number.MAX_VALUE || t2 == -Number.MAX_VALUE)
        return;
      if (!CABLES.UTILS.isNumeric(A2) || !CABLES.UTILS.isNumeric(e2) || !CABLES.UTILS.isNumeric(t2))
        return;
      if (this._first) {
        this._max[0] = A2;
        this._max[1] = e2;
        this._max[2] = t2;
        this._min[0] = A2;
        this._min[1] = e2;
        this._min[2] = t2;
        this._first = false;
        return;
      }
      this._max[0] = Math.max(this._max[0], A2);
      this._max[1] = Math.max(this._max[1], e2);
      this._max[2] = Math.max(this._max[2], t2);
      this._min[0] = Math.min(this._min[0], A2);
      this._min[1] = Math.min(this._min[1], e2);
      this._min[2] = Math.min(this._min[2], t2);
    }
    calcCenterSize() {
      if (this._first)
        return;
      this._size[0] = this._max[0] - this._min[0];
      this._size[1] = this._max[1] - this._min[1];
      this._size[2] = this._max[2] - this._min[2];
      this._center[0] = (this._min[0] + this._max[0]) / 2;
      this._center[1] = (this._min[1] + this._max[1]) / 2;
      this._center[2] = (this._min[2] + this._max[2]) / 2;
      this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1]));
    }
    mulMat4(A2) {
      if (this._first) {
        this._max[0] = 0;
        this._max[1] = 0;
        this._max[2] = 0;
        this._min[0] = 0;
        this._min[1] = 0;
        this._min[2] = 0;
        this._first = false;
      }
      vec3.transformMat4(this._max, this._max, A2);
      vec3.transformMat4(this._min, this._min, A2);
      this.calcCenterSize();
    }
    render(A2, e2, t2) {
      if (!this._wireMesh)
        this._wireMesh = new CGL.WireCube(A2);
      A2.pushModelMatrix();
      mat4.translate(A2.mMatrix, A2.mMatrix, this._center);
      if (CABLES.UI && t2) {
        CABLES.UI.OverlayMeshes.drawCube(t2, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2);
      }
      A2.popModelMatrix();
    }
  }
  const l = function(A2) {
    this.name = A2 || "unknown";
    this._log = new r("cgl_geometry");
    this.faceVertCount = 3;
    this.glPrimitive = null;
    this._attributes = {};
    this._vertices = [];
    this.verticesIndices = [];
    this.isGeometry = true;
    this.morphTargets = [];
    Object.defineProperty(this, "vertices", { get() {
      return this._vertices;
    }, set(A3) {
      this.setVertices(A3);
    } });
    Object.defineProperty(this, "texCoords", { get() {
      const A3 = this.getAttribute("texCoords");
      if (!A3)
        return [];
      return A3.data;
    }, set(A3) {
      this.setAttribute("texCoords", A3, 2);
    } });
    Object.defineProperty(this, "vertexNormals", { get() {
      const A3 = this.getAttribute("vertexNormals");
      if (!A3)
        return [];
      return A3.data;
    }, set(A3) {
      this.setAttribute("vertexNormals", A3, 3);
    } });
    Object.defineProperty(this, "tangents", { get() {
      const A3 = this.getAttribute("tangents");
      if (!A3)
        return [];
      return A3.data;
    }, set(A3) {
      this.setAttribute("tangents", A3, 3);
    } });
    Object.defineProperty(this, "biTangents", { get() {
      const A3 = this.getAttribute("biTangents");
      if (!A3)
        return [];
      return A3.data;
    }, set(A3) {
      this.setAttribute("biTangents", A3, 3);
    } });
    Object.defineProperty(this, "vertexColors", { get() {
      const A3 = this.getAttribute("vertexColors");
      if (!A3)
        return [];
      return A3.data;
    }, set(A3) {
      this.setAttribute("vertexColors", A3, 4);
    } });
  };
  l.prototype.clear = function() {
    this._vertices = new Float32Array([]);
    this.verticesIndices = [];
    this.texCoords = new Float32Array([]);
    this.vertexNormals = new Float32Array([]);
    this.tangents = [];
    this.biTangents = [];
    this._attributes = {};
  };
  l.prototype.getAttributes = function() {
    return this._attributes;
  };
  l.prototype.getAttribute = function(A2) {
    for (const e2 in this._attributes) {
      if (this._attributes[e2].name == A2)
        return this._attributes[e2];
    }
    return null;
  };
  l.prototype.setAttribute = function(A2, e2, t2) {
    let g2 = "";
    if (!t2 || t2 > 4) {
      console.log("itemsize wrong?", t2, A2);
      this._log.stack("itemsize");
      t2 = 3;
    }
    if (t2 == 1)
      g2 = "float";
    else if (t2 == 2)
      g2 = "vec2";
    else if (t2 == 3)
      g2 = "vec3";
    else if (t2 == 4)
      g2 = "vec4";
    const i2 = { name: A2, data: e2, itemSize: t2, type: g2 };
    this._attributes[A2] = i2;
  };
  l.prototype.copyAttribute = function(A2, e2) {
    const t2 = this.getAttribute(A2);
    e2.setAttribute(A2, new Float32Array(t2.data), t2.itemSize);
  };
  l.prototype.setVertices = function(A2) {
    if (A2 instanceof Float32Array)
      this._vertices = A2;
    else
      this._vertices = new Float32Array(A2);
  };
  l.prototype.setTexCoords = function(A2) {
    if (A2 instanceof Float32Array)
      this.texCoords = A2;
    else
      this.texCoords = new Float32Array(A2);
  };
  l.prototype.calcNormals = function(A2) {
    const e2 = { smooth: A2 };
    this.calculateNormals(e2);
  };
  l.prototype.flipNormals = function(e2, t2, g2) {
    let i2 = vec3.create();
    if (e2 == void 0)
      e2 = 1;
    if (t2 == void 0)
      t2 = 1;
    if (g2 == void 0)
      g2 = 1;
    for (let A2 = 0; A2 < this.vertexNormals.length; A2 += 3) {
      vec3.set(i2, this.vertexNormals[A2 + 0], this.vertexNormals[A2 + 1], this.vertexNormals[A2 + 2]);
      i2[0] *= -e2;
      i2[1] *= -t2;
      i2[2] *= -g2;
      vec3.normalize(i2, i2);
      this.vertexNormals[A2 + 0] = i2[0];
      this.vertexNormals[A2 + 1] = i2[1];
      this.vertexNormals[A2 + 2] = i2[2];
    }
  };
  l.prototype.getNumTriangles = function() {
    if (this.verticesIndices && this.verticesIndices.length)
      return this.verticesIndices.length / 3;
    return this.vertices.length / 3;
  };
  l.prototype.flipVertDir = function() {
    const e2 = [];
    e2.length = this.verticesIndices.length;
    for (let A2 = 0; A2 < this.verticesIndices.length; A2 += 3) {
      e2[A2] = this.verticesIndices[A2 + 2];
      e2[A2 + 1] = this.verticesIndices[A2 + 1];
      e2[A2 + 2] = this.verticesIndices[A2];
    }
    this.verticesIndices = e2;
  };
  l.prototype.setPointVertices = function(e2) {
    if (e2.length % 3 !== 0) {
      this._log.error("SetPointVertices: Array must be multiple of three.");
      return;
    }
    if (!(e2 instanceof Float32Array))
      this.vertices = new Float32Array(e2);
    else
      this.vertices = e2;
    if (!(this.texCoords instanceof Float32Array))
      this.texCoords = new Float32Array(e2.length / 3 * 2);
    this.verticesIndices.length = e2.length / 3;
    for (let A2 = 0; A2 < e2.length / 3; A2++) {
      this.verticesIndices[A2] = A2;
      this.texCoords[A2 * 2] = 0;
      this.texCoords[A2 * 2 + 1] = 0;
    }
  };
  l.prototype.merge = function(e2) {
    if (!e2)
      return;
    if (this.isIndexed() != e2.isIndexed()) {
      if (this.isIndexed()) {
        this.unIndex(false, true);
      }
      if (e2.isIndexed()) {
        const A2 = e2.copy();
        A2.unIndex(false, true);
        e2 = A2;
      }
    }
    const t2 = this.verticesIndices.length;
    const g2 = this._vertices.length / 3;
    this.verticesIndices.length += e2.verticesIndices.length;
    for (let A2 = 0; A2 < e2.verticesIndices.length; A2++)
      this.verticesIndices[t2 + A2] = e2.verticesIndices[A2] + g2;
    this.vertices = i.float32Concat(this._vertices, e2.vertices);
    this.texCoords = i.float32Concat(this.texCoords, e2.texCoords);
    this.vertexNormals = i.float32Concat(this.vertexNormals, e2.vertexNormals);
    this.tangents = i.float32Concat(this.tangents, e2.tangents);
    this.biTangents = i.float32Concat(this.biTangents, e2.biTangents);
  };
  l.prototype.copy = function() {
    const e2 = new l(this.name + " copy");
    e2.faceVertCount = this.faceVertCount;
    e2.glPrimitive = this.glPrimitive;
    e2.setVertices(this._vertices.slice(0));
    if (this.verticesIndices) {
      e2.verticesIndices.length = this.verticesIndices.length;
      for (let A2 = 0; A2 < this.verticesIndices.length; A2++)
        e2.verticesIndices[A2] = this.verticesIndices[A2];
    }
    for (let A2 in this._attributes)
      this.copyAttribute(A2, e2);
    e2.morphTargets.length = this.morphTargets.length;
    for (let A2 = 0; A2 < this.morphTargets.length; A2++)
      e2.morphTargets[A2] = this.morphTargets[A2];
    return e2;
  };
  l.prototype.calculateNormals = function(e2) {
    e2 = e2 || {};
    if (e2.smooth === false)
      this.unIndex();
    const t2 = vec3.create();
    const g2 = vec3.create();
    const i2 = vec3.create();
    function I2(A2) {
      vec3.subtract(t2, A2[0], A2[1]);
      vec3.subtract(g2, A2[0], A2[2]);
      vec3.cross(i2, t2, g2);
      vec3.normalize(i2, i2);
      if (e2 && e2.forceZUp) {
        if (i2[2] < 0) {
          i2[0] *= -1;
          i2[1] *= -1;
          i2[2] *= -1;
        }
      }
      return i2;
    }
    this.getVertexVec = function(A2) {
      const e3 = [0, 0, 0];
      e3[0] = this.vertices[A2 * 3 + 0];
      e3[1] = this.vertices[A2 * 3 + 1];
      e3[2] = this.vertices[A2 * 3 + 2];
      return e3;
    };
    if (!(this.vertexNormals instanceof Float32Array) || this.vertexNormals.length != this.vertices.length)
      this.vertexNormals = new Float32Array(this.vertices.length);
    for (let A2 = 0; A2 < this.vertices.length; A2++) {
      this.vertexNormals[A2] = 0;
    }
    if (!this.isIndexed()) {
      const n2 = [];
      for (let A2 = 0; A2 < this.vertices.length; A2 += 9) {
        const o2 = [[this.vertices[A2 + 0], this.vertices[A2 + 1], this.vertices[A2 + 2]], [this.vertices[A2 + 3], this.vertices[A2 + 4], this.vertices[A2 + 5]], [this.vertices[A2 + 6], this.vertices[A2 + 7], this.vertices[A2 + 8]]];
        const C2 = I2(o2);
        n2.push(C2[0], C2[1], C2[2], C2[0], C2[1], C2[2], C2[0], C2[1], C2[2]);
      }
      this.vertexNormals = n2;
    } else {
      const a2 = [];
      a2.length = Math.floor(this.verticesIndices.length / 3);
      for (let A2 = 0; A2 < this.verticesIndices.length; A2 += 3) {
        const o2 = [this.getVertexVec(this.verticesIndices[A2 + 0]), this.getVertexVec(this.verticesIndices[A2 + 1]), this.getVertexVec(this.verticesIndices[A2 + 2])];
        a2[A2 / 3] = I2(o2);
        this.vertexNormals[this.verticesIndices[A2 + 0] * 3 + 0] += a2[A2 / 3][0];
        this.vertexNormals[this.verticesIndices[A2 + 0] * 3 + 1] += a2[A2 / 3][1];
        this.vertexNormals[this.verticesIndices[A2 + 0] * 3 + 2] += a2[A2 / 3][2];
        this.vertexNormals[this.verticesIndices[A2 + 1] * 3 + 0] += a2[A2 / 3][0];
        this.vertexNormals[this.verticesIndices[A2 + 1] * 3 + 1] += a2[A2 / 3][1];
        this.vertexNormals[this.verticesIndices[A2 + 1] * 3 + 2] += a2[A2 / 3][2];
        this.vertexNormals[this.verticesIndices[A2 + 2] * 3 + 0] += a2[A2 / 3][0];
        this.vertexNormals[this.verticesIndices[A2 + 2] * 3 + 1] += a2[A2 / 3][1];
        this.vertexNormals[this.verticesIndices[A2 + 2] * 3 + 2] += a2[A2 / 3][2];
      }
      for (let e3 = 0; e3 < this.verticesIndices.length; e3 += 3) {
        for (let A2 = 0; A2 < 3; A2++) {
          const r2 = [this.vertexNormals[this.verticesIndices[e3 + A2] * 3 + 0], this.vertexNormals[this.verticesIndices[e3 + A2] * 3 + 1], this.vertexNormals[this.verticesIndices[e3 + A2] * 3 + 2]];
          vec3.normalize(r2, r2);
          this.vertexNormals[this.verticesIndices[e3 + A2] * 3 + 0] = r2[0];
          this.vertexNormals[this.verticesIndices[e3 + A2] * 3 + 1] = r2[1];
          this.vertexNormals[this.verticesIndices[e3 + A2] * 3 + 2] = r2[2];
        }
      }
    }
  };
  l.prototype.calcTangentsBitangents = function() {
    if (!this.vertices.length) {
      return;
    }
    if (!this.vertexNormals.length) {
      return;
    }
    if (!this.texCoords.length) {
      const d2 = this.vertices.length / 3 * 2;
      this.texCoords = new Float32Array(d2);
      for (let A2 = 0; A2 < d2; A2 += 1)
        this.texCoords[A2] = 0;
    }
    if (!this.verticesIndices || !this.verticesIndices.length) {
      return;
    }
    if (this.verticesIndices.length % 3 !== 0) {
      this._log.error("Vertex indices mismatch!");
      return;
    }
    const e2 = this.verticesIndices.length / 3;
    const t2 = this.vertices.length / 3;
    this.tangents = new Float32Array(this.vertexNormals.length);
    this.biTangents = new Float32Array(this.vertexNormals.length);
    const g2 = [];
    g2.length = t2 * 2;
    const i2 = vec3.create();
    const I2 = vec3.create();
    const n2 = vec3.create();
    const o2 = vec2.create();
    const C2 = vec2.create();
    const a2 = vec2.create();
    const r2 = vec3.create();
    const s2 = vec3.create();
    for (let A2 = 0; A2 < e2; A2 += 1) {
      const m2 = this.verticesIndices[A2 * 3];
      const f2 = this.verticesIndices[A2 * 3 + 1];
      const D2 = this.verticesIndices[A2 * 3 + 2];
      vec3.set(i2, this.vertices[m2 * 3], this.vertices[m2 * 3 + 1], this.vertices[m2 * 3 + 2]);
      vec3.set(I2, this.vertices[f2 * 3], this.vertices[f2 * 3 + 1], this.vertices[f2 * 3 + 2]);
      vec3.set(n2, this.vertices[D2 * 3], this.vertices[D2 * 3 + 1], this.vertices[D2 * 3 + 2]);
      vec2.set(o2, this.texCoords[m2 * 2], this.texCoords[m2 * 2 + 1]);
      vec2.set(C2, this.texCoords[f2 * 2], this.texCoords[f2 * 2 + 1]);
      vec2.set(a2, this.texCoords[D2 * 2], this.texCoords[D2 * 2 + 1]);
      const y2 = I2[0] - i2[0];
      const b2 = n2[0] - i2[0];
      const N2 = I2[1] - i2[1];
      const S2 = n2[1] - i2[1];
      const w2 = I2[2] - i2[2];
      const R2 = n2[2] - i2[2];
      const G2 = C2[0] - o2[0];
      const _2 = a2[0] - o2[0];
      const F2 = C2[1] - o2[1];
      const M2 = a2[1] - o2[1];
      const U2 = 1 / (G2 * M2 - _2 * F2);
      vec3.set(r2, (M2 * y2 - F2 * b2) * U2, (M2 * N2 - F2 * S2) * U2, (M2 * w2 - F2 * R2) * U2);
      vec3.set(s2, (G2 * b2 - _2 * y2) * U2, (G2 * S2 - _2 * N2) * U2, (G2 * R2 - _2 * w2) * U2);
      g2[m2] = r2;
      g2[f2] = r2;
      g2[D2] = r2;
      g2[m2 + t2] = s2;
      g2[f2 + t2] = s2;
      g2[D2 + t2] = s2;
    }
    const B2 = vec3.create();
    const Q2 = vec3.create();
    const E2 = vec3.create();
    const l2 = vec3.create();
    const u2 = vec3.create();
    const c2 = vec3.create();
    const h2 = vec3.create();
    const p2 = vec3.create();
    for (let A2 = 0; A2 < t2; A2 += 1) {
      if (!g2[A2])
        continue;
      vec3.set(B2, this.vertexNormals[A2 * 3], this.vertexNormals[A2 * 3 + 1], this.vertexNormals[A2 * 3 + 2]);
      vec3.set(Q2, g2[A2][0], g2[A2][1], g2[A2][2]);
      const L2 = vec3.dot(B2, Q2);
      vec3.scale(u2, B2, L2);
      vec3.subtract(c2, Q2, u2);
      vec3.normalize(p2, c2);
      vec3.cross(h2, B2, Q2);
      const v2 = 1;
      vec3.scale(E2, p2, 1 / v2);
      vec3.cross(l2, B2, E2);
      this.tangents[A2 * 3 + 0] = E2[0];
      this.tangents[A2 * 3 + 1] = E2[1];
      this.tangents[A2 * 3 + 2] = E2[2];
      this.biTangents[A2 * 3 + 0] = l2[0];
      this.biTangents[A2 * 3 + 1] = l2[1];
      this.biTangents[A2 * 3 + 2] = l2[2];
    }
  };
  l.prototype.isIndexed = function() {
    if (this._vertices.length == 0)
      return true;
    return this.verticesIndices.length != 0;
  };
  l.prototype.unIndex = function(A2, e2) {
    const t2 = [];
    const g2 = [];
    let i2 = 0;
    for (let A3 in this._attributes) {
      const I2 = this._attributes[A3];
      let t3 = [];
      for (let e3 = 0; e3 < this.verticesIndices.length; e3 += 3) {
        for (let A4 = 0; A4 < 3; A4++) {
          if (I2.itemSize == 3)
            t3.push(I2.data[this.verticesIndices[e3 + A4] * 3 + 0], I2.data[this.verticesIndices[e3 + A4] * 3 + 1], I2.data[this.verticesIndices[e3 + A4] * 3 + 2]);
          else if (I2.itemSize == 4)
            t3.push(I2.data[this.verticesIndices[e3 + A4] * 4 + 0], I2.data[this.verticesIndices[e3 + A4] * 4 + 1], I2.data[this.verticesIndices[e3 + A4] * 4 + 2], I2.data[this.verticesIndices[e3 + A4] * 4 + 3]);
          else if (I2.itemSize == 2)
            t3.push(I2.data[this.verticesIndices[e3 + A4] * 2 + 0], I2.data[this.verticesIndices[e3 + A4] * 2 + 1]);
          else if (I2.itemSize == 1)
            t3.push(I2.data[this.verticesIndices[e3 + A4]]);
          else
            console.log("unknown attr", I2);
        }
      }
      this.setAttribute(I2.name, t3, I2.itemSize);
    }
    for (let A3 = 0; A3 < this.verticesIndices.length; A3 += 3) {
      t2.push(this.vertices[this.verticesIndices[A3 + 0] * 3 + 0], this.vertices[this.verticesIndices[A3 + 0] * 3 + 1], this.vertices[this.verticesIndices[A3 + 0] * 3 + 2]);
      g2.push(i2);
      i2++;
      t2.push(this.vertices[this.verticesIndices[A3 + 1] * 3 + 0], this.vertices[this.verticesIndices[A3 + 1] * 3 + 1], this.vertices[this.verticesIndices[A3 + 1] * 3 + 2]);
      g2.push(i2);
      i2++;
      t2.push(this.vertices[this.verticesIndices[A3 + 2] * 3 + 0], this.vertices[this.verticesIndices[A3 + 2] * 3 + 1], this.vertices[this.verticesIndices[A3 + 2] * 3 + 2]);
      g2.push(i2);
      i2++;
    }
    this.vertices = t2;
    this.verticesIndices = [];
    if (A2)
      this.verticesIndices = g2;
    if (!e2)
      this.calculateNormals();
  };
  l.prototype.calcBarycentric = function() {
    let e2 = [];
    e2.length = this.vertices.length;
    for (let A2 = 0; A2 < this.vertices.length; A2++)
      e2[A2] = 0;
    let t2 = 0;
    for (let A2 = 0; A2 < this.vertices.length; A2 += 3) {
      e2[A2 + t2] = 1;
      t2++;
      if (t2 == 3)
        t2 = 0;
    }
    this.setAttribute("attrBarycentric", e2, 3);
  };
  l.prototype.getBounds = function() {
    return new E(this);
  };
  l.prototype.center = function(A2, e2, t2) {
    if (A2 === void 0) {
      A2 = true;
      e2 = true;
      t2 = true;
    }
    let g2 = 0;
    const i2 = this.getBounds();
    const I2 = [i2.minX + (i2.maxX - i2.minX) / 2, i2.minY + (i2.maxY - i2.minY) / 2, i2.minZ + (i2.maxZ - i2.minZ) / 2];
    for (g2 = 0; g2 < this.vertices.length; g2 += 3) {
      if (this.vertices[g2 + 0] == this.vertices[g2 + 0]) {
        if (A2)
          this.vertices[g2 + 0] -= I2[0];
        if (e2)
          this.vertices[g2 + 1] -= I2[1];
        if (t2)
          this.vertices[g2 + 2] -= I2[2];
      }
    }
    return I2;
  };
  l.prototype.mapTexCoords2d = function() {
    const e2 = this.getBounds();
    const t2 = this.vertices.length / 3;
    this.texCoords = new Float32Array(t2 * 2);
    for (let A2 = 0; A2 < t2; A2++) {
      const g2 = this.vertices[A2 * 3 + 0];
      const i2 = this.vertices[A2 * 3 + 1];
      this.texCoords[A2 * 2 + 0] = g2 / (e2.maxX - e2.minX) + 0.5;
      this.texCoords[A2 * 2 + 1] = 1 - i2 / (e2.maxY - e2.minY) + 0.5;
    }
  };
  l.prototype.getInfoOneLine = function() {
    let A2 = "";
    if (this.faceVertCount == 3 && this.verticesIndices)
      A2 += this.verticesIndices.length / 3;
    else
      A2 += 0;
    A2 += " tris ";
    if (this.vertices)
      A2 += this.vertices.length / 3;
    else
      A2 += 0;
    A2 += " verts";
    return A2;
  };
  l.prototype.getInfo = function() {
    const A2 = {};
    if (this.faceVertCount == 3 && this.verticesIndices)
      A2.numFaces = this.verticesIndices.length / 3;
    else
      A2.numFaces = 0;
    if (this.verticesIndices && this.verticesIndices.length)
      A2.indices = this.verticesIndices.length;
    if (this.vertices)
      A2.numVerts = this.vertices.length / 3;
    else
      A2.numVerts = 0;
    if (this.vertexNormals)
      A2.numNormals = this.vertexNormals.length / 3;
    else
      A2.numNormals = 0;
    if (this.texCoords)
      A2.numTexCoords = this.texCoords.length / 2;
    else
      A2.numTexCoords = 0;
    if (this.tangents)
      A2.numTangents = this.tangents.length / 3;
    else
      A2.numTangents = 0;
    if (this.biTangents)
      A2.numBiTangents = this.biTangents.length / 3;
    else
      A2.numBiTangents = 0;
    if (this.biTangents)
      A2.numBiTangents = this.biTangents.length / 3;
    else
      A2.numBiTangents = 0;
    if (this.vertexColors)
      A2.numVertexColors = this.vertexColors.length / 4;
    else
      A2.numVertexColors = 0;
    if (this.getAttributes())
      A2.numAttribs = Object.keys(this.getAttributes()).length;
    else
      A2.numAttribs = 0;
    A2.isIndexed = this.isIndexed();
    return A2;
  };
  l.buildFromFaces = function(e2, A2, t2) {
    const g2 = [];
    const i2 = [];
    for (let A3 = 0; A3 < e2.length; A3 += 3) {
      const n2 = e2[A3 + 0];
      const o2 = e2[A3 + 1];
      const C2 = e2[A3 + 2];
      const a2 = [-1, -1, -1];
      if (t2)
        for (let A4 = 0; A4 < g2.length; A4 += 3) {
          if (g2[A4 + 0] == n2[0] && g2[A4 + 1] == n2[1] && g2[A4 + 2] == n2[2])
            a2[0] = A4 / 3;
          if (g2[A4 + 0] == o2[0] && g2[A4 + 1] == o2[1] && g2[A4 + 2] == o2[2])
            a2[1] = A4 / 3;
          if (g2[A4 + 0] == C2[0] && g2[A4 + 1] == C2[1] && g2[A4 + 2] == C2[2])
            a2[2] = A4 / 3;
        }
      if (a2[0] == -1) {
        g2.push(n2[0], n2[1], n2[2]);
        a2[0] = (g2.length - 1) / 3;
      }
      if (a2[1] == -1) {
        g2.push(o2[0], o2[1], o2[2]);
        a2[1] = (g2.length - 1) / 3;
      }
      if (a2[2] == -1) {
        g2.push(C2[0], C2[1], C2[2]);
        a2[2] = (g2.length - 1) / 3;
      }
      i2.push(parseInt(a2[0], 10));
      i2.push(parseInt(a2[1], 10));
      i2.push(parseInt(a2[2], 10));
    }
    const I2 = new l(A2);
    I2.name = A2;
    I2.vertices = g2;
    I2.verticesIndices = i2;
    return I2;
  };
  l.json2geom = function(e2) {
    const t2 = new l("jsonMeshGeom");
    t2.verticesIndices = [];
    t2.vertices = e2.vertices || [];
    t2.vertexNormals = e2.normals || [];
    t2.vertexColors = e2.colors || [];
    t2.tangents = e2.tangents || [];
    t2.biTangents = e2.bitangents || [];
    if (e2.texturecoords)
      t2.setTexCoords(e2.texturecoords[0]);
    if (e2.vertices_b64)
      t2.vertices = new Float32Array(Q(e2.vertices_b64));
    if (e2.normals_b64)
      t2.vertexNormals = new Float32Array(Q(e2.normals_b64));
    if (e2.tangents_b64)
      t2.tangents = new Float32Array(Q(e2.tangents_b64));
    if (e2.bitangents_b64)
      t2.biTangents = new Float32Array(Q(e2.bitangents_b64));
    if (e2.texturecoords_b64)
      t2.setTexCoords(new Float32Array(Q(e2.texturecoords_b64[0])));
    if (e2.faces_b64) {
      t2.verticesIndices = new Uint32Array(Q(e2.faces_b64));
    } else {
      t2.verticesIndices.length = e2.faces.length * 3;
      for (let A2 = 0; A2 < e2.faces.length; A2++) {
        t2.verticesIndices[A2 * 3] = e2.faces[A2][0];
        t2.verticesIndices[A2 * 3 + 1] = e2.faces[A2][1];
        t2.verticesIndices[A2 * 3 + 2] = e2.faces[A2][2];
      }
    }
    return t2;
  };
  const u = function() {
    this._log = new r("eventtarget");
    this._eventCallbacks = {};
    this._logName = "";
    this._logEvents = false;
    this._listeners = {};
    this.addEventListener = this.on = function(A2, e2, t2) {
      const g2 = { id: (t2 || "") + CABLES.simpleId(), name: A2, cb: e2 };
      if (!this._eventCallbacks[A2])
        this._eventCallbacks[A2] = [g2];
      else
        this._eventCallbacks[A2].push(g2);
      this._listeners[g2.id] = g2;
      return g2.id;
    };
    this.hasEventListener = function(A2, e2) {
      if (A2 && !e2) {
        if (this._listeners[A2])
          return true;
        else
          return false;
      } else {
        this._log.warn("old eventtarget function haseventlistener!");
        if (A2 && e2) {
          if (this._eventCallbacks[A2]) {
            const t2 = this._eventCallbacks[A2].indexOf(e2);
            if (t2 == -1)
              return false;
            return true;
          }
        }
      }
    };
    this.hasListenerForEventName = function(A2) {
      return this._eventCallbacks[A2] && this._eventCallbacks[A2].length > 0;
    };
    this.removeEventListener = this.off = function(g2, e2) {
      if (g2 === null || g2 === void 0)
        return;
      if (!e2) {
        const i2 = this._listeners[g2];
        if (!i2) {
          this._log.log("could not find event...");
          return;
        }
        let t3 = true;
        while (t3) {
          t3 = false;
          let e3 = -1;
          for (let A2 = 0; A2 < this._eventCallbacks[i2.name].length; A2++) {
            if (this._eventCallbacks[i2.name][A2].id.startsWith(g2)) {
              t3 = true;
              e3 = A2;
            }
          }
          if (e3 !== -1) {
            this._eventCallbacks[i2.name].splice(e3, 1);
            delete this._listeners[g2];
          }
        }
        return;
      }
      this._log.info("[eventtaget] ", "old function signature: removeEventListener! use listener id");
      this._log.log(new Error().stack);
      let t2 = null;
      for (let A2 = 0; A2 < this._eventCallbacks[g2].length; A2++)
        if (this._eventCallbacks[g2][A2].cb == e2)
          t2 = A2;
      if (t2 !== null) {
        delete this._eventCallbacks[t2];
      } else
        this._log.warn("removeEventListener not found " + g2);
    };
    this.logEvents = function(A2, e2) {
      this._logEvents = A2;
      this._logName = e2;
    };
    this.emitEvent = function(e2, t2, g2, i2, I2, n2, o2) {
      if (this._logEvents)
        this._log.log("[event] ", this._logName, e2, this._eventCallbacks);
      if (this._eventCallbacks[e2]) {
        for (let A2 = 0; A2 < this._eventCallbacks[e2].length; A2++) {
          if (this._eventCallbacks[e2][A2]) {
            this._eventCallbacks[e2][A2].cb(t2, g2, i2, I2, n2, o2);
          }
        }
      } else {
        if (this._logEvents)
          this._log.log("[event] has no event callback", e2, this._eventCallbacks);
      }
    };
  };
  const c = { ANIM: { EASINGS: ["linear", "absolute", "smoothstep", "smootherstep", "Cubic In", "Cubic Out", "Cubic In Out", "Expo In", "Expo Out", "Expo In Out", "Sin In", "Sin Out", "Sin In Out", "Quart In", "Quart Out", "Quart In Out", "Quint In", "Quint Out", "Quint In Out", "Back In", "Back Out", "Back In Out", "Elastic In", "Elastic Out", "Bounce In", "Bounce Out"], EASING_LINEAR: 0, EASING_ABSOLUTE: 1, EASING_SMOOTHSTEP: 2, EASING_SMOOTHERSTEP: 3, EASING_CUBICSPLINE: 4, EASING_CUBIC_IN: 5, EASING_CUBIC_OUT: 6, EASING_CUBIC_INOUT: 7, EASING_EXPO_IN: 8, EASING_EXPO_OUT: 9, EASING_EXPO_INOUT: 10, EASING_SIN_IN: 11, EASING_SIN_OUT: 12, EASING_SIN_INOUT: 13, EASING_BACK_IN: 14, EASING_BACK_OUT: 15, EASING_BACK_INOUT: 16, EASING_ELASTIC_IN: 17, EASING_ELASTIC_OUT: 18, EASING_BOUNCE_IN: 19, EASING_BOUNCE_OUT: 21, EASING_QUART_IN: 22, EASING_QUART_OUT: 23, EASING_QUART_INOUT: 24, EASING_QUINT_IN: 25, EASING_QUINT_OUT: 26, EASING_QUINT_INOUT: 27 }, OP: { OP_PORT_TYPE_VALUE: 0, OP_PORT_TYPE_NUMBER: 0, OP_PORT_TYPE_FUNCTION: 1, OP_PORT_TYPE_TRIGGER: 1, OP_PORT_TYPE_OBJECT: 2, OP_PORT_TYPE_TEXTURE: 2, OP_PORT_TYPE_ARRAY: 3, OP_PORT_TYPE_DYNAMIC: 4, OP_PORT_TYPE_STRING: 5, OP_VERSION_PREFIX: "_v" }, PORT: { PORT_DIR_IN: 0, PORT_DIR_OUT: 1 }, PACO: { PACO_CLEAR: 0, PACO_VALUECHANGE: 1, PACO_OP_DELETE: 2, PACO_UNLINK: 3, PACO_LINK: 4, PACO_LOAD: 5, PACO_OP_CREATE: 6, PACO_OP_ENABLE: 7, PACO_OP_DISABLE: 8, PACO_UIATTRIBS: 9, PACO_VARIABLES: 10, PACO_TRIGGERS: 11, PACO_PORT_SETVARIABLE: 12, PACO_PORT_SETANIMATED: 13, PACO_PORT_ANIM_UPDATED: 14, PACO_DESERIALIZE: 15 } };
  const h = function(A2) {
    this.time = 0;
    this.value = 0;
    this.onChange = null;
    this._easing = 0;
    this.cb = null;
    this.cbTriggered = false;
    this.setEasing(c.ANIM.EASING_LINEAR);
    this.set(A2);
  };
  h.cubicSpline = function(A2, e2, t2) {
    let g2 = e2.value, i2 = e2.bezTangOut, I2 = t2.value, n2 = t2.bezTangIn;
    let o2 = A2;
    let C2 = o2 * o2;
    let a2 = C2 * o2;
    return (2 * a2 - 3 * C2 + 1) * g2 + (a2 - 2 * C2 + o2) * i2 + (-2 * a2 + 3 * C2) * I2 + (a2 - C2) * n2;
  };
  h.easeCubicSpline = function(A2, e2) {
    return h.cubicSpline(A2, this, e2);
  };
  h.linear = function(A2, e2, t2) {
    return parseFloat(e2.value) + parseFloat(t2.value - e2.value) * A2;
  };
  h.easeLinear = function(A2, e2) {
    return h.linear(A2, this, e2);
  };
  h.easeAbsolute = function(A2, e2) {
    return this.value;
  };
  const p = function(A2) {
    return A2 = 2 ** (10 * (A2 - 1));
  };
  h.easeExpoIn = function(A2, e2) {
    A2 = p(A2);
    return h.linear(A2, this, e2);
  };
  const d = function(A2) {
    A2 = -(2 ** (-10 * A2)) + 1;
    return A2;
  };
  h.easeExpoOut = function(A2, e2) {
    A2 = d(A2);
    return h.linear(A2, this, e2);
  };
  const m = function(A2) {
    A2 *= 2;
    if (A2 < 1) {
      A2 = 0.5 * 2 ** (10 * (A2 - 1));
    } else {
      A2--;
      A2 = 0.5 * (-(2 ** (-10 * A2)) + 2);
    }
    return A2;
  };
  h.easeExpoInOut = function(A2, e2) {
    A2 = m(A2);
    return h.linear(A2, this, e2);
  };
  h.easeSinIn = function(A2, e2) {
    A2 = -1 * Math.cos(A2 * Math.PI / 2) + 1;
    return h.linear(A2, this, e2);
  };
  h.easeSinOut = function(A2, e2) {
    A2 = Math.sin(A2 * Math.PI / 2);
    return h.linear(A2, this, e2);
  };
  h.easeSinInOut = function(A2, e2) {
    A2 = -0.5 * (Math.cos(Math.PI * A2) - 1);
    return h.linear(A2, this, e2);
  };
  const f = function(A2) {
    A2 = A2 * A2 * A2;
    return A2;
  };
  h.easeCubicIn = function(A2, e2) {
    A2 = f(A2);
    return h.linear(A2, this, e2);
  };
  h.easeInQuint = function(A2, e2) {
    A2 = A2 * A2 * A2 * A2 * A2;
    return h.linear(A2, this, e2);
  };
  h.easeOutQuint = function(A2, e2) {
    A2 = (A2 -= 1) * A2 * A2 * A2 * A2 + 1;
    return h.linear(A2, this, e2);
  };
  h.easeInOutQuint = function(A2, e2) {
    if ((A2 /= 0.5) < 1)
      A2 = 0.5 * A2 * A2 * A2 * A2 * A2;
    else
      A2 = 0.5 * ((A2 -= 2) * A2 * A2 * A2 * A2 + 2);
    return h.linear(A2, this, e2);
  };
  h.easeInQuart = function(A2, e2) {
    A2 = A2 * A2 * A2 * A2;
    return h.linear(A2, this, e2);
  };
  h.easeOutQuart = function(A2, e2) {
    A2 = -1 * ((A2 -= 1) * A2 * A2 * A2 - 1);
    return h.linear(A2, this, e2);
  };
  h.easeInOutQuart = function(A2, e2) {
    if ((A2 /= 0.5) < 1)
      A2 = 0.5 * A2 * A2 * A2 * A2;
    else
      A2 = -0.5 * ((A2 -= 2) * A2 * A2 * A2 - 2);
    return h.linear(A2, this, e2);
  };
  h.bounce = function(A2) {
    if ((A2 /= 1) < 1 / 2.75)
      A2 = 7.5625 * A2 * A2;
    else if (A2 < 2 / 2.75)
      A2 = 7.5625 * (A2 -= 1.5 / 2.75) * A2 + 0.75;
    else if (A2 < 2.5 / 2.75)
      A2 = 7.5625 * (A2 -= 2.25 / 2.75) * A2 + 0.9375;
    else
      A2 = 7.5625 * (A2 -= 2.625 / 2.75) * A2 + 0.984375;
    return A2;
  };
  h.easeInBounce = function(A2, e2) {
    return h.linear(h.bounce(A2), this, e2);
  };
  h.easeOutBounce = function(A2, e2) {
    return h.linear(h.bounce(A2), this, e2);
  };
  h.easeInElastic = function(A2, e2) {
    let t2 = 1.70158;
    let g2 = 0;
    let i2 = 1;
    const I2 = 0;
    const n2 = 1;
    const o2 = 1;
    if (A2 === 0)
      A2 = I2;
    else if ((A2 /= n2) == 1)
      A2 = I2 + o2;
    else {
      if (!g2)
        g2 = n2 * 0.3;
      if (i2 < Math.abs(o2)) {
        i2 = o2;
        t2 = g2 / 4;
      } else
        t2 = g2 / (2 * Math.PI) * Math.asin(o2 / i2);
      A2 = -(i2 * 2 ** (10 * (A2 -= 1)) * Math.sin((A2 * n2 - t2) * (2 * Math.PI) / g2)) + I2;
    }
    return h.linear(A2, this, e2);
  };
  h.easeOutElastic = function(A2, e2) {
    let t2 = 1.70158;
    let g2 = 0;
    let i2 = 1;
    const I2 = 0;
    const n2 = 1;
    const o2 = 1;
    if (A2 === 0)
      A2 = I2;
    else if ((A2 /= n2) == 1)
      A2 = I2 + o2;
    else {
      if (!g2)
        g2 = n2 * 0.3;
      if (i2 < Math.abs(o2)) {
        i2 = o2;
        t2 = g2 / 4;
      } else
        t2 = g2 / (2 * Math.PI) * Math.asin(o2 / i2);
      A2 = i2 * 2 ** (-10 * A2) * Math.sin((A2 * n2 - t2) * (2 * Math.PI) / g2) + o2 + I2;
    }
    return h.linear(A2, this, e2);
  };
  h.easeInBack = function(A2, e2) {
    const t2 = 1.70158;
    A2 = A2 * A2 * ((t2 + 1) * A2 - t2);
    return h.linear(A2, this, e2);
  };
  h.easeOutBack = function(A2, e2) {
    const t2 = 1.70158;
    A2 = (A2 = A2 / 1 - 1) * A2 * ((t2 + 1) * A2 + t2) + 1;
    return h.linear(A2, this, e2);
  };
  h.easeInOutBack = function(A2, e2) {
    let t2 = 1.70158;
    const g2 = 1 / 2;
    if ((A2 /= 1 / 2) < 1)
      A2 = g2 * (A2 * A2 * (((t2 *= 1.525) + 1) * A2 - t2));
    else
      A2 = g2 * ((A2 -= 2) * A2 * (((t2 *= 1.525) + 1) * A2 + t2) + 2);
    return h.linear(A2, this, e2);
  };
  const D = function(A2) {
    A2--;
    A2 = A2 * A2 * A2 + 1;
    return A2;
  };
  h.easeCubicOut = function(A2, e2) {
    A2 = D(A2);
    return h.linear(A2, this, e2);
  };
  const y = function(A2) {
    A2 *= 2;
    if (A2 < 1)
      A2 = 0.5 * A2 * A2 * A2;
    else {
      A2 -= 2;
      A2 = 0.5 * (A2 * A2 * A2 + 2);
    }
    return A2;
  };
  h.easeCubicInOut = function(A2, e2) {
    A2 = y(A2);
    return h.linear(A2, this, e2);
  };
  h.easeSmoothStep = function(A2, e2) {
    const t2 = Math.max(0, Math.min(1, A2));
    A2 = t2 * t2 * (3 - 2 * t2);
    return h.linear(A2, this, e2);
  };
  h.easeSmootherStep = function(A2, e2) {
    const t2 = Math.max(0, Math.min(1, (A2 - 0) / (1 - 0)));
    A2 = t2 * t2 * t2 * (t2 * (t2 * 6 - 15) + 10);
    return h.linear(A2, this, e2);
  };
  h.prototype.setEasing = function(A2) {
    this._easing = A2;
    if (this._easing == c.ANIM.EASING_LINEAR)
      this.ease = h.easeLinear;
    else if (this._easing == c.ANIM.EASING_ABSOLUTE)
      this.ease = h.easeAbsolute;
    else if (this._easing == c.ANIM.EASING_SMOOTHSTEP)
      this.ease = h.easeSmoothStep;
    else if (this._easing == c.ANIM.EASING_SMOOTHERSTEP)
      this.ease = h.easeSmootherStep;
    else if (this._easing == c.ANIM.EASING_CUBIC_IN)
      this.ease = h.easeCubicIn;
    else if (this._easing == c.ANIM.EASING_CUBIC_OUT)
      this.ease = h.easeCubicOut;
    else if (this._easing == c.ANIM.EASING_CUBIC_INOUT)
      this.ease = h.easeCubicInOut;
    else if (this._easing == c.ANIM.EASING_EXPO_IN)
      this.ease = h.easeExpoIn;
    else if (this._easing == c.ANIM.EASING_EXPO_OUT)
      this.ease = h.easeExpoOut;
    else if (this._easing == c.ANIM.EASING_EXPO_INOUT)
      this.ease = h.easeExpoInOut;
    else if (this._easing == c.ANIM.EASING_SIN_IN)
      this.ease = h.easeSinIn;
    else if (this._easing == c.ANIM.EASING_SIN_OUT)
      this.ease = h.easeSinOut;
    else if (this._easing == c.ANIM.EASING_SIN_INOUT)
      this.ease = h.easeSinInOut;
    else if (this._easing == c.ANIM.EASING_BACK_OUT)
      this.ease = h.easeOutBack;
    else if (this._easing == c.ANIM.EASING_BACK_IN)
      this.ease = h.easeInBack;
    else if (this._easing == c.ANIM.EASING_BACK_INOUT)
      this.ease = h.easeInOutBack;
    else if (this._easing == c.ANIM.EASING_ELASTIC_IN)
      this.ease = h.easeInElastic;
    else if (this._easing == c.ANIM.EASING_ELASTIC_OUT)
      this.ease = h.easeOutElastic;
    else if (this._easing == c.ANIM.EASING_ELASTIC_INOUT)
      this.ease = h.easeElasticInOut;
    else if (this._easing == c.ANIM.EASING_BOUNCE_IN)
      this.ease = h.easeInBounce;
    else if (this._easing == c.ANIM.EASING_BOUNCE_OUT)
      this.ease = h.easeOutBounce;
    else if (this._easing == c.ANIM.EASING_QUART_OUT)
      this.ease = h.easeOutQuart;
    else if (this._easing == c.ANIM.EASING_QUART_IN)
      this.ease = h.easeInQuart;
    else if (this._easing == c.ANIM.EASING_QUART_INOUT)
      this.ease = h.easeInOutQuart;
    else if (this._easing == c.ANIM.EASING_QUINT_OUT)
      this.ease = h.easeOutQuint;
    else if (this._easing == c.ANIM.EASING_QUINT_IN)
      this.ease = h.easeInQuint;
    else if (this._easing == c.ANIM.EASING_QUINT_INOUT)
      this.ease = h.easeInOutQuint;
    else if (this._easing == c.ANIM.EASING_CUBICSPLINE) {
      this.ease = h.easeCubicSpline;
    } else {
      this._easing = c.ANIM.EASING_LINEAR;
      this.ease = h.easeLinear;
    }
  };
  h.prototype.trigger = function() {
    this.cb();
    this.cbTriggered = true;
  };
  h.prototype.setValue = function(A2) {
    this.value = A2;
    if (this.onChange !== null)
      this.onChange();
  };
  h.prototype.set = function(A2) {
    if (A2) {
      if (A2.e)
        this.setEasing(A2.e);
      if (A2.cb) {
        this.cb = A2.cb;
        this.cbTriggered = false;
      }
      if (A2.b) {
      }
      if (A2.hasOwnProperty("t"))
        this.time = A2.t;
      if (A2.hasOwnProperty("time"))
        this.time = A2.time;
      if (A2.hasOwnProperty("v"))
        this.value = A2.v;
      else if (A2.hasOwnProperty("value"))
        this.value = A2.value;
    }
    if (this.onChange !== null)
      this.onChange();
  };
  h.prototype.getSerialized = function() {
    const A2 = {};
    A2.t = this.time;
    A2.v = this.value;
    A2.e = this._easing;
    return A2;
  };
  h.prototype.getEasing = function() {
    return this._easing;
  };
  const b = function(A2) {
    u.apply(this);
    A2 = A2 || {};
    this.keys = [];
    this.onChange = null;
    this.stayInTimeline = false;
    this.loop = false;
    this._log = new r("Anim");
    this._lastKeyIndex = 0;
    this._cachedIndex = 0;
    this.name = A2.name || null;
    this.defaultEasing = A2.defaultEasing || c.ANIM.EASING_LINEAR;
    this.onLooped = null;
    this._timesLooped = 0;
    this._needsSort = false;
  };
  b.prototype.forceChangeCallback = function() {
    if (this.onChange !== null)
      this.onChange();
    this.emitEvent("onChange", this);
  };
  b.prototype.getLoop = function() {
    return this.loop;
  };
  b.prototype.setLoop = function(A2) {
    this.loop = A2;
    this.emitEvent("onChange", this);
  };
  b.prototype.hasEnded = function(A2) {
    if (this.keys.length === 0)
      return true;
    if (this.keys[this._lastKeyIndex].time <= A2)
      return true;
    return false;
  };
  b.prototype.isRising = function(A2) {
    if (this.hasEnded(A2))
      return false;
    const e2 = this.getKeyIndex(A2);
    if (this.keys[e2].value < this.keys[e2 + 1].value)
      return true;
    return false;
  };
  b.prototype.clearBefore = function(A2) {
    const e2 = this.getValue(A2);
    const t2 = this.getKeyIndex(A2);
    this.setValue(A2, e2);
    if (t2 > 1)
      this.keys.splice(0, t2);
    this._updateLastIndex();
  };
  b.prototype.clear = function(A2) {
    let e2 = 0;
    if (A2)
      e2 = this.getValue(A2);
    this.keys.length = 0;
    this._updateLastIndex();
    if (A2)
      this.setValue(A2, e2);
    if (this.onChange !== null)
      this.onChange();
    this.emitEvent("onChange", this);
  };
  b.prototype.sortKeys = function() {
    this.keys.sort((A2, e2) => {
      return parseFloat(A2.time) - parseFloat(e2.time);
    });
    this._updateLastIndex();
    this._needsSort = false;
    if (this.keys.length % 1e3 == 0)
      console.log(this.name, this.keys.length);
  };
  b.prototype.getLength = function() {
    if (this.keys.length === 0)
      return 0;
    return this.keys[this.keys.length - 1].time;
  };
  b.prototype.getKeyIndex = function(e2) {
    let t2 = 0;
    let g2 = 0;
    if (this._cachedIndex && this.keys.length > this._cachedIndex && e2 >= this.keys[this._cachedIndex].time)
      g2 = this._cachedIndex;
    for (let A2 = g2; A2 < this.keys.length; A2++) {
      if (e2 >= this.keys[A2].time)
        t2 = A2;
      if (this.keys[A2].time > e2) {
        if (e2 != 0)
          this._cachedIndex = t2;
        return t2;
      }
    }
    return t2;
  };
  b.prototype.setValue = function(e2, t2, g2) {
    let i2 = null;
    if (this.keys.length == 0 || e2 <= this.keys[this.keys.length - 1].time) {
      for (let A2 = 0; A2 < this.keys.length; A2++)
        if (this.keys[A2].time == e2) {
          i2 = this.keys[A2];
          this.keys[A2].setValue(t2);
          this.keys[A2].cb = g2;
          break;
        }
    }
    if (!i2) {
      i2 = new h({ time: e2, value: t2, e: this.defaultEasing, cb: g2 });
      this.keys.push(i2);
      this._updateLastIndex();
    }
    if (this.onChange)
      this.onChange();
    this.emitEvent("onChange", this);
    this._needsSort = true;
    return i2;
  };
  b.prototype.setKeyEasing = function(A2, e2) {
    if (this.keys[A2]) {
      this.keys[A2].setEasing(e2);
      this.emitEvent("onChange", this);
    }
  };
  b.prototype.getSerialized = function() {
    const e2 = {};
    e2.keys = [];
    e2.loop = this.loop;
    for (let A2 = 0; A2 < this.keys.length; A2++)
      e2.keys.push(this.keys[A2].getSerialized());
    return e2;
  };
  b.prototype.getKey = function(A2) {
    const e2 = this.getKeyIndex(A2);
    return this.keys[e2];
  };
  b.prototype.getNextKey = function(A2) {
    let e2 = this.getKeyIndex(A2) + 1;
    if (e2 >= this.keys.length)
      e2 = this.keys.length - 1;
    return this.keys[e2];
  };
  b.prototype.isFinished = function(A2) {
    if (this.keys.length <= 0)
      return true;
    return A2 > this.keys[this.keys.length - 1].time;
  };
  b.prototype.isStarted = function(A2) {
    if (this.keys.length <= 0)
      return false;
    return A2 >= this.keys[0].time;
  };
  b.prototype.getValue = function(A2) {
    if (this.keys.length === 0) {
      return 0;
    }
    if (this._needsSort)
      this.sortKeys();
    if (!this.loop && A2 > this.keys[this._lastKeyIndex].time) {
      if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered)
        this.keys[this._lastKeyIndex].trigger();
      return this.keys[this._lastKeyIndex].value;
    }
    if (A2 < this.keys[0].time) {
      return this.keys[0].value;
    }
    if (this.loop && A2 > this.keys[this._lastKeyIndex].time) {
      const n2 = A2 / this.keys[this._lastKeyIndex].time;
      if (n2 > this._timesLooped) {
        this._timesLooped++;
        if (this.onLooped)
          this.onLooped();
      }
      A2 = (A2 - this.keys[0].time) % (this.keys[this._lastKeyIndex].time - this.keys[0].time);
      A2 += this.keys[0].time;
    }
    const e2 = this.getKeyIndex(A2);
    if (e2 >= this._lastKeyIndex) {
      if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered)
        this.keys[this._lastKeyIndex].trigger();
      return this.keys[this._lastKeyIndex].value;
    }
    const t2 = e2 + 1;
    const g2 = this.keys[e2];
    const i2 = this.keys[t2];
    if (g2.cb && !g2.cbTriggered)
      g2.trigger();
    if (!i2)
      return -1;
    const I2 = (A2 - g2.time) / (i2.time - g2.time);
    if (!g2.ease)
      this.log._warn("has no ease", g2, i2);
    return g2.ease(I2, i2);
  };
  b.prototype._updateLastIndex = function() {
    this._lastKeyIndex = this.keys.length - 1;
  };
  b.prototype.addKey = function(A2) {
    if (A2.time === void 0) {
      this.log.warn("key time undefined, ignoring!");
    } else {
      this.keys.push(A2);
      if (this.onChange !== null)
        this.onChange();
      this.emitEvent("onChange", this);
    }
    this._updateLastIndex();
  };
  b.prototype.easingFromString = function(A2) {
    if (A2 == "linear")
      return c.ANIM.EASING_LINEAR;
    if (A2 == "absolute")
      return c.ANIM.EASING_ABSOLUTE;
    if (A2 == "smoothstep")
      return c.ANIM.EASING_SMOOTHSTEP;
    if (A2 == "smootherstep")
      return c.ANIM.EASING_SMOOTHERSTEP;
    if (A2 == "Cubic In")
      return c.ANIM.EASING_CUBIC_IN;
    if (A2 == "Cubic Out")
      return c.ANIM.EASING_CUBIC_OUT;
    if (A2 == "Cubic In Out")
      return c.ANIM.EASING_CUBIC_INOUT;
    if (A2 == "Expo In")
      return c.ANIM.EASING_EXPO_IN;
    if (A2 == "Expo Out")
      return c.ANIM.EASING_EXPO_OUT;
    if (A2 == "Expo In Out")
      return c.ANIM.EASING_EXPO_INOUT;
    if (A2 == "Sin In")
      return c.ANIM.EASING_SIN_IN;
    if (A2 == "Sin Out")
      return c.ANIM.EASING_SIN_OUT;
    if (A2 == "Sin In Out")
      return c.ANIM.EASING_SIN_INOUT;
    if (A2 == "Back In")
      return c.ANIM.EASING_BACK_IN;
    if (A2 == "Back Out")
      return c.ANIM.EASING_BACK_OUT;
    if (A2 == "Back In Out")
      return c.ANIM.EASING_BACK_INOUT;
    if (A2 == "Elastic In")
      return c.ANIM.EASING_ELASTIC_IN;
    if (A2 == "Elastic Out")
      return c.ANIM.EASING_ELASTIC_OUT;
    if (A2 == "Bounce In")
      return c.ANIM.EASING_BOUNCE_IN;
    if (A2 == "Bounce Out")
      return c.ANIM.EASING_BOUNCE_OUT;
    if (A2 == "Quart Out")
      return c.ANIM.EASING_QUART_OUT;
    if (A2 == "Quart In")
      return c.ANIM.EASING_QUART_IN;
    if (A2 == "Quart In Out")
      return c.ANIM.EASING_QUART_INOUT;
    if (A2 == "Quint Out")
      return c.ANIM.EASING_QUINT_OUT;
    if (A2 == "Quint In")
      return c.ANIM.EASING_QUINT_IN;
    if (A2 == "Quint In Out")
      return c.ANIM.EASING_QUINT_INOUT;
  };
  b.prototype.createPort = function(A2, e2, t2) {
    const g2 = A2.inDropDown(e2, c.ANIM.EASINGS, "Cubic Out");
    g2.set("linear");
    g2.defaultValue = "linear";
    g2.onChange = function() {
      this.defaultEasing = this.easingFromString(g2.get());
      this.emitEvent("onChangeDefaultEasing", this);
      if (t2)
        t2();
    }.bind(this);
    return g2;
  };
  b.slerpQuaternion = function(A2, e2, t2, g2, i2, I2) {
    if (!b.slerpQuaternion.q1) {
      b.slerpQuaternion.q1 = quat.create();
      b.slerpQuaternion.q2 = quat.create();
    }
    const n2 = t2.getKeyIndex(A2);
    let o2 = n2 + 1;
    if (o2 >= t2.keys.length)
      o2 = t2.keys.length - 1;
    if (n2 == o2) {
      quat.set(e2, t2.keys[n2].value, g2.keys[n2].value, i2.keys[n2].value, I2.keys[n2].value);
    } else {
      const C2 = t2.keys[n2].time;
      const a2 = t2.keys[o2].time;
      const r2 = (A2 - C2) / (a2 - C2);
      quat.set(b.slerpQuaternion.q1, t2.keys[n2].value, g2.keys[n2].value, i2.keys[n2].value, I2.keys[n2].value);
      quat.set(b.slerpQuaternion.q2, t2.keys[o2].value, g2.keys[o2].value, i2.keys[o2].value, I2.keys[o2].value);
      quat.slerp(e2, b.slerpQuaternion.q1, b.slerpQuaternion.q2, r2);
    }
    return e2;
  };
  const N = { Key: h };
  const S = function(A2, e2, t2, g2) {
    u.apply(this);
    this.data = {};
    this._log = new r("core_port");
    this.direction = c.PORT.PORT_DIR_IN;
    this.id = String(CABLES.simpleId());
    this._op = A2;
    this.links = [];
    this.value = 0;
    this.name = e2;
    this.type = t2 || c.OP.OP_PORT_TYPE_VALUE;
    this.uiAttribs = g2 || {};
    this.anim = null;
    this._oldAnimVal = -5711;
    this.defaultValue = null;
    this._uiActiveState = true;
    this.ignoreValueSerialize = false;
    this.onLinkChanged = null;
    this.crashed = false;
    this._valueBeforeLink = null;
    this._lastAnimFrame = -1;
    this._animated = false;
    this.onValueChanged = null;
    this.onTriggered = null;
    this.onUiActiveStateChange = null;
    this.changeAlways = false;
    this.forceRefChange = false;
    this._useVariableName = null;
    this.activityCounter = 0;
    this.apf = 0;
    this.activityCounterStartFrame = 0;
    this._tempLastUiValue = null;
    Object.defineProperty(this, "title", { get() {
      return this.uiAttribs.title || this.name;
    } });
    Object.defineProperty(this, "parent", { get() {
      this._log.stack("use port.op, not .parent");
      return this._op;
    } });
    Object.defineProperty(this, "op", { get() {
      return this._op;
    } });
    Object.defineProperty(this, "val", { get() {
      this._log.warn("val getter deprecated!", this);
      this._log.stack("val getter deprecated");
      return this.get();
    }, set(A3) {
      this._log.warn("val setter deprecated!", this);
      this._log.stack("val setter deprecated");
      this.setValue(A3);
    } });
  };
  S.prototype.copyLinkedUiAttrib = function(A2, e2) {
    if (!CABLES.UI)
      return;
    if (!this.isLinked())
      return;
    const t2 = {};
    t2[A2] = this.links[0].getOtherPort(this).getUiAttrib(A2);
    e2.setUiAttribs(t2);
  };
  S.prototype.getValueForDisplay = function() {
    let A2 = this.value;
    if (typeof this.value === "string" || this.value instanceof String) {
      if (A2.length > 1e3) {
        A2 = A2.substring(0, 999);
        A2 += "...";
      }
      if (this.uiAttribs && this.uiAttribs.display == "boolnum") {
        A2 += " - ";
        if (!this.value)
          A2 += "false";
        else
          A2 += "true";
      }
      A2 = A2.replace(/[\u00A0-\u9999<>\&]/g, function(A3) {
        return "&#" + A3.charCodeAt(0) + ";";
      });
      if (A2.length > 100)
        A2 = A2.substring(0, 100);
    } else {
      A2 = this.value;
    }
    return A2;
  };
  S.prototype.onAnimToggle = function() {
  };
  S.prototype._onAnimToggle = function() {
    this.onAnimToggle();
  };
  S.prototype.remove = function() {
    this.removeLinks();
    this._op.removePort(this);
  };
  S.prototype.setUiAttribs = function(A2) {
    let e2 = false;
    if (!this.uiAttribs)
      this.uiAttribs = {};
    for (const t2 in A2) {
      if (A2[t2] === void 0) {
        delete this.uiAttribs[t2];
        continue;
      }
      if (this.uiAttribs[t2] != A2[t2])
        e2 = true;
      this.uiAttribs[t2] = A2[t2];
      if (t2 == "group" && this.indexPort)
        this.indexPort.setUiAttribs({ group: A2[t2] });
    }
    if (A2.hasOwnProperty("expose"))
      this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch);
    if (e2)
      this.emitEvent("onUiAttrChange", A2, this);
  };
  S.prototype.getUiAttribs = function() {
    return this.uiAttribs;
  };
  S.prototype.getUiAttrib = function(A2) {
    if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(A2)) {
      return null;
    }
    return this.uiAttribs[A2];
  };
  S.prototype.get = function() {
    if (this._animated && this._lastAnimFrame != this._op.patch.getFrameNum()) {
      this._lastAnimFrame = this._op.patch.getFrameNum();
      this.value = this.anim.getValue(this._op.patch.timer.getTime());
      this._oldAnimVal = this.value;
      this.forceChange();
    }
    return this.value;
  };
  S.prototype.setRef = function(A2) {
    this.forceRefChange = true;
    this.set(A2);
  };
  S.prototype.set = S.prototype.setValue = function(A2) {
    if (A2 === void 0)
      A2 = null;
    if (this._op.enabled && !this.crashed) {
      if (A2 !== this.value || this.changeAlways || this.type == c.OP.OP_PORT_TYPE_TEXTURE || this.type == c.OP.OP_PORT_TYPE_ARRAY) {
        if (this._animated) {
          this.anim.setValue(this._op.patch.timer.getTime(), A2);
        } else {
          try {
            this.value = A2;
            this.forceChange();
          } catch (A3) {
            this.crashed = true;
            this.setValue = function(A4) {
            };
            this.onTriggered = function() {
            };
            this._log.error("exception in ", this._op);
            this._log.error(A3);
            this._op.patch.emitEvent("exception", A3, this._op);
          }
          if (this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == c.OP.OP_PORT_TYPE_TEXTURE)
            gui.texturePreview().updateTexturePort(this);
        }
        if (this.direction == c.PORT.PORT_DIR_OUT)
          for (let A3 = 0; A3 < this.links.length; ++A3)
            this.links[A3].setValue();
      }
    }
  };
  S.prototype.updateAnim = function() {
    if (this._animated) {
      this.value = this.get();
      if (this._oldAnimVal != this.value || this.changeAlways) {
        this._oldAnimVal = this.value;
        this.forceChange();
      }
      this._oldAnimVal = this.value;
    }
  };
  S.prototype.forceChange = function() {
    if (this.onValueChanged || this.onChange) {
    }
    this._activity();
    this.emitEvent("change", this.value, this);
    if (this.onChange)
      this.onChange(this, this.value);
    else if (this.onValueChanged)
      this.onValueChanged(this, this.value);
  };
  S.prototype.getTypeString = function() {
    if (this.type == c.OP.OP_PORT_TYPE_VALUE)
      return "Number";
    if (this.type == c.OP.OP_PORT_TYPE_FUNCTION)
      return "Trigger";
    if (this.type == c.OP.OP_PORT_TYPE_OBJECT)
      return "Object";
    if (this.type == c.OP.OP_PORT_TYPE_DYNAMIC)
      return "Dynamic";
    if (this.type == c.OP.OP_PORT_TYPE_ARRAY)
      return "Array";
    if (this.type == c.OP.OP_PORT_TYPE_STRING)
      return "String";
    return "Unknown";
  };
  S.prototype.deSerializeSettings = function(A2) {
    if (!A2)
      return;
    if (A2.animated)
      this.setAnimated(A2.animated);
    if (A2.useVariable)
      this.setVariableName(A2.useVariable);
    if (A2.title)
      this.setUiAttribs({ title: A2.title });
    if (A2.expose)
      this.setUiAttribs({ expose: true });
    if (A2.order)
      this.setUiAttribs({ order: A2.order });
    if (A2.multiPortManual)
      this.setUiAttribs({ multiPortManual: A2.multiPortManual });
    if (A2.multiPortNum)
      this.setUiAttribs({ multiPortNum: A2.multiPortNum });
    if (A2.anim) {
      if (!this.anim)
        this.anim = new b({ name: "port " + this.name });
      this._op._hasAnimPort = true;
      this.anim.addEventListener("onChange", () => {
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
      });
      if (A2.anim.loop)
        this.anim.loop = A2.anim.loop;
      for (const e2 in A2.anim.keys) {
        this.anim.keys.push(new N.Key(A2.anim.keys[e2]));
      }
      this.anim.sortKeys();
    }
  };
  S.prototype.setInitialValue = function(A2) {
    if (this.op.preservedPortLinks[this.name]) {
      for (let A3 = 0; A3 < this.op.preservedPortLinks[this.name].length; A3++) {
        const e2 = this.op.preservedPortLinks[this.name][A3];
        this.op.patch._addLink(e2.objIn, e2.objOut, e2.portIn, e2.portOut);
      }
    }
    if (this.op.preservedPortValues && this.op.preservedPortValues.hasOwnProperty(this.name) && this.op.preservedPortValues[this.name] !== void 0) {
      this.set(this.op.preservedPortValues[this.name]);
    } else if (A2 !== void 0)
      this.set(A2);
    if (A2 !== void 0)
      this.defaultValue = A2;
  };
  S.prototype.getSerialized = function() {
    let A2 = { name: this.getName() };
    if (!this.ignoreValueSerialize && this.links.length === 0) {
      if (this.type == c.OP.OP_PORT_TYPE_OBJECT && this.value && this.value.tex) {
      } else
        A2.value = this.value;
    }
    if (this._useVariableName)
      A2.useVariable = this._useVariableName;
    if (this._animated)
      A2.animated = true;
    if (this.anim)
      A2.anim = this.anim.getSerialized();
    if (this.uiAttribs.multiPortNum)
      A2.multiPortNum = this.uiAttribs.multiPortNum;
    if (this.uiAttribs.multiPortManual)
      A2.multiPortManual = this.uiAttribs.multiPortManual;
    if (this.uiAttribs.display == "file")
      A2.display = this.uiAttribs.display;
    if (this.uiAttribs.expose) {
      A2.expose = true;
      if (this.uiAttribs.hasOwnProperty("order"))
        A2.order = this.uiAttribs.order;
    }
    if (this.uiAttribs.title)
      A2.title = this.uiAttribs.title;
    if ((this.preserveLinks || this.direction == c.PORT.PORT_DIR_OUT) && this.links.length > 0) {
      A2.links = [];
      for (const e2 in this.links) {
        if (!this.links[e2].ignoreInSerialize && (this.links[e2].portIn && this.links[e2].portOut))
          A2.links.push(this.links[e2].getSerialized());
      }
    }
    if (this.direction == c.PORT.PORT_DIR_IN && this.links.length > 0) {
      for (const e2 in this.links) {
        if (!this.links[e2].portIn || !this.links[e2].portOut)
          continue;
        const t2 = this.links[e2].getOtherPort(this);
        if (t2.op.isInBlueprint2 && this.op.isInBlueprint2) {
          if (t2.op.isInBlueprint2() && !this.op.isInBlueprint2()) {
            A2.links = A2.links || [];
            A2.links.push(this.links[e2].getSerialized());
          }
        }
      }
    }
    if (A2.links && A2.links.length == 0)
      delete A2.links;
    if (this.type === c.OP.OP_PORT_TYPE_FUNCTION)
      delete A2.value;
    if (this.type === c.OP.OP_PORT_TYPE_FUNCTION && this.links.length == 0)
      A2 = null;
    if (A2 && Object.keys(A2).length == 1 && A2.name)
      A2 = null;
    I(A2);
    return A2;
  };
  S.prototype.shouldLink = function() {
    return true;
  };
  S.prototype.removeLinks = function() {
    let A2 = 0;
    while (this.links.length > 0) {
      A2++;
      if (A2 > 5e3) {
        this._log.warn("could not delete links... / infinite loop");
        this.links.length = 0;
        break;
      }
      this.links[0].remove();
    }
  };
  S.prototype.removeLink = function(A2) {
    for (const e2 in this.links)
      if (this.links[e2] == A2)
        this.links.splice(e2, 1);
    if (this.direction == c.PORT.PORT_DIR_IN) {
      if (this.type == c.OP.OP_PORT_TYPE_VALUE)
        this.setValue(this._valueBeforeLink || 0);
      else
        this.setValue(this._valueBeforeLink || null);
    }
    if (CABLES.UI && this._op.checkLinkTimeWarnings)
      this._op.checkLinkTimeWarnings();
    if (this.onLinkChanged)
      this.onLinkChanged();
    this.emitEvent("onLinkChanged");
    this.emitEvent("onLinkRemoved");
    this._op.emitEvent("onLinkChanged");
  };
  S.prototype.getName = function() {
    return this.name;
  };
  S.prototype.getTitle = function() {
    if (this.uiAttribs.title)
      return this.uiAttribs.title;
    return this.name;
  };
  S.prototype.addLink = function(A2) {
    this._valueBeforeLink = this.value;
    this.links.push(A2);
    if (CABLES.UI && this._op.checkLinkTimeWarnings)
      this._op.checkLinkTimeWarnings();
    if (this.onLinkChanged)
      this.onLinkChanged();
    this.emitEvent("onLinkChanged");
    this._op.emitEvent("onLinkChanged");
  };
  S.prototype.getLinkTo = function(A2) {
    for (const e2 in this.links)
      if (this.links[e2].portIn == A2 || this.links[e2].portOut == A2)
        return this.links[e2];
  };
  S.prototype.removeLinkTo = function(A2) {
    for (const e2 in this.links) {
      if (this.links[e2].portIn == A2 || this.links[e2].portOut == A2) {
        this.links[e2].remove();
        if (CABLES.UI && this._op.checkLinkTimeWarnings)
          this._op.checkLinkTimeWarnings();
        if (this.onLinkChanged)
          this.onLinkChanged();
        this.emitEvent("onLinkChanged");
        this.emitEvent("onLinkRemoved");
        return;
      }
    }
  };
  S.prototype.isLinkedTo = function(A2) {
    for (const e2 in this.links)
      if (this.links[e2].portIn == A2 || this.links[e2].portOut == A2)
        return true;
    return false;
  };
  S.prototype._activity = function() {
    this.activityCounter++;
  };
  S.prototype.trigger = function() {
    const e2 = this.links.length;
    this._activity();
    if (e2 === 0)
      return;
    if (!this._op.enabled)
      return;
    let t2 = null;
    try {
      for (let A2 = 0; A2 < e2; ++A2) {
        if (this.links[A2].portIn) {
          t2 = this.links[A2].portIn;
          t2.op.patch.pushTriggerStack(t2);
          t2._onTriggered();
          t2.op.patch.popTriggerStack();
        }
        if (this.links[A2])
          this.links[A2].activity();
      }
    } catch (A2) {
      t2.op.enabled = false;
      if (this._op.patch.isEditorMode()) {
        if (t2.op.onError)
          t2.op.onError(A2);
      }
      this._log.error("exception in port: " + t2.op.name, t2.op);
      this._log.error(A2);
    }
  };
  S.prototype.call = function() {
    this._log.warn("call deprecated - use trigger() ");
    this.trigger();
  };
  S.prototype.execute = function() {
    this._log.warn("### execute port: " + this.getName(), this.goals.length);
  };
  S.prototype.setVariableName = function(A2) {
    this._useVariableName = A2;
    this._op.patch.on("variableRename", (A3, e2) => {
      if (A3 != this._useVariableName)
        return;
      this._useVariableName = e2;
    });
  };
  S.prototype.getVariableName = function() {
    return this._useVariableName;
  };
  S.prototype.setVariable = function(A2) {
    this.setAnimated(false);
    const e2 = { useVariable: false };
    if (this._variableIn && this._varChangeListenerId) {
      this._variableIn.off(this._varChangeListenerId);
      this._variableIn = null;
    }
    if (A2) {
      this._variableIn = this._op.patch.getVar(A2);
      if (!this._variableIn) {
        this._log.warn("PORT VAR NOT FOUND!!!", A2);
      } else {
        if (this.type == c.OP.OP_PORT_TYPE_OBJECT) {
          this._varChangeListenerId = this._variableIn.on("change", () => {
            this.set(null);
            this.set(this._variableIn.getValue());
          });
        } else {
          this._varChangeListenerId = this._variableIn.on("change", this.set.bind(this));
        }
        this.set(this._variableIn.getValue());
      }
      this._useVariableName = A2;
      e2.useVariable = true;
      e2.variableName = this._useVariableName;
    } else {
      e2.variableName = this._useVariableName = null;
      e2.useVariable = false;
    }
    this.setUiAttribs(e2);
    this._op.patch.emitEvent("portSetVariable", this._op, this, A2);
  };
  S.prototype._handleNoTriggerOpAnimUpdates = function(A2) {
    let e2 = false;
    for (let A3 = 0; A3 < this._op.portsIn.length; A3++) {
      if (this._op.portsIn.type == c.OP.OP_PORT_TYPE_FUNCTION) {
        e2 = true;
        break;
      }
    }
    if (!e2) {
      if (A2)
        this._notriggerAnimUpdate = this._op.patch.on("onRenderFrame", () => {
          this.updateAnim();
        });
      else
        this._op.patch.removeEventListener(this._notriggerAnimUpdate);
    }
  };
  S.prototype.setAnimated = function(A2) {
    if (this._animated != A2) {
      this._animated = A2;
      this._op._hasAnimPort = true;
      if (this._animated && !this.anim) {
        this.anim = new b({ name: "port " + this.name });
        this.anim.addEventListener("onChange", () => {
          this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
        });
      }
      this._onAnimToggle();
    }
    this._handleNoTriggerOpAnimUpdates(A2);
    if (!A2) {
      this.anim = null;
    }
    this.setUiAttribs({ isAnimated: this._animated });
  };
  S.prototype.toggleAnim = function() {
    this._animated = !this._animated;
    if (this._animated && !this.anim) {
      this.anim = new b({ name: "port " + this.name });
      this.anim.addEventListener("onChange", () => {
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
      });
    }
    this.setAnimated(this._animated);
    this._onAnimToggle();
    this.setUiAttribs({ isAnimated: this._animated });
  };
  S.prototype.getType = function() {
    return this.type;
  };
  S.prototype.isLinked = function() {
    return this.links.length > 0 || this._animated || this._useVariableName != null;
  };
  S.prototype.isBoundToVar = function() {
    const A2 = this._useVariableName != null;
    this.uiAttribs.boundToVar = A2;
    return A2;
  };
  S.prototype.isAnimated = function() {
    return this._animated;
  };
  S.prototype.isHidden = function() {
    return this.uiAttribs.hidePort;
  };
  S.prototype._onTriggered = function(A2) {
    this._activity();
    this._op.updateAnims();
    if (this._op.enabled && this.onTriggered)
      this.onTriggered(A2);
    if (this._op.enabled)
      this.emitEvent("trigger");
  };
  S.prototype._onSetProfiling = function(A2) {
    this._op.patch.profiler.add("port", this);
    this.setValue(A2);
    this._op.patch.profiler.add("port", null);
  };
  S.prototype._onTriggeredProfiling = function() {
    if (this._op.enabled && this.onTriggered) {
      this._op.patch.profiler.add("port", this);
      this.onTriggered();
      this._op.patch.profiler.add("port", null);
    }
  };
  S.prototype.getUiActiveState = function() {
    return this._uiActiveState;
  };
  S.prototype.setUiActiveState = function(A2) {
    this._uiActiveState = A2;
    if (this.onUiActiveStateChange)
      this.onUiActiveStateChange();
  };
  S.prototype.onValueChange = function(A2) {
    this.onChange = A2;
  };
  S.prototype.hidePort = function() {
  };
  S.portTypeNumberToString = function(A2) {
    if (A2 == c.OP.OP_PORT_TYPE_VALUE)
      return "value";
    if (A2 == c.OP.OP_PORT_TYPE_FUNCTION)
      return "function";
    if (A2 == c.OP.OP_PORT_TYPE_OBJECT)
      return "object";
    if (A2 == c.OP.OP_PORT_TYPE_ARRAY)
      return "array";
    if (A2 == c.OP.OP_PORT_TYPE_STRING)
      return "string";
    if (A2 == c.OP.OP_PORT_TYPE_DYNAMIC)
      return "dynamic";
    return "unknown";
  };
  class w {
    constructor(A2, e2, t2, g2, i2, I2, n2, o2, C2, a2) {
      this._log = new r("cg_uniform");
      this._type = e2;
      this._name = t2;
      this._shader = A2;
      this._value = 1e-5;
      this._oldValue = null;
      this._port = null;
      this._structName = C2;
      this._structUniformName = o2;
      this._propertyName = a2;
      this._shader._addUniform(this);
      this.needsUpdate = true;
      this.shaderType = null;
      this.comment = null;
      if (e2 == "f") {
        this.set = this.setValue = this.setValueF.bind(this);
        this.updateValue = this.updateValueF.bind(this);
      } else if (e2 == "f[]") {
        this.set = this.setValue = this.setValueArrayF.bind(this);
        this.updateValue = this.updateValueArrayF.bind(this);
      } else if (e2 == "2f[]") {
        this.set = this.setValue = this.setValueArray2F.bind(this);
        this.updateValue = this.updateValueArray2F.bind(this);
      } else if (e2 == "3f[]") {
        this.set = this.setValue = this.setValueArray3F.bind(this);
        this.updateValue = this.updateValueArray3F.bind(this);
      } else if (e2 == "4f[]") {
        this.set = this.setValue = this.setValueArray4F.bind(this);
        this.updateValue = this.updateValueArray4F.bind(this);
      } else if (e2 == "i") {
        this.set = this.setValue = this.setValueI.bind(this);
        this.updateValue = this.updateValueI.bind(this);
      } else if (e2 == "2i") {
        this.set = this.setValue = this.setValue2I.bind(this);
        this.updateValue = this.updateValue2I.bind(this);
      } else if (e2 == "3i") {
        this.set = this.setValue = this.setValue3I.bind(this);
        this.updateValue = this.updateValue3I.bind(this);
      } else if (e2 == "4i") {
        this.set = this.setValue = this.setValue4I.bind(this);
        this.updateValue = this.updateValue4I.bind(this);
      } else if (e2 == "b") {
        this.set = this.setValue = this.setValueBool.bind(this);
        this.updateValue = this.updateValueBool.bind(this);
      } else if (e2 == "4f") {
        this.set = this.setValue = this.setValue4F.bind(this);
        this.updateValue = this.updateValue4F.bind(this);
      } else if (e2 == "3f") {
        this.set = this.setValue = this.setValue3F.bind(this);
        this.updateValue = this.updateValue3F.bind(this);
      } else if (e2 == "2f") {
        this.set = this.setValue = this.setValue2F.bind(this);
        this.updateValue = this.updateValue2F.bind(this);
      } else if (e2 == "t") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (e2 == "tc") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (e2 == "t[]") {
        this.set = this.setValue = this.setValueArrayT.bind(this);
        this.updateValue = this.updateValueArrayT.bind(this);
      } else if (e2 == "m4" || e2 == "m4[]") {
        this.set = this.setValue = this.setValueM4.bind(this);
        this.updateValue = this.updateValueM4.bind(this);
      } else
        throw new Error("Unknown uniform type");
      if (typeof g2 == "object" && g2 instanceof S) {
        this._port = g2;
        this._value = this._port.get();
        if (i2 && I2 && n2) {
          if (!(i2 instanceof S) || !(I2 instanceof S) || !(n2 instanceof S)) {
            this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
          }
          this._value = [0, 0, 0, 0];
          this._port2 = i2;
          this._port3 = I2;
          this._port4 = n2;
          this._port.on("change", this.updateFromPort4f.bind(this));
          this._port2.on("change", this.updateFromPort4f.bind(this));
          this._port3.on("change", this.updateFromPort4f.bind(this));
          this._port4.on("change", this.updateFromPort4f.bind(this));
          this.updateFromPort4f();
        } else if (i2 && I2) {
          if (!(i2 instanceof S) || !(I2 instanceof S)) {
            this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
          }
          this._value = [0, 0, 0];
          this._port2 = i2;
          this._port3 = I2;
          this._port.on("change", this.updateFromPort3f.bind(this));
          this._port2.on("change", this.updateFromPort3f.bind(this));
          this._port3.on("change", this.updateFromPort3f.bind(this));
          this.updateFromPort3f();
        } else if (i2) {
          if (!(i2 instanceof S)) {
            this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
          }
          this._value = [0, 0];
          this._port2 = i2;
          this._port.on("change", this.updateFromPort2f.bind(this));
          this._port2.on("change", this.updateFromPort2f.bind(this));
          this.updateFromPort2f();
        } else {
          this._port.on("change", this.updateFromPort.bind(this));
        }
      } else
        this._value = g2;
      this.setValue(this._value);
      this.needsUpdate = true;
    }
    getType() {
      return this._type;
    }
    getName() {
      return this._name;
    }
    getValue() {
      return this._value;
    }
    getShaderType() {
      return this.shaderType;
    }
    isStructMember() {
      return !!this._structName;
    }
    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }
    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }
    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }
    updateFromPort() {
      this.setValue(this._port.get());
    }
  }
  const R = w;
  class G extends R {
    constructor(A2, e2, t2, g2, i2, I2, n2, o2, C2, a2) {
      super(A2, e2, t2, g2, i2, I2, n2, o2, C2, a2);
      this._loc = -1;
      this._cgl = A2._cgl;
    }
    get name() {
      return this._name;
    }
    copy(A2) {
      const e2 = new G(A2, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
      e2.shaderType = this.shaderType;
      return e2;
    }
    getGlslTypeString() {
      return G.glslTypeString(this._type);
    }
    _isValidLoc() {
      return this._loc != -1;
    }
    resetLoc() {
      this._loc = -1;
      this.needsUpdate = true;
    }
    bindTextures() {
    }
    getLoc() {
      return this._loc;
    }
    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }
    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }
    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }
    updateFromPort() {
      this.setValue(this._port.get());
    }
    updateValueF() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1f(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueF(A2) {
      if (A2 != this._value) {
        this.needsUpdate = true;
        this._value = A2;
      }
    }
    updateValueI() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    updateValue2I() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    updateValue3I() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    updateValue4I() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueI(A2) {
      if (A2 != this._value) {
        this.needsUpdate = true;
        this._value = A2;
      }
    }
    setValue2I(A2) {
      if (!A2)
        return;
      if (!this._oldValue) {
        this._oldValue = [A2[0] - 1, 1];
        this.needsUpdate = true;
      } else if (A2[0] != this._oldValue[0] || A2[1] != this._oldValue[1]) {
        this._oldValue[0] = A2[0];
        this._oldValue[1] = A2[1];
        this.needsUpdate = true;
      }
      this._value = A2;
    }
    setValue3I(A2) {
      if (!A2)
        return;
      if (!this._oldValue) {
        this._oldValue = [A2[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (A2[0] != this._oldValue[0] || A2[1] != this._oldValue[1] || A2[2] != this._oldValue[2]) {
        this._oldValue[0] = A2[0];
        this._oldValue[1] = A2[1];
        this._oldValue[2] = A2[2];
        this.needsUpdate = true;
      }
      this._value = A2;
    }
    setValue4I(A2) {
      this.needsUpdate = true;
      this._value = A2 || vec4.create();
    }
    updateValueBool() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueBool(A2) {
      if (A2 != this._value) {
        this.needsUpdate = true;
        this._value = A2;
      }
    }
    setValueArray4F(A2) {
      this.needsUpdate = true;
      this._value = A2;
    }
    updateValueArray4F() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform4fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArray3F(A2) {
      this.needsUpdate = true;
      this._value = A2;
    }
    updateValueArray3F() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform3fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArray2F(A2) {
      this.needsUpdate = true;
      this._value = A2;
    }
    updateValueArray2F() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform2fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArrayF(A2) {
      this.needsUpdate = true;
      this._value = A2;
    }
    updateValueArrayF() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform1fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueArrayT(A2) {
      this.needsUpdate = true;
      this._value = A2;
    }
    updateValue3F() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    setValue3F(A2) {
      if (!A2)
        return;
      if (!this._oldValue) {
        this._oldValue = [A2[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (A2[0] != this._oldValue[0] || A2[1] != this._oldValue[1] || A2[2] != this._oldValue[2]) {
        this._oldValue[0] = A2[0];
        this._oldValue[1] = A2[1];
        this._oldValue[2] = A2[2];
        this.needsUpdate = true;
      }
      this._value = A2;
    }
    updateValue2F() {
      if (!this._value)
        return;
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }
    setValue2F(A2) {
      if (!A2)
        return;
      if (!this._oldValue) {
        this._oldValue = [A2[0] - 1, 1];
        this.needsUpdate = true;
      } else if (A2[0] != this._oldValue[0] || A2[1] != this._oldValue[1]) {
        this._oldValue[0] = A2[0];
        this._oldValue[1] = A2[1];
        this.needsUpdate = true;
      }
      this._value = A2;
    }
    updateValue4F() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      if (!this._value) {
        this._log.warn("no value for uniform", this._name, this);
        this._value = [0, 0, 0, 0];
      }
      this.needsUpdate = false;
      this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
      this._cgl.profileData.profileUniformCount++;
    }
    setValue4F(A2) {
      if (typeof this.value == "number")
        this.value = vec4.create();
      if (!A2)
        return;
      if (!this._oldValue) {
        this._oldValue = [A2[0] - 1, 1, 2, 3];
        this.needsUpdate = true;
      } else if (A2[0] != this._oldValue[0] || A2[1] != this._oldValue[1] || A2[2] != this._oldValue[2] || A2[3] != this._oldValue[3]) {
        this._oldValue[0] = A2[0];
        this._oldValue[1] = A2[1];
        this._oldValue[2] = A2[2];
        this.needsUpdate = true;
      }
      this._value = A2;
    }
    updateValueM4() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      if (!this._value || this._value.length % 16 != 0)
        return console.log("this.name", this._name, this._value);
      this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    setValueM4(A2) {
      this.needsUpdate = true;
      this._value = A2 || mat4.create();
    }
    updateValueArrayT() {
      if (!this._isValidLoc())
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
      else
        this.needsUpdate = false;
      if (!this._value)
        return;
      this._shader.getCgl().gl.uniform1iv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }
    updateValueT() {
      if (!this._isValidLoc()) {
        this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._cgl.profileData.profileUniformCount++;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this.needsUpdate = false;
    }
    setValueT(A2) {
      this.needsUpdate = true;
      this._value = A2;
    }
  }
  G.glslTypeString = (A2) => {
    if (A2 == "f")
      return "float";
    if (A2 == "b")
      return "bool";
    if (A2 == "i")
      return "int";
    if (A2 == "2i")
      return "ivec2";
    if (A2 == "2f")
      return "vec2";
    if (A2 == "3f")
      return "vec3";
    if (A2 == "4f")
      return "vec4";
    if (A2 == "m4")
      return "mat4";
    if (A2 == "t")
      return "sampler2D";
    if (A2 == "tc")
      return "samplerCube";
    if (A2 == "3f[]")
      return null;
    if (A2 == "m4[]")
      return null;
    if (A2 == "f[]")
      return null;
    console.warn("[CGL UNIFORM] unknown glsl type string ", A2);
  };
  const _ = { SHADERVAR_VERTEX_POSITION: "vPosition", SHADERVAR_VERTEX_NUMBER: "attrVertIndex", SHADERVAR_VERTEX_NORMAL: "attrVertNormal", SHADERVAR_VERTEX_TEXCOORD: "attrTexCoord", SHADERVAR_INSTANCE_MMATRIX: "instMat", SHADERVAR_VERTEX_COLOR: "attrVertColor", SHADERVAR_INSTANCE_INDEX: "instanceIndex", SHADERVAR_UNI_PROJMAT: "projMatrix", SHADERVAR_UNI_VIEWMAT: "viewMatrix", SHADERVAR_UNI_MODELMAT: "modelMatrix", SHADERVAR_UNI_NORMALMAT: "normalMatrix", SHADERVAR_UNI_INVVIEWMAT: "inverseViewMatrix", SHADERVAR_UNI_INVPROJMAT: "invProjMatrix", SHADERVAR_UNI_MATERIALID: "materialId", SHADERVAR_UNI_OBJECTID: "objectId", SHADERVAR_UNI_VIEWPOS: "camPos" };
  const tA = { BLEND_NONE: 0, BLEND_NORMAL: 1, BLEND_ADD: 2, BLEND_SUB: 3, BLEND_MUL: 4 };
  const gA = 180 / Math.PI;
  const iA = Math.PI / 180;
  const F = { MATH: { DEG2RAD: iA, RAD2DEG: gA }, SHADER: _, BLEND_MODES: tA };
  function IA(A2) {
    A2.prototype.hasFeedbacks = function() {
      return this._feedBacks.length > 0;
    };
    A2.prototype.removeFeedbacks = function(A3) {
      if (!this._feedbacks)
        return;
      this._feedbacks.length = 0;
      this._feedBacksChanged = true;
    };
    A2.prototype.setAttributeFeedback = function() {
    };
    A2.prototype.setFeedback = function(A3, e2, t2) {
      let g2 = { nameOut: e2 };
      let i2 = false;
      this.unBindFeedbacks();
      for (let A4 = 0; A4 < this._feedBacks.length; A4++) {
        if (this._feedBacks[A4].nameOut == e2) {
          g2 = this._feedBacks[A4];
          i2 = true;
        }
      }
      if (!i2)
        this._feedBacksChanged = true;
      g2.initialArr = t2;
      g2.attrib = A3;
      if (g2.outBuffer)
        this._cgl.gl.deleteBuffer(g2.outBuffer);
      g2.outBuffer = this._cgl.gl.createBuffer();
      this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, g2.outBuffer);
      this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, g2.initialArr, this._cgl.gl.STATIC_DRAW);
      this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, g2.attrib.buffer);
      this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, g2.initialArr, this._cgl.gl.STATIC_DRAW);
      if (!i2)
        this._feedBacks.push(g2);
      return g2;
    };
    A2.prototype.bindFeedback = function(e2) {
      if (!this._feedBacks || this._feedBacks.length === 0)
        return;
      if (this._transformFeedBackLoc == -1)
        this._transformFeedBackLoc = this._cgl.gl.createTransformFeedback();
      this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);
      let t2 = false;
      for (let A3 = 0; A3 < this._feedBacks.length; A3++) {
        const g2 = this._feedBacks[A3];
        if (g2.attrib == e2) {
          t2 = true;
          this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, A3, g2.outBuffer);
        }
      }
      if (!t2) {
      }
    };
    A2.prototype.drawFeedbacks = function(A3, e2) {
      let t2 = 0;
      if (this._feedBacksChanged) {
        const g2 = [];
        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);
        for (t2 = 0; t2 < this._feedBacks.length; t2++)
          g2.push(this._feedBacks[t2].nameOut);
        A3.setFeedbackNames(g2);
        console.log("feedbacknames", g2);
        A3.compile();
        this._feedBacksChanged = false;
        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);
        console.log("changed finished");
        return;
      }
      this._cgl.gl.beginTransformFeedback(this.glPrimitive);
      this._cgl.gl.drawArrays(e2, 0, this._feedBacks[0].attrib.numItems);
      this._cgl.gl.endTransformFeedback();
      this.unBindFeedbacks();
      this.feedBacksSwapBuffers();
    };
    A2.prototype.unBindFeedbacks = function() {
      for (let A3 = 0; A3 < this._feedBacks.length; A3++) {
        this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, A3, null);
      }
      this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);
    };
    A2.prototype.feedBacksSwapBuffers = function() {
      for (let A3 = 0; A3 < this._feedBacks.length; A3++) {
        const e2 = this._feedBacks[A3].attrib.buffer;
        this._feedBacks[A3].attrib.buffer = this._feedBacks[A3].outBuffer;
        this._feedBacks[A3].outBuffer = e2;
      }
    };
  }
  const M = {};
  M.lastMesh = null;
  const U = function(A2, e2, t2) {
    this._cgl = A2;
    let g2 = t2 || {};
    if (CABLES.UTILS.isNumeric(g2))
      g2 = { glPrimitive: t2 };
    this._log = new r("cgl_mesh");
    this._bufVertexAttrib = null;
    this._bufVerticesIndizes = this._cgl.gl.createBuffer();
    this._indexType = this._cgl.gl.UNSIGNED_SHORT;
    this._attributes = [];
    this._attribLocs = {};
    this._geom = null;
    this._lastShader = null;
    this._numInstances = 0;
    this._glPrimitive = g2.glPrimitive;
    this.opId = g2.opId || "";
    this._preWireframeGeom = null;
    this.addVertexNumbers = false;
    this._name = "unknown";
    this.feedBackAttributes = [];
    this.setGeom(e2);
    this._feedBacks = [];
    this._feedBacksChanged = false;
    this._transformFeedBackLoc = -1;
    this._lastAttrUpdate = 0;
    this.memFreed = false;
    this._cgl.profileData.addHeavyEvent("mesh constructed", this._name);
    this._queryExt = null;
    Object.defineProperty(this, "numInstances", { get() {
      return this._numInstances;
    }, set(A3) {
      this.setNumInstances(A3);
    } });
  };
  U.prototype.freeMem = function() {
    this.memFreed = true;
    for (let A2 = 0; A2 < this._attributes.length; A2++) {
      this._attributes[A2].floatArray = null;
    }
  };
  U.prototype.updateVertices = function(A2) {
    this.setAttribute(F.SHADER.SHADERVAR_VERTEX_POSITION, A2.vertices, 3);
    this._numVerts = A2.vertices.length / 3;
  };
  U.prototype.setAttributePointer = function(e2, t2, g2, i2) {
    for (let A2 = 0; A2 < this._attributes.length; A2++) {
      if (this._attributes[A2].name == e2) {
        if (!this._attributes[A2].pointer)
          this._attributes[A2].pointer = [];
        this._attributes[A2].pointer.push({ loc: -1, name: t2, stride: g2, offset: i2, instanced: e2 == F.SHADER.SHADERVAR_INSTANCE_MMATRIX });
      }
    }
  };
  U.prototype.getAttribute = function(e2) {
    for (let A2 = 0; A2 < this._attributes.length; A2++)
      if (this._attributes[A2].name == e2)
        return this._attributes[A2];
  };
  U.prototype.setAttributeRange = function(A2, e2, t2, g2) {
    if (!A2)
      return;
    if (!t2 && !g2)
      return;
    if (!A2.name) {
      this._log.stack("no attrname?!");
    }
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, A2.buffer);
    this._cgl.profileData.profileMeshAttributes += g2 - t2 || 0;
    this._cgl.profileData.profileSingleMeshAttribute[this._name] = this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0;
    this._cgl.profileData.profileSingleMeshAttribute[this._name] += g2 - t2 || 0;
    if (A2.numItems < e2.length / A2.itemSize) {
      this._resizeAttr(e2, A2);
    }
    if (g2 > e2.length) {
      if (CABLES.platform.isDevEnv())
        this._log.log(this._cgl.canvas.id + " " + A2.name + " buffersubdata out of bounds ?", e2.length, g2, t2, A2);
      return;
    }
    if (this._cgl.glVersion == 1)
      this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, e2);
    else
      this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, t2 * 4, e2, t2, g2 - t2);
  };
  U.prototype._resizeAttr = function(A2, e2) {
    if (e2.buffer)
      this._cgl.gl.deleteBuffer(e2.buffer);
    e2.buffer = this._cgl.gl.createBuffer();
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, e2.buffer);
    this._bufferArray(A2, e2);
    e2.numItems = A2.length / e2.itemSize;
  };
  U.prototype._bufferArray = function(A2, e2) {
    let t2 = e2.floatArray || null;
    if (!A2)
      return;
    if (this._cgl.debugOneFrame) {
      console.log("_bufferArray", A2.length, e2.name);
    }
    if (!(A2 instanceof Float32Array)) {
      if (e2 && t2 && t2.length == A2.length) {
        t2.set(A2);
      } else {
        t2 = new Float32Array(A2);
        if (this._cgl.debugOneFrame) {
          console.log("_bufferArray create new float32array", A2.length, e2.name);
        }
        if (A2.length > 1e4) {
          this._cgl.profileData.profileNonTypedAttrib++;
          this._cgl.profileData.profileNonTypedAttribNames = "(" + this._name + ":" + e2.name + ")";
        }
      }
    } else
      t2 = A2;
    e2.arrayLength = t2.length;
    e2.floatArray = null;
    this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, t2, this._cgl.gl.DYNAMIC_DRAW);
  };
  U.prototype.addAttribute = U.prototype.updateAttribute = U.prototype.setAttribute = function(A2, e2, t2, g2) {
    if (!e2) {
      this._log.error("mesh addAttribute - no array given! " + A2);
      throw new Error();
    }
    let i2 = null;
    let I2 = false;
    let n2 = 0;
    const o2 = e2.length / t2;
    this._cgl.profileData.profileMeshAttributes += o2 || 0;
    if (typeof g2 == "function") {
      i2 = g2;
    }
    if (typeof g2 == "object") {
      if (g2.cb)
        i2 = g2.cb;
      if (g2.instanced)
        I2 = g2.instanced;
    }
    if (A2 == F.SHADER.SHADERVAR_INSTANCE_MMATRIX)
      I2 = true;
    for (n2 = 0; n2 < this._attributes.length; n2++) {
      const r3 = this._attributes[n2];
      if (r3.name == A2) {
        if (r3.numItems === o2) {
        } else {
          this._resizeAttr(e2, r3);
        }
        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, r3.buffer);
        this._bufferArray(e2, r3);
        return r3;
      }
    }
    const C2 = this._cgl.gl.createBuffer();
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, C2);
    let a2 = this._cgl.gl.FLOAT;
    if (g2 && g2.type)
      a2 = g2.type;
    const r2 = { buffer: C2, name: A2, cb: i2, itemSize: t2, numItems: o2, startItem: 0, instanced: I2, type: a2 };
    this._bufferArray(e2, r2);
    if (A2 == F.SHADER.SHADERVAR_VERTEX_POSITION)
      this._bufVertexAttrib = r2;
    this._attributes.push(r2);
    this._attribLocs = {};
    return r2;
  };
  U.prototype.getAttributes = function() {
    return this._attributes;
  };
  U.prototype.updateTexCoords = function(A2) {
    if (A2.texCoords && A2.texCoords.length > 0) {
      this.setAttribute(F.SHADER.SHADERVAR_VERTEX_TEXCOORD, A2.texCoords, 2);
    } else {
      const e2 = new Float32Array(Math.round(A2.vertices.length / 3 * 2));
      this.setAttribute(F.SHADER.SHADERVAR_VERTEX_TEXCOORD, e2, 2);
    }
  };
  U.prototype.updateNormals = function(A2) {
    if (A2.vertexNormals && A2.vertexNormals.length > 0) {
      this.setAttribute(F.SHADER.SHADERVAR_VERTEX_NORMAL, A2.vertexNormals, 3);
    } else {
      const e2 = new Float32Array(Math.round(A2.vertices.length));
      this.setAttribute(F.SHADER.SHADERVAR_VERTEX_NORMAL, e2, 3);
    }
  };
  U.prototype._setVertexNumbers = function(A2) {
    if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || A2) {
      if (A2)
        this._verticesNumbers = A2;
      else {
        this._verticesNumbers = new Float32Array(this._numVerts);
        for (let A3 = 0; A3 < this._numVerts; A3++)
          this._verticesNumbers[A3] = A3;
      }
      this.setAttribute(F.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (A3, e2, t2) => {
        if (!t2.uniformNumVertices)
          t2.uniformNumVertices = new G(t2, "f", "numVertices", this._numVerts);
        t2.uniformNumVertices.setValue(this._numVerts);
      });
    }
  };
  U.prototype.setVertexIndices = function(e2) {
    if (!this._bufVerticesIndizes) {
      this._log.warn("no bufVerticesIndizes: " + this._name);
      return;
    }
    if (e2.length > 0) {
      if (e2 instanceof Float32Array)
        this._log.warn("vertIndices float32Array: " + this._name);
      for (let A2 = 0; A2 < e2.length; A2++) {
        if (e2[A2] >= this._numVerts) {
          this._log.warn("invalid index in " + this._name, A2, e2[A2]);
          return;
        }
      }
      this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);
      if (e2.length > 65535) {
        this.vertIndicesTyped = new Uint32Array(e2);
        this._indexType = this._cgl.gl.UNSIGNED_INT;
      } else if (e2 instanceof Uint32Array) {
        this.vertIndicesTyped = e2;
        this._indexType = this._cgl.gl.UNSIGNED_INT;
      } else if (!(e2 instanceof Uint16Array)) {
        this.vertIndicesTyped = new Uint16Array(e2);
        this._indexType = this._cgl.gl.UNSIGNED_SHORT;
      } else
        this.vertIndicesTyped = e2;
      this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this._cgl.gl.DYNAMIC_DRAW);
      this._bufVerticesIndizes.itemSize = 1;
      this._bufVerticesIndizes.numItems = e2.length;
    } else
      this._bufVerticesIndizes.numItems = 0;
  };
  U.prototype.setGeom = function(A2, e2) {
    this._geom = A2;
    if (A2.glPrimitive != null)
      this._glPrimitive = A2.glPrimitive;
    if (this._geom && this._geom.name)
      this._name = "mesh " + this._geom.name;
    M.lastMesh = null;
    this._cgl.profileData.profileMeshSetGeom++;
    this._disposeAttributes();
    this.updateVertices(this._geom);
    this.setVertexIndices(this._geom.verticesIndices);
    if (this.addVertexNumbers)
      this._setVertexNumbers();
    const t2 = this._geom.getAttributes();
    const g2 = { texCoords: F.SHADER.SHADERVAR_VERTEX_TEXCOORD, vertexNormals: F.SHADER.SHADERVAR_VERTEX_NORMAL, vertexColors: F.SHADER.SHADERVAR_VERTEX_COLOR, tangents: "attrTangent", biTangents: "attrBiTangent" };
    for (const i2 in t2)
      if (t2[i2].data && t2[i2].data.length)
        this.setAttribute(g2[i2] || i2, t2[i2].data, t2[i2].itemSize);
    if (e2) {
      this._geom = null;
    }
  };
  U.prototype._preBind = function(e2) {
    for (let A2 = 0; A2 < this._attributes.length; A2++)
      if (this._attributes[A2].cb)
        this._attributes[A2].cb(this._attributes[A2], this._geom, e2);
  };
  U.prototype._checkAttrLengths = function() {
    if (this.memFreed)
      return;
    for (let A2 = 0; A2 < this._attributes.length; A2++) {
      if (this._attributes[A2].arrayLength / this._attributes[A2].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize) {
        let A3 = "unknown";
        if (this._geom)
          A3 = this._geom.name;
      }
    }
  };
  U.prototype._bind = function(e2) {
    if (!e2.isValid())
      return;
    let t2 = [];
    if (this._attribLocs[e2.id])
      t2 = this._attribLocs[e2.id];
    else
      this._attribLocs[e2.id] = t2;
    this._lastShader = e2;
    if (e2.lastCompile > this._lastAttrUpdate || t2.length != this._attributes.length) {
      this._lastAttrUpdate = e2.lastCompile;
      for (let A2 = 0; A2 < this._attributes.length; A2++)
        t2[A2] = -1;
    }
    for (let A2 = 0; A2 < this._attributes.length; A2++) {
      const g2 = this._attributes[A2];
      if (t2[A2] == -1) {
        if (g2._attrLocationLastShaderTime != e2.lastCompile) {
          g2._attrLocationLastShaderTime = e2.lastCompile;
          t2[A2] = this._cgl.glGetAttribLocation(e2.getProgram(), g2.name);
          this._cgl.profileData.profileAttrLoc++;
        }
      }
      if (t2[A2] != -1) {
        this._cgl.gl.enableVertexAttribArray(t2[A2]);
        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, g2.buffer);
        if (g2.instanced) {
          if (g2.itemSize <= 4) {
            if (!g2.itemSize || g2.itemSize == 0)
              this._log.warn("instanced attrib itemsize error", this._geom.name, g2);
            this._cgl.gl.vertexAttribPointer(t2[A2], g2.itemSize, g2.type, false, g2.itemSize * 4, 0);
            this._cgl.gl.vertexAttribDivisor(t2[A2], 1);
          } else if (g2.itemSize == 16) {
            const i2 = 16 * 4;
            this._cgl.gl.vertexAttribPointer(t2[A2], 4, g2.type, false, i2, 0);
            this._cgl.gl.enableVertexAttribArray(t2[A2] + 1);
            this._cgl.gl.vertexAttribPointer(t2[A2] + 1, 4, g2.type, false, i2, 4 * 4 * 1);
            this._cgl.gl.enableVertexAttribArray(t2[A2] + 2);
            this._cgl.gl.vertexAttribPointer(t2[A2] + 2, 4, g2.type, false, i2, 4 * 4 * 2);
            this._cgl.gl.enableVertexAttribArray(t2[A2] + 3);
            this._cgl.gl.vertexAttribPointer(t2[A2] + 3, 4, g2.type, false, i2, 4 * 4 * 3);
            this._cgl.gl.vertexAttribDivisor(t2[A2], 1);
            this._cgl.gl.vertexAttribDivisor(t2[A2] + 1, 1);
            this._cgl.gl.vertexAttribDivisor(t2[A2] + 2, 1);
            this._cgl.gl.vertexAttribDivisor(t2[A2] + 3, 1);
          } else {
            this._log.warn("unknown instance attrib size", g2.name);
          }
        } else {
          if (!g2.itemSize || g2.itemSize == 0)
            this._log.warn("attrib itemsize error", this._name, g2);
          this._cgl.gl.vertexAttribPointer(t2[A2], g2.itemSize, g2.type, false, g2.itemSize * 4, 0);
          if (g2.pointer) {
            for (let A3 = 0; A3 < g2.pointer.length; A3++) {
              const I2 = g2.pointer[A3];
              if (I2.loc == -1)
                I2.loc = this._cgl.glGetAttribLocation(e2.getProgram(), I2.name);
              this._cgl.profileData.profileAttrLoc++;
              this._cgl.gl.enableVertexAttribArray(I2.loc);
              this._cgl.gl.vertexAttribPointer(I2.loc, g2.itemSize, g2.type, false, I2.stride, I2.offset);
            }
          }
          this.bindFeedback(g2);
        }
      }
    }
    if (this._bufVerticesIndizes && this._bufVerticesIndizes.numItems !== 0)
      this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);
  };
  U.prototype.unBind = function() {
    const A2 = this._lastShader;
    this._lastShader = null;
    if (!A2)
      return;
    let e2 = [];
    if (this._attribLocs[A2.id])
      e2 = this._attribLocs[A2.id];
    else
      this._attribLocs[A2.id] = e2;
    M.lastMesh = null;
    for (let A3 = 0; A3 < this._attributes.length; A3++) {
      if (this._attributes[A3].instanced) {
        if (this._attributes[A3].itemSize <= 4) {
          if (e2[A3] != -1)
            this._cgl.gl.vertexAttribDivisor(e2[A3], 0);
          if (e2[A3] >= 0)
            this._cgl.gl.disableVertexAttribArray(e2[A3]);
        } else {
          this._cgl.gl.vertexAttribDivisor(e2[A3], 0);
          this._cgl.gl.vertexAttribDivisor(e2[A3] + 1, 0);
          this._cgl.gl.vertexAttribDivisor(e2[A3] + 2, 0);
          this._cgl.gl.vertexAttribDivisor(e2[A3] + 3, 0);
          this._cgl.gl.disableVertexAttribArray(e2[A3] + 1);
          this._cgl.gl.disableVertexAttribArray(e2[A3] + 2);
          this._cgl.gl.disableVertexAttribArray(e2[A3] + 3);
        }
      }
      if (e2[A3] != -1)
        this._cgl.gl.disableVertexAttribArray(e2[A3]);
    }
  };
  U.prototype.meshChanged = function() {
    return this._cgl.lastMesh && this._cgl.lastMesh != this;
  };
  U.prototype.printDebug = function(A2) {
    console.log("--attributes");
    for (let A3 = 0; A3 < this._attributes.length; A3++) {
      console.log("attribute " + A3 + " " + this._attributes[A3].name);
    }
  };
  U.prototype.setNumVertices = function(A2) {
    this._bufVertexAttrib.numItems = A2;
  };
  U.prototype.getNumVertices = function() {
    return this._bufVertexAttrib.numItems;
  };
  U.prototype.render = function(t2) {
    if (!t2 || !t2.isValid() || this._cgl.aborted)
      return;
    this._checkAttrLengths();
    if (this._geom) {
      if (this._preWireframeGeom && !t2.wireframe && !this._geom.isIndexed()) {
        this.setGeom(this._preWireframeGeom);
        this._preWireframeGeom = null;
      }
      if (t2.wireframe) {
        let A3 = false;
        if (this._geom.isIndexed()) {
          if (!this._preWireframeGeom) {
            this._preWireframeGeom = this._geom;
            this._geom = this._geom.copy();
          }
          this._geom.unIndex();
          A3 = true;
        }
        if (!this._geom.getAttribute("attrBarycentric")) {
          if (!this._preWireframeGeom) {
            this._preWireframeGeom = this._geom;
            this._geom = this._geom.copy();
          }
          A3 = true;
          this._geom.calcBarycentric();
        }
        if (A3)
          this.setGeom(this._geom);
      }
    }
    let A2 = false;
    if (M.lastMesh != this) {
      if (M.lastMesh)
        M.lastMesh.unBind();
      A2 = true;
    }
    if (A2)
      this._preBind(t2);
    if (!t2.bind())
      return;
    this._bind(t2);
    if (this.addVertexNumbers)
      this._setVertexNumbers();
    M.lastMesh = this;
    let e2 = this._cgl.gl.TRIANGLES;
    if (this._glPrimitive !== void 0)
      e2 = this._glPrimitive;
    if (t2.glPrimitive !== null)
      e2 = t2.glPrimitive;
    let g2 = 1;
    let i2 = this._cgl.profileData.doProfileGlQuery;
    let I2 = false;
    if (i2) {
      let A3 = this._name + " - " + t2.getName() + " #" + t2.id;
      if (this._numInstances)
        A3 += " instanced " + this._numInstances + "x";
      let e3 = this._cgl.profileData.glQueryData[A3];
      if (!e3)
        e3 = { id: A3, num: 0 };
      if (t2.opId)
        e3.shaderOp = t2.opId;
      if (this.opId)
        e3.meshOp = this.opId;
      this._cgl.profileData.glQueryData[A3] = e3;
      if (!this._queryExt && this._queryExt !== false)
        this._queryExt = this._cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || false;
      if (this._queryExt) {
        if (e3._drawQuery) {
          const n2 = this._cgl.gl.getQueryParameter(e3._drawQuery, this._cgl.gl.QUERY_RESULT_AVAILABLE);
          if (n2) {
            const o2 = this._cgl.gl.getQueryParameter(e3._drawQuery, this._cgl.gl.QUERY_RESULT);
            const C2 = o2 / 1e6;
            e3._times = e3._times || 0;
            e3._times += C2;
            e3._numcount++;
            e3.when = performance.now();
            e3._drawQuery = null;
            e3.queryStarted = false;
          }
        }
        if (!e3.queryStarted) {
          e3._drawQuery = this._cgl.gl.createQuery();
          this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, e3._drawQuery);
          I2 = e3.queryStarted = true;
        }
      }
    }
    if (this.hasFeedbacks()) {
      this.drawFeedbacks(t2, e2);
    } else if (!this._bufVerticesIndizes || this._bufVerticesIndizes.numItems === 0) {
      if (e2 == this._cgl.gl.TRIANGLES)
        g2 = 3;
      if (this._numInstances === 0)
        this._cgl.gl.drawArrays(e2, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem);
      else
        this._cgl.gl.drawArraysInstanced(e2, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances);
    } else {
      if (e2 == this._cgl.gl.TRIANGLES)
        g2 = 3;
      if (this._numInstances === 0) {
        this._cgl.gl.drawElements(e2, this._bufVerticesIndizes.numItems, this._indexType, 0);
      } else {
        this._cgl.gl.drawElementsInstanced(e2, this._bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances);
      }
    }
    if (this._cgl.debugOneFrame && this._cgl.gl.getError() != this._cgl.gl.NO_ERROR) {
      this._log.error("mesh draw gl error");
      this._log.error("mesh", this);
      this._log.error("shader", t2);
      const a2 = [];
      for (let A3 = 0; A3 < this._cgl.gl.getProgramParameter(t2.getProgram(), this._cgl.gl.ACTIVE_ATTRIBUTES); A3++) {
        const r2 = this._cgl.gl.getActiveAttrib(t2.getProgram(), A3).name;
        this._log.error("attrib ", r2);
      }
    }
    this._cgl.profileData.profileMeshNumElements += this._bufVertexAttrib.numItems / g2 * (this._numInstances || 1);
    this._cgl.profileData.profileMeshDraw++;
    if (i2 && I2) {
      this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);
    }
    this._cgl.printError("mesh render " + this._name);
    this.unBind();
  };
  U.prototype.setNumInstances = function(e2) {
    e2 = Math.max(0, e2);
    if (this._numInstances != e2) {
      this._numInstances = e2;
      const t2 = new Float32Array(e2);
      for (let A2 = 0; A2 < e2; A2++)
        t2[A2] = A2;
      this.setAttribute(F.SHADER.SHADERVAR_INSTANCE_INDEX, t2, 1, { instanced: true });
    }
  };
  U.prototype._disposeAttributes = function() {
    if (!this._attributes)
      return;
    for (let A2 = 0; A2 < this._attributes.length; A2++) {
      if (this._attributes[A2].buffer) {
        this._cgl.gl.deleteBuffer(this._attributes[A2].buffer);
        this._attributes[A2].buffer = null;
      }
    }
    this._attributes.length = 0;
  };
  U.prototype.dispose = function() {
    if (this._bufVertexAttrib && this._bufVertexAttrib.buffer)
      this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);
    if (this._bufVerticesIndizes)
      this._cgl.gl.deleteBuffer(this._bufVerticesIndizes);
    this._bufVerticesIndizes = null;
    this._disposeAttributes();
  };
  IA(U);
  const L = {};
  L.getSimpleRect = function(A2, e2) {
    const t2 = new l(e2);
    t2.vertices = [1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0];
    t2.texCoords = [1, 1, 0, 1, 1, 0, 0, 0];
    t2.verticesIndices = [0, 1, 2, 2, 1, 3];
    t2.vertexNormals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    return new U(A2, t2);
  };
  L.getSimpleCube = function(A2, e2) {
    const t2 = new l(e2);
    t2.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1];
    t2.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0]);
    t2.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    t2.vertexNormals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
    t2.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
    t2.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);
    return new U(A2, t2);
  };
  class nA {
    constructor(A2, e2, t2) {
      this.cgl = A2;
      this._options = t2;
      this.fb = null;
      let g2 = t2.shader;
      this._useDefaultShader = true;
      if (t2.shader)
        this._useDefaultShader = false;
      t2.numRenderBuffers = t2.numRenderBuffers || 1;
      if (!g2) {
        g2 = "".endl() + "IN vec2 texCoord;";
        for (let A3 = 0; A3 < t2.numRenderBuffers; A3++) {
          g2 = g2.endl() + "UNI sampler2D tex" + A3 + ";".endl();
        }
        g2 = g2.endl() + "void main()".endl() + "{";
        if (t2.numRenderBuffers == 1) {
          g2 = g2.endl() + "    outColor= texture(tex0,texCoord);".endl();
        } else
          for (let A3 = 0; A3 < t2.numRenderBuffers; A3++) {
            g2 = g2.endl() + "outColor" + A3 + " = texture(tex" + A3 + ",texCoord);".endl();
          }
        g2 = g2.endl() + "}";
      }
      const i2 = t2.vertexShader || "".endl() + "IN vec3 vPosition;".endl() + "IN vec2 attrTexCoord;".endl() + "OUT vec2 texCoord;".endl() + "void main()".endl() + "{".endl() + "   texCoord=attrTexCoord;".endl() + "   gl_Position = vec4(vPosition,  1.0);".endl() + "}";
      this.bgShader = new CGL.Shader(A2, "corelib copytexture " + e2);
      this.bgShader.setSource(i2, g2);
      if (!t2.vertexShader)
        this.bgShader.ignoreMissingUniforms = true;
      new CGL.Uniform(this.bgShader, "t", "tex", 0);
      new CGL.Uniform(this.bgShader, "t", "tex1", 1);
      new CGL.Uniform(this.bgShader, "t", "tex2", 2);
      new CGL.Uniform(this.bgShader, "t", "tex3", 3);
      this.mesh = L.getSimpleRect(this.cgl, "texEffectRect");
    }
    setSize(A2, e2) {
      this._options.width = A2;
      this._options.height = e2;
    }
    copy(A2, e2, t2, g2, i2) {
      const I2 = this.cgl;
      if (!A2)
        A2 = CGL.Texture.getEmptyTexture(this.cgl);
      let n2 = this._options.width || A2.width, o2 = this._options.height || A2.height;
      if (this.fb) {
        if (n2 <= 0)
          n2 = 8;
        if (o2 <= 0)
          o2 = 8;
        if (this.fb.getWidth() != n2 || this.fb.getHeight() != o2)
          this.fb.setSize(n2, o2);
      } else {
        let A3 = CGL.Texture.FILTER_LINEAR;
        let e3 = CGL.Texture.WRAP_CLAMP_TO_EDGE;
        if (this._options.isFloatingPointTexture)
          A3 = CGL.Texture.FILTER_NEAREST;
        if (this._options.hasOwnProperty("filter"))
          A3 = this._options.filter;
        if (this._options.hasOwnProperty("wrap"))
          e3 = this._options.wrap;
        const C2 = { isFloatingPointTexture: this._options.isFloatingPointTexture, pixelFormat: this._options.pixelFormat, numRenderBuffers: this._options.numRenderBuffers || 1, filter: A3, wrap: e3 };
        if (I2.glVersion == 1)
          this.fb = new CGL.Framebuffer(I2, n2, o2, C2);
        else
          this.fb = new CGL.Framebuffer2(I2, n2, o2, C2);
      }
      I2.frameStore.renderOffscreen = true;
      this.fb.renderStart(I2);
      I2.setTexture(0, A2.tex);
      if (e2)
        I2.setTexture(1, e2.tex);
      if (t2)
        I2.setTexture(2, t2.tex);
      if (g2)
        I2.setTexture(3, g2.tex);
      if (i2)
        I2.setTexture(4, i2.tex);
      I2.pushShader(this.bgShader);
      this.mesh.render(this.bgShader);
      I2.popShader();
      this.fb.renderEnd();
      I2.frameStore.renderOffscreen = false;
      return this.fb.getTextureColor();
    }
    dispose() {
      if (this.fb)
        this.fb.dispose();
      if (this.bgShader)
        this.bgShader.dispose();
      if (this.mesh)
        this.mesh.dispose();
    }
  }
  CGL.CopyTexture = nA;
  (((void 0).CGL = (void 0).CGL || {}).COREMODULES = (void 0).CGL.COREMODULES || {}).Copytexture = A.Copytexture;
})();
(() => {
  "use strict";
  var A = {};
  class e {
    constructor() {
      this.pixelData = null;
      this._finishedFence = true;
      this._size = 0;
      this._pbo = null;
    }
    _fence(I) {
      const n = I.gl;
      this._finishedFence = false;
      return new Promise(function(e2, t) {
        if (I.aborted)
          return;
        let g = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0);
        if (!g)
          return;
        n.flush();
        function i() {
          if (I.aborted)
            return;
          const A2 = n.clientWaitSync(g, 0, 0);
          if (A2 == n.WAIT_FAILED) {
            console.error("fence wait failed");
            if (t)
              t();
          } else if (A2 == n.TIMEOUT_EXPIRED) {
            return setTimeout(i, 0);
          } else if (A2 == n.CONDITION_SATISFIED) {
            e2();
            n.deleteSync(g);
          } else if (A2 == n.ALREADY_SIGNALED) {
            e2();
            n.deleteSync(g);
          } else {
            console.log("unknown fence status", A2);
          }
        }
        i();
      });
    }
    read(A2, e2, t, g, i, I, n, o) {
      if (CABLES.UI) {
        if (!CABLES.UI.loaded || performance.now() - CABLES.UI.loadedTime < 1e3)
          return;
      }
      if (!this._finishedFence)
        return;
      const C = A2.gl;
      let a = 1;
      if (A2.aborted)
        return;
      if (!e2)
        return;
      if (t === CGL.Texture.TYPE_FLOAT)
        t = CGL.Texture.PFORMATSTR_RGBA32F;
      let r = CGL.Texture.isPixelFormatFloat(t);
      if (r)
        a = 4;
      if (CGL.Texture.isPixelFormatHalfFloat(t))
        a = 2;
      const s = CGL.Texture.setUpGlPixelFormat(A2, t);
      const B = s.numColorChannels * I * n;
      if (I == 0 || n == 0 || B == 0)
        return;
      if (!this._pixelData || this._size != B * a) {
        if (r)
          this._pixelData = new Float32Array(B * a);
        else
          this._pixelData = new Uint8Array(B);
        this._size = B * a;
      }
      let Q = C.UNSIGNED_BYTE;
      if (r)
        Q = C.FLOAT;
      if (this._size == 0 || !this._pixelData) {
        console.error("readpixel size 0", this._size, I, n);
        return;
      }
      if (this._finishedFence) {
        this._pbo = C.createBuffer();
        C.bindBuffer(C.PIXEL_PACK_BUFFER, this._pbo);
        C.bufferData(C.PIXEL_PACK_BUFFER, this._pixelData.byteLength, C.DYNAMIC_READ);
        C.bindFramebuffer(C.FRAMEBUFFER, e2);
        C.bindBuffer(C.PIXEL_PACK_BUFFER, this._pbo);
        A2.profileData.profileFencedPixelRead++;
        C.readPixels(g, i, I, n, C.RGBA, s.glDataType, 0);
        C.bindBuffer(C.PIXEL_PACK_BUFFER, null);
        C.bindFramebuffer(C.FRAMEBUFFER, null);
      }
      let E = this._pixelData.byteLength;
      if (this._finishedFence && this._pbo)
        this._fence(A2).then((A3) => {
          this._wasTriggered = false;
          this._finishedFence = true;
          if (!A3 && this._pixelData && this._pixelData.byteLength == E) {
            C.bindBuffer(C.PIXEL_PACK_BUFFER, this._pbo);
            C.getBufferSubData(C.PIXEL_PACK_BUFFER, 0, this._pixelData);
            C.bindBuffer(C.PIXEL_PACK_BUFFER, null);
            if (o)
              o(this._pixelData);
          }
          C.deleteBuffer(this._pbo);
          this._pbo = null;
        });
      return true;
    }
  }
  CGL.PixelReader = e;
  (((void 0).CGL = (void 0).CGL || {}).COREMODULES = (void 0).CGL.COREMODULES || {}).Pixelreader = A.Pixelreader;
})();
