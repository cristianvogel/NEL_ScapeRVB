// inputs
const parentPort = op.inObject("Link");
const labelPort = op.inString("Text", "Value");
const valuesPort = op.inArray("Values");
const defaultValuePort = op.inString("Default", "");
const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);
const inSize = op.inInt("Lines", 1);
const extIndex = op.inInt("External Index", 0);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
setDefaultValueButtonPort.onTriggered = setDefault;
// Add after other vars
let changeTimer = null;
// outputs
const siblingsPort = op.outObject("Children");
const valuePort = op.outString("Result", defaultValuePort.get());
const outIndex = op.outNumber("Index");
const hasChanged = op.outTrigger("Changed");

defaultValuePort.setUiAttribs({ "title": "Input" });

// vars
const el = document.createElement("div");
el.addEventListener("dblclick", function ()
{
    valuePort.set(defaultValuePort.get());
    const optionElements = input.querySelectorAll("option");
    optionElements.forEach(function (optionElement, index)
    {
        if (optionElement.value.trim() === defaultValuePort.get())
        {
            optionElement.selected = true;
            outIndex.set(index);
        }
        else
        {
            optionElement.removeAttribute("selected");
        }
    });
});

el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__select");
el.classList.add("sidebar__reloadable");

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
label.style.marginBottom = "0px";
label.style.fontSize = "0.8rem";
const line = document.createElement("hr");
line.style.marginTop = "0px";
line.style.marginBottom = "8px";
line.style.border = "none"; // Remove the default border
line.style.height = "2px"; // Set the height of the <hr> element
line.style.backgroundColor = "#555"; // Stylish grey color



const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);
el.appendChild(line);
const input = document.createElement("select");

input.classList.add("sidebar__select-select");
input.setAttribute("style", "font-size: 1.1em; width: 100%;");
el.appendChild(input);
input.addEventListener("input", onInput);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultValuePort.onChange = onDefaultValueChanged;
op.onDelete = onDelete;
valuesPort.onChange = onValuesPortChange;
extIndex.onChange = onExternalIndexChange;

let options = [];
// functions

inSize.onChange = () =>
{
    input.setAttribute("size", inSize.get());
};

op.onLoaded = function ()
{
    valuePort.set(defaultValuePort.get());
};

function onValuesPortChange()
{
    // remove all children
    while (input.lastChild)
    {
        input.removeChild(input.lastChild);
    }
    options = valuesPort.get();
    const defaultValue = defaultValuePort.get();
    if (options)
    {
        options.forEach(function (option)
        {
            const optionEl = document.createElement("option");

            optionEl.setAttribute("value", option);
            if (option === defaultValue || option === valuePort.get())
            {
                optionEl.setAttribute("selected", "");
            }
            const textEl = document.createTextNode(option);
            optionEl.appendChild(textEl);
            input.appendChild(optionEl);
        });
    }
    else
    {
        valuePort.set("");
    }

    outIndex.set(0);
    setSelectedProperty(); /* set the selected property for the default value */
}

function onExternalIndexChange()
{
    const index = extIndex.get();
    const optionElements = input.querySelectorAll("option");
    if (index >= 0 && index < optionElements.length)
    {
        optionElements.forEach(function (optionElement, i)
        {
            if (i === index)
            {
                optionElement.selected = true;
                outIndex.set(i);
                valuePort.set(optionElement.value);
            }
            else
            {
                optionElement.removeAttribute("selected");
            }
        });
    }
}
let finalIndex = 0;

function setSelectedProperty(defaultinput)
{
    const optionElements = input.querySelectorAll("option");

    let finalEle = null;

    optionElements.forEach(function (optionElement, index)
    {
        if (optionElement.value.trim() === valuePort.get())
        {
            finalEle = optionElement;
            finalIndex = index;
        }
        optionElement.removeAttribute("selected");
    });

    if (defaultinput)
    {
        const defaultItem = defaultValuePort.get() + "".trim();

        optionElements.forEach(function (optionElement, index)
        {
            if (optionElement.value.trim() === defaultItem)
            {
                finalEle = optionElement;
                finalIndex = index;
            }

            optionElement.removeAttribute("selected");
        });
    }

    if (finalEle) finalEle.setAttribute("selected", "");
    outIndex.set(finalIndex);
}

function onInput(ev)
{
     // Clear any existing timer
     if (changeTimer) {
        clearTimeout(changeTimer);
    }

    valuePort.set(ev.target.value);
    outIndex.set(options.indexOf(ev.target.value));
    setSelectedProperty();

        // Set new timer
        changeTimer = setTimeout(() => {
            hasChanged.trigger();
        }, 50);
}

function onDefaultValueChanged()
{
    const defaultValue = defaultValuePort.get();
    valuePort.set(defaultValue);
    input.value = defaultValue;
    setSelectedProperty();
}

function onLabelTextChanged()
{
    const lblText = labelPort.get();
    label.textContent = lblText;
    if (CABLES.UI) op.setUiAttrib({ "extendTitle": lblText });
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(ele)
{
    if (ele)
    {
        ele.style.display = "block";
    }
    setSelectedProperty();
}

function hideElement(ele)
{
    if (ele)
    {
        ele.style.display = "none";
    }
}

// Add cleanup to onDelete
function onDelete() {
    if (changeTimer) {
        clearTimeout(changeTimer);
    }
    removeElementFromDOM(el);
}

function removeElementFromDOM(ele)
{
    if (ele && ele.parentNode && ele.parentNode.removeChild)
    {
        ele.parentNode.removeChild(ele);
    }
}

function setDefault()
{
    defaultValuePort.set(input.value);
    op.refreshParams();
}
